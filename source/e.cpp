# 1 "run.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 175 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "run.cpp" 2
# 15 "run.cpp"
# 1 "./types.h" 1



# 1 "./common_utils.h" 1




extern "C"
{



# 1 "/usr/include/stdio.h" 1 3 4
# 64 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 484 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 485 "/usr/include/sys/cdefs.h" 2 3 4
# 550 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_posix_availability.h" 1 3 4
# 551 "/usr/include/sys/cdefs.h" 2 3 4
# 65 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/Availability.h" 1 3 4
# 148 "/usr/include/Availability.h" 3 4
# 1 "/usr/include/AvailabilityInternal.h" 1 3 4
# 149 "/usr/include/Availability.h" 2 3 4
# 66 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/_types.h" 1 3 4
# 27 "/usr/include/_types.h" 3 4
# 1 "/usr/include/sys/_types.h" 1 3 4
# 33 "/usr/include/sys/_types.h" 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
# 32 "/usr/include/machine/_types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 37 "/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4
# 58 "/usr/include/sys/_types.h" 3 4
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[1168]; };
# 94 "/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
# 28 "/usr/include/_types.h" 2 3 4
# 39 "/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 68 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/sys/_types/_va_list.h" 1 3 4
# 31 "/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 72 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/sys/_types/_size_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 73 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/sys/_types/_null.h" 1 3 4
# 74 "/usr/include/stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 86 "/usr/include/stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 120 "/usr/include/stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 228 "/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen");

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs") ;
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen") ;
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite") ;
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);


__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
# 290 "/usr/include/stdio.h" 3 4
extern "C" {



char *ctermid(char *);





FILE *fdopen(int, const char *) __asm("_" "fdopen");

int fileno(FILE *);
}
# 312 "/usr/include/stdio.h" 3 4
extern "C" {
int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen");

}
# 334 "/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 371 "/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);



__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *, const char *) __asm("_" "tempnam") ;
}
# 409 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_off_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 410 "/usr/include/stdio.h" 2 3 4

extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}



extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 434 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 435 "/usr/include/stdio.h" 2 3 4

extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((availability(macosx,introduced=10.7)));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
# 10 "./common_utils.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 65 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/sys/wait.h" 1 3 4
# 79 "/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






# 1 "/usr/include/sys/_types/_pid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/_types/_id_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/usr/include/sys/wait.h" 2 3 4
# 109 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
# 73 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/usr/include/sys/signal.h" 2 3 4







# 1 "/usr/include/machine/signal.h" 1 3 4
# 32 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/i386/signal.h" 1 3 4
# 39 "/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/usr/include/machine/signal.h" 2 3 4
# 82 "/usr/include/sys/signal.h" 2 3 4
# 145 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/usr/include/machine/_mcontext.h" 3 4
# 1 "/usr/include/i386/_mcontext.h" 1 3 4
# 33 "/usr/include/i386/_mcontext.h" 3 4
# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
# 43 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
# 402 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 454 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
# 751 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 34 "/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 76 "/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 115 "/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/usr/include/machine/_mcontext.h" 2 3 4
# 146 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 36 "/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 147 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_ucontext.h" 1 3 4
# 34 "/usr/include/sys/_types/_ucontext.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 148 "/usr/include/sys/signal.h" 2 3 4


# 1 "/usr/include/sys/_types/_pthread_attr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 151 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 152 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_types/_uid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 154 "/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 266 "/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 328 "/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 345 "/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 364 "/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 386 "/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 110 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 72 "/usr/include/sys/resource.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 1 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 18 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 19 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 20 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 21 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 22 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/usr/include/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;






# 1 "/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_intptr_t.h" 3 4
typedef __darwin_intptr_t intptr_t;
# 54 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 55 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/usr/include/stdint.h" 2 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 2 3 4
# 73 "/usr/include/sys/resource.h" 2 3 4







# 1 "/usr/include/sys/_types/_timeval.h" 1 3 4
# 30 "/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/usr/include/sys/resource.h" 2 3 4








typedef __uint64_t rlim_t;
# 151 "/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 162 "/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 190 "/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};
# 290 "/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 317 "/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
# 346 "/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit") ;
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit") ;
}
# 111 "/usr/include/sys/wait.h" 2 3 4
# 186 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
# 35 "/usr/include/machine/endian.h" 3 4
# 1 "/usr/include/i386/endian.h" 1 3 4
# 99 "/usr/include/i386/endian.h" 3 4
# 1 "/usr/include/sys/_endian.h" 1 3 4
# 124 "/usr/include/sys/_endian.h" 3 4
# 1 "/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((__uint16_t)((_data << 8) | (_data >> 8)));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 125 "/usr/include/sys/_endian.h" 2 3 4
# 100 "/usr/include/i386/endian.h" 2 3 4
# 36 "/usr/include/machine/endian.h" 2 3 4
# 187 "/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 247 "/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait") ;
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid") ;

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid") ;


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/alloca.h" 1 3 4
# 31 "/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 68 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 77 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_rune_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 78 "/usr/include/stdlib.h" 2 3 4


# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 81 "/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 117 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 127 "/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((availability(macosx,introduced=10.6)));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod") ;
float strtof(const char *, char **) __asm("_" "strtof") ;
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system") ;
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv") ;
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv") ;

void setkey(const char *) __asm("_" "setkey") ;



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv") ;







# 1 "/usr/include/machine/types.h" 1 3 4
# 35 "/usr/include/machine/types.h" 3 4
# 1 "/usr/include/i386/types.h" 1 3 4
# 81 "/usr/include/i386/types.h" 3 4
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;


typedef int64_t register_t;
# 97 "/usr/include/i386/types.h" 3 4
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;


# 1 "/usr/include/sys/_types/___offsetof.h" 1 3 4
# 114 "/usr/include/i386/types.h" 2 3 4
# 36 "/usr/include/machine/types.h" 2 3 4
# 239 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/sys/_types/_dev_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 241 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_mode_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 242 "/usr/include/stdlib.h" 2 3 4

u_int32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((availability(macosx,introduced=10.7)));

int atexit_b(void (^)(void)) __attribute__((availability(macosx,introduced=10.6)));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((availability(macosx,introduced=10.0,deprecated=10.5)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 11 "./common_utils.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 53 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 3 4
typedef long unsigned int rsize_t;
# 12 "./common_utils.h" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 70 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/runetype.h" 1 3 4
# 49 "/usr/include/runetype.h" 3 4
# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/usr/include/runetype.h" 2 3 4
# 1 "/usr/include/sys/_types/_wint_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_wint_t.h" 3 4
typedef __darwin_wint_t wint_t;
# 51 "/usr/include/runetype.h" 2 3 4
# 60 "/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 71 "/usr/include/ctype.h" 2 3 4
# 128 "/usr/include/ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 147 "/usr/include/ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 187 "/usr/include/ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

inline int
tolower(int _c)
{
        return (__tolower(_c));
}

inline int
toupper(int _c)
{
        return (__toupper(_c));
}


inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 13 "./common_utils.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 14 "./common_utils.h" 2
# 1 "/usr/include/math.h" 1 3 4
# 33 "/usr/include/math.h" 3 4
extern "C" {
# 44 "/usr/include/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 111 "/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 144 "/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 188 "/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union {
        long double __ld;
        struct{ unsigned long long __m; unsigned short __sexp; } __p;
    } __u;
    __u.__ld = __x;
    return (int)(__u.__p.__sexp >> 15);
}







inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 3.36210314311209350626e-4932L;
}
# 322 "/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 565 "/usr/include/math.h" 3 4
extern float __inff(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern double __inf(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern long double __infl(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern float __nan(void) __attribute__((availability(macosx,introduced=10.0)));
# 597 "/usr/include/math.h" 3 4
extern float __exp10f(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __exp10(double) __attribute__((availability(macosx,introduced=10.9)));





inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) __attribute__((availability(macosx,introduced=10.9)));
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) __attribute__((availability(macosx,introduced=10.9)));
# 614 "/usr/include/math.h" 3 4
extern float __cospif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __cospi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __sinpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __sinpi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __tanpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __tanpi(double) __attribute__((availability(macosx,introduced=10.9)));






inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) __attribute__((availability(macosx,introduced=10.9)));
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) __attribute__((availability(macosx,introduced=10.9)));






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}






extern double j0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double j1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double jn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double y0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double y1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double yn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double scalb(double, double);
extern int signgam;
# 712 "/usr/include/math.h" 3 4
extern long int rinttol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern long int roundtol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double drem(double, double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern int finite(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double gamma(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double significand(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
# 737 "/usr/include/math.h" 3 4
}
# 15 "./common_utils.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdbool.h" 1 3 4
# 16 "./common_utils.h" 2
# 1 "/usr/include/getopt.h" 1 3 4
# 44 "/usr/include/getopt.h" 3 4
# 1 "/usr/include/unistd.h" 1 3 4
# 72 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 84 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 85 "/usr/include/sys/unistd.h" 2 3 4
# 122 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
# 123 "/usr/include/sys/unistd.h" 2 3 4
# 132 "/usr/include/sys/unistd.h" 3 4
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/usr/include/unistd.h" 2 3 4

# 1 "/usr/include/sys/_types/_gid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 75 "/usr/include/unistd.h" 2 3 4








# 1 "/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 84 "/usr/include/unistd.h" 2 3 4
# 423 "/usr/include/unistd.h" 3 4
extern "C" {
void _exit(int) __attribute__((noreturn));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close") ;

int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause") ;

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read") ;

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep") ;

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r") ;




int unlink(const char *);

ssize_t write(int, const void *, size_t) __asm("_" "write") ;
}
# 500 "/usr/include/unistd.h" 3 4
extern "C" {
size_t confstr(int, char *, size_t) __asm("_" "confstr") ;

int getopt(int, char * const [], const char *) __asm("_" "getopt") ;

extern char *optarg;
extern int optind, opterr, optopt;
}
# 525 "/usr/include/unistd.h" 3 4
 extern "C" {





__attribute__((deprecated))

void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);






void encrypt(char *, int) __asm("_" "encrypt") ;



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((const)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown") ;

int lockf(int, int, off_t) __asm("_" "lockf") ;

int nice(int) __asm("_" "nice") ;

ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread") ;

ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite") ;






__attribute__((deprecated))

void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp") ;




int setregid(gid_t, gid_t) __asm("_" "setregid") ;

int setreuid(uid_t, uid_t) __asm("_" "setreuid") ;

void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep") ;
pid_t vfork(void);


int fsync(int) __asm("_" "fsync") ;

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}
# 618 "/usr/include/unistd.h" 3 4
extern "C" {
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}








# 1 "/usr/include/sys/select.h" 1 3 4
# 75 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/_types/_fd_def.h" 1 3 4
# 45 "/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[(unsigned long)_n/(sizeof(__int32_t) * 8)] & ((__int32_t)(1<<((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}
# 76 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_timespec.h" 1 3 4
# 30 "/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 77 "/usr/include/sys/select.h" 2 3 4







# 1 "/usr/include/sys/_types/_time_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 85 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 86 "/usr/include/sys/select.h" 2 3 4
# 100 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 101 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_set.h" 1 3 4
# 102 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 103 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 104 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 105 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 108 "/usr/include/sys/select.h" 2 3 4



extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )




  __asm("_" "pselect" "$1050")




  ;



# 1 "/usr/include/sys/_select.h" 1 3 4
# 39 "/usr/include/sys/_select.h" 3 4
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )




  __asm("_" "select" "$1050")




  ;
# 130 "/usr/include/sys/select.h" 2 3 4

}
# 634 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/sys/_types/_uuid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uuid_t.h" 3 4
typedef __darwin_uuid_t uuid_t;
# 638 "/usr/include/unistd.h" 2 3 4

extern "C" {
void _Exit(int) __attribute__((noreturn));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);





# 1 "/usr/include/gethostuuid.h" 1 3 4
# 39 "/usr/include/gethostuuid.h" 3 4
int gethostuuid(uuid_t, const struct timespec *) __attribute__((availability(macosx,introduced=10.5)));
# 654 "/usr/include/unistd.h" 2 3 4




mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkpath_np(const char *path, mode_t omode) __attribute__((availability(macosx,introduced=10.8)));
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey") ;



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode");
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((availability(macosx,introduced=10.6)));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((availability(macosx,introduced=10.6)));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist") ;
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist") ;
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
# 731 "/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((availability(macosx,introduced=10.6)));




int fsync_volume_np(int, int) __attribute__((availability(macosx,introduced=10.8)));
int sync_volume_np(const char *, int) __attribute__((availability(macosx,introduced=10.8)));

extern int optreset;

}
# 45 "/usr/include/getopt.h" 2 3 4
# 54 "/usr/include/getopt.h" 3 4
struct option {

 const char *name;




 int has_arg;

 int *flag;

 int val;
};

extern "C" {
int getopt_long(int, char * const *, const char *,
 const struct option *, int *);
int getopt_long_only(int, char * const *, const char *,
 const struct option *, int *);


int getopt(int, char * const [], const char *) __asm("_" "getopt") ;

extern char *optarg;
extern int optind, opterr, optopt;



extern int optreset;

}
# 17 "./common_utils.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 69 "/usr/include/string.h" 3 4
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror") ;
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
}
# 103 "/usr/include/string.h" 3 4
extern "C" {
char *strtok_r(char *, const char *, char **);
}
# 115 "/usr/include/string.h" 3 4
extern "C" {
int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);
}
# 129 "/usr/include/string.h" 3 4
extern "C" {
char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int sig);
}






# 1 "/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 142 "/usr/include/string.h" 2 3 4
# 1 "/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 143 "/usr/include/string.h" 2 3 4

extern "C" {
errno_t memset_s(void *, rsize_t, int, rsize_t) __attribute__((availability(macosx,introduced=10.9)));
}







extern "C" {
void *memmem(const void *, size_t, const void *, size_t) __attribute__((availability(macosx,introduced=10.7)));
void memset_pattern4(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));

char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);


void swab(const void * , void * , ssize_t);
}







# 1 "/usr/include/strings.h" 1 3 4
# 67 "/usr/include/strings.h" 3 4
extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((availability(macosx,introduced=10.5)));
int ffsll(long long) __attribute__((availability(macosx,introduced=10.9)));
int fls(int) __attribute__((availability(macosx,introduced=10.5)));
int flsl(long) __attribute__((availability(macosx,introduced=10.5)));
int flsll(long long) __attribute__((availability(macosx,introduced=10.9)));
}


# 1 "/usr/include/string.h" 1 3 4
# 93 "/usr/include/strings.h" 2 3 4
# 177 "/usr/include/string.h" 2 3 4
# 18 "./common_utils.h" 2


typedef int8_t int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;

typedef uint8_t uint8;
typedef uint16_t uint16;
typedef uint32_t uint32;
typedef uint64_t uint64;

typedef float float32;
typedef double float64;

typedef int8 i8;
typedef int16 i16;
typedef int32 i32;
typedef int64 i64;

typedef uint8 u8;
typedef uint16 u16;
typedef uint32 u32;
typedef uint64 u64;

typedef float32 f32;
typedef float64 f64;

typedef u64 usize;
# 66 "./common_utils.h"
void* xmalloc(size_t num_bytes);
void* xcalloc(size_t num_elems, size_t elem_size);
void* xcalloc_1arg(size_t bytes);
void* xrealloc(void* ptr, size_t num_bytes);


void* memdup(void *src, size_t size);

char *strf(const char *fmt, ...);


char* read_file(const char *path);
bool write_file(const char *path, const char *buf, size_t len);
# 96 "./common_utils.h"
typedef struct {
    char* ptr;
    char* end;
    char** blocks;
    size_t block_count;
    size_t block_cap;
} ArenaAllocator;

void ArenaAllocator_init(ArenaAllocator* arena);
void* ArenaAllocator_allocate(ArenaAllocator* arena, size_t size);
void ArenaAllocator_grow(ArenaAllocator* arena, size_t min_size);
void ArenaAllocator_delete(ArenaAllocator* arena);
# 116 "./common_utils.h"
void debug_print(const char* const in);







typedef void* (*Fn_MemoryAllocator)(size_t bytes);


extern struct option program_args[(2) + 1];

typedef struct {
    bool verbose;
    bool hot_config;
} CommandLineArgs;

bool parse_command_line_args(CommandLineArgs* cmd, const int argc, char* argv[]);


uint64_t hash_uint64(uint64_t x);
uint64_t hash_ptr(const void* ptr);
uint64_t hash_mix(uint64_t x, uint64_t y);
uint64_t hash_bytes(const void* ptr, size_t len);

typedef struct Map {
    uint64_t* keys;
    uint64_t* vals;
    size_t len;
    size_t cap;
} Map;

uint64_t map_get_uint64_from_uint64(Map* map, uint64_t key);

void map_put_uint64_from_uint64(Map* map, uint64_t key, uint64_t val);

void map_grow(Map* map, size_t new_cap);

void map_put_uint64_from_uint64(Map* map, uint64_t key, uint64_t val);

void* map_get(Map* map, const void* key);

void map_put(Map* map, const void* key, void* val);

void* map_get_from_uint64(Map *map, uint64_t key);

void map_put_from_uint64(Map* map, uint64_t key, void* val);

uint64_t map_get_uint64(Map* map, void* key);

void map_put_uint64(Map* map, void* key, uint64_t val);



typedef struct Intern {
    size_t len;
    struct Intern* next;
    char str[];
} Intern;

extern ArenaAllocator intern_arena;
extern Map interns;

const char *str_intern_range(const char* start, const char* end);

const char *str_intern(const char* str);

bool str_islower(const char* str);



}
# 5 "./types.h" 2
# 1 "./opengl.hpp" 1
# 10 "./opengl.hpp"
# 1 "/usr/local/include/GL/glew.h" 1 3
# 221 "/usr/local/include/GL/glew.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 222 "/usr/local/include/GL/glew.h" 2 3
# 270 "/usr/local/include/GL/glew.h" 3
extern "C" {







typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;
# 304 "/usr/local/include/GL/glew.h" 3
typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;

typedef GLint64EXT GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;
# 848 "/usr/local/include/GL/glew.h" 3
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const void *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const void *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, void* *params);
extern void glGetPolygonStipple (GLubyte *mask);
extern const GLubyte * glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const void *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const void *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const void *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
# 1203 "/usr/local/include/GL/glew.h" 3
# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 1 3







# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/OpenGLAvailability.h" 1 3
# 9 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 2 3
# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3
# 10 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 2 3


extern "C" {
# 219 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
class GLUnurbs;
class GLUquadric;
class GLUtesselator;

typedef class GLUnurbs GLUnurbsObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
typedef class GLUquadric GLUquadricObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
typedef class GLUtesselator GLUtesselatorObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
typedef class GLUtesselator GLUtriangulatorObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
# 240 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern void gluBeginCurve (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluBeginPolygon (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluBeginSurface (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluBeginTrim (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9)));
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDeleteQuadric (GLUquadric* quad) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDeleteTess (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndCurve (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndPolygon (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndSurface (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndTrim (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern const GLubyte * gluErrorString (GLenum error) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern const GLubyte * gluGetString (GLenum name) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMatrix4MakeLookAt\"" "")));
extern GLUnurbs* gluNewNurbsRenderer (void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLUquadric* gluNewQuadric (void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLUtesselator* gluNewTess (void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNextContour (GLUtesselator* tess, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9)));
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMatrix4MakeOrtho\"" "")));
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMatrix4MakePerspective\"" "")));
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMathProject\"" "")));
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessBeginContour (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessCallback (GLUtesselator* tess, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessEndContour (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessEndPolygon (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMathUnproject\"" "")));
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use GLKMathUnproject\"" "")));


}
# 1204 "/usr/local/include/GL/glew.h" 2 3
# 1255 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
typedef void ( * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 1380 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, void *img);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
# 1523 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void ( * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void ( * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void ( * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void ( * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void ( * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);
# 1679 "/usr/local/include/GL/glew.h" 3
typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void ( * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
typedef void ( * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYPROC) (GLenum target);
typedef void ( * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void** params);
typedef void ( * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, void* data);
typedef void ( * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean ( * PFNGLISQUERYPROC) (GLuint id);
typedef void* ( * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERPROC) (GLenum target);
# 1816 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint ( * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint ( * PFNGLCREATESHADERPROC) (GLenum type);
typedef void ( * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void ( * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void ( * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void ( * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean ( * PFNGLISSHADERPROC) (GLuint shader);
typedef void ( * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const* string, const GLint* length);
typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void ( * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);
# 2037 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 2166 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint colorNumber, const GLchar* name);
typedef void ( * PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void ( * PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
typedef void ( * PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawBuffer, const GLfloat* value);
typedef void ( * PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawBuffer, const GLint* value);
typedef void ( * PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawBuffer, const GLuint* value);
typedef void ( * PFNGLCOLORMASKIPROC) (GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void ( * PFNGLDISABLEIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLENABLEIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLGETBOOLEANI_VPROC) (GLenum pname, GLuint index, GLboolean* data);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar* name);
typedef const GLubyte* ( * PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void ( * PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void ( * PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint* params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISENABLEDIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void ( * PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint v0);
typedef void ( * PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint v0);
typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint v0, GLint v1);
typedef void ( * PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint v0, GLuint v1);
typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte* v0);
typedef void ( * PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort* v0);
typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte* v0);
typedef void ( * PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort* v0);
typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void*pointer);
# 2322 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint buffer);
typedef void ( * PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalFormat, GLuint buffer);
# 2364 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum value, GLint64 * data);
typedef void ( * PFNGLGETINTEGER64I_VPROC) (GLenum pname, GLuint index, GLint64 * data);
# 2384 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
# 2410 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);
# 2485 "/usr/local/include/GL/glew.h" 3
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSPROC) (void);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *pixels);
typedef void ( * PFNGLGETNTEXIMAGEPROC) (GLenum tex, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *pixels);
typedef void ( * PFNGLGETNUNIFORMDVPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
# 2518 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 2579 "/usr/local/include/GL/glew.h" 3
typedef void ( *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, void *userParam);
typedef void ( * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);
# 2612 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
# 2659 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);
# 2672 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
# 2693 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void ( * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean ( * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);
# 2717 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLQUERYOBJECTPARAMETERUIAMDPROC) (GLenum target, GLuint id, GLenum pname, GLuint param);
# 2738 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void ( * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void *data);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void ( * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void ( * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void ( * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
# 2797 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);
# 2876 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void ( * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
# 2896 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);
# 2955 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void ( * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);
# 2993 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 3010 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 3025 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);
# 3125 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void ( * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);
# 3160 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
# 3199 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void *pointer);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);
# 3223 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
# 3277 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 3299 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum ( * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
# 3371 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, void **params);
typedef void ( * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, void *pointer);
# 3399 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 3427 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
# 3455 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean ( * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);
# 3508 "/usr/local/include/GL/glew.h" 3
typedef int GLfixed;

typedef void ( * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void ( * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void ( * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const void*binary, GLsizei length);
# 3531 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMEMORYBARRIERBYREGIONPROC) (GLbitfield barriers);
# 3548 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPRIMITIVEBOUNDINGBOXARBPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
# 3594 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
# 3613 "/usr/local/include/GL/glew.h" 3
typedef GLuint64 ( * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);
# 3661 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);
# 3686 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
# 3704 "/usr/local/include/GL/glew.h" 3
typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync ( * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);
# 3720 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
# 3741 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
# 3763 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLIPCONTROLPROC) (GLenum origin, GLenum depth);
# 3782 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 3841 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void ( * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
# 3861 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
# 3900 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
# 3913 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 3961 "/usr/local/include/GL/glew.h" 3
typedef void ( *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
# 4033 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDTEXTUREUNITPROC) (GLuint unit, GLuint texture);
typedef void ( * PFNGLBLITNAMEDFRAMEBUFFERPROC) (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat* value);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYNAMEDBUFFERSUBDATAPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCREATEBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLCREATEFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLCREATEPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLCREATEQUERIESPROC) (GLenum target, GLsizei n, GLuint* ids);
typedef void ( * PFNGLCREATERENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLCREATESAMPLERSPROC) (GLsizei n, GLuint* samplers);
typedef void ( * PFNGLCREATETEXTURESPROC) (GLenum target, GLsizei n, GLuint* textures);
typedef void ( * PFNGLCREATETRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLCREATEVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPPROC) (GLuint texture);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) (GLuint buffer, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTI64VPROC) (GLuint id,GLuint buffer,GLenum pname,GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTIVPROC) (GLuint id,GLuint buffer,GLenum pname,GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTUI64VPROC) (GLuint id,GLuint buffer,GLenum pname,GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTUIVPROC) (GLuint id,GLuint buffer,GLenum pname,GLintptr offset);
typedef void ( * PFNGLGETTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVPROC) (GLuint texture, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVPROC) (GLuint texture, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKI64_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint64* param);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKI_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint* param);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKIVPROC) (GLuint xfb, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINDEXED64IVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
typedef void ( * PFNGLGETVERTEXARRAYINDEXEDIVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYIVPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void * ( * PFNGLMAPNAMEDBUFFERPROC) (GLuint buffer, GLenum access);
typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLNAMEDBUFFERDATAPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) (GLuint framebuffer, GLenum pname, GLint param);
typedef void ( * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTUREBUFFERPROC) (GLuint texture, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREBUFFERRANGEPROC) (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFPROC) (GLuint texture, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIPROC) (GLuint texture, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURESTORAGE1DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) (GLuint xfb, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFERPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYATTRIBBINDINGPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXARRAYATTRIBFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYATTRIBIFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYATTRIBLFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYBINDINGDIVISORPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void ( * PFNGLVERTEXARRAYELEMENTBUFFERPROC) (GLuint vaobj, GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERSPROC) (GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);
# 4256 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);
# 4269 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
# 4288 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount, const GLint *basevertex);
# 4310 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect);
typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect);
# 4451 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
# 4545 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void ( * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 4627 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);
# 4651 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void ( * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void ( * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
# 4668 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
# 4686 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSPECIALIZESHADERARBPROC) (GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);
# 4728 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void ( * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void ( * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
# 4784 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETUNIFORMI64VARBPROC) (GLuint program, GLint location, GLint64* params);
typedef void ( * PFNGLGETUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLuint64* params);
typedef void ( * PFNGLGETNUNIFORMI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint64* params);
typedef void ( * PFNGLGETNUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint64* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64ARBPROC) (GLuint program, GLint location, GLint64 x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64ARBPROC) (GLuint program, GLint location, GLuint64 x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM1I64ARBPROC) (GLint location, GLint64 x);
typedef void ( * PFNGLUNIFORM1I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM1UI64ARBPROC) (GLint location, GLuint64 x);
typedef void ( * PFNGLUNIFORM1UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM2I64ARBPROC) (GLint location, GLint64 x, GLint64 y);
typedef void ( * PFNGLUNIFORM2I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM2UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y);
typedef void ( * PFNGLUNIFORM2UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM3I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void ( * PFNGLUNIFORM3I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM3UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void ( * PFNGLUNIFORM3UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM4I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void ( * PFNGLUNIFORM4I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM4UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void ( * PFNGLUNIFORM4UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
# 4967 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, void *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, void *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
# 5045 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
# 5062 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
# 5081 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
# 5194 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);
# 5207 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void ( * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void ( * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
# 5248 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * ( * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
# 5274 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);
# 5295 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void ( * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void ( * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void ( * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);
# 5318 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
# 5343 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 5392 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 5477 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
# 5518 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMAXSHADERCOMPILERTHREADSARBPROC) (GLuint count);
# 5571 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);
# 5655 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint ( * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);
# 5683 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
# 5727 "/usr/local/include/GL/glew.h" 3
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void ( * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void ( * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void ( * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void ( * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void ( * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void ( * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void ( * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void ( * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void ( * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void*column, void*span);
typedef void ( * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void ( * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
# 5805 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
# 5823 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);
# 5838 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void ( * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void ( * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void ( * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void ( * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
# 5909 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar * const * strings);
typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void ( * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
# 6079 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
# 6202 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void ( * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
# 6261 "/usr/local/include/GL/glew.h" 3
typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
# 6388 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
# 6411 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);
# 6489 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void ( * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void ( * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);
# 6548 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBUFFERPAGECOMMITMENTARBPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
# 6573 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void ( * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
# 6633 "/usr/local/include/GL/glew.h" 3
typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void ( * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync ( * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void ( * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void ( * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean ( * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void ( * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
# 6691 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void ( * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
# 6706 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXTUREBARRIERPROC) (void);
# 6736 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 6762 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
# 6789 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, void *img);
# 7042 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 7163 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 7186 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 7226 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 7242 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
# 7264 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
# 7292 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void ( * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
# 7311 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
# 7343 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
# 7396 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void ( * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void ( * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const * uniformNames, GLuint* uniformIndices);
typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
# 7440 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYPROC) (GLuint array);
# 7459 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
# 7499 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void ( * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
# 7577 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);
# 7640 "/usr/local/include/GL/glew.h" 3
typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, void** params);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void * ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
# 7756 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void *string);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void *string);
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
# 7899 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
# 7930 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);
# 8031 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void ( * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void ( * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void ( * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void ( * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void ( * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);
# 8062 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);
# 8176 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);
# 8193 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void *pointer);
# 8219 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
# 8293 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);
# 8332 "/usr/local/include/GL/glew.h" 3
typedef void * ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 8370 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
# 8390 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
# 8492 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void *pointer, GLenum usage);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
# 8527 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
# 8555 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
# 8724 "/usr/local/include/GL/glew.h" 3
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
# 8747 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
# 8763 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 8781 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 8808 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 8858 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 8876 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 8912 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
# 8964 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
# 8979 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 9004 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);
# 9026 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar* label);
# 9041 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void ( * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void ( * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);
# 9061 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 9078 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void ( * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, void *img);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, void *img);
typedef void ( * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void *string);
typedef void ( * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void** params);
typedef void ( * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void** params);
typedef void ( * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void** param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void** param);
typedef void * ( * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void ( * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void ( * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
# 9517 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 9540 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
# 9558 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
# 9580 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
# 9616 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);
# 9668 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 9685 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 9762 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
# 9840 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 9857 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
# 9899 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
# 9992 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 10032 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);
# 10045 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);
# 10077 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 10103 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount);
# 10136 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 10215 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void *data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
# 10258 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
# 10295 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);
# 10314 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 10329 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPOLYGONOFFSETCLAMPEXTPROC) (GLfloat factor, GLfloat units, GLfloat clamp);
# 10356 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);
# 10384 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOVERAGEMODULATIONNVPROC) (GLenum components);
typedef void ( * PFNGLCOVERAGEMODULATIONTABLENVPROC) (GLsizei n, const GLfloat* v);
typedef void ( * PFNGLGETCOVERAGEMODULATIONTABLENVPROC) (GLsizei bufsize, GLfloat* v);
typedef void ( * PFNGLRASTERSAMPLESEXTPROC) (GLuint samples, GLboolean fixedsamplelocations);
# 10414 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINSCENEEXTPROC) (void);
typedef void ( * PFNGLENDSCENEEXTPROC) (void);
# 10437 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
# 10484 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void ( * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
# 10579 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void ( * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);
# 10647 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 10672 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 10751 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
# 10773 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 10792 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 11022 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
# 11077 "/usr/local/include/GL/glew.h" 3
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);
# 11103 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 11234 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 11265 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);
# 11324 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
# 11375 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
# 11519 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, void **data);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, void *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
# 11628 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);
# 11652 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLWINDOWRECTANGLESEXTPROC) (GLenum mode, GLsizei count, const GLint box[]);
# 11667 "/usr/local/include/GL/glew.h" 3
typedef GLsync ( * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
# 11680 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);
# 11693 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void *string);
# 11715 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
# 11767 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const void *const *indices, GLsizei primcount, GLint modestride);
# 11833 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
# 11923 "/usr/local/include/GL/glew.h" 3
typedef void * ( * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void ( * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void ( * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);
# 11946 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
# 11986 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLCREATEPERFQUERYINTELPROC) (GLuint queryId, GLuint* queryHandle);
typedef void ( * PFNGLDELETEPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLENDPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLGETFIRSTPERFQUERYIDINTELPROC) (GLuint* queryId);
typedef void ( * PFNGLGETNEXTPERFQUERYIDINTELPROC) (GLuint queryId, GLuint* nextQueryId);
typedef void ( * PFNGLGETPERFCOUNTERINFOINTELPROC) (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue);
typedef void ( * PFNGLGETPERFQUERYDATAINTELPROC) (GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten);
typedef void ( * PFNGLGETPERFQUERYIDBYNAMEINTELPROC) (GLchar* queryName, GLuint *queryId);
typedef void ( * PFNGLGETPERFQUERYINFOINTELPROC) (GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask);
# 12017 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void ( * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);
# 12049 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDBARRIERKHRPROC) (void);
# 12124 "/usr/local/include/GL/glew.h" 3
typedef void ( *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void ( * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLGETOBJECTPTRLABELPROC) (const void *ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void ( * PFNGLOBJECTPTRLABELPROC) (const void *ptr, GLsizei length, const GLchar* label);
typedef void ( * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void ( * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);
# 12186 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETNUNIFORMFVPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
# 12295 "/usr/local/include/GL/glew.h" 3
typedef GLuint ( * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void ( * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint ( * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);
# 12343 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 12365 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);
# 12446 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void ( * PFNGLENDCONDITIONALRENDERNVXPROC) (void);
# 12479 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLLGPUCOPYIMAGESUBDATANVXPROC) (GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLLGPUINTERLOCKNVXPROC) (void);
typedef void ( * PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
# 12496 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
# 12511 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
# 12526 "/usr/local/include/GL/glew.h" 3
typedef GLuint64 ( * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);
# 12614 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBLENDBARRIERNVPROC) (void);
typedef void ( * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);
# 12651 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLVIEWPORTPOSITIONWSCALENVPROC) (GLuint index, GLfloat xcoeff, GLfloat ycoeff);
# 12684 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCALLCOMMANDLISTNVPROC) (GLuint list);
typedef void ( * PFNGLCOMMANDLISTSEGMENTSNVPROC) (GLuint list, GLuint segments);
typedef void ( * PFNGLCOMPILECOMMANDLISTNVPROC) (GLuint list);
typedef void ( * PFNGLCREATECOMMANDLISTSNVPROC) (GLsizei n, GLuint* lists);
typedef void ( * PFNGLCREATESTATESNVPROC) (GLsizei n, GLuint* states);
typedef void ( * PFNGLDELETECOMMANDLISTSNVPROC) (GLsizei n, const GLuint* lists);
typedef void ( * PFNGLDELETESTATESNVPROC) (GLsizei n, const GLuint* states);
typedef void ( * PFNGLDRAWCOMMANDSADDRESSNVPROC) (GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSNVPROC) (GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) (const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSSTATESNVPROC) (GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef GLuint ( * PFNGLGETCOMMANDHEADERNVPROC) (GLenum tokenID, GLuint size);
typedef GLushort ( * PFNGLGETSTAGEINDEXNVPROC) (GLenum shadertype);
typedef GLboolean ( * PFNGLISCOMMANDLISTNVPROC) (GLuint list);
typedef GLboolean ( * PFNGLISSTATENVPROC) (GLuint state);
typedef void ( * PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) (GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void ( * PFNGLSTATECAPTURENVPROC) (GLuint state, GLenum mode);
# 12746 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLENDCONDITIONALRENDERNVPROC) (void);
# 12766 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSUBPIXELPRECISIONBIASNVPROC) (GLuint xbits, GLuint ybits);
# 12783 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) (GLenum pname, GLfloat value);
# 12800 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERINVPROC) (GLenum pname, GLint param);
# 12825 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
# 12855 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
# 12898 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
# 12911 "/usr/local/include/GL/glew.h" 3
typedef void ( *GLVULKANPROCNV)(void);

typedef void ( * PFNGLDRAWVKIMAGENVPROC) (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef GLVULKANPROCNV ( * PFNGLGETVKPROCADDRNVPROC) (const GLchar* name);
typedef void ( * PFNGLSIGNALVKFENCENVPROC) (GLuint64 vkFence);
typedef void ( * PFNGLSIGNALVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
typedef void ( * PFNGLWAITVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
# 12959 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);
# 12999 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);
# 13020 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
# 13097 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAGMENTCOVERAGECOLORNVPROC) (GLuint color);
# 13117 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);
# 13211 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 13228 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
# 13265 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLMULTICASTBARRIERNVPROC) (void);
typedef void ( * PFNGLMULTICASTBLITFRAMEBUFFERNVPROC) (GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void ( * PFNGLMULTICASTBUFFERSUBDATANVPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC) (GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLMULTICASTCOPYIMAGESUBDATANVPROC) (GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void ( * PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLMULTICASTWAITSYNCNVPROC) (GLuint signalGpu, GLbitfield waitGpuMask);
typedef void ( * PFNGLRENDERGPUMASKNVPROC) (GLbitfield mask);
# 13309 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
# 13407 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void ( * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void ( * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void ( * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 13488 "/usr/local/include/GL/glew.h" 3
typedef unsigned short GLhalf;

typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);
# 13598 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params);
# 13650 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
# 13693 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
# 13869 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void ( * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERSTROKEPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint ( * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void ( * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHCOMMANDSNVPROC) (GLuint path, GLubyte* commands);
typedef void ( * PFNGLGETPATHCOORDSNVPROC) (GLuint path, GLfloat* coords);
typedef void ( * PFNGLGETPATHDASHARRAYNVPROC) (GLuint path, GLfloat* dashArray);
typedef GLfloat ( * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void ( * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void ( * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void ( * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void ( * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPROGRAMRESOURCEFVNVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLfloat *params);
typedef void ( * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean ( * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean ( * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean ( * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void ( * PFNGLMATRIXLOAD3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOAD3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULT3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULT3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void ( * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void ( * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void ( * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void ( * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void ( * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef GLenum ( * PFNGLPATHGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum ( * PFNGLPATHGLYPHINDEXRANGENVPROC) (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]);
typedef void ( * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum ( * PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void ( * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void ( * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void ( * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void ( * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void ( * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void ( * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void *pathString);
typedef void ( * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void ( * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void ( * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean ( * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void ( * PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef void ( * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void ( * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask, GLenum coverMode);
typedef void ( * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void ( * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);
# 14026 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, void *pointer);
# 14045 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
# 14067 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void ( * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void ( * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
# 14093 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
# 14160 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);
# 14199 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);
# 14235 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
# 14308 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean ( * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void ( * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void ( * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void ( * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void ( * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void ( * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 14425 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXTUREBARRIERNVPROC) (void);
# 14476 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
# 14687 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
# 14725 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);
# 14768 "/usr/local/include/GL/glew.h" 3
typedef GLintptr GLvdpauSurfaceNV;

typedef void ( * PFNGLVDPAUFININVPROC) (void);
typedef void ( * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void ( * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const void*getProcAddress);
typedef void ( * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void ( * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void ( * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void ( * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void ( * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);
# 14807 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, void *pointer);
# 14836 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
# 14911 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void ( * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void ( * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void ( * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
# 15030 "/usr/local/include/GL/glew.h" 3
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);
# 15251 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void ( * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
# 15308 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLVIEWPORTSWIZZLENVPROC) (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
# 15362 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLEARDEPTHFOESPROC) (GLclampf depth);
typedef void ( * PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLFRUSTUMFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void ( * PFNGLGETCLIPPLANEFOESPROC) (GLenum plane, GLfloat* equation);
typedef void ( * PFNGLORTHOFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
# 15430 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
# 15514 "/usr/local/include/GL/glew.h" 3
typedef int GLclampx;

typedef void ( * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void ( * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void ( * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void ( * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void ( * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void ( * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void ( * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void ( * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void ( * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void ( * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void ( * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void ( * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void ( * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);
# 15589 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void ( * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void ( * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void ( * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void ( * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
# 15646 "/usr/local/include/GL/glew.h" 3
typedef const GLchar* ( * PFNGLERRORSTRINGREGALPROC) (GLenum error);
# 15659 "/usr/local/include/GL/glew.h" 3
typedef GLboolean ( * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean ( * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);
# 15684 "/usr/local/include/GL/glew.h" 3
typedef void ( *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, void *context);

typedef void ( * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);
# 15699 "/usr/local/include/GL/glew.h" 3
typedef void * ( * PFNGLGETPROCADDRESSREGALPROC) (const GLchar *name);
# 15759 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
# 15774 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);
# 15818 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 15860 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
# 15875 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void *pixels);
# 15912 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);
# 15952 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);
# 16048 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 16073 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);
# 16086 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* data);
# 16131 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);
# 16173 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 16195 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);
# 16248 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);
# 16267 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 16445 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void *table);
# 16485 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 16512 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
# 16551 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
# 16593 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);
# 16618 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
# 16732 "/usr/local/include/GL/glew.h" 3
typedef void ( * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
# 16744 "/usr/local/include/GL/glew.h" 3
extern PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern PFNGLBLENDCOLORPROC __glewBlendColor;
extern PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern PFNGLFOGCOORDDPROC __glewFogCoordd;
extern PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern PFNGLFOGCOORDFPROC __glewFogCoordf;
extern PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern PFNGLBEGINQUERYPROC __glewBeginQuery;
extern PFNGLBINDBUFFERPROC __glewBindBuffer;
extern PFNGLBUFFERDATAPROC __glewBufferData;
extern PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern PFNGLENDQUERYPROC __glewEndQuery;
extern PFNGLGENBUFFERSPROC __glewGenBuffers;
extern PFNGLGENQUERIESPROC __glewGenQueries;
extern PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern PFNGLISBUFFERPROC __glewIsBuffer;
extern PFNGLISQUERYPROC __glewIsQuery;
extern PFNGLMAPBUFFERPROC __glewMapBuffer;
extern PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern PFNGLATTACHSHADERPROC __glewAttachShader;
extern PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern PFNGLCOMPILESHADERPROC __glewCompileShader;
extern PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern PFNGLCREATESHADERPROC __glewCreateShader;
extern PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern PFNGLDELETESHADERPROC __glewDeleteShader;
extern PFNGLDETACHSHADERPROC __glewDetachShader;
extern PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern PFNGLISPROGRAMPROC __glewIsProgram;
extern PFNGLISSHADERPROC __glewIsShader;
extern PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern PFNGLSHADERSOURCEPROC __glewShaderSource;
extern PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern PFNGLUNIFORM1FPROC __glewUniform1f;
extern PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern PFNGLUNIFORM1IPROC __glewUniform1i;
extern PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern PFNGLUNIFORM2FPROC __glewUniform2f;
extern PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern PFNGLUNIFORM2IPROC __glewUniform2i;
extern PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern PFNGLUNIFORM3FPROC __glewUniform3f;
extern PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern PFNGLUNIFORM3IPROC __glewUniform3i;
extern PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern PFNGLUNIFORM4FPROC __glewUniform4f;
extern PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern PFNGLUNIFORM4IPROC __glewUniform4i;
extern PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern PFNGLUSEPROGRAMPROC __glewUseProgram;
extern PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern PFNGLCLAMPCOLORPROC __glewClampColor;
extern PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern PFNGLCOLORMASKIPROC __glewColorMaski;
extern PFNGLDISABLEIPROC __glewDisablei;
extern PFNGLENABLEIPROC __glewEnablei;
extern PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern PFNGLGETSTRINGIPROC __glewGetStringi;
extern PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern PFNGLISENABLEDIPROC __glewIsEnabledi;
extern PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern PFNGLTEXBUFFERPROC __glewTexBuffer;

extern PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern PFNGLGETGRAPHICSRESETSTATUSPROC __glewGetGraphicsResetStatus;
extern PFNGLGETNCOMPRESSEDTEXIMAGEPROC __glewGetnCompressedTexImage;
extern PFNGLGETNTEXIMAGEPROC __glewGetnTexImage;
extern PFNGLGETNUNIFORMDVPROC __glewGetnUniformdv;

extern PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern PFNGLQUERYOBJECTPARAMETERUIAMDPROC __glewQueryObjectParameteruiAMD;

extern PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern PFNGLSHADERBINARYPROC __glewShaderBinary;

extern PFNGLMEMORYBARRIERBYREGIONPROC __glewMemoryBarrierByRegion;

extern PFNGLPRIMITIVEBOUNDINGBOXARBPROC __glewPrimitiveBoundingBoxARB;

extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern PFNGLBUFFERSTORAGEPROC __glewBufferStorage;
extern PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern PFNGLCLIPCONTROLPROC __glewClipControl;

extern PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern PFNGLBINDTEXTUREUNITPROC __glewBindTextureUnit;
extern PFNGLBLITNAMEDFRAMEBUFFERPROC __glewBlitNamedFramebuffer;
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC __glewCheckNamedFramebufferStatus;
extern PFNGLCLEARNAMEDBUFFERDATAPROC __glewClearNamedBufferData;
extern PFNGLCLEARNAMEDBUFFERSUBDATAPROC __glewClearNamedBufferSubData;
extern PFNGLCLEARNAMEDFRAMEBUFFERFIPROC __glewClearNamedFramebufferfi;
extern PFNGLCLEARNAMEDFRAMEBUFFERFVPROC __glewClearNamedFramebufferfv;
extern PFNGLCLEARNAMEDFRAMEBUFFERIVPROC __glewClearNamedFramebufferiv;
extern PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC __glewClearNamedFramebufferuiv;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC __glewCompressedTextureSubImage1D;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC __glewCompressedTextureSubImage2D;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC __glewCompressedTextureSubImage3D;
extern PFNGLCOPYNAMEDBUFFERSUBDATAPROC __glewCopyNamedBufferSubData;
extern PFNGLCOPYTEXTURESUBIMAGE1DPROC __glewCopyTextureSubImage1D;
extern PFNGLCOPYTEXTURESUBIMAGE2DPROC __glewCopyTextureSubImage2D;
extern PFNGLCOPYTEXTURESUBIMAGE3DPROC __glewCopyTextureSubImage3D;
extern PFNGLCREATEBUFFERSPROC __glewCreateBuffers;
extern PFNGLCREATEFRAMEBUFFERSPROC __glewCreateFramebuffers;
extern PFNGLCREATEPROGRAMPIPELINESPROC __glewCreateProgramPipelines;
extern PFNGLCREATEQUERIESPROC __glewCreateQueries;
extern PFNGLCREATERENDERBUFFERSPROC __glewCreateRenderbuffers;
extern PFNGLCREATESAMPLERSPROC __glewCreateSamplers;
extern PFNGLCREATETEXTURESPROC __glewCreateTextures;
extern PFNGLCREATETRANSFORMFEEDBACKSPROC __glewCreateTransformFeedbacks;
extern PFNGLCREATEVERTEXARRAYSPROC __glewCreateVertexArrays;
extern PFNGLDISABLEVERTEXARRAYATTRIBPROC __glewDisableVertexArrayAttrib;
extern PFNGLENABLEVERTEXARRAYATTRIBPROC __glewEnableVertexArrayAttrib;
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC __glewFlushMappedNamedBufferRange;
extern PFNGLGENERATETEXTUREMIPMAPPROC __glewGenerateTextureMipmap;
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC __glewGetCompressedTextureImage;
extern PFNGLGETNAMEDBUFFERPARAMETERI64VPROC __glewGetNamedBufferParameteri64v;
extern PFNGLGETNAMEDBUFFERPARAMETERIVPROC __glewGetNamedBufferParameteriv;
extern PFNGLGETNAMEDBUFFERPOINTERVPROC __glewGetNamedBufferPointerv;
extern PFNGLGETNAMEDBUFFERSUBDATAPROC __glewGetNamedBufferSubData;
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetNamedFramebufferAttachmentParameteriv;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC __glewGetNamedFramebufferParameteriv;
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC __glewGetNamedRenderbufferParameteriv;
extern PFNGLGETQUERYBUFFEROBJECTI64VPROC __glewGetQueryBufferObjecti64v;
extern PFNGLGETQUERYBUFFEROBJECTIVPROC __glewGetQueryBufferObjectiv;
extern PFNGLGETQUERYBUFFEROBJECTUI64VPROC __glewGetQueryBufferObjectui64v;
extern PFNGLGETQUERYBUFFEROBJECTUIVPROC __glewGetQueryBufferObjectuiv;
extern PFNGLGETTEXTUREIMAGEPROC __glewGetTextureImage;
extern PFNGLGETTEXTURELEVELPARAMETERFVPROC __glewGetTextureLevelParameterfv;
extern PFNGLGETTEXTURELEVELPARAMETERIVPROC __glewGetTextureLevelParameteriv;
extern PFNGLGETTEXTUREPARAMETERIIVPROC __glewGetTextureParameterIiv;
extern PFNGLGETTEXTUREPARAMETERIUIVPROC __glewGetTextureParameterIuiv;
extern PFNGLGETTEXTUREPARAMETERFVPROC __glewGetTextureParameterfv;
extern PFNGLGETTEXTUREPARAMETERIVPROC __glewGetTextureParameteriv;
extern PFNGLGETTRANSFORMFEEDBACKI64_VPROC __glewGetTransformFeedbacki64_v;
extern PFNGLGETTRANSFORMFEEDBACKI_VPROC __glewGetTransformFeedbacki_v;
extern PFNGLGETTRANSFORMFEEDBACKIVPROC __glewGetTransformFeedbackiv;
extern PFNGLGETVERTEXARRAYINDEXED64IVPROC __glewGetVertexArrayIndexed64iv;
extern PFNGLGETVERTEXARRAYINDEXEDIVPROC __glewGetVertexArrayIndexediv;
extern PFNGLGETVERTEXARRAYIVPROC __glewGetVertexArrayiv;
extern PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC __glewInvalidateNamedFramebufferData;
extern PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC __glewInvalidateNamedFramebufferSubData;
extern PFNGLMAPNAMEDBUFFERPROC __glewMapNamedBuffer;
extern PFNGLMAPNAMEDBUFFERRANGEPROC __glewMapNamedBufferRange;
extern PFNGLNAMEDBUFFERDATAPROC __glewNamedBufferData;
extern PFNGLNAMEDBUFFERSTORAGEPROC __glewNamedBufferStorage;
extern PFNGLNAMEDBUFFERSUBDATAPROC __glewNamedBufferSubData;
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC __glewNamedFramebufferDrawBuffer;
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC __glewNamedFramebufferDrawBuffers;
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC __glewNamedFramebufferParameteri;
extern PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC __glewNamedFramebufferReadBuffer;
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC __glewNamedFramebufferRenderbuffer;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREPROC __glewNamedFramebufferTexture;
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC __glewNamedFramebufferTextureLayer;
extern PFNGLNAMEDRENDERBUFFERSTORAGEPROC __glewNamedRenderbufferStorage;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewNamedRenderbufferStorageMultisample;
extern PFNGLTEXTUREBUFFERPROC __glewTextureBuffer;
extern PFNGLTEXTUREBUFFERRANGEPROC __glewTextureBufferRange;
extern PFNGLTEXTUREPARAMETERIIVPROC __glewTextureParameterIiv;
extern PFNGLTEXTUREPARAMETERIUIVPROC __glewTextureParameterIuiv;
extern PFNGLTEXTUREPARAMETERFPROC __glewTextureParameterf;
extern PFNGLTEXTUREPARAMETERFVPROC __glewTextureParameterfv;
extern PFNGLTEXTUREPARAMETERIPROC __glewTextureParameteri;
extern PFNGLTEXTUREPARAMETERIVPROC __glewTextureParameteriv;
extern PFNGLTEXTURESTORAGE1DPROC __glewTextureStorage1D;
extern PFNGLTEXTURESTORAGE2DPROC __glewTextureStorage2D;
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC __glewTextureStorage2DMultisample;
extern PFNGLTEXTURESTORAGE3DPROC __glewTextureStorage3D;
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC __glewTextureStorage3DMultisample;
extern PFNGLTEXTURESUBIMAGE1DPROC __glewTextureSubImage1D;
extern PFNGLTEXTURESUBIMAGE2DPROC __glewTextureSubImage2D;
extern PFNGLTEXTURESUBIMAGE3DPROC __glewTextureSubImage3D;
extern PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC __glewTransformFeedbackBufferBase;
extern PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC __glewTransformFeedbackBufferRange;
extern PFNGLUNMAPNAMEDBUFFERPROC __glewUnmapNamedBuffer;
extern PFNGLVERTEXARRAYATTRIBBINDINGPROC __glewVertexArrayAttribBinding;
extern PFNGLVERTEXARRAYATTRIBFORMATPROC __glewVertexArrayAttribFormat;
extern PFNGLVERTEXARRAYATTRIBIFORMATPROC __glewVertexArrayAttribIFormat;
extern PFNGLVERTEXARRAYATTRIBLFORMATPROC __glewVertexArrayAttribLFormat;
extern PFNGLVERTEXARRAYBINDINGDIVISORPROC __glewVertexArrayBindingDivisor;
extern PFNGLVERTEXARRAYELEMENTBUFFERPROC __glewVertexArrayElementBuffer;
extern PFNGLVERTEXARRAYVERTEXBUFFERPROC __glewVertexArrayVertexBuffer;
extern PFNGLVERTEXARRAYVERTEXBUFFERSPROC __glewVertexArrayVertexBuffers;

extern PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC __glewGetCompressedTextureSubImage;
extern PFNGLGETTEXTURESUBIMAGEPROC __glewGetTextureSubImage;

extern PFNGLSPECIALIZESHADERARBPROC __glewSpecializeShaderARB;

extern PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern PFNGLUNIFORM1DPROC __glewUniform1d;
extern PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern PFNGLUNIFORM2DPROC __glewUniform2d;
extern PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern PFNGLUNIFORM3DPROC __glewUniform3d;
extern PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern PFNGLUNIFORM4DPROC __glewUniform4d;
extern PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern PFNGLGETUNIFORMI64VARBPROC __glewGetUniformi64vARB;
extern PFNGLGETUNIFORMUI64VARBPROC __glewGetUniformui64vARB;
extern PFNGLGETNUNIFORMI64VARBPROC __glewGetnUniformi64vARB;
extern PFNGLGETNUNIFORMUI64VARBPROC __glewGetnUniformui64vARB;
extern PFNGLPROGRAMUNIFORM1I64ARBPROC __glewProgramUniform1i64ARB;
extern PFNGLPROGRAMUNIFORM1I64VARBPROC __glewProgramUniform1i64vARB;
extern PFNGLPROGRAMUNIFORM1UI64ARBPROC __glewProgramUniform1ui64ARB;
extern PFNGLPROGRAMUNIFORM1UI64VARBPROC __glewProgramUniform1ui64vARB;
extern PFNGLPROGRAMUNIFORM2I64ARBPROC __glewProgramUniform2i64ARB;
extern PFNGLPROGRAMUNIFORM2I64VARBPROC __glewProgramUniform2i64vARB;
extern PFNGLPROGRAMUNIFORM2UI64ARBPROC __glewProgramUniform2ui64ARB;
extern PFNGLPROGRAMUNIFORM2UI64VARBPROC __glewProgramUniform2ui64vARB;
extern PFNGLPROGRAMUNIFORM3I64ARBPROC __glewProgramUniform3i64ARB;
extern PFNGLPROGRAMUNIFORM3I64VARBPROC __glewProgramUniform3i64vARB;
extern PFNGLPROGRAMUNIFORM3UI64ARBPROC __glewProgramUniform3ui64ARB;
extern PFNGLPROGRAMUNIFORM3UI64VARBPROC __glewProgramUniform3ui64vARB;
extern PFNGLPROGRAMUNIFORM4I64ARBPROC __glewProgramUniform4i64ARB;
extern PFNGLPROGRAMUNIFORM4I64VARBPROC __glewProgramUniform4i64vARB;
extern PFNGLPROGRAMUNIFORM4UI64ARBPROC __glewProgramUniform4ui64ARB;
extern PFNGLPROGRAMUNIFORM4UI64VARBPROC __glewProgramUniform4ui64vARB;
extern PFNGLUNIFORM1I64ARBPROC __glewUniform1i64ARB;
extern PFNGLUNIFORM1I64VARBPROC __glewUniform1i64vARB;
extern PFNGLUNIFORM1UI64ARBPROC __glewUniform1ui64ARB;
extern PFNGLUNIFORM1UI64VARBPROC __glewUniform1ui64vARB;
extern PFNGLUNIFORM2I64ARBPROC __glewUniform2i64ARB;
extern PFNGLUNIFORM2I64VARBPROC __glewUniform2i64vARB;
extern PFNGLUNIFORM2UI64ARBPROC __glewUniform2ui64ARB;
extern PFNGLUNIFORM2UI64VARBPROC __glewUniform2ui64vARB;
extern PFNGLUNIFORM3I64ARBPROC __glewUniform3i64ARB;
extern PFNGLUNIFORM3I64VARBPROC __glewUniform3i64vARB;
extern PFNGLUNIFORM3UI64ARBPROC __glewUniform3ui64ARB;
extern PFNGLUNIFORM3UI64VARBPROC __glewUniform3ui64vARB;
extern PFNGLUNIFORM4I64ARBPROC __glewUniform4i64ARB;
extern PFNGLUNIFORM4I64VARBPROC __glewUniform4i64vARB;
extern PFNGLUNIFORM4UI64ARBPROC __glewUniform4ui64ARB;
extern PFNGLUNIFORM4UI64VARBPROC __glewUniform4ui64vARB;

extern PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern PFNGLCOLORTABLEPROC __glewColorTable;
extern PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern PFNGLGETMINMAXPROC __glewGetMinmax;
extern PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern PFNGLHISTOGRAMPROC __glewHistogram;
extern PFNGLMINMAXPROC __glewMinmax;
extern PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern PFNGLRESETMINMAXPROC __glewResetMinmax;
extern PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern PFNGLBINDTEXTURESPROC __glewBindTextures;
extern PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern PFNGLISQUERYARBPROC __glewIsQueryARB;

extern PFNGLMAXSHADERCOMPILERTHREADSARBPROC __glewMaxShaderCompilerThreadsARB;

extern PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewFramebufferSampleLocationsfvARB;
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewNamedFramebufferSampleLocationsfvARB;

extern PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern PFNGLBINDSAMPLERPROC __glewBindSampler;
extern PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern PFNGLISSAMPLERPROC __glewIsSampler;
extern PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern PFNGLBUFFERPAGECOMMITMENTARBPROC __glewBufferPageCommitmentARB;

extern PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;
extern PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern PFNGLDELETESYNCPROC __glewDeleteSync;
extern PFNGLFENCESYNCPROC __glewFenceSync;
extern PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern PFNGLGETSYNCIVPROC __glewGetSynciv;
extern PFNGLISSYNCPROC __glewIsSync;
extern PFNGLWAITSYNCPROC __glewWaitSync;

extern PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern PFNGLTEXTUREBARRIERPROC __glewTextureBarrier;

extern PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;
extern PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern PFNGLTEXTUREVIEWPROC __glewTextureView;

extern PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC __glewVertexArrayBindVertexBufferEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC __glewVertexArrayVertexAttribBindingEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC __glewVertexArrayVertexAttribFormatEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC __glewVertexArrayVertexAttribIFormatEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC __glewVertexArrayVertexAttribLFormatEXT;
extern PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC __glewVertexArrayVertexBindingDivisorEXT;
extern PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern PFNGLCOLORP3UIPROC __glewColorP3ui;
extern PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern PFNGLCOLORP4UIPROC __glewColorP4ui;
extern PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern PFNGLGETOBJECTLABELEXTPROC __glewGetObjectLabelEXT;
extern PFNGLLABELOBJECTEXTPROC __glewLabelObjectEXT;

extern PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC __glewVertexArrayVertexAttribDivisorEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern PFNGLPOLYGONOFFSETCLAMPEXTPROC __glewPolygonOffsetClampEXT;

extern PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern PFNGLCOVERAGEMODULATIONNVPROC __glewCoverageModulationNV;
extern PFNGLCOVERAGEMODULATIONTABLENVPROC __glewCoverageModulationTableNV;
extern PFNGLGETCOVERAGEMODULATIONTABLENVPROC __glewGetCoverageModulationTableNV;
extern PFNGLRASTERSAMPLESEXTPROC __glewRasterSamplesEXT;

extern PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern PFNGLWINDOWRECTANGLESEXTPROC __glewWindowRectanglesEXT;

extern PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern PFNGLBEGINPERFQUERYINTELPROC __glewBeginPerfQueryINTEL;
extern PFNGLCREATEPERFQUERYINTELPROC __glewCreatePerfQueryINTEL;
extern PFNGLDELETEPERFQUERYINTELPROC __glewDeletePerfQueryINTEL;
extern PFNGLENDPERFQUERYINTELPROC __glewEndPerfQueryINTEL;
extern PFNGLGETFIRSTPERFQUERYIDINTELPROC __glewGetFirstPerfQueryIdINTEL;
extern PFNGLGETNEXTPERFQUERYIDINTELPROC __glewGetNextPerfQueryIdINTEL;
extern PFNGLGETPERFCOUNTERINFOINTELPROC __glewGetPerfCounterInfoINTEL;
extern PFNGLGETPERFQUERYDATAINTELPROC __glewGetPerfQueryDataINTEL;
extern PFNGLGETPERFQUERYIDBYNAMEINTELPROC __glewGetPerfQueryIdByNameINTEL;
extern PFNGLGETPERFQUERYINFOINTELPROC __glewGetPerfQueryInfoINTEL;

extern PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern PFNGLBLENDBARRIERKHRPROC __glewBlendBarrierKHR;

extern PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern PFNGLOBJECTLABELPROC __glewObjectLabel;
extern PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern PFNGLGETNUNIFORMFVPROC __glewGetnUniformfv;
extern PFNGLGETNUNIFORMIVPROC __glewGetnUniformiv;
extern PFNGLGETNUNIFORMUIVPROC __glewGetnUniformuiv;
extern PFNGLREADNPIXELSPROC __glewReadnPixels;

extern PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern PFNGLLGPUCOPYIMAGESUBDATANVXPROC __glewLGPUCopyImageSubDataNVX;
extern PFNGLLGPUINTERLOCKNVXPROC __glewLGPUInterlockNVX;
extern PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC __glewLGPUNamedBufferSubDataNVX;

extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawArraysIndirectBindlessCountNV;
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawElementsIndirectBindlessCountNV;

extern PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern PFNGLVIEWPORTPOSITIONWSCALENVPROC __glewViewportPositionWScaleNV;

extern PFNGLCALLCOMMANDLISTNVPROC __glewCallCommandListNV;
extern PFNGLCOMMANDLISTSEGMENTSNVPROC __glewCommandListSegmentsNV;
extern PFNGLCOMPILECOMMANDLISTNVPROC __glewCompileCommandListNV;
extern PFNGLCREATECOMMANDLISTSNVPROC __glewCreateCommandListsNV;
extern PFNGLCREATESTATESNVPROC __glewCreateStatesNV;
extern PFNGLDELETECOMMANDLISTSNVPROC __glewDeleteCommandListsNV;
extern PFNGLDELETESTATESNVPROC __glewDeleteStatesNV;
extern PFNGLDRAWCOMMANDSADDRESSNVPROC __glewDrawCommandsAddressNV;
extern PFNGLDRAWCOMMANDSNVPROC __glewDrawCommandsNV;
extern PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC __glewDrawCommandsStatesAddressNV;
extern PFNGLDRAWCOMMANDSSTATESNVPROC __glewDrawCommandsStatesNV;
extern PFNGLGETCOMMANDHEADERNVPROC __glewGetCommandHeaderNV;
extern PFNGLGETSTAGEINDEXNVPROC __glewGetStageIndexNV;
extern PFNGLISCOMMANDLISTNVPROC __glewIsCommandListNV;
extern PFNGLISSTATENVPROC __glewIsStateNV;
extern PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC __glewListDrawCommandsStatesClientNV;
extern PFNGLSTATECAPTURENVPROC __glewStateCaptureNV;

extern PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern PFNGLSUBPIXELPRECISIONBIASNVPROC __glewSubpixelPrecisionBiasNV;

extern PFNGLCONSERVATIVERASTERPARAMETERFNVPROC __glewConservativeRasterParameterfNV;

extern PFNGLCONSERVATIVERASTERPARAMETERINVPROC __glewConservativeRasterParameteriNV;

extern PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern PFNGLDRAWVKIMAGENVPROC __glewDrawVkImageNV;
extern PFNGLGETVKPROCADDRNVPROC __glewGetVkProcAddrNV;
extern PFNGLSIGNALVKFENCENVPROC __glewSignalVkFenceNV;
extern PFNGLSIGNALVKSEMAPHORENVPROC __glewSignalVkSemaphoreNV;
extern PFNGLWAITVKSEMAPHORENVPROC __glewWaitVkSemaphoreNV;

extern PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern PFNGLISFENCENVPROC __glewIsFenceNV;
extern PFNGLSETFENCENVPROC __glewSetFenceNV;
extern PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern PFNGLFRAGMENTCOVERAGECOLORNVPROC __glewFragmentCoverageColorNV;

extern PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern PFNGLMULTICASTBARRIERNVPROC __glewMulticastBarrierNV;
extern PFNGLMULTICASTBLITFRAMEBUFFERNVPROC __glewMulticastBlitFramebufferNV;
extern PFNGLMULTICASTBUFFERSUBDATANVPROC __glewMulticastBufferSubDataNV;
extern PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC __glewMulticastCopyBufferSubDataNV;
extern PFNGLMULTICASTCOPYIMAGESUBDATANVPROC __glewMulticastCopyImageSubDataNV;
extern PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewMulticastFramebufferSampleLocationsfvNV;
extern PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC __glewMulticastGetQueryObjecti64vNV;
extern PFNGLMULTICASTGETQUERYOBJECTIVNVPROC __glewMulticastGetQueryObjectivNV;
extern PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC __glewMulticastGetQueryObjectui64vNV;
extern PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC __glewMulticastGetQueryObjectuivNV;
extern PFNGLMULTICASTWAITSYNCNVPROC __glewMulticastWaitSyncNV;
extern PFNGLRENDERGPUMASKNVPROC __glewRenderGpuMaskNV;

extern PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern PFNGLGETINTERNALFORMATSAMPLEIVNVPROC __glewGetInternalformatSampleivNV;

extern PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern PFNGLGETPROGRAMRESOURCEFVNVPROC __glewGetProgramResourcefvNV;
extern PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern PFNGLISPATHNVPROC __glewIsPathNV;
extern PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern PFNGLMATRIXLOAD3X2FNVPROC __glewMatrixLoad3x2fNV;
extern PFNGLMATRIXLOAD3X3FNVPROC __glewMatrixLoad3x3fNV;
extern PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC __glewMatrixLoadTranspose3x3fNV;
extern PFNGLMATRIXMULT3X2FNVPROC __glewMatrixMult3x2fNV;
extern PFNGLMATRIXMULT3X3FNVPROC __glewMatrixMult3x3fNV;
extern PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC __glewMatrixMultTranspose3x3fNV;
extern PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern PFNGLPATHGLYPHINDEXARRAYNVPROC __glewPathGlyphIndexArrayNV;
extern PFNGLPATHGLYPHINDEXRANGENVPROC __glewPathGlyphIndexRangeNV;
extern PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC __glewPathMemoryGlyphIndexArrayNV;
extern PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC __glewProgramPathFragmentInputGenNV;
extern PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC __glewStencilThenCoverFillPathInstancedNV;
extern PFNGLSTENCILTHENCOVERFILLPATHNVPROC __glewStencilThenCoverFillPathNV;
extern PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC __glewStencilThenCoverStrokePathInstancedNV;
extern PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC __glewStencilThenCoverStrokePathNV;
extern PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewFramebufferSampleLocationsfvNV;
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewNamedFramebufferSampleLocationsfvNV;

extern PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern PFNGLVIEWPORTSWIZZLENVPROC __glewViewportSwizzleNV;

extern PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
extern PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
extern PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
extern PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
extern PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
extern PFNGLORTHOFOESPROC __glewOrthofOES;

extern PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC __glewFramebufferTextureMultiviewOVR;

extern PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern PFNGLCLEARCOLORXPROC __glewClearColorx;
extern PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern PFNGLCOLOR4XPROC __glewColor4x;
extern PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern PFNGLFOGXPROC __glewFogx;
extern PFNGLFOGXVPROC __glewFogxv;
extern PFNGLFRUSTUMFPROC __glewFrustumf;
extern PFNGLFRUSTUMXPROC __glewFrustumx;
extern PFNGLLIGHTMODELXPROC __glewLightModelx;
extern PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern PFNGLLIGHTXPROC __glewLightx;
extern PFNGLLIGHTXVPROC __glewLightxv;
extern PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern PFNGLMATERIALXPROC __glewMaterialx;
extern PFNGLMATERIALXVPROC __glewMaterialxv;
extern PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern PFNGLNORMAL3XPROC __glewNormal3x;
extern PFNGLORTHOFPROC __glewOrthof;
extern PFNGLORTHOXPROC __glewOrthox;
extern PFNGLPOINTSIZEXPROC __glewPointSizex;
extern PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern PFNGLROTATEXPROC __glewRotatex;
extern PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern PFNGLSCALEXPROC __glewScalex;
extern PFNGLTEXENVXPROC __glewTexEnvx;
extern PFNGLTEXENVXVPROC __glewTexEnvxv;
extern PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern PFNGLTRANSLATEXPROC __glewTranslatex;

extern PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern PFNGLGETFIXEDVPROC __glewGetFixedv;
extern PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern PFNGLGETPROCADDRESSREGALPROC __glewGetProcAddressREGAL;

extern PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;
extern GLboolean __GLEW_VERSION_1_1;
extern GLboolean __GLEW_VERSION_1_2;
extern GLboolean __GLEW_VERSION_1_2_1;
extern GLboolean __GLEW_VERSION_1_3;
extern GLboolean __GLEW_VERSION_1_4;
extern GLboolean __GLEW_VERSION_1_5;
extern GLboolean __GLEW_VERSION_2_0;
extern GLboolean __GLEW_VERSION_2_1;
extern GLboolean __GLEW_VERSION_3_0;
extern GLboolean __GLEW_VERSION_3_1;
extern GLboolean __GLEW_VERSION_3_2;
extern GLboolean __GLEW_VERSION_3_3;
extern GLboolean __GLEW_VERSION_4_0;
extern GLboolean __GLEW_VERSION_4_1;
extern GLboolean __GLEW_VERSION_4_2;
extern GLboolean __GLEW_VERSION_4_3;
extern GLboolean __GLEW_VERSION_4_4;
extern GLboolean __GLEW_VERSION_4_5;
extern GLboolean __GLEW_3DFX_multisample;
extern GLboolean __GLEW_3DFX_tbuffer;
extern GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern GLboolean __GLEW_AMD_blend_minmax_factor;
extern GLboolean __GLEW_AMD_conservative_depth;
extern GLboolean __GLEW_AMD_debug_output;
extern GLboolean __GLEW_AMD_depth_clamp_separate;
extern GLboolean __GLEW_AMD_draw_buffers_blend;
extern GLboolean __GLEW_AMD_gcn_shader;
extern GLboolean __GLEW_AMD_gpu_shader_int64;
extern GLboolean __GLEW_AMD_interleaved_elements;
extern GLboolean __GLEW_AMD_multi_draw_indirect;
extern GLboolean __GLEW_AMD_name_gen_delete;
extern GLboolean __GLEW_AMD_occlusion_query_event;
extern GLboolean __GLEW_AMD_performance_monitor;
extern GLboolean __GLEW_AMD_pinned_memory;
extern GLboolean __GLEW_AMD_query_buffer_object;
extern GLboolean __GLEW_AMD_sample_positions;
extern GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern GLboolean __GLEW_AMD_shader_atomic_counter_ops;
extern GLboolean __GLEW_AMD_shader_explicit_vertex_parameter;
extern GLboolean __GLEW_AMD_shader_stencil_export;
extern GLboolean __GLEW_AMD_shader_stencil_value_export;
extern GLboolean __GLEW_AMD_shader_trinary_minmax;
extern GLboolean __GLEW_AMD_sparse_texture;
extern GLboolean __GLEW_AMD_stencil_operation_extended;
extern GLboolean __GLEW_AMD_texture_texture4;
extern GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern GLboolean __GLEW_AMD_transform_feedback4;
extern GLboolean __GLEW_AMD_vertex_shader_layer;
extern GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern GLboolean __GLEW_ANGLE_depth_texture;
extern GLboolean __GLEW_ANGLE_framebuffer_blit;
extern GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern GLboolean __GLEW_ANGLE_instanced_arrays;
extern GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern GLboolean __GLEW_ANGLE_program_binary;
extern GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern GLboolean __GLEW_ANGLE_texture_usage;
extern GLboolean __GLEW_ANGLE_timer_query;
extern GLboolean __GLEW_ANGLE_translated_shader_source;
extern GLboolean __GLEW_APPLE_aux_depth_stencil;
extern GLboolean __GLEW_APPLE_client_storage;
extern GLboolean __GLEW_APPLE_element_array;
extern GLboolean __GLEW_APPLE_fence;
extern GLboolean __GLEW_APPLE_float_pixels;
extern GLboolean __GLEW_APPLE_flush_buffer_range;
extern GLboolean __GLEW_APPLE_object_purgeable;
extern GLboolean __GLEW_APPLE_pixel_buffer;
extern GLboolean __GLEW_APPLE_rgb_422;
extern GLboolean __GLEW_APPLE_row_bytes;
extern GLboolean __GLEW_APPLE_specular_vector;
extern GLboolean __GLEW_APPLE_texture_range;
extern GLboolean __GLEW_APPLE_transform_hint;
extern GLboolean __GLEW_APPLE_vertex_array_object;
extern GLboolean __GLEW_APPLE_vertex_array_range;
extern GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern GLboolean __GLEW_APPLE_ycbcr_422;
extern GLboolean __GLEW_ARB_ES2_compatibility;
extern GLboolean __GLEW_ARB_ES3_1_compatibility;
extern GLboolean __GLEW_ARB_ES3_2_compatibility;
extern GLboolean __GLEW_ARB_ES3_compatibility;
extern GLboolean __GLEW_ARB_arrays_of_arrays;
extern GLboolean __GLEW_ARB_base_instance;
extern GLboolean __GLEW_ARB_bindless_texture;
extern GLboolean __GLEW_ARB_blend_func_extended;
extern GLboolean __GLEW_ARB_buffer_storage;
extern GLboolean __GLEW_ARB_cl_event;
extern GLboolean __GLEW_ARB_clear_buffer_object;
extern GLboolean __GLEW_ARB_clear_texture;
extern GLboolean __GLEW_ARB_clip_control;
extern GLboolean __GLEW_ARB_color_buffer_float;
extern GLboolean __GLEW_ARB_compatibility;
extern GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern GLboolean __GLEW_ARB_compute_shader;
extern GLboolean __GLEW_ARB_compute_variable_group_size;
extern GLboolean __GLEW_ARB_conditional_render_inverted;
extern GLboolean __GLEW_ARB_conservative_depth;
extern GLboolean __GLEW_ARB_copy_buffer;
extern GLboolean __GLEW_ARB_copy_image;
extern GLboolean __GLEW_ARB_cull_distance;
extern GLboolean __GLEW_ARB_debug_output;
extern GLboolean __GLEW_ARB_depth_buffer_float;
extern GLboolean __GLEW_ARB_depth_clamp;
extern GLboolean __GLEW_ARB_depth_texture;
extern GLboolean __GLEW_ARB_derivative_control;
extern GLboolean __GLEW_ARB_direct_state_access;
extern GLboolean __GLEW_ARB_draw_buffers;
extern GLboolean __GLEW_ARB_draw_buffers_blend;
extern GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern GLboolean __GLEW_ARB_draw_indirect;
extern GLboolean __GLEW_ARB_draw_instanced;
extern GLboolean __GLEW_ARB_enhanced_layouts;
extern GLboolean __GLEW_ARB_explicit_attrib_location;
extern GLboolean __GLEW_ARB_explicit_uniform_location;
extern GLboolean __GLEW_ARB_fragment_coord_conventions;
extern GLboolean __GLEW_ARB_fragment_layer_viewport;
extern GLboolean __GLEW_ARB_fragment_program;
extern GLboolean __GLEW_ARB_fragment_program_shadow;
extern GLboolean __GLEW_ARB_fragment_shader;
extern GLboolean __GLEW_ARB_fragment_shader_interlock;
extern GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern GLboolean __GLEW_ARB_framebuffer_object;
extern GLboolean __GLEW_ARB_framebuffer_sRGB;
extern GLboolean __GLEW_ARB_geometry_shader4;
extern GLboolean __GLEW_ARB_get_program_binary;
extern GLboolean __GLEW_ARB_get_texture_sub_image;
extern GLboolean __GLEW_ARB_gl_spirv;
extern GLboolean __GLEW_ARB_gpu_shader5;
extern GLboolean __GLEW_ARB_gpu_shader_fp64;
extern GLboolean __GLEW_ARB_gpu_shader_int64;
extern GLboolean __GLEW_ARB_half_float_pixel;
extern GLboolean __GLEW_ARB_half_float_vertex;
extern GLboolean __GLEW_ARB_imaging;
extern GLboolean __GLEW_ARB_indirect_parameters;
extern GLboolean __GLEW_ARB_instanced_arrays;
extern GLboolean __GLEW_ARB_internalformat_query;
extern GLboolean __GLEW_ARB_internalformat_query2;
extern GLboolean __GLEW_ARB_invalidate_subdata;
extern GLboolean __GLEW_ARB_map_buffer_alignment;
extern GLboolean __GLEW_ARB_map_buffer_range;
extern GLboolean __GLEW_ARB_matrix_palette;
extern GLboolean __GLEW_ARB_multi_bind;
extern GLboolean __GLEW_ARB_multi_draw_indirect;
extern GLboolean __GLEW_ARB_multisample;
extern GLboolean __GLEW_ARB_multitexture;
extern GLboolean __GLEW_ARB_occlusion_query;
extern GLboolean __GLEW_ARB_occlusion_query2;
extern GLboolean __GLEW_ARB_parallel_shader_compile;
extern GLboolean __GLEW_ARB_pipeline_statistics_query;
extern GLboolean __GLEW_ARB_pixel_buffer_object;
extern GLboolean __GLEW_ARB_point_parameters;
extern GLboolean __GLEW_ARB_point_sprite;
extern GLboolean __GLEW_ARB_post_depth_coverage;
extern GLboolean __GLEW_ARB_program_interface_query;
extern GLboolean __GLEW_ARB_provoking_vertex;
extern GLboolean __GLEW_ARB_query_buffer_object;
extern GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern GLboolean __GLEW_ARB_robustness;
extern GLboolean __GLEW_ARB_robustness_application_isolation;
extern GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern GLboolean __GLEW_ARB_sample_locations;
extern GLboolean __GLEW_ARB_sample_shading;
extern GLboolean __GLEW_ARB_sampler_objects;
extern GLboolean __GLEW_ARB_seamless_cube_map;
extern GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern GLboolean __GLEW_ARB_separate_shader_objects;
extern GLboolean __GLEW_ARB_shader_atomic_counter_ops;
extern GLboolean __GLEW_ARB_shader_atomic_counters;
extern GLboolean __GLEW_ARB_shader_ballot;
extern GLboolean __GLEW_ARB_shader_bit_encoding;
extern GLboolean __GLEW_ARB_shader_clock;
extern GLboolean __GLEW_ARB_shader_draw_parameters;
extern GLboolean __GLEW_ARB_shader_group_vote;
extern GLboolean __GLEW_ARB_shader_image_load_store;
extern GLboolean __GLEW_ARB_shader_image_size;
extern GLboolean __GLEW_ARB_shader_objects;
extern GLboolean __GLEW_ARB_shader_precision;
extern GLboolean __GLEW_ARB_shader_stencil_export;
extern GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern GLboolean __GLEW_ARB_shader_subroutine;
extern GLboolean __GLEW_ARB_shader_texture_image_samples;
extern GLboolean __GLEW_ARB_shader_texture_lod;
extern GLboolean __GLEW_ARB_shader_viewport_layer_array;
extern GLboolean __GLEW_ARB_shading_language_100;
extern GLboolean __GLEW_ARB_shading_language_420pack;
extern GLboolean __GLEW_ARB_shading_language_include;
extern GLboolean __GLEW_ARB_shading_language_packing;
extern GLboolean __GLEW_ARB_shadow;
extern GLboolean __GLEW_ARB_shadow_ambient;
extern GLboolean __GLEW_ARB_sparse_buffer;
extern GLboolean __GLEW_ARB_sparse_texture;
extern GLboolean __GLEW_ARB_sparse_texture2;
extern GLboolean __GLEW_ARB_sparse_texture_clamp;
extern GLboolean __GLEW_ARB_stencil_texturing;
extern GLboolean __GLEW_ARB_sync;
extern GLboolean __GLEW_ARB_tessellation_shader;
extern GLboolean __GLEW_ARB_texture_barrier;
extern GLboolean __GLEW_ARB_texture_border_clamp;
extern GLboolean __GLEW_ARB_texture_buffer_object;
extern GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern GLboolean __GLEW_ARB_texture_buffer_range;
extern GLboolean __GLEW_ARB_texture_compression;
extern GLboolean __GLEW_ARB_texture_compression_bptc;
extern GLboolean __GLEW_ARB_texture_compression_rgtc;
extern GLboolean __GLEW_ARB_texture_cube_map;
extern GLboolean __GLEW_ARB_texture_cube_map_array;
extern GLboolean __GLEW_ARB_texture_env_add;
extern GLboolean __GLEW_ARB_texture_env_combine;
extern GLboolean __GLEW_ARB_texture_env_crossbar;
extern GLboolean __GLEW_ARB_texture_env_dot3;
extern GLboolean __GLEW_ARB_texture_filter_minmax;
extern GLboolean __GLEW_ARB_texture_float;
extern GLboolean __GLEW_ARB_texture_gather;
extern GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern GLboolean __GLEW_ARB_texture_multisample;
extern GLboolean __GLEW_ARB_texture_non_power_of_two;
extern GLboolean __GLEW_ARB_texture_query_levels;
extern GLboolean __GLEW_ARB_texture_query_lod;
extern GLboolean __GLEW_ARB_texture_rectangle;
extern GLboolean __GLEW_ARB_texture_rg;
extern GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern GLboolean __GLEW_ARB_texture_stencil8;
extern GLboolean __GLEW_ARB_texture_storage;
extern GLboolean __GLEW_ARB_texture_storage_multisample;
extern GLboolean __GLEW_ARB_texture_swizzle;
extern GLboolean __GLEW_ARB_texture_view;
extern GLboolean __GLEW_ARB_timer_query;
extern GLboolean __GLEW_ARB_transform_feedback2;
extern GLboolean __GLEW_ARB_transform_feedback3;
extern GLboolean __GLEW_ARB_transform_feedback_instanced;
extern GLboolean __GLEW_ARB_transform_feedback_overflow_query;
extern GLboolean __GLEW_ARB_transpose_matrix;
extern GLboolean __GLEW_ARB_uniform_buffer_object;
extern GLboolean __GLEW_ARB_vertex_array_bgra;
extern GLboolean __GLEW_ARB_vertex_array_object;
extern GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern GLboolean __GLEW_ARB_vertex_attrib_binding;
extern GLboolean __GLEW_ARB_vertex_blend;
extern GLboolean __GLEW_ARB_vertex_buffer_object;
extern GLboolean __GLEW_ARB_vertex_program;
extern GLboolean __GLEW_ARB_vertex_shader;
extern GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern GLboolean __GLEW_ARB_viewport_array;
extern GLboolean __GLEW_ARB_window_pos;
extern GLboolean __GLEW_ATIX_point_sprites;
extern GLboolean __GLEW_ATIX_texture_env_combine3;
extern GLboolean __GLEW_ATIX_texture_env_route;
extern GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern GLboolean __GLEW_ATI_draw_buffers;
extern GLboolean __GLEW_ATI_element_array;
extern GLboolean __GLEW_ATI_envmap_bumpmap;
extern GLboolean __GLEW_ATI_fragment_shader;
extern GLboolean __GLEW_ATI_map_object_buffer;
extern GLboolean __GLEW_ATI_meminfo;
extern GLboolean __GLEW_ATI_pn_triangles;
extern GLboolean __GLEW_ATI_separate_stencil;
extern GLboolean __GLEW_ATI_shader_texture_lod;
extern GLboolean __GLEW_ATI_text_fragment_shader;
extern GLboolean __GLEW_ATI_texture_compression_3dc;
extern GLboolean __GLEW_ATI_texture_env_combine3;
extern GLboolean __GLEW_ATI_texture_float;
extern GLboolean __GLEW_ATI_texture_mirror_once;
extern GLboolean __GLEW_ATI_vertex_array_object;
extern GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern GLboolean __GLEW_ATI_vertex_streams;
extern GLboolean __GLEW_EGL_NV_robustness_video_memory_purge;
extern GLboolean __GLEW_EXT_422_pixels;
extern GLboolean __GLEW_EXT_Cg_shader;
extern GLboolean __GLEW_EXT_abgr;
extern GLboolean __GLEW_EXT_bgra;
extern GLboolean __GLEW_EXT_bindable_uniform;
extern GLboolean __GLEW_EXT_blend_color;
extern GLboolean __GLEW_EXT_blend_equation_separate;
extern GLboolean __GLEW_EXT_blend_func_separate;
extern GLboolean __GLEW_EXT_blend_logic_op;
extern GLboolean __GLEW_EXT_blend_minmax;
extern GLboolean __GLEW_EXT_blend_subtract;
extern GLboolean __GLEW_EXT_clip_volume_hint;
extern GLboolean __GLEW_EXT_cmyka;
extern GLboolean __GLEW_EXT_color_subtable;
extern GLboolean __GLEW_EXT_compiled_vertex_array;
extern GLboolean __GLEW_EXT_convolution;
extern GLboolean __GLEW_EXT_coordinate_frame;
extern GLboolean __GLEW_EXT_copy_texture;
extern GLboolean __GLEW_EXT_cull_vertex;
extern GLboolean __GLEW_EXT_debug_label;
extern GLboolean __GLEW_EXT_debug_marker;
extern GLboolean __GLEW_EXT_depth_bounds_test;
extern GLboolean __GLEW_EXT_direct_state_access;
extern GLboolean __GLEW_EXT_draw_buffers2;
extern GLboolean __GLEW_EXT_draw_instanced;
extern GLboolean __GLEW_EXT_draw_range_elements;
extern GLboolean __GLEW_EXT_fog_coord;
extern GLboolean __GLEW_EXT_fragment_lighting;
extern GLboolean __GLEW_EXT_framebuffer_blit;
extern GLboolean __GLEW_EXT_framebuffer_multisample;
extern GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern GLboolean __GLEW_EXT_framebuffer_object;
extern GLboolean __GLEW_EXT_framebuffer_sRGB;
extern GLboolean __GLEW_EXT_geometry_shader4;
extern GLboolean __GLEW_EXT_gpu_program_parameters;
extern GLboolean __GLEW_EXT_gpu_shader4;
extern GLboolean __GLEW_EXT_histogram;
extern GLboolean __GLEW_EXT_index_array_formats;
extern GLboolean __GLEW_EXT_index_func;
extern GLboolean __GLEW_EXT_index_material;
extern GLboolean __GLEW_EXT_index_texture;
extern GLboolean __GLEW_EXT_light_texture;
extern GLboolean __GLEW_EXT_misc_attribute;
extern GLboolean __GLEW_EXT_multi_draw_arrays;
extern GLboolean __GLEW_EXT_multisample;
extern GLboolean __GLEW_EXT_packed_depth_stencil;
extern GLboolean __GLEW_EXT_packed_float;
extern GLboolean __GLEW_EXT_packed_pixels;
extern GLboolean __GLEW_EXT_paletted_texture;
extern GLboolean __GLEW_EXT_pixel_buffer_object;
extern GLboolean __GLEW_EXT_pixel_transform;
extern GLboolean __GLEW_EXT_pixel_transform_color_table;
extern GLboolean __GLEW_EXT_point_parameters;
extern GLboolean __GLEW_EXT_polygon_offset;
extern GLboolean __GLEW_EXT_polygon_offset_clamp;
extern GLboolean __GLEW_EXT_post_depth_coverage;
extern GLboolean __GLEW_EXT_provoking_vertex;
extern GLboolean __GLEW_EXT_raster_multisample;
extern GLboolean __GLEW_EXT_rescale_normal;
extern GLboolean __GLEW_EXT_scene_marker;
extern GLboolean __GLEW_EXT_secondary_color;
extern GLboolean __GLEW_EXT_separate_shader_objects;
extern GLboolean __GLEW_EXT_separate_specular_color;
extern GLboolean __GLEW_EXT_shader_image_load_formatted;
extern GLboolean __GLEW_EXT_shader_image_load_store;
extern GLboolean __GLEW_EXT_shader_integer_mix;
extern GLboolean __GLEW_EXT_shadow_funcs;
extern GLboolean __GLEW_EXT_shared_texture_palette;
extern GLboolean __GLEW_EXT_sparse_texture2;
extern GLboolean __GLEW_EXT_stencil_clear_tag;
extern GLboolean __GLEW_EXT_stencil_two_side;
extern GLboolean __GLEW_EXT_stencil_wrap;
extern GLboolean __GLEW_EXT_subtexture;
extern GLboolean __GLEW_EXT_texture;
extern GLboolean __GLEW_EXT_texture3D;
extern GLboolean __GLEW_EXT_texture_array;
extern GLboolean __GLEW_EXT_texture_buffer_object;
extern GLboolean __GLEW_EXT_texture_compression_dxt1;
extern GLboolean __GLEW_EXT_texture_compression_latc;
extern GLboolean __GLEW_EXT_texture_compression_rgtc;
extern GLboolean __GLEW_EXT_texture_compression_s3tc;
extern GLboolean __GLEW_EXT_texture_cube_map;
extern GLboolean __GLEW_EXT_texture_edge_clamp;
extern GLboolean __GLEW_EXT_texture_env;
extern GLboolean __GLEW_EXT_texture_env_add;
extern GLboolean __GLEW_EXT_texture_env_combine;
extern GLboolean __GLEW_EXT_texture_env_dot3;
extern GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern GLboolean __GLEW_EXT_texture_filter_minmax;
extern GLboolean __GLEW_EXT_texture_integer;
extern GLboolean __GLEW_EXT_texture_lod_bias;
extern GLboolean __GLEW_EXT_texture_mirror_clamp;
extern GLboolean __GLEW_EXT_texture_object;
extern GLboolean __GLEW_EXT_texture_perturb_normal;
extern GLboolean __GLEW_EXT_texture_rectangle;
extern GLboolean __GLEW_EXT_texture_sRGB;
extern GLboolean __GLEW_EXT_texture_sRGB_decode;
extern GLboolean __GLEW_EXT_texture_shared_exponent;
extern GLboolean __GLEW_EXT_texture_snorm;
extern GLboolean __GLEW_EXT_texture_swizzle;
extern GLboolean __GLEW_EXT_timer_query;
extern GLboolean __GLEW_EXT_transform_feedback;
extern GLboolean __GLEW_EXT_vertex_array;
extern GLboolean __GLEW_EXT_vertex_array_bgra;
extern GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern GLboolean __GLEW_EXT_vertex_shader;
extern GLboolean __GLEW_EXT_vertex_weighting;
extern GLboolean __GLEW_EXT_window_rectangles;
extern GLboolean __GLEW_EXT_x11_sync_object;
extern GLboolean __GLEW_GREMEDY_frame_terminator;
extern GLboolean __GLEW_GREMEDY_string_marker;
extern GLboolean __GLEW_HP_convolution_border_modes;
extern GLboolean __GLEW_HP_image_transform;
extern GLboolean __GLEW_HP_occlusion_test;
extern GLboolean __GLEW_HP_texture_lighting;
extern GLboolean __GLEW_IBM_cull_vertex;
extern GLboolean __GLEW_IBM_multimode_draw_arrays;
extern GLboolean __GLEW_IBM_rasterpos_clip;
extern GLboolean __GLEW_IBM_static_data;
extern GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern GLboolean __GLEW_IBM_vertex_array_lists;
extern GLboolean __GLEW_INGR_color_clamp;
extern GLboolean __GLEW_INGR_interlace_read;
extern GLboolean __GLEW_INTEL_conservative_rasterization;
extern GLboolean __GLEW_INTEL_fragment_shader_ordering;
extern GLboolean __GLEW_INTEL_framebuffer_CMAA;
extern GLboolean __GLEW_INTEL_map_texture;
extern GLboolean __GLEW_INTEL_parallel_arrays;
extern GLboolean __GLEW_INTEL_performance_query;
extern GLboolean __GLEW_INTEL_texture_scissor;
extern GLboolean __GLEW_KHR_blend_equation_advanced;
extern GLboolean __GLEW_KHR_blend_equation_advanced_coherent;
extern GLboolean __GLEW_KHR_context_flush_control;
extern GLboolean __GLEW_KHR_debug;
extern GLboolean __GLEW_KHR_no_error;
extern GLboolean __GLEW_KHR_robust_buffer_access_behavior;
extern GLboolean __GLEW_KHR_robustness;
extern GLboolean __GLEW_KHR_texture_compression_astc_hdr;
extern GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern GLboolean __GLEW_KHR_texture_compression_astc_sliced_3d;
extern GLboolean __GLEW_KTX_buffer_region;
extern GLboolean __GLEW_MESAX_texture_stack;
extern GLboolean __GLEW_MESA_pack_invert;
extern GLboolean __GLEW_MESA_resize_buffers;
extern GLboolean __GLEW_MESA_shader_integer_functions;
extern GLboolean __GLEW_MESA_window_pos;
extern GLboolean __GLEW_MESA_ycbcr_texture;
extern GLboolean __GLEW_NVX_blend_equation_advanced_multi_draw_buffers;
extern GLboolean __GLEW_NVX_conditional_render;
extern GLboolean __GLEW_NVX_gpu_memory_info;
extern GLboolean __GLEW_NVX_linked_gpu_multicast;
extern GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern GLboolean __GLEW_NV_bindless_multi_draw_indirect_count;
extern GLboolean __GLEW_NV_bindless_texture;
extern GLboolean __GLEW_NV_blend_equation_advanced;
extern GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern GLboolean __GLEW_NV_blend_square;
extern GLboolean __GLEW_NV_clip_space_w_scaling;
extern GLboolean __GLEW_NV_command_list;
extern GLboolean __GLEW_NV_compute_program5;
extern GLboolean __GLEW_NV_conditional_render;
extern GLboolean __GLEW_NV_conservative_raster;
extern GLboolean __GLEW_NV_conservative_raster_dilate;
extern GLboolean __GLEW_NV_conservative_raster_pre_snap_triangles;
extern GLboolean __GLEW_NV_copy_depth_to_color;
extern GLboolean __GLEW_NV_copy_image;
extern GLboolean __GLEW_NV_deep_texture3D;
extern GLboolean __GLEW_NV_depth_buffer_float;
extern GLboolean __GLEW_NV_depth_clamp;
extern GLboolean __GLEW_NV_depth_range_unclamped;
extern GLboolean __GLEW_NV_draw_texture;
extern GLboolean __GLEW_NV_draw_vulkan_image;
extern GLboolean __GLEW_NV_evaluators;
extern GLboolean __GLEW_NV_explicit_multisample;
extern GLboolean __GLEW_NV_fence;
extern GLboolean __GLEW_NV_fill_rectangle;
extern GLboolean __GLEW_NV_float_buffer;
extern GLboolean __GLEW_NV_fog_distance;
extern GLboolean __GLEW_NV_fragment_coverage_to_color;
extern GLboolean __GLEW_NV_fragment_program;
extern GLboolean __GLEW_NV_fragment_program2;
extern GLboolean __GLEW_NV_fragment_program4;
extern GLboolean __GLEW_NV_fragment_program_option;
extern GLboolean __GLEW_NV_fragment_shader_interlock;
extern GLboolean __GLEW_NV_framebuffer_mixed_samples;
extern GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern GLboolean __GLEW_NV_geometry_program4;
extern GLboolean __GLEW_NV_geometry_shader4;
extern GLboolean __GLEW_NV_geometry_shader_passthrough;
extern GLboolean __GLEW_NV_gpu_multicast;
extern GLboolean __GLEW_NV_gpu_program4;
extern GLboolean __GLEW_NV_gpu_program5;
extern GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern GLboolean __GLEW_NV_gpu_program_fp64;
extern GLboolean __GLEW_NV_gpu_shader5;
extern GLboolean __GLEW_NV_half_float;
extern GLboolean __GLEW_NV_internalformat_sample_query;
extern GLboolean __GLEW_NV_light_max_exponent;
extern GLboolean __GLEW_NV_multisample_coverage;
extern GLboolean __GLEW_NV_multisample_filter_hint;
extern GLboolean __GLEW_NV_occlusion_query;
extern GLboolean __GLEW_NV_packed_depth_stencil;
extern GLboolean __GLEW_NV_parameter_buffer_object;
extern GLboolean __GLEW_NV_parameter_buffer_object2;
extern GLboolean __GLEW_NV_path_rendering;
extern GLboolean __GLEW_NV_path_rendering_shared_edge;
extern GLboolean __GLEW_NV_pixel_data_range;
extern GLboolean __GLEW_NV_point_sprite;
extern GLboolean __GLEW_NV_present_video;
extern GLboolean __GLEW_NV_primitive_restart;
extern GLboolean __GLEW_NV_register_combiners;
extern GLboolean __GLEW_NV_register_combiners2;
extern GLboolean __GLEW_NV_robustness_video_memory_purge;
extern GLboolean __GLEW_NV_sample_locations;
extern GLboolean __GLEW_NV_sample_mask_override_coverage;
extern GLboolean __GLEW_NV_shader_atomic_counters;
extern GLboolean __GLEW_NV_shader_atomic_float;
extern GLboolean __GLEW_NV_shader_atomic_float64;
extern GLboolean __GLEW_NV_shader_atomic_fp16_vector;
extern GLboolean __GLEW_NV_shader_atomic_int64;
extern GLboolean __GLEW_NV_shader_buffer_load;
extern GLboolean __GLEW_NV_shader_storage_buffer_object;
extern GLboolean __GLEW_NV_shader_thread_group;
extern GLboolean __GLEW_NV_shader_thread_shuffle;
extern GLboolean __GLEW_NV_stereo_view_rendering;
extern GLboolean __GLEW_NV_tessellation_program5;
extern GLboolean __GLEW_NV_texgen_emboss;
extern GLboolean __GLEW_NV_texgen_reflection;
extern GLboolean __GLEW_NV_texture_barrier;
extern GLboolean __GLEW_NV_texture_compression_vtc;
extern GLboolean __GLEW_NV_texture_env_combine4;
extern GLboolean __GLEW_NV_texture_expand_normal;
extern GLboolean __GLEW_NV_texture_multisample;
extern GLboolean __GLEW_NV_texture_rectangle;
extern GLboolean __GLEW_NV_texture_shader;
extern GLboolean __GLEW_NV_texture_shader2;
extern GLboolean __GLEW_NV_texture_shader3;
extern GLboolean __GLEW_NV_transform_feedback;
extern GLboolean __GLEW_NV_transform_feedback2;
extern GLboolean __GLEW_NV_uniform_buffer_unified_memory;
extern GLboolean __GLEW_NV_vdpau_interop;
extern GLboolean __GLEW_NV_vertex_array_range;
extern GLboolean __GLEW_NV_vertex_array_range2;
extern GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern GLboolean __GLEW_NV_vertex_program;
extern GLboolean __GLEW_NV_vertex_program1_1;
extern GLboolean __GLEW_NV_vertex_program2;
extern GLboolean __GLEW_NV_vertex_program2_option;
extern GLboolean __GLEW_NV_vertex_program3;
extern GLboolean __GLEW_NV_vertex_program4;
extern GLboolean __GLEW_NV_video_capture;
extern GLboolean __GLEW_NV_viewport_array2;
extern GLboolean __GLEW_NV_viewport_swizzle;
extern GLboolean __GLEW_OES_byte_coordinates;
extern GLboolean __GLEW_OES_compressed_paletted_texture;
extern GLboolean __GLEW_OES_read_format;
extern GLboolean __GLEW_OES_single_precision;
extern GLboolean __GLEW_OML_interlace;
extern GLboolean __GLEW_OML_resample;
extern GLboolean __GLEW_OML_subsample;
extern GLboolean __GLEW_OVR_multiview;
extern GLboolean __GLEW_OVR_multiview2;
extern GLboolean __GLEW_PGI_misc_hints;
extern GLboolean __GLEW_PGI_vertex_hints;
extern GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern GLboolean __GLEW_REGAL_enable;
extern GLboolean __GLEW_REGAL_error_string;
extern GLboolean __GLEW_REGAL_extension_query;
extern GLboolean __GLEW_REGAL_log;
extern GLboolean __GLEW_REGAL_proc_address;
extern GLboolean __GLEW_REND_screen_coordinates;
extern GLboolean __GLEW_S3_s3tc;
extern GLboolean __GLEW_SGIS_color_range;
extern GLboolean __GLEW_SGIS_detail_texture;
extern GLboolean __GLEW_SGIS_fog_function;
extern GLboolean __GLEW_SGIS_generate_mipmap;
extern GLboolean __GLEW_SGIS_multisample;
extern GLboolean __GLEW_SGIS_pixel_texture;
extern GLboolean __GLEW_SGIS_point_line_texgen;
extern GLboolean __GLEW_SGIS_sharpen_texture;
extern GLboolean __GLEW_SGIS_texture4D;
extern GLboolean __GLEW_SGIS_texture_border_clamp;
extern GLboolean __GLEW_SGIS_texture_edge_clamp;
extern GLboolean __GLEW_SGIS_texture_filter4;
extern GLboolean __GLEW_SGIS_texture_lod;
extern GLboolean __GLEW_SGIS_texture_select;
extern GLboolean __GLEW_SGIX_async;
extern GLboolean __GLEW_SGIX_async_histogram;
extern GLboolean __GLEW_SGIX_async_pixel;
extern GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern GLboolean __GLEW_SGIX_clipmap;
extern GLboolean __GLEW_SGIX_convolution_accuracy;
extern GLboolean __GLEW_SGIX_depth_texture;
extern GLboolean __GLEW_SGIX_flush_raster;
extern GLboolean __GLEW_SGIX_fog_offset;
extern GLboolean __GLEW_SGIX_fog_texture;
extern GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern GLboolean __GLEW_SGIX_framezoom;
extern GLboolean __GLEW_SGIX_interlace;
extern GLboolean __GLEW_SGIX_ir_instrument1;
extern GLboolean __GLEW_SGIX_list_priority;
extern GLboolean __GLEW_SGIX_pixel_texture;
extern GLboolean __GLEW_SGIX_pixel_texture_bits;
extern GLboolean __GLEW_SGIX_reference_plane;
extern GLboolean __GLEW_SGIX_resample;
extern GLboolean __GLEW_SGIX_shadow;
extern GLboolean __GLEW_SGIX_shadow_ambient;
extern GLboolean __GLEW_SGIX_sprite;
extern GLboolean __GLEW_SGIX_tag_sample_buffer;
extern GLboolean __GLEW_SGIX_texture_add_env;
extern GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern GLboolean __GLEW_SGIX_texture_lod_bias;
extern GLboolean __GLEW_SGIX_texture_multi_buffer;
extern GLboolean __GLEW_SGIX_texture_range;
extern GLboolean __GLEW_SGIX_texture_scale_bias;
extern GLboolean __GLEW_SGIX_vertex_preclip;
extern GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern GLboolean __GLEW_SGIX_ycrcb;
extern GLboolean __GLEW_SGI_color_matrix;
extern GLboolean __GLEW_SGI_color_table;
extern GLboolean __GLEW_SGI_texture_color_table;
extern GLboolean __GLEW_SUNX_constant_data;
extern GLboolean __GLEW_SUN_convolution_border_modes;
extern GLboolean __GLEW_SUN_global_alpha;
extern GLboolean __GLEW_SUN_mesh_array;
extern GLboolean __GLEW_SUN_read_video_pixels;
extern GLboolean __GLEW_SUN_slice_accum;
extern GLboolean __GLEW_SUN_triangle_list;
extern GLboolean __GLEW_SUN_vertex;
extern GLboolean __GLEW_WIN_phong_shading;
extern GLboolean __GLEW_WIN_specular_fog;
extern GLboolean __GLEW_WIN_swap_hint;
# 20074 "/usr/local/include/GL/glew.h" 3
extern GLenum glewInit (void);
extern GLboolean glewIsSupported (const char *name);
# 20086 "/usr/local/include/GL/glew.h" 3
extern GLboolean glewExperimental;
extern GLboolean glewGetExtension (const char *name);
extern const GLubyte * glewGetErrorString (GLenum error);
extern const GLubyte * glewGetString (GLenum name);


}
# 11 "./opengl.hpp" 2

# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3
# 13 "./opengl.hpp" 2






typedef GLuint UniformLocation;
typedef GLuint Texture;
typedef GLuint VertexArray;
typedef VertexArray VAO;
typedef GLuint VertexBuffer;
typedef VertexBuffer VBO;
typedef GLuint ElementBuffer;
typedef ElementBuffer EBO;
typedef GLuint GLBuffer;
# 6 "./types.h" 2

# 1 "/usr/local/include/glm/glm.hpp" 1 3
# 52 "/usr/local/include/glm/glm.hpp" 3
# 1 "/usr/local/include/glm/detail/_fixes.hpp" 1 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 1 3
# 300 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
# 226 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
typedef __char16_t char16_t;
typedef __char32_t char32_t;
# 349 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
namespace std {
  inline namespace __1 {
  }
}
# 494 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
template <bool> struct __static_assert_test;
template <> struct __static_assert_test<true> {};
template <unsigned> struct __static_assert_check {};
# 301 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 1 3
# 203 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 1 3
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 2 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 3


namespace std {inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;

typedef long double max_align_t;



struct __attribute__ ((__type_visibility__("default"))) nullptr_t
{
    void* __lx;

    struct __nat {int __for_bool_;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t() : __lx(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t(int __nat::*) : __lx(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int __nat::*() const {return 0;}

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp* () const {return 0;}

    template <class _Tp, class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp _Up::* () const {return 0;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator==(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!=(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<=(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>=(nullptr_t, nullptr_t) {return true;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t __get_nullptr_t() {return nullptr_t(0);}





} }
# 204 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 2 3
# 207 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3


namespace std {inline namespace __1 {

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};





template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};






struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
    static const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                          operator value_type() const {return value;}




};

template <class _Tp, _Tp __v>
                  const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};






template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 309 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};



template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};
# 382 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 397 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 415 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};



namespace __libcpp_is_function_imp
{
template <class _Tp> char __test(_Tp*);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source();
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};



template <class _Tp> struct __libcpp_is_member_function_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 487 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};



template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};







template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
# 579 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference {typedef _Tp& type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<_Tp&> {typedef _Tp& type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<void> {typedef void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const void> {typedef const void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<volatile void> {typedef volatile void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const volatile void> {typedef const volatile void type;};
# 612 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
typename add_lvalue_reference<_Tp>::type
declval();



struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename remove_reference<_Tp>::type* type;};







template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};



template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};



template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};







template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};







namespace __is_abstract_imp
{
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};

template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};





template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 801 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 920 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 951 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 971 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 983 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};



template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{






};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Aligner>::value)>)> __t1074;
    union type
    {
        _Aligner __align;
        unsigned char __data[_Len];
    };
};
# 1097 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[_Len]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[_Len]; };};
# 1154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef __typeof__(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote
{
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
    typedef typename __promote<_A3>::type __type3;
public:
    typedef __typeof__(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote<_A1, _A2, void, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
public:
    typedef __typeof__(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
    static const bool __does_not_throw = false;
};
# 1236 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,
    __nat
    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,
    __nat
    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};







template <class _Tp, class _Up = void, class V = void>
struct __attribute__ ((__type_visibility__("default"))) common_type
{
public:
    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, void, void>
{
public:
    typedef _Tp type;
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up, void>
{
private:




    static _Tp __t();
    static _Up __u();

public:
    typedef typename remove_reference<__typeof__(true ? __t() : __u())>::type type;
};
# 1441 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<__typeof__((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type



__is_assignable_test(_Tp, _Arg&);


template <class _Arg>
false_type



__is_assignable_test(__any, _Arg&);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public common_type
        <
            __typeof__(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        >::type {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                     const typename add_lvalue_reference<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable




    : public is_copy_assignable<_Tp> {};




template <class _Tp>
struct __destructible_test
{
    _Tp __t;
};

template <class _Tp>
__typeof__((std::__1::declval<__destructible_test<_Tp> >().~__destructible_test<_Tp>(), true_type()))



__is_destructible_test(_Tp&);


false_type
__is_destructible_test(__any);

template <class _Tp, bool = is_void<_Tp>::value || is_abstract<_Tp>::value
                                                || is_function<_Tp>::value>
struct __destructible_imp
    : public common_type
        <
            __typeof__(__is_destructible_test(declval<_Tp>()))
        >::type {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_imp<_Tp> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public false_type {};
# 1564 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
move(_Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
move(const _Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
forward(typename std::remove_reference<_Tp>::type& __t) throw()
{
    return __t;
}


template <class _Tp>
class __rv
{
    typedef typename remove_reference<_Tp>::type _Trr;
    _Trr& t_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Trr* operator->() {return &t_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __rv(_Trr& __t) : t_(__t) {}
};
# 1615 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(const _Tp& __t)
{
    return std::__1::forward<_Tp>(__t);
}



template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};
# 1722 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};



template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{


};



template <class _Callable> class result_of;



template <class _Fn, bool, bool>
class __result_of
{
};

template <class _Fn>
class __result_of<_Fn(), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()()) type;
};

template <class _Fn, class _A0>
class __result_of<_Fn(_A0), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>())) type;
};

template <class _Fn, class _A0, class _A1>
class __result_of<_Fn(_A0, _A1), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
};

template <class _Fn, class _A0, class _A1, class _A2>
class __result_of<_Fn(_A0, _A1, _A2), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
};

template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
struct __result_of_mp;



template <class _MP, class _Tp>
struct __result_of_mp<_MP, _Tp, true>
    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>
{
};



template <class _MP, class _Tp, bool>
struct __result_of_mdp;

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, false>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_Tp>()), _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, true>
{
    typedef typename __apply_cv<_Tp, _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mp<_Rp _Class::*, _Tp, false>
    : public __result_of_mdp<_Rp _Class::*, _Tp,
            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
{
};



template <class _Fn, class _Tp>
class __result_of<_Fn(_Tp), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0>
class __result_of<_Fn(_Tp, _A0), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1>
class __result_of<_Fn(_Tp, _A0, _A1), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};



template <class _Fn>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn()>
    : public __result_of<_Fn(),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0)>
    : public __result_of<_Fn(_A0),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1)>
    : public __result_of<_Fn(_A0, _A1),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1, _A2)>
    : public __result_of<_Fn(_A0, _A1, _A2),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};
# 2131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
__typeof__((_Tp(), true_type()))
__is_constructible0_test(_Tp&);

false_type
__is_constructible0_test(__any);

template <class _Tp, class _A0>
__typeof__((_Tp(std::__1::declval<_A0>()), true_type()))
__is_constructible1_test(_Tp&, _A0&);

template <class _A0>
false_type
__is_constructible1_test(__any, _A0&);

template <class _Tp, class _A0, class _A1>
__typeof__((_Tp(std::__1::declval<_A0>(), std::__1::declval<_A1>()), true_type()))
__is_constructible2_test(_Tp&, _A0&, _A1&);

template <class _A0, class _A1>
false_type
__is_constructible2_test(__any, _A0&, _A1&);

template <bool, class _Tp>
struct __is_constructible0_imp
    : public common_type
             <
                 __typeof__(__is_constructible0_test(declval<_Tp&>()))
             >::type
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_imp
    : public common_type
             <
                 __typeof__(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
             >::type
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_imp
    : public common_type
             <
                 __typeof__(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
             >::type
    {};





template <class _Tp>
struct __is_constructible0_imp<true, _Tp>
    : public is_scalar<_Tp>
    {};

template <class _Tp, class _A0>
struct __is_constructible1_imp<true, _Tp, _A0>
    : public is_convertible<_A0, _Tp>
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_imp<true, _Tp, _A0, _A1>
    : public false_type
    {};



template <bool, class _Tp>
struct __is_constructible0_void_check
    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp>
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_void_check
    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0>
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check
    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0, _A1>
    {};



template <class _Tp>
struct __is_constructible0_void_check<true, _Tp>
    : public false_type
    {};

template <class _Tp, class _A0>
struct __is_constructible1_void_check<true, _Tp, _A0>
    : public false_type
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
    : public false_type
    {};



namespace __is_construct
{

struct __nat {};

}

template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public __is_constructible2_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value
                                        || is_void<_A1>::value,
                                           _Tp, _A0, _A1>
    {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
    : public __is_constructible0_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value,
                                           _Tp>
    {};

template <class _Tp, class _A0>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, _A0, __is_construct::__nat>
    : public __is_constructible1_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value,
                                           _Tp, _A0>
    {};




template <class _Ap, size_t _Np>
struct __is_constructible0_imp<false, _Ap[_Np]>
    : public is_constructible<typename remove_all_extents<_Ap>::type>
    {};

template <class _Ap, size_t _Np, class _A0>
struct __is_constructible1_imp<false, _Ap[_Np], _A0>
    : public false_type
    {};

template <class _Ap, size_t _Np, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
    : public false_type
    {};



template <class _Ap>
struct __is_constructible0_imp<false, _Ap[]>
    : public false_type
    {};

template <class _Ap, class _A0>
struct __is_constructible1_imp<false, _Ap[], _A0>
    : public false_type
    {};

template <class _Ap, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
    : public false_type
    {};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible



    : public is_copy_constructible<_Tp>

    {};
# 2389 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : false_type
{
};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
{
};
# 2462 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible



    : public is_trivially_copy_constructible<_Tp>

    {};





template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 2522 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};
# 2644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : false_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_constructor(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible



    : public is_nothrow_copy_constructible<_Tp>

    {};
# 2745 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public false_type {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, const _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
# 2789 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};
# 2853 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_nothrow_destructor
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_reference<_Tp>::value> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 2881 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>




    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};
# 3190 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))







void

swap(_Tp& __x, _Tp& __y)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)



{
    swap(*__a, *__b);
}



namespace __detail
{

using std::__1::swap;
__nat swap(__any, __any);

template <class _Tp>
struct __swappable
{
    typedef __typeof__(swap(std::__1::declval<_Tp&>(), std::__1::declval<_Tp&>())) type;
    static const bool value = !is_same<type, __nat>::value;
};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
{
};
# 3266 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __is_nothrow_swappable
    : public false_type
{
};





template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};
# 3319 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
} }
# 303 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3
# 310 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3






template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_signbit(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_signbitf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_signbitd((double)(__x)) : __inline_signbitl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
signbit(_A1 __x) throw()
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
int
__libcpp_fpclassify(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __fpclassifyf((float)(__x)) : sizeof(__x) == sizeof(double) ? __fpclassifyd((double)(__x)) : __fpclassifyl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, int>::type
fpclassify(_A1 __x) throw()
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isfinite(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isfinitef((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isfinited((double)(__x)) : __inline_isfinitel((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isfinite(_A1 __x) throw()
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isinf(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isinff((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isinfd((double)(__x)) : __inline_isinfl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isinf(_A1 __x) throw()
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnan(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isnanf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isnand((double)(__x)) : __inline_isnanl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnan(_A1 __x) throw()
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnormal(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isnormalf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isnormald((double)(__x)) : __inline_isnormall((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnormal(_A1 __x) throw()
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__x);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreater((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreaterequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreaterequal((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isless(_A1 __x, _A2 __y) throw()
{
    return __builtin_isless((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessequal((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessgreater((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isunordered(_A1 __x, _A2 __y) throw()
{
    return __builtin_isunordered((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__x, (type)__y);
}



namespace std {inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;




inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float
abs(float __x) throw() {return fabsf(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double
abs(double __x) throw() {return fabs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double
abs(long double __x) throw() {return fabsl(__x);}






using ::acos;
using ::acosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acos(float __x) throw() {return acosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acos(long double __x) throw() {return acosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acos(_A1 __x) throw() {return acos((double)__x);}



using ::asin;
using ::asinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asin(float __x) throw() {return asinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asin(long double __x) throw() {return asinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asin(_A1 __x) throw() {return asin((double)__x);}



using ::atan;
using ::atanf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan(float __x) throw() {return atanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan(long double __x) throw() {return atanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atan(_A1 __x) throw() {return atan((double)__x);}



using ::atan2;
using ::atan2f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan2(float __y, float __x) throw() {return atan2f(__y, __x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan2(long double __y, long double __x) throw() {return atan2l(__y, __x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
atan2(_A1 __y, _A2 __x) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t740;

    return atan2((__result_type)__y, (__result_type)__x);
}



using ::ceil;
using ::ceilf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ceil(float __x) throw() {return ceilf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ceil(long double __x) throw() {return ceill(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ceil(_A1 __x) throw() {return ceil((double)__x);}



using ::cos;
using ::cosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cos(float __x) throw() {return cosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cos(long double __x) throw() {return cosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cos(_A1 __x) throw() {return cos((double)__x);}



using ::cosh;
using ::coshf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cosh(float __x) throw() {return coshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cosh(long double __x) throw() {return coshl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cosh(_A1 __x) throw() {return cosh((double)__x);}




using ::exp;
using ::expf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp(float __x) throw() {return expf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp(long double __x) throw() {return expl(__x);}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp(_A1 __x) throw() {return exp((double)__x);}



using ::fabs;
using ::fabsf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fabs(float __x) throw() {return fabsf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fabs(long double __x) throw() {return fabsl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
fabs(_A1 __x) throw() {return fabs((double)__x);}



using ::floor;
using ::floorf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float floor(float __x) throw() {return floorf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double floor(long double __x) throw() {return floorl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
floor(_A1 __x) throw() {return floor((double)__x);}




using ::fmod;
using ::fmodf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmod(float __x, float __y) throw() {return fmodf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmod(long double __x, long double __y) throw() {return fmodl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmod(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t862;

    return fmod((__result_type)__x, (__result_type)__y);
}




using ::frexp;
using ::frexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float frexp(float __x, int* __e) throw() {return frexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double frexp(long double __x, int* __e) throw() {return frexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
frexp(_A1 __x, int* __e) throw() {return frexp((double)__x, __e);}



using ::ldexp;
using ::ldexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ldexp(float __x, int __e) throw() {return ldexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ldexp(long double __x, int __e) throw() {return ldexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ldexp(_A1 __x, int __e) throw() {return ldexp((double)__x, __e);}




using ::log;
using ::logf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log(float __x) throw() {return logf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log(long double __x) throw() {return logl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log(_A1 __x) throw() {return log((double)__x);}




using ::log10;
using ::log10f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log10(float __x) throw() {return log10f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log10(long double __x) throw() {return log10l(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log10(_A1 __x) throw() {return log10((double)__x);}



using ::modf;
using ::modff;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float modf(float __x, float* __y) throw() {return modff(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double modf(long double __x, long double* __y) throw() {return modfl(__x, __y);}





using ::pow;
using ::powf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float pow(float __x, float __y) throw() {return powf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double pow(long double __x, long double __y) throw() {return powl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
pow(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t965;

    return pow((__result_type)__x, (__result_type)__y);
}



using ::sin;
using ::sinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sin(float __x) throw() {return sinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sin(long double __x) throw() {return sinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sin(_A1 __x) throw() {return sin((double)__x);}



using ::sinh;
using ::sinhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sinh(float __x) throw() {return sinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sinh(long double __x) throw() {return sinhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sinh(_A1 __x) throw() {return sinh((double)__x);}




using ::sqrt;
using ::sqrtf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sqrt(float __x) throw() {return sqrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sqrt(long double __x) throw() {return sqrtl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sqrt(_A1 __x) throw() {return sqrt((double)__x);}



using ::tan;
using ::tanf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tan(float __x) throw() {return tanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tan(long double __x) throw() {return tanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tan(_A1 __x) throw() {return tan((double)__x);}



using ::tanh;
using ::tanhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tanh(float __x) throw() {return tanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tanh(long double __x) throw() {return tanhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tanh(_A1 __x) throw() {return tanh((double)__x);}




using ::acosh;
using ::acoshf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acosh(float __x) throw() {return acoshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acosh(long double __x) throw() {return acoshl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acosh(_A1 __x) throw() {return acosh((double)__x);}





using ::asinh;
using ::asinhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asinh(float __x) throw() {return asinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asinh(long double __x) throw() {return asinhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asinh(_A1 __x) throw() {return asinh((double)__x);}





using ::atanh;
using ::atanhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atanh(float __x) throw() {return atanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atanh(long double __x) throw() {return atanhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atanh(_A1 __x) throw() {return atanh((double)__x);}





using ::cbrt;
using ::cbrtf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cbrt(float __x) throw() {return cbrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cbrt(long double __x) throw() {return cbrtl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cbrt(_A1 __x) throw() {return cbrt((double)__x);}




using ::copysign;
using ::copysignf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float copysign(float __x, float __y) throw() {return copysignf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double copysign(long double __x, long double __y) throw() {return copysignl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
copysign(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1127;

    return copysign((__result_type)__x, (__result_type)__y);
}





using ::erf;
using ::erff;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erf(float __x) throw() {return erff(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erf(long double __x) throw() {return erfl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erf(_A1 __x) throw() {return erf((double)__x);}



using ::erfc;
using ::erfcf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erfc(float __x) throw() {return erfcf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erfc(long double __x) throw() {return erfcl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erfc(_A1 __x) throw() {return erfc((double)__x);}



using ::exp2;
using ::exp2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp2(float __x) throw() {return exp2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp2(long double __x) throw() {return exp2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp2(_A1 __x) throw() {return exp2((double)__x);}



using ::expm1;
using ::expm1f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float expm1(float __x) throw() {return expm1f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double expm1(long double __x) throw() {return expm1l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
expm1(_A1 __x) throw() {return expm1((double)__x);}



using ::fdim;
using ::fdimf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fdim(float __x, float __y) throw() {return fdimf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fdim(long double __x, long double __y) throw() {return fdiml(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fdim(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1205;

    return fdim((__result_type)__x, (__result_type)__y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmaf(float __x, float __y, float __z) throw() {return (float)((double)__x*__y + __z);}




using ::fma;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fma(float __x, float __y, float __z) throw() {return fmaf(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fma(long double __x, long double __y, long double __z) throw() {return fmal(__x, __y, __z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    typename __promote<_A1, _A2, _A3>::type
>::type
fma(_A1 __x, _A2 __y, _A3 __z) throw()
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value && is_same<_A3, __result_type>::value)))>)> __t1235;


    return fma((__result_type)__x, (__result_type)__y, (__result_type)__z);
}



using ::fmax;
using ::fmaxf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmax(float __x, float __y) throw() {return fmaxf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmax(long double __x, long double __y) throw() {return fmaxl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmax(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1259;

    return fmax((__result_type)__x, (__result_type)__y);
}



using ::fmin;
using ::fminf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmin(float __x, float __y) throw() {return fminf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmin(long double __x, long double __y) throw() {return fminl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmin(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1283;

    return fmin((__result_type)__x, (__result_type)__y);
}



using ::hypot;
using ::hypotf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float hypot(float __x, float __y) throw() {return hypotf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double hypot(long double __x, long double __y) throw() {return hypotl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
hypot(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1307;

    return hypot((__result_type)__x, (__result_type)__y);
}



using ::ilogb;
using ::ilogbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(float __x) throw() {return ilogbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(long double __x) throw() {return ilogbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, int>::type
ilogb(_A1 __x) throw() {return ilogb((double)__x);}



using ::lgamma;
using ::lgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float lgamma(float __x) throw() {return lgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double lgamma(long double __x) throw() {return lgammal(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
lgamma(_A1 __x) throw() {return lgamma((double)__x);}




using ::llrint;
using ::llrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(float __x) throw() {return llrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(long double __x) throw() {return llrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llrint(_A1 __x) throw() {return llrint((double)__x);}



using ::llround;
using ::llroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(float __x) throw() {return llroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(long double __x) throw() {return llroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llround(_A1 __x) throw() {return llround((double)__x);}



using ::log1p;
using ::log1pf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log1p(float __x) throw() {return log1pf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log1p(long double __x) throw() {return log1pl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log1p(_A1 __x) throw() {return log1p((double)__x);}



using ::log2;
using ::log2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log2(float __x) throw() {return log2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log2(long double __x) throw() {return log2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log2(_A1 __x) throw() {return log2((double)__x);}



using ::logb;
using ::logbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float logb(float __x) throw() {return logbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double logb(long double __x) throw() {return logbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
logb(_A1 __x) throw() {return logb((double)__x);}



using ::lrint;
using ::lrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(float __x) throw() {return lrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(long double __x) throw() {return lrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lrint(_A1 __x) throw() {return lrint((double)__x);}



using ::lround;
using ::lroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(float __x) throw() {return lroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(long double __x) throw() {return lroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lround(_A1 __x) throw() {return lround((double)__x);}







using ::nan;
using ::nanf;







using ::nearbyint;
using ::nearbyintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nearbyint(float __x) throw() {return nearbyintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nearbyint(long double __x) throw() {return nearbyintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nearbyint(_A1 __x) throw() {return nearbyint((double)__x);}



using ::nextafter;
using ::nextafterf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nextafter(float __x, float __y) throw() {return nextafterf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nextafter(long double __x, long double __y) throw() {return nextafterl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
nextafter(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1476;

    return nextafter((__result_type)__x, (__result_type)__y);
}



using ::nexttoward;
using ::nexttowardf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nexttoward(float __x, long double __y) throw() {return nexttowardf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nexttoward(long double __x, long double __y) throw() {return nexttowardl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nexttoward(_A1 __x, long double __y) throw() {return nexttoward((double)__x, __y);}



using ::remainder;
using ::remainderf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remainder(float __x, float __y) throw() {return remainderf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remainder(long double __x, long double __y) throw() {return remainderl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remainder(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1513;

    return remainder((__result_type)__x, (__result_type)__y);
}



using ::remquo;
using ::remquof;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remquo(float __x, float __y, int* __z) throw() {return remquof(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remquo(long double __x, long double __y, int* __z) throw() {return remquol(__x, __y, __z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remquo(_A1 __x, _A2 __y, int* __z) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1537;

    return remquo((__result_type)__x, (__result_type)__y, __z);
}



using ::rint;
using ::rintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float rint(float __x) throw() {return rintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double rint(long double __x) throw() {return rintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
rint(_A1 __x) throw() {return rint((double)__x);}



using ::round;
using ::roundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float round(float __x) throw() {return roundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double round(long double __x) throw() {return roundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
round(_A1 __x) throw() {return round((double)__x);}



using ::scalbln;
using ::scalblnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbln(float __x, long __y) throw() {return scalblnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbln(long double __x, long __y) throw() {return scalblnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbln(_A1 __x, long __y) throw() {return scalbln((double)__x, __y);}



using ::scalbn;
using ::scalbnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbn(float __x, int __y) throw() {return scalbnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbn(long double __x, int __y) throw() {return scalbnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbn(_A1 __x, int __y) throw() {return scalbn((double)__x, __y);}



using ::tgamma;
using ::tgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tgamma(float __x) throw() {return tgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tgamma(long double __x) throw() {return tgammal(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tgamma(_A1 __x) throw() {return tgamma((double)__x);}



using ::trunc;
using ::truncf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float trunc(float __x) throw() {return truncf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double trunc(long double __x) throw() {return truncl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
trunc(_A1 __x) throw() {return trunc((double)__x);}



using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;






} }
# 4 "/usr/local/include/glm/detail/_fixes.hpp" 2 3
# 52 "/usr/local/include/glm/glm.hpp" 2 3





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 1 3
# 42 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 1 3 4
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 64 "/usr/include/limits.h" 3 4
# 1 "/usr/include/machine/limits.h" 1 3 4





# 1 "/usr/include/i386/limits.h" 1 3 4
# 40 "/usr/include/i386/limits.h" 3 4
# 1 "/usr/include/i386/_limits.h" 1 3 4
# 41 "/usr/include/i386/limits.h" 2 3 4
# 7 "/usr/include/machine/limits.h" 2 3 4
# 65 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
# 66 "/usr/include/limits.h" 2 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 2 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 2 3
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 57 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 1 3
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/float.h" 1 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 2 3
# 68 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 3
# 58 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 1 3
# 107 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 113 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 2 3
# 122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3
namespace std {inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return type();}

    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type();}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type();}

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int digits, bool is_signed>
struct __libcpp_compute_min
{
    static const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false>
{
    static const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static const bool is_specialized = true;

    static const bool is_signed = type(-1) < type(0);
    static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static const int digits10 = digits * 3 / 10;
    static const int max_digits10 = 0;
    static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = true;


    static const bool traps = true;



    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static const bool is_specialized = true;

    static const bool is_signed = false;
    static const int digits = 1;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const type __min = false;
    static const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 24;
    static const int digits10 = 6;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5F;}

    static const int min_exponent = (-125);
    static const int min_exponent10 = (-37);
    static const int max_exponent = 128;
    static const int max_exponent10 = 38;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 1.40129846e-45F;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-1021);
    static const int min_exponent10 = (-307);
    static const int max_exponent = 1024;
    static const int max_exponent10 = 308;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 4.9406564584124654e-324;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 64;
    static const int digits10 = 18;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 3.36210314311209350626e-4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.18973149535723176502e+4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.08420217248550443401e-19L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-16381);
    static const int min_exponent10 = (-4931);
    static const int max_exponent = 16384;
    static const int max_exponent10 = 4932;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 3.64519953188247460253e-4951L;}




    static const bool is_iec559 = true;

    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<_Tp>::radix;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<_Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 59 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 60 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/fwd.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_int.hpp" 1 3





# 1 "/usr/local/include/glm/detail/setup.hpp" 1 3
# 28 "/usr/local/include/glm/detail/setup.hpp" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 28 "/usr/local/include/glm/detail/setup.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../simd/platform.h" 1 3
# 432 "/usr/local/include/glm/detail/../simd/platform.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mmintrin.h" 3 4
typedef long long __m64 __attribute__((__vector_size__(8)));

typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_empty(void)
{
    __builtin_ia32_emms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mm_malloc.h" 1 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mm_malloc.h" 3 4
extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t __size, size_t __align)
{
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{
  free(__p);
}
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return __a + __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return __a - __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return __a * __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return __a / __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_sqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rcpss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ps(__m128 __a)
{
  return __builtin_ia32_rcpps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rsqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 1),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 2),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 5),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 6),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 3);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}



static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64(__a);
}



static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si32(__m128 __a)
{
  return __a[0];
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si64(__m128 __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}

static __inline__ float __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load_ss_struct*)__p)->__u;
  return (__m128){ __u, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct*)__p)->__u;
  return (__m128){ __u, __u, __u, __u };
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ps(const float *__p)
{
  return *(__m128*)__p;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ss(float __w)
{
  return (__m128){ __w, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set1_ps(float __w)
{
  return (__m128){ __w, __w, __w, __w };
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __w, __x, __y, __z };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __z, __y, __x, __w };
}

static __inline__ __m128 __attribute__((__always_inline__))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __attribute__((__always_inline__))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storehps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storelps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_ps(float *__p, __m128 __a)
{
  __builtin_ia32_storeups(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 0, 0, 0, 0);
  _mm_storeu_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps1(float *__p, __m128 __a)
{
    return _mm_store1_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128 *)__p = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 680 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_ia32_movntps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_pi16(__m64 __a, int __n)
{
  __v4hi __b = (__v4hi)__a;
  return (unsigned short)__b[__n & 3];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_insert_pi16(__m64 __a, int __d, int __n)
{
   __v4hi __b = (__v4hi)__a;
   __b[__n & 3] = __d;
   return (__m64)__b;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}





static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_setcsr(unsigned int __i)
{
  __builtin_ia32_ldmxcsr(__i);
}
# 797 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 2, 6, 3, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 4, 1, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_move_ss(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 6, 7, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps(__a);
}
# 996 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 1 3 4
# 997 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 2 3 4

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return __a + __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return __a - __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return __a * __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return __a / __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd(__b);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 1);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 2);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 5);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 6);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pd(__m128 __a)
{
  return __builtin_ia32_cvtps2pd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_pd(__m128i __a)
{
  return __builtin_ia32_cvtdq2pd((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si32(__m128d __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_pd(double const *__dp)
{
  return *(__m128d*)__dp;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load1_pd(double const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load1_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __u };
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadr_pd(double const *__dp)
{
  __m128d __u = *(__m128d*)__dp;
  return __builtin_shufflevector(__u, __u, 1, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadu_pd(double const *__dp)
{
  struct __loadu_pd {
    __m128d __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_pd*)__dp)->__v;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_sd(double const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load_sd_struct*)__dp)->__u;
  return (__m128d){ __u, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadh_pd_struct*)__dp)->__u;
  return (__m128d){ __a[0], __u };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadl_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_sd(double __w)
{
  return (__m128d){ __w, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set1_pd(double __w)
{
  return (__m128d){ __w, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_pd(double __w, double __x)
{
  return (__m128d){ __x, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setr_pd(double __w, double __x)
{
  return (__m128d){ __w, __x };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_move_sd(__m128d __a, __m128d __b)
{
  return (__m128d){ __b[0], __a[1] };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_pd(double *__dp, __m128d __a)
{
  struct __mm_store1_pd_struct {
    double __u[2];
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store1_pd_struct*)__dp)->__u[0] = __a[0];
  ((struct __mm_store1_pd_struct*)__dp)->__u[1] = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  __builtin_ia32_storeupd(__dp, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector(__a, __a, 1, 0);
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a + (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a + (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a + (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a * (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a - (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a - (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a - (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return __a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return ~__a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return __a | __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return __a ^ __b;
}







static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 901 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{


  typedef signed char __v16qs __attribute__((__vector_size__(16)));
  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}


static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si64(__m128d __a)
{
  return __a[0];
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_ps(__m128i __a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si128(int __a)
{
  return (__m128i)(__v4si){ __a, 0, 0, 0 };
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si128(long long __a)
{
  return (__m128i){ __a, 0 };
}


static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_load_si128(__m128i const *__p)
{
  return *__p;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadu_si128(__m128i const *__p)
{
  struct __loadu_si128 {
    __m128i __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_si128*)__p)->__v;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadl_epi64(__m128i const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64x(long long q1, long long q0)
{
  return (__m128i){ q0, q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64(__m64 q1, __m64 q0)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi32(int i3, int i2, int i1, int i0)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi16(short w7, short w6, short w5, short w4, short w3, short w2, short w1, short w0)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi8(char b15, char b14, char b13, char b12, char b11, char b10, char b9, char b8, char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64x(long long __q)
{
  return (__m128i){ __q, __q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64(__m64 __q)
{
  return (__m128i){ (long long)__q, (long long)__q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi32(int __i)
{
  return (__m128i)(__v4si){ __i, __i, __i, __i };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi16(short __w)
{
  return (__m128i)(__v8hi){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi8(char __b)
{
  return (__m128i)(__v16qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi64(__m64 q0, __m64 q1)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi32(int i0, int i1, int i2, int i3)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi16(short w0, short w1, short w2, short w3, short w4, short w5, short w6, short w7)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi8(char b0, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8, char b9, char b10, char b11, char b12, char b13, char b14, char b15)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_si128(__m128i *__p, __m128i __b)
{
  __builtin_ia32_storedqu((char *)__p, (__v16qi)__b);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_epi64(__m128i *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_ia32_movntpd(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_ia32_movntdq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_clflush(void const *__p)
{
  __builtin_ia32_clflush(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_lfence(void)
{
  __builtin_ia32_lfence();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mfence(void)
{
  __builtin_ia32_mfence();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_epi16(__m128i __a, int __imm)
{
  __v8hi __b = (__v8hi)__a;
  return (unsigned short)__b[__imm & 7];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_insert_epi16(__m128i __a, int __b, int __imm)
{
  __v8hi __c = (__v8hi)__a;
  __c[__imm & 7] = __b;
  return (__m128i)__c;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 1314 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_movpi64_epi64(__m64 __a)
{
  return (__m128i){ (long long)__a, 0 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector(__a, (__m128i){ 0 }, 0, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd(__a);
}
# 1405 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_pause(void)
{
  __asm__ volatile ("pause");
}
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 2 3 4

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_lddqu_si128(__m128i const *__p)
{
  return (__m128i)__builtin_ia32_lddqu((char const *)__p);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_addsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_addsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_haddps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_hsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehdup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 1, 1, 3, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_moveldup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0, 2, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_addsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_addsubpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_haddpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_hsubpd(__a, __b);
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_movedup_pd(__m128d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0);
}
# 103 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_monitor(void const *__p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitor((void *)__p, __extensions, __hints);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mwait(unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_mwait(__extensions, __hints);
}
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 2 3 4

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi8(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi8(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsb128((__v16qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi16(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi16(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsw128((__v8hi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi32(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi32(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsd128((__v4si)__a);
}
# 79 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadds_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadds_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)__a, (__v2si)__b);
}
# 432 "/usr/local/include/glm/detail/../simd/platform.h" 2 3








 typedef __m128 glm_vec4;
 typedef __m128i glm_ivec4;
 typedef __m128i glm_uvec4;
# 30 "/usr/local/include/glm/detail/setup.hpp" 2 3
# 780 "/usr/local/include/glm/detail/setup.hpp" 3
namespace glm
{
 using std::size_t;



  typedef int length_t;

}
# 825 "/usr/local/include/glm/detail/setup.hpp" 3
namespace glm
{
 enum ctor{uninitialize};
}
# 6 "/usr/local/include/glm/detail/type_int.hpp" 2 3
# 15 "/usr/local/include/glm/detail/type_int.hpp" 3
namespace glm{
namespace detail
{
# 43 "/usr/local/include/glm/detail/type_int.hpp" 3
#pragma clang diagnostic ignored "-Wc++11-long-long"
 typedef signed long long sint64;
   typedef unsigned long long uint64;






  typedef signed char int8;
  typedef signed short int16;
  typedef signed int int32;
  typedef sint64 int64;

  typedef unsigned char uint8;
  typedef unsigned short uint16;
  typedef unsigned int uint32;
  typedef uint64 uint64;


 typedef signed int lowp_int_t;
 typedef signed int mediump_int_t;
 typedef signed int highp_int_t;

 typedef unsigned int lowp_uint_t;
 typedef unsigned int mediump_uint_t;
 typedef unsigned int highp_uint_t;






  template <typename genType>
  struct make_signed
  {};

  template <>
  struct make_signed<char>
  {
   typedef char type;
  };

  template <>
  struct make_signed<short>
  {
   typedef short type;
  };

  template <>
  struct make_signed<int>
  {
   typedef int type;
  };

  template <>
  struct make_signed<long>
  {
   typedef long type;
  };

  template <>
  struct make_signed<unsigned char>
  {
   typedef char type;
  };

  template <>
  struct make_signed<unsigned short>
  {
   typedef short type;
  };

  template <>
  struct make_signed<unsigned int>
  {
   typedef int type;
  };

  template <>
  struct make_signed<unsigned long>
  {
   typedef long type;
  };

  template <typename genType>
  struct make_unsigned
  {};

  template <>
  struct make_unsigned<char>
  {
   typedef unsigned char type;
  };

  template <>
  struct make_unsigned<short>
  {
   typedef unsigned short type;
  };

  template <>
  struct make_unsigned<int>
  {
   typedef unsigned int type;
  };

  template <>
  struct make_unsigned<long>
  {
   typedef unsigned long type;
  };

  template <>
  struct make_unsigned<unsigned char>
  {
   typedef unsigned char type;
  };

  template <>
  struct make_unsigned<unsigned short>
  {
   typedef unsigned short type;
  };

  template <>
  struct make_unsigned<unsigned int>
  {
   typedef unsigned int type;
  };

  template <>
  struct make_unsigned<unsigned long>
  {
   typedef unsigned long type;
  };

  template <>
  struct make_signed<long long>
  {
   typedef long long type;
  };

  template <>
  struct make_signed<unsigned long long>
  {
   typedef long long type;
  };

  template <>
  struct make_unsigned<long long>
  {
   typedef unsigned long long type;
  };

  template <>
  struct make_unsigned<unsigned long long>
  {
   typedef unsigned long long type;
  };

}

 typedef detail::int8 int8;
 typedef detail::int16 int16;
 typedef detail::int32 int32;
 typedef detail::int64 int64;

 typedef detail::uint8 uint8;
 typedef detail::uint16 uint16;
 typedef detail::uint32 uint32;
 typedef detail::uint64 uint64;
# 224 "/usr/local/include/glm/detail/type_int.hpp" 3
 typedef detail::lowp_int_t lowp_int;






 typedef detail::mediump_int_t mediump_int;






 typedef detail::highp_int_t highp_int;






 typedef detail::lowp_uint_t lowp_uint;






 typedef detail::mediump_uint_t mediump_uint;






 typedef detail::highp_uint_t highp_uint;


 typedef mediump_int int_t;
# 274 "/usr/local/include/glm/detail/type_int.hpp" 3
 typedef mediump_uint uint_t;
# 288 "/usr/local/include/glm/detail/type_int.hpp" 3
 typedef unsigned int uint;
# 306 "/usr/local/include/glm/detail/type_int.hpp" 3
}
# 6 "/usr/local/include/glm/fwd.hpp" 2 3

# 1 "/usr/local/include/glm/detail/type_float.hpp" 1 3







namespace glm{
namespace detail
{
 typedef float float32;
 typedef double float64;
}

 typedef float lowp_float_t;
 typedef float mediump_float_t;
 typedef double highp_float_t;
# 27 "/usr/local/include/glm/detail/type_float.hpp" 3
 typedef lowp_float_t lowp_float;






 typedef mediump_float_t mediump_float;






 typedef highp_float_t highp_float;


 typedef mediump_float float_t;
# 55 "/usr/local/include/glm/detail/type_float.hpp" 3
 typedef float float32;
 typedef double float64;
# 67 "/usr/local/include/glm/detail/type_float.hpp" 3
}
# 7 "/usr/local/include/glm/fwd.hpp" 2 3

# 1 "/usr/local/include/glm/detail/type_vec.hpp" 1 3





# 1 "/usr/local/include/glm/detail/precision.hpp" 1 3







namespace glm
{
 enum precision
 {
  packed_highp,
  packed_mediump,
  packed_lowp,
# 23 "/usr/local/include/glm/detail/precision.hpp" 3
  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

namespace detail
{
 template <glm::precision P>
 struct is_aligned
 {
  static const bool value = false;
 };
# 62 "/usr/local/include/glm/detail/precision.hpp" 3
}
}
# 6 "/usr/local/include/glm/detail/type_vec.hpp" 2 3



namespace glm{
namespace detail
{
 template <typename T, std::size_t size, bool aligned>
 struct storage
 {
  typedef struct type {
   uint8 data[size];
  } type;
 };
# 28 "/usr/local/include/glm/detail/type_vec.hpp" 3
 template <typename T> struct storage<T, 1, true> { struct __attribute__((aligned(1))) type { uint8 data[1]; }; };
 template <typename T> struct storage<T, 2, true> { struct __attribute__((aligned(2))) type { uint8 data[2]; }; };
 template <typename T> struct storage<T, 4, true> { struct __attribute__((aligned(4))) type { uint8 data[4]; }; };
 template <typename T> struct storage<T, 8, true> { struct __attribute__((aligned(8))) type { uint8 data[8]; }; };
 template <typename T> struct storage<T, 16, true> { struct __attribute__((aligned(16))) type { uint8 data[16]; }; };
 template <typename T> struct storage<T, 32, true> { struct __attribute__((aligned(32))) type { uint8 data[32]; }; };
 template <typename T> struct storage<T, 64, true> { struct __attribute__((aligned(64))) type { uint8 data[64]; }; };


  template <>
  struct storage<float, 16, true>
  {
   typedef glm_vec4 type;
  };

  template <>
  struct storage<int, 16, true>
  {
   typedef glm_ivec4 type;
  };

  template <>
  struct storage<unsigned int, 16, true>
  {
   typedef glm_uvec4 type;
  };
# 102 "/usr/local/include/glm/detail/type_vec.hpp" 3
}

 template <typename T, precision P> struct tvec1;
 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;

 typedef tvec1<float, highp> highp_vec1_t;
 typedef tvec1<float, mediump> mediump_vec1_t;
 typedef tvec1<float, lowp> lowp_vec1_t;
 typedef tvec1<double, highp> highp_dvec1_t;
 typedef tvec1<double, mediump> mediump_dvec1_t;
 typedef tvec1<double, lowp> lowp_dvec1_t;
 typedef tvec1<int, highp> highp_ivec1_t;
 typedef tvec1<int, mediump> mediump_ivec1_t;
 typedef tvec1<int, lowp> lowp_ivec1_t;
 typedef tvec1<uint, highp> highp_uvec1_t;
 typedef tvec1<uint, mediump> mediump_uvec1_t;
 typedef tvec1<uint, lowp> lowp_uvec1_t;
 typedef tvec1<bool, highp> highp_bvec1_t;
 typedef tvec1<bool, mediump> mediump_bvec1_t;
 typedef tvec1<bool, lowp> lowp_bvec1_t;
# 133 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef tvec2<float, highp> highp_vec2;






 typedef tvec2<float, mediump> mediump_vec2;






 typedef tvec2<float, lowp> lowp_vec2;






 typedef tvec2<double, highp> highp_dvec2;






 typedef tvec2<double, mediump> mediump_dvec2;






 typedef tvec2<double, lowp> lowp_dvec2;






 typedef tvec2<int, highp> highp_ivec2;






 typedef tvec2<int, mediump> mediump_ivec2;






 typedef tvec2<int, lowp> lowp_ivec2;






 typedef tvec2<uint, highp> highp_uvec2;






 typedef tvec2<uint, mediump> mediump_uvec2;






 typedef tvec2<uint, lowp> lowp_uvec2;






 typedef tvec2<bool, highp> highp_bvec2;






 typedef tvec2<bool, mediump> mediump_bvec2;






 typedef tvec2<bool, lowp> lowp_bvec2;
# 243 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef tvec3<float, highp> highp_vec3;






 typedef tvec3<float, mediump> mediump_vec3;






 typedef tvec3<float, lowp> lowp_vec3;






 typedef tvec3<double, highp> highp_dvec3;






 typedef tvec3<double, mediump> mediump_dvec3;






 typedef tvec3<double, lowp> lowp_dvec3;






 typedef tvec3<int, highp> highp_ivec3;






 typedef tvec3<int, mediump> mediump_ivec3;






 typedef tvec3<int, lowp> lowp_ivec3;






 typedef tvec3<uint, highp> highp_uvec3;






 typedef tvec3<uint, mediump> mediump_uvec3;






 typedef tvec3<uint, lowp> lowp_uvec3;





 typedef tvec3<bool, highp> highp_bvec3;





 typedef tvec3<bool, mediump> mediump_bvec3;





 typedef tvec3<bool, lowp> lowp_bvec3;
# 349 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef tvec4<float, highp> highp_vec4;





 typedef tvec4<float, mediump> mediump_vec4;





 typedef tvec4<float, lowp> lowp_vec4;





 typedef tvec4<double, highp> highp_dvec4;





 typedef tvec4<double, mediump> mediump_dvec4;





 typedef tvec4<double, lowp> lowp_dvec4;





 typedef tvec4<int, highp> highp_ivec4;





 typedef tvec4<int, mediump> mediump_ivec4;





 typedef tvec4<int, lowp> lowp_ivec4;





 typedef tvec4<uint, highp> highp_uvec4;





 typedef tvec4<uint, mediump> mediump_uvec4;





 typedef tvec4<uint, lowp> lowp_uvec4;





 typedef tvec4<bool, highp> highp_bvec4;





 typedef tvec4<bool, mediump> mediump_bvec4;





 typedef tvec4<bool, lowp> lowp_bvec4;
# 454 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_vec2 vec2;




 typedef highp_vec3 vec3;




 typedef highp_vec4 vec4;
# 481 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_dvec2 dvec2;




 typedef highp_dvec3 dvec3;




 typedef highp_dvec4 dvec4;
# 508 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_ivec2 ivec2;




 typedef highp_ivec3 ivec3;




 typedef highp_ivec4 ivec4;
# 535 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_uvec2 uvec2;




 typedef highp_uvec3 uvec3;




 typedef highp_uvec4 uvec4;
# 562 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_bvec2 bvec2;




 typedef highp_bvec3 bvec3;




 typedef highp_bvec4 bvec4;



}
# 8 "/usr/local/include/glm/fwd.hpp" 2 3

# 1 "/usr/local/include/glm/detail/type_mat.hpp" 1 3







namespace glm{
namespace detail
{
 template <typename T, precision P, template <class, precision> class colType, template <class, precision> class rowType>
 struct outerProduct_trait{};
}

 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;
 template <typename T, precision P> struct tmat2x2;
 template <typename T, precision P> struct tmat2x3;
 template <typename T, precision P> struct tmat2x4;
 template <typename T, precision P> struct tmat3x2;
 template <typename T, precision P> struct tmat3x3;
 template <typename T, precision P> struct tmat3x4;
 template <typename T, precision P> struct tmat4x2;
 template <typename T, precision P> struct tmat4x3;
 template <typename T, precision P> struct tmat4x4;

 template <typename T, precision P, template <typename, precision> class matType>
               matType<T, P> inverse(matType<T, P> const & m);
# 39 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x2<float, lowp> lowp_mat2;






 typedef tmat2x2<float, mediump> mediump_mat2;






 typedef tmat2x2<float, highp> highp_mat2;






 typedef tmat2x2<float, lowp> lowp_mat2x2;






 typedef tmat2x2<float, mediump> mediump_mat2x2;






 typedef tmat2x2<float, highp> highp_mat2x2;
# 86 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x3<float, lowp> lowp_mat2x3;






 typedef tmat2x3<float, mediump> mediump_mat2x3;






 typedef tmat2x3<float, highp> highp_mat2x3;
# 112 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x4<float, lowp> lowp_mat2x4;






 typedef tmat2x4<float, mediump> mediump_mat2x4;






 typedef tmat2x4<float, highp> highp_mat2x4;
# 138 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x2<float, lowp> lowp_mat3x2;






 typedef tmat3x2<float, mediump> mediump_mat3x2;






 typedef tmat3x2<float, highp> highp_mat3x2;
# 164 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x3<float, lowp> lowp_mat3;






 typedef tmat3x3<float, mediump> mediump_mat3;






 typedef tmat3x3<float, highp> highp_mat3;






 typedef tmat3x3<float, lowp> lowp_mat3x3;






 typedef tmat3x3<float, mediump> mediump_mat3x3;






 typedef tmat3x3<float, highp> highp_mat3x3;
# 211 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x4<float, lowp> lowp_mat3x4;






 typedef tmat3x4<float, mediump> mediump_mat3x4;






 typedef tmat3x4<float, highp> highp_mat3x4;
# 237 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x2<float, lowp> lowp_mat4x2;






 typedef tmat4x2<float, mediump> mediump_mat4x2;






 typedef tmat4x2<float, highp> highp_mat4x2;
# 263 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x3<float, lowp> lowp_mat4x3;






 typedef tmat4x3<float, mediump> mediump_mat4x3;






 typedef tmat4x3<float, highp> highp_mat4x3;
# 290 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x4<float, lowp> lowp_mat4;






 typedef tmat4x4<float, mediump> mediump_mat4;






 typedef tmat4x4<float, highp> highp_mat4;






 typedef tmat4x4<float, lowp> lowp_mat4x4;






 typedef tmat4x4<float, mediump> mediump_mat4x4;






 typedef tmat4x4<float, highp> highp_mat4x4;
# 359 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef highp_mat2x2 mat2x2;




 typedef highp_mat2x3 mat2x3;




 typedef highp_mat2x4 mat2x4;




 typedef highp_mat3x2 mat3x2;




 typedef highp_mat3x3 mat3x3;




 typedef highp_mat3x4 mat3x4;




 typedef highp_mat4x2 mat4x2;




 typedef highp_mat4x3 mat4x3;




 typedef highp_mat4x4 mat4x4;






 typedef mat2x2 mat2;




 typedef mat3x3 mat3;




 typedef mat4x4 mat4;
# 428 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x2<double, lowp> lowp_dmat2;





 typedef tmat2x2<double, mediump> mediump_dmat2;





 typedef tmat2x2<double, highp> highp_dmat2;





 typedef tmat2x2<double, lowp> lowp_dmat2x2;





 typedef tmat2x2<double, mediump> mediump_dmat2x2;





 typedef tmat2x2<double, highp> highp_dmat2x2;
# 469 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x3<double, lowp> lowp_dmat2x3;





 typedef tmat2x3<double, mediump> mediump_dmat2x3;





 typedef tmat2x3<double, highp> highp_dmat2x3;
# 492 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x4<double, lowp> lowp_dmat2x4;





 typedef tmat2x4<double, mediump> mediump_dmat2x4;





 typedef tmat2x4<double, highp> highp_dmat2x4;
# 515 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x2<double, lowp> lowp_dmat3x2;





 typedef tmat3x2<double, mediump> mediump_dmat3x2;





 typedef tmat3x2<double, highp> highp_dmat3x2;
# 538 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x3<float, lowp> lowp_dmat3;





 typedef tmat3x3<double, mediump> mediump_dmat3;





 typedef tmat3x3<double, highp> highp_dmat3;





 typedef tmat3x3<double, lowp> lowp_dmat3x3;





 typedef tmat3x3<double, mediump> mediump_dmat3x3;





 typedef tmat3x3<double, highp> highp_dmat3x3;
# 579 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x4<double, lowp> lowp_dmat3x4;





 typedef tmat3x4<double, mediump> mediump_dmat3x4;





 typedef tmat3x4<double, highp> highp_dmat3x4;
# 602 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x2<double, lowp> lowp_dmat4x2;





 typedef tmat4x2<double, mediump> mediump_dmat4x2;





 typedef tmat4x2<double, highp> highp_dmat4x2;
# 625 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x3<double, lowp> lowp_dmat4x3;





 typedef tmat4x3<double, mediump> mediump_dmat4x3;





 typedef tmat4x3<double, highp> highp_dmat4x3;
# 648 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x4<double, lowp> lowp_dmat4;





 typedef tmat4x4<double, mediump> mediump_dmat4;





 typedef tmat4x4<double, highp> highp_dmat4;





 typedef tmat4x4<double, lowp> lowp_dmat4x4;





 typedef tmat4x4<double, mediump> mediump_dmat4x4;





 typedef tmat4x4<double, highp> highp_dmat4x4;
# 707 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef highp_dmat2x2 dmat2;




 typedef highp_dmat3x3 dmat3;




 typedef highp_dmat4x4 dmat4;




 typedef highp_dmat2x2 dmat2x2;




 typedef highp_dmat2x3 dmat2x3;




 typedef highp_dmat2x4 dmat2x4;




 typedef highp_dmat3x2 dmat3x2;




 typedef highp_dmat3x3 dmat3x3;




 typedef highp_dmat3x4 dmat3x4;




 typedef highp_dmat4x2 dmat4x2;




 typedef highp_dmat4x3 dmat4x3;




 typedef highp_dmat4x4 dmat4x4;




}
# 9 "/usr/local/include/glm/fwd.hpp" 2 3




namespace glm
{
 template <typename T, precision P> struct tquat;




 typedef tquat<float, lowp> lowp_quat;




 typedef tquat<float, mediump> mediump_quat;




 typedef tquat<float, highp> highp_quat;
# 40 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_quat quat;





 typedef lowp_quat lowp_fquat;




 typedef mediump_quat mediump_fquat;




 typedef highp_quat highp_fquat;




 typedef quat fquat;





 typedef tquat<double, lowp> lowp_dquat;




 typedef tquat<double, mediump> mediump_dquat;




 typedef tquat<double, highp> highp_dquat;
# 89 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_dquat dquat;


}



namespace glm
{


 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;




 typedef detail::int8 int8;



 typedef detail::int16 int16;



 typedef detail::int32 int32;



 typedef detail::int64 int64;
# 268 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::int8 int8_t;



 typedef detail::int16 int16_t;



 typedef detail::int32 int32_t;



 typedef detail::int64 int64_t;




 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;





 typedef tvec1<i8, lowp> lowp_i8vec1;



 typedef tvec2<i8, lowp> lowp_i8vec2;



 typedef tvec3<i8, lowp> lowp_i8vec3;



 typedef tvec4<i8, lowp> lowp_i8vec4;




 typedef tvec1<i8, mediump> mediump_i8vec1;



 typedef tvec2<i8, mediump> mediump_i8vec2;



 typedef tvec3<i8, mediump> mediump_i8vec3;



 typedef tvec4<i8, mediump> mediump_i8vec4;




 typedef tvec1<i8, highp> highp_i8vec1;



 typedef tvec2<i8, highp> highp_i8vec2;



 typedef tvec3<i8, highp> highp_i8vec3;



 typedef tvec4<i8, highp> highp_i8vec4;
# 364 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i8vec1 i8vec1;



 typedef highp_i8vec2 i8vec2;



 typedef highp_i8vec3 i8vec3;



 typedef highp_i8vec4 i8vec4;





 typedef tvec1<i16, lowp> lowp_i16vec1;



 typedef tvec2<i16, lowp> lowp_i16vec2;



 typedef tvec3<i16, lowp> lowp_i16vec3;



 typedef tvec4<i16, lowp> lowp_i16vec4;




 typedef tvec1<i16, mediump> mediump_i16vec1;



 typedef tvec2<i16, mediump> mediump_i16vec2;



 typedef tvec3<i16, mediump> mediump_i16vec3;



 typedef tvec4<i16, mediump> mediump_i16vec4;




 typedef tvec1<i16, highp> highp_i16vec1;



 typedef tvec2<i16, highp> highp_i16vec2;



 typedef tvec3<i16, highp> highp_i16vec3;



 typedef tvec4<i16, highp> highp_i16vec4;
# 444 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i16vec1 i16vec1;



 typedef highp_i16vec2 i16vec2;



 typedef highp_i16vec3 i16vec3;



 typedef highp_i16vec4 i16vec4;





 typedef tvec1<i32, lowp> lowp_i32vec1;



 typedef tvec2<i32, lowp> lowp_i32vec2;



 typedef tvec3<i32, lowp> lowp_i32vec3;



 typedef tvec4<i32, lowp> lowp_i32vec4;




 typedef tvec1<i32, mediump> mediump_i32vec1;



 typedef tvec2<i32, mediump> mediump_i32vec2;



 typedef tvec3<i32, mediump> mediump_i32vec3;



 typedef tvec4<i32, mediump> mediump_i32vec4;




 typedef tvec1<i32, highp> highp_i32vec1;



 typedef tvec2<i32, highp> highp_i32vec2;



 typedef tvec3<i32, highp> highp_i32vec3;



 typedef tvec4<i32, highp> highp_i32vec4;
# 523 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;





 typedef tvec1<i32, lowp> lowp_i32vec1;



 typedef tvec2<i32, lowp> lowp_i32vec2;



 typedef tvec3<i32, lowp> lowp_i32vec3;



 typedef tvec4<i32, lowp> lowp_i32vec4;




 typedef tvec1<i32, mediump> mediump_i32vec1;



 typedef tvec2<i32, mediump> mediump_i32vec2;



 typedef tvec3<i32, mediump> mediump_i32vec3;



 typedef tvec4<i32, mediump> mediump_i32vec4;




 typedef tvec1<i32, highp> highp_i32vec1;



 typedef tvec2<i32, highp> highp_i32vec2;



 typedef tvec3<i32, highp> highp_i32vec3;



 typedef tvec4<i32, highp> highp_i32vec4;
# 602 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;






 typedef tvec1<i64, lowp> lowp_i64vec1;



 typedef tvec2<i64, lowp> lowp_i64vec2;



 typedef tvec3<i64, lowp> lowp_i64vec3;



 typedef tvec4<i64, lowp> lowp_i64vec4;




 typedef tvec1<i64, mediump> mediump_i64vec1;



 typedef tvec2<i64, mediump> mediump_i64vec2;



 typedef tvec3<i64, mediump> mediump_i64vec3;



 typedef tvec4<i64, mediump> mediump_i64vec4;




 typedef tvec1<i64, highp> highp_i64vec1;



 typedef tvec2<i64, highp> highp_i64vec2;



 typedef tvec3<i64, highp> highp_i64vec3;



 typedef tvec4<i64, highp> highp_i64vec4;
# 682 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i64vec1 i64vec1;



 typedef highp_i64vec2 i64vec2;



 typedef highp_i64vec3 i64vec3;



 typedef highp_i64vec4 i64vec4;
# 703 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;




 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;




 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;





 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;





 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;





 typedef detail::uint8 uint8;



 typedef detail::uint16 uint16;



 typedef detail::uint32 uint32;



 typedef detail::uint64 uint64;
# 877 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::uint8 uint8_t;



 typedef detail::uint16 uint16_t;



 typedef detail::uint32 uint32_t;



 typedef detail::uint64 uint64_t;




 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;





 typedef tvec1<u8, lowp> lowp_u8vec1;



 typedef tvec2<u8, lowp> lowp_u8vec2;



 typedef tvec3<u8, lowp> lowp_u8vec3;



 typedef tvec4<u8, lowp> lowp_u8vec4;




 typedef tvec1<u8, mediump> mediump_u8vec1;



 typedef tvec2<u8, mediump> mediump_u8vec2;



 typedef tvec3<u8, mediump> mediump_u8vec3;



 typedef tvec4<u8, mediump> mediump_u8vec4;




 typedef tvec1<u8, highp> highp_u8vec1;



 typedef tvec2<u8, highp> highp_u8vec2;



 typedef tvec3<u8, highp> highp_u8vec3;



 typedef tvec4<u8, highp> highp_u8vec4;
# 973 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u8vec1 u8vec1;



 typedef highp_u8vec2 u8vec2;



 typedef highp_u8vec3 u8vec3;



 typedef highp_u8vec4 u8vec4;





 typedef tvec1<u16, lowp> lowp_u16vec1;



 typedef tvec2<u16, lowp> lowp_u16vec2;



 typedef tvec3<u16, lowp> lowp_u16vec3;



 typedef tvec4<u16, lowp> lowp_u16vec4;




 typedef tvec1<u16, mediump> mediump_u16vec1;



 typedef tvec2<u16, mediump> mediump_u16vec2;



 typedef tvec3<u16, mediump> mediump_u16vec3;



 typedef tvec4<u16, mediump> mediump_u16vec4;




 typedef tvec1<u16, highp> highp_u16vec1;



 typedef tvec2<u16, highp> highp_u16vec2;



 typedef tvec3<u16, highp> highp_u16vec3;



 typedef tvec4<u16, highp> highp_u16vec4;
# 1053 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u16vec1 u16vec1;



 typedef highp_u16vec2 u16vec2;



 typedef highp_u16vec3 u16vec3;



 typedef highp_u16vec4 u16vec4;





 typedef tvec1<u32, lowp> lowp_u32vec1;



 typedef tvec2<u32, lowp> lowp_u32vec2;



 typedef tvec3<u32, lowp> lowp_u32vec3;



 typedef tvec4<u32, lowp> lowp_u32vec4;




 typedef tvec1<u32, mediump> mediump_u32vec1;



 typedef tvec2<u32, mediump> mediump_u32vec2;



 typedef tvec3<u32, mediump> mediump_u32vec3;



 typedef tvec4<u32, mediump> mediump_u32vec4;




 typedef tvec1<u32, highp> highp_u32vec1;



 typedef tvec2<u32, highp> highp_u32vec2;



 typedef tvec3<u32, highp> highp_u32vec3;



 typedef tvec4<u32, highp> highp_u32vec4;
# 1132 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;





 typedef tvec1<u32, lowp> lowp_u32vec1;



 typedef tvec2<u32, lowp> lowp_u32vec2;



 typedef tvec3<u32, lowp> lowp_u32vec3;



 typedef tvec4<u32, lowp> lowp_u32vec4;




 typedef tvec1<u32, mediump> mediump_u32vec1;



 typedef tvec2<u32, mediump> mediump_u32vec2;



 typedef tvec3<u32, mediump> mediump_u32vec3;



 typedef tvec4<u32, mediump> mediump_u32vec4;




 typedef tvec1<u32, highp> highp_u32vec1;



 typedef tvec2<u32, highp> highp_u32vec2;



 typedef tvec3<u32, highp> highp_u32vec3;



 typedef tvec4<u32, highp> highp_u32vec4;
# 1211 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;






 typedef tvec1<u64, lowp> lowp_u64vec1;



 typedef tvec2<u64, lowp> lowp_u64vec2;



 typedef tvec3<u64, lowp> lowp_u64vec3;



 typedef tvec4<u64, lowp> lowp_u64vec4;




 typedef tvec1<u64, mediump> mediump_u64vec1;



 typedef tvec2<u64, mediump> mediump_u64vec2;



 typedef tvec3<u64, mediump> mediump_u64vec3;



 typedef tvec4<u64, mediump> mediump_u64vec4;




 typedef tvec1<u64, highp> highp_u64vec1;



 typedef tvec2<u64, highp> highp_u64vec2;



 typedef tvec3<u64, highp> highp_u64vec3;



 typedef tvec4<u64, highp> highp_u64vec4;
# 1291 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u64vec1 u64vec1;



 typedef highp_u64vec2 u64vec2;



 typedef highp_u64vec3 u64vec3;



 typedef highp_u64vec4 u64vec4;
# 1312 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;



 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 mediump_float32;



 typedef detail::float64 mediump_float64;



 typedef detail::float32 mediump_float32_t;



 typedef detail::float64 mediump_float64_t;



 typedef float32 mediump_f32;



 typedef float64 mediump_f64;




 typedef detail::float32 highp_float32;



 typedef detail::float64 highp_float64;



 typedef detail::float32 highp_float32_t;



 typedef detail::float64 highp_float64_t;



 typedef float32 highp_f32;



 typedef float64 highp_f64;
# 1489 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_float32 float32;



 typedef highp_float64 float64;



 typedef highp_float32_t float32_t;



 typedef highp_float64_t float64_t;



 typedef highp_float32_t f32;



 typedef highp_float64_t f64;





 typedef tvec1<float, lowp> lowp_vec1;



 typedef tvec2<float, lowp> lowp_vec2;



 typedef tvec3<float, lowp> lowp_vec3;



 typedef tvec4<float, lowp> lowp_vec4;



 typedef tvec1<float, lowp> lowp_fvec1;



 typedef tvec2<float, lowp> lowp_fvec2;



 typedef tvec3<float, lowp> lowp_fvec3;



 typedef tvec4<float, lowp> lowp_fvec4;




 typedef tvec1<float, mediump> mediump_vec1;



 typedef tvec2<float, mediump> mediump_vec2;



 typedef tvec3<float, mediump> mediump_vec3;



 typedef tvec4<float, mediump> mediump_vec4;



 typedef tvec1<float, mediump> mediump_fvec1;



 typedef tvec2<float, mediump> mediump_fvec2;



 typedef tvec3<float, mediump> mediump_fvec3;



 typedef tvec4<float, mediump> mediump_fvec4;




 typedef tvec1<float, highp> highp_vec1;



 typedef tvec2<float, highp> highp_vec2;



 typedef tvec3<float, highp> highp_vec3;



 typedef tvec4<float, highp> highp_vec4;



 typedef tvec1<float, highp> highp_fvec1;



 typedef tvec2<float, highp> highp_fvec2;



 typedef tvec3<float, highp> highp_fvec3;



 typedef tvec4<float, highp> highp_fvec4;




 typedef tvec1<f32, lowp> lowp_f32vec1;



 typedef tvec2<f32, lowp> lowp_f32vec2;



 typedef tvec3<f32, lowp> lowp_f32vec3;



 typedef tvec4<f32, lowp> lowp_f32vec4;



 typedef tvec1<f32, mediump> mediump_f32vec1;



 typedef tvec2<f32, mediump> mediump_f32vec2;



 typedef tvec3<f32, mediump> mediump_f32vec3;



 typedef tvec4<f32, mediump> mediump_f32vec4;



 typedef tvec1<f32, highp> highp_f32vec1;



 typedef tvec2<f32, highp> highp_f32vec2;



 typedef tvec3<f32, highp> highp_f32vec3;



 typedef tvec4<f32, highp> highp_f32vec4;




 typedef tvec1<f64, lowp> lowp_f64vec1;



 typedef tvec2<f64, lowp> lowp_f64vec2;



 typedef tvec3<f64, lowp> lowp_f64vec3;



 typedef tvec4<f64, lowp> lowp_f64vec4;



 typedef tvec1<f64, mediump> mediump_f64vec1;



 typedef tvec2<f64, mediump> mediump_f64vec2;



 typedef tvec3<f64, mediump> mediump_f64vec3;



 typedef tvec4<f64, mediump> mediump_f64vec4;



 typedef tvec1<f64, highp> highp_f64vec1;



 typedef tvec2<f64, highp> highp_f64vec2;



 typedef tvec3<f64, highp> highp_f64vec3;



 typedef tvec4<f64, highp> highp_f64vec4;
# 1719 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, lowp> lowp_fmat2x2;



 typedef tmat2x3<f32, lowp> lowp_fmat2x3;



 typedef tmat2x4<f32, lowp> lowp_fmat2x4;



 typedef tmat3x2<f32, lowp> lowp_fmat3x2;



 typedef tmat3x3<f32, lowp> lowp_fmat3x3;



 typedef tmat3x4<f32, lowp> lowp_fmat3x4;



 typedef tmat4x2<f32, lowp> lowp_fmat4x2;



 typedef tmat4x3<f32, lowp> lowp_fmat4x3;



 typedef tmat4x4<f32, lowp> lowp_fmat4x4;







 typedef lowp_fmat2x2 lowp_fmat2;



 typedef lowp_fmat3x3 lowp_fmat3;



 typedef lowp_fmat4x4 lowp_fmat4;
# 1776 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, mediump> mediump_fmat2x2;



 typedef tmat2x3<f32, mediump> mediump_fmat2x3;



 typedef tmat2x4<f32, mediump> mediump_fmat2x4;



 typedef tmat3x2<f32, mediump> mediump_fmat3x2;



 typedef tmat3x3<f32, mediump> mediump_fmat3x3;



 typedef tmat3x4<f32, mediump> mediump_fmat3x4;



 typedef tmat4x2<f32, mediump> mediump_fmat4x2;



 typedef tmat4x3<f32, mediump> mediump_fmat4x3;



 typedef tmat4x4<f32, mediump> mediump_fmat4x4;







 typedef mediump_fmat2x2 mediump_fmat2;



 typedef mediump_fmat3x3 mediump_fmat3;



 typedef mediump_fmat4x4 mediump_fmat4;
# 1833 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, highp> highp_fmat2x2;



 typedef tmat2x3<f32, highp> highp_fmat2x3;



 typedef tmat2x4<f32, highp> highp_fmat2x4;



 typedef tmat3x2<f32, highp> highp_fmat3x2;



 typedef tmat3x3<f32, highp> highp_fmat3x3;



 typedef tmat3x4<f32, highp> highp_fmat3x4;



 typedef tmat4x2<f32, highp> highp_fmat4x2;



 typedef tmat4x3<f32, highp> highp_fmat4x3;



 typedef tmat4x4<f32, highp> highp_fmat4x4;







 typedef highp_fmat2x2 highp_fmat2;



 typedef highp_fmat3x3 highp_fmat3;



 typedef highp_fmat4x4 highp_fmat4;
# 1890 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, lowp> lowp_f32mat2x2;



 typedef tmat2x3<f32, lowp> lowp_f32mat2x3;



 typedef tmat2x4<f32, lowp> lowp_f32mat2x4;



 typedef tmat3x2<f32, lowp> lowp_f32mat3x2;



 typedef tmat3x3<f32, lowp> lowp_f32mat3x3;



 typedef tmat3x4<f32, lowp> lowp_f32mat3x4;



 typedef tmat4x2<f32, lowp> lowp_f32mat4x2;



 typedef tmat4x3<f32, lowp> lowp_f32mat4x3;



 typedef tmat4x4<f32, lowp> lowp_f32mat4x4;







 typedef lowp_f32mat2x2 lowp_f32mat2;



 typedef lowp_f32mat3x3 lowp_f32mat3;



 typedef lowp_f32mat4x4 lowp_f32mat4;
# 1947 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, mediump> mediump_f32mat2x2;



 typedef tmat2x3<f32, mediump> mediump_f32mat2x3;



 typedef tmat2x4<f32, mediump> mediump_f32mat2x4;



 typedef tmat3x2<f32, mediump> mediump_f32mat3x2;



 typedef tmat3x3<f32, mediump> mediump_f32mat3x3;



 typedef tmat3x4<f32, mediump> mediump_f32mat3x4;



 typedef tmat4x2<f32, mediump> mediump_f32mat4x2;



 typedef tmat4x3<f32, mediump> mediump_f32mat4x3;



 typedef tmat4x4<f32, mediump> mediump_f32mat4x4;







 typedef mediump_f32mat2x2 mediump_f32mat2;



 typedef mediump_f32mat3x3 mediump_f32mat3;



 typedef mediump_f32mat4x4 mediump_f32mat4;
# 2004 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, highp> highp_f32mat2x2;



 typedef tmat2x3<f32, highp> highp_f32mat2x3;



 typedef tmat2x4<f32, highp> highp_f32mat2x4;



 typedef tmat3x2<f32, highp> highp_f32mat3x2;



 typedef tmat3x3<f32, highp> highp_f32mat3x3;



 typedef tmat3x4<f32, highp> highp_f32mat3x4;



 typedef tmat4x2<f32, highp> highp_f32mat4x2;



 typedef tmat4x3<f32, highp> highp_f32mat4x3;



 typedef tmat4x4<f32, highp> highp_f32mat4x4;







 typedef highp_f32mat2x2 highp_f32mat2;



 typedef highp_f32mat3x3 highp_f32mat3;



 typedef highp_f32mat4x4 highp_f32mat4;
# 2061 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f64, lowp> lowp_f64mat2x2;



 typedef tmat2x3<f64, lowp> lowp_f64mat2x3;



 typedef tmat2x4<f64, lowp> lowp_f64mat2x4;



 typedef tmat3x2<f64, lowp> lowp_f64mat3x2;



 typedef tmat3x3<f64, lowp> lowp_f64mat3x3;



 typedef tmat3x4<f64, lowp> lowp_f64mat3x4;



 typedef tmat4x2<f64, lowp> lowp_f64mat4x2;



 typedef tmat4x3<f64, lowp> lowp_f64mat4x3;



 typedef tmat4x4<f64, lowp> lowp_f64mat4x4;







 typedef lowp_f64mat2x2 lowp_f64mat2;



 typedef lowp_f64mat3x3 lowp_f64mat3;



 typedef lowp_f64mat4x4 lowp_f64mat4;
# 2118 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f64, mediump> mediump_f64mat2x2;



 typedef tmat2x3<f64, mediump> mediump_f64mat2x3;



 typedef tmat2x4<f64, mediump> mediump_f64mat2x4;



 typedef tmat3x2<f64, mediump> mediump_f64mat3x2;



 typedef tmat3x3<f64, mediump> mediump_f64mat3x3;



 typedef tmat3x4<f64, mediump> mediump_f64mat3x4;



 typedef tmat4x2<f64, mediump> mediump_f64mat4x2;



 typedef tmat4x3<f64, mediump> mediump_f64mat4x3;



 typedef tmat4x4<f64, mediump> mediump_f64mat4x4;







 typedef mediump_f64mat2x2 mediump_f64mat2;



 typedef mediump_f64mat3x3 mediump_f64mat3;



 typedef mediump_f64mat4x4 mediump_f64mat4;







 typedef tmat2x2<f64, highp> highp_f64mat2x2;



 typedef tmat2x3<f64, highp> highp_f64mat2x3;



 typedef tmat2x4<f64, highp> highp_f64mat2x4;



 typedef tmat3x2<f64, highp> highp_f64mat3x2;



 typedef tmat3x3<f64, highp> highp_f64mat3x3;



 typedef tmat3x4<f64, highp> highp_f64mat3x4;



 typedef tmat4x2<f64, highp> highp_f64mat4x2;



 typedef tmat4x3<f64, highp> highp_f64mat4x3;



 typedef tmat4x4<f64, highp> highp_f64mat4x4;







 typedef highp_f64mat2x2 highp_f64mat2;



 typedef highp_f64mat3x3 highp_f64mat3;



 typedef highp_f64mat4x4 highp_f64mat4;






 typedef tquat<f32, lowp> lowp_f32quat;



 typedef tquat<f64, lowp> lowp_f64quat;



 typedef tquat<f32, mediump> mediump_f32quat;



 typedef tquat<f64, mediump> mediump_f64quat;



 typedef tquat<f32, highp> highp_f32quat;



 typedef tquat<f64, highp> highp_f64quat;
# 2327 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_f32vec1 fvec1;



 typedef highp_f32vec2 fvec2;



 typedef highp_f32vec3 fvec3;



 typedef highp_f32vec4 fvec4;



 typedef highp_f32mat2x2 fmat2x2;



 typedef highp_f32mat2x3 fmat2x3;



 typedef highp_f32mat2x4 fmat2x4;



 typedef highp_f32mat3x2 fmat3x2;



 typedef highp_f32mat3x3 fmat3x3;



 typedef highp_f32mat3x4 fmat3x4;



 typedef highp_f32mat4x2 fmat4x2;



 typedef highp_f32mat4x3 fmat4x3;



 typedef highp_f32mat4x4 fmat4x4;



 typedef fmat2x2 fmat2;



 typedef fmat3x3 fmat3;



 typedef fmat4x4 fmat4;



 typedef highp_fquat fquat;





 typedef highp_f32vec1 f32vec1;



 typedef highp_f32vec2 f32vec2;



 typedef highp_f32vec3 f32vec3;



 typedef highp_f32vec4 f32vec4;



 typedef highp_f32mat2x2 f32mat2x2;



 typedef highp_f32mat2x3 f32mat2x3;



 typedef highp_f32mat2x4 f32mat2x4;



 typedef highp_f32mat3x2 f32mat3x2;



 typedef highp_f32mat3x3 f32mat3x3;



 typedef highp_f32mat3x4 f32mat3x4;



 typedef highp_f32mat4x2 f32mat4x2;



 typedef highp_f32mat4x3 f32mat4x3;



 typedef highp_f32mat4x4 f32mat4x4;



 typedef f32mat2x2 f32mat2;



 typedef f32mat3x3 f32mat3;



 typedef f32mat4x4 f32mat4;



 typedef highp_f32quat f32quat;
# 2503 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_f64vec1 f64vec1;



 typedef highp_f64vec2 f64vec2;



 typedef highp_f64vec3 f64vec3;



 typedef highp_f64vec4 f64vec4;



 typedef highp_f64mat2x2 f64mat2x2;



 typedef highp_f64mat2x3 f64mat2x3;



 typedef highp_f64mat2x4 f64mat2x4;



 typedef highp_f64mat3x2 f64mat3x2;



 typedef highp_f64mat3x3 f64mat3x3;



 typedef highp_f64mat3x4 f64mat3x4;



 typedef highp_f64mat4x2 f64mat4x2;



 typedef highp_f64mat4x3 f64mat4x3;



 typedef highp_f64mat4x4 f64mat4x4;



 typedef f64mat2x2 f64mat2;



 typedef f64mat3x3 f64mat3;



 typedef f64mat4x4 f64mat4;



 typedef highp_f64quat f64quat;


}
# 61 "/usr/local/include/glm/glm.hpp" 2 3







# 1 "/usr/local/include/glm/vec2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_vec2.hpp" 1 3
# 16 "/usr/local/include/glm/detail/type_vec2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec2
 {


  typedef T value_type;
  typedef tvec2<T, P> type;
  typedef tvec2<bool, P> bool_type;
# 70 "/usr/local/include/glm/detail/type_vec2.hpp" 3
   union {T x, r, s;};
   union {T y, g, t;};
# 81 "/usr/local/include/glm/detail/type_vec2.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 2;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec2() ;
                                   tvec2(tvec2<T, P> const& v) ;
  template <precision Q>
                                   tvec2(tvec2<T, Q> const& v);



                                   explicit tvec2(ctor);
                                   explicit tvec2(T scalar);
                                   tvec2(T s1, T s2);




  template <typename A, typename B>
                                   tvec2(A x, B y);
  template <typename A, typename B>
                                   tvec2(tvec1<A, P> const & v1, tvec1<B, P> const & v2);




  template <typename U, precision Q>
                                                tvec2(tvec3<U, Q> const & v);

  template <typename U, precision Q>
                                                tvec2(tvec4<U, Q> const & v);


  template <typename U, precision Q>
                                                tvec2(tvec2<U, Q> const & v);
# 132 "/usr/local/include/glm/detail/type_vec2.hpp" 3
                tvec2<T, P>& operator=(tvec2<T, P> const & v) ;

  template <typename U>
                tvec2<T, P>& operator=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator+=(U scalar);
  template <typename U>
                tvec2<T, P>& operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator+=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator-=(U scalar);
  template <typename U>
                tvec2<T, P>& operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator-=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator*=(U scalar);
  template <typename U>
                tvec2<T, P>& operator*=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator*=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator/=(U scalar);
  template <typename U>
                tvec2<T, P>& operator/=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator/=(tvec2<U, P> const & v);



                tvec2<T, P> & operator++();
                tvec2<T, P> & operator--();
                tvec2<T, P> operator++(int);
                tvec2<T, P> operator--(int);



  template <typename U>
                tvec2<T, P> & operator%=(U scalar);
  template <typename U>
                tvec2<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator%=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator&=(U scalar);
  template <typename U>
                tvec2<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator&=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator|=(U scalar);
  template <typename U>
                tvec2<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator|=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator^=(U scalar);
  template <typename U>
                tvec2<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator^=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec2<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator<<=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec2<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator>>=(tvec2<U, P> const & v);
 };



 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v);



 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator+(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator-(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator*(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator/(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator%(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator&(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator|(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator^(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator<<(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator>>(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator~(tvec2<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <precision P>
               tvec2<bool, P> operator&&(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2);

 template <precision P>
               tvec2<bool, P> operator||(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec2.inl" 1 3



namespace glm
{
# 22 "/usr/local/include/glm/detail/type_vec2.inl" 3
  template <typename T, precision P> inline
                                        tvec2<T, P>::tvec2()

    : x(0), y(0)

  {}



  template <typename T, precision P> inline
                                        tvec2<T, P>::tvec2(tvec2<T, P> const & v)
   : x(v.x), y(v.y)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec2<T, P>::tvec2(tvec2<T, Q> const & v)
  : x(v.x), y(v.y)
 {}



 template <typename T, precision P> inline
                                       tvec2<T, P>::tvec2(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec2<T, P>::tvec2(T scalar)
  : x(scalar), y(scalar)
 {}

 template <typename T, precision P> inline
                                       tvec2<T, P>::tvec2(T s1, T s2)
  : x(s1), y(s2)
 {}



 template <typename T, precision P>
 template <typename A, typename B> inline
                                       tvec2<T, P>::tvec2(A a, B b)
  : x(static_cast<T>(a))
  , y(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B> inline
                                       tvec2<T, P>::tvec2(tvec1<A, P> const & a, tvec1<B, P> const & b)
  : x(static_cast<T>(a.x))
  , y(static_cast<T>(b.x))
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec2<T, P>::tvec2(tvec2<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec2<T, P>::tvec2(tvec3<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec2<T, P>::tvec2(tvec4<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template <typename T, precision P> inline
                    T & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec2.inl", 103, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec2.inl", 110, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec2<T, P> & tvec2<T, P>::operator=(tvec2<T, P> const & v)
  {
   this->x = v.x;
   this->y = v.y;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec2<T, P> & tvec2<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> & tvec2<T, P>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> tvec2<T, P>::operator++(int)
 {
  tvec2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> tvec2<T, P>::operator--(int)
 {
  tvec2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   -v.x,
   -v.y);
 }



 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x + scalar,
   v.y + scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar + v.x,
   scalar + v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x - scalar,
   v.y - scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar - v.x,
   scalar - v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x * scalar,
   v.y * scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar * v.x,
   scalar * v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x / scalar,
   v.y / scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar / v.x,
   scalar / v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x % scalar,
   v.y % scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar % v.x,
   scalar % v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x & scalar,
   v.y & scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar & v.x,
   scalar & v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x | scalar,
   v.y | scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar | v.x,
   scalar | v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x << scalar,
   v.y << scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar << v.x,
   scalar << v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator~(tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   ~v.x,
   ~v.y);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return (v1.x == v2.x) && (v1.y == v2.y);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return (v1.x != v2.x) || (v1.y != v2.y);
 }

 template <precision P> inline
                    tvec2<bool, P> operator&&(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)
 {
  return tvec2<bool, P>(v1.x && v2.x, v1.y && v2.y);
 }

 template <precision P> inline
                    tvec2<bool, P> operator||(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)
 {
  return tvec2<bool, P>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 387 "/usr/local/include/glm/detail/type_vec2.hpp" 2 3
# 6 "/usr/local/include/glm/vec2.hpp" 2 3
# 68 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/vec3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_vec3.hpp" 1 3
# 16 "/usr/local/include/glm/detail/type_vec3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec3
 {


  typedef T value_type;
  typedef tvec3<T, P> type;
  typedef tvec3<bool, P> bool_type;
# 69 "/usr/local/include/glm/detail/type_vec3.hpp" 3
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 81 "/usr/local/include/glm/detail/type_vec3.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 3;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec3() ;
                                   tvec3(tvec3<T, P> const & v) ;
  template <precision Q>
                                   tvec3(tvec3<T, Q> const & v);



                                   explicit tvec3(ctor);
                                   explicit tvec3(T scalar);
                                   tvec3(T a, T b, T c);




  template <typename A, typename B, typename C>
                                   tvec3(A a, B b, C c);
  template <typename A, typename B, typename C>
                                   tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c);




  template <typename A, typename B, precision Q>
                                   tvec3(tvec2<A, Q> const & a, B b);

  template <typename A, typename B, precision Q>
                                   tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec3(A a, tvec2<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b);

  template <typename U, precision Q>
                                                tvec3(tvec4<U, Q> const & v);


  template <typename U, precision Q>
                                                tvec3(tvec3<U, Q> const & v);
# 153 "/usr/local/include/glm/detail/type_vec3.hpp" 3
                tvec3<T, P> & operator=(tvec3<T, P> const & v) ;

  template <typename U>
                tvec3<T, P> & operator=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator+=(U scalar);
  template <typename U>
                tvec3<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator+=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator-=(U scalar);
  template <typename U>
                tvec3<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator-=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator*=(U scalar);
  template <typename U>
                tvec3<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator*=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator/=(U scalar);
  template <typename U>
                tvec3<T, P> & operator/=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator/=(tvec3<U, P> const & v);



                tvec3<T, P> & operator++();
                tvec3<T, P> & operator--();
                tvec3<T, P> operator++(int);
                tvec3<T, P> operator--(int);



  template <typename U>
                tvec3<T, P> & operator%=(U scalar);
  template <typename U>
                tvec3<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator%=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator&=(U scalar);
  template <typename U>
                tvec3<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator&=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator|=(U scalar);
  template <typename U>
                tvec3<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator|=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator^=(U scalar);
  template <typename U>
                tvec3<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator^=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec3<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator<<=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec3<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator>>=(tvec3<U, P> const & v);
 };



 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v);



 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator+(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator%(T const & scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec3<T, P> const & v1, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator~(tvec3<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <precision P>
               tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);

 template <precision P>
               tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec3.inl" 1 3



namespace glm
{
# 35 "/usr/local/include/glm/detail/type_vec3.inl" 3
  template <typename T, precision P> inline
                                        tvec3<T, P>::tvec3()

    : x(0), y(0), z(0)

  {}



  template <typename T, precision P> inline
                                        tvec3<T, P>::tvec3(tvec3<T, P> const & v)
   : x(v.x), y(v.y), z(v.z)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec3<T, P>::tvec3(tvec3<T, Q> const & v)
  : x(v.x), y(v.y), z(v.z)
 {}



 template <typename T, precision P> inline
                                       tvec3<T, P>::tvec3(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec3<T, P>::tvec3(T scalar)
  : x(scalar), y(scalar), z(scalar)
 {}

 template <typename T, precision P> inline
                                       tvec3<T, P>::tvec3(T a, T b, T c)
  : x(a), y(b), z(c)
 {}



 template <typename T, precision P>
 template <typename A, typename B, typename C> inline
                                       tvec3<T, P>::tvec3(A a, B b, C c) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C> inline
                                       tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c))
 {}



 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(A a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}



 template <typename T, precision P> inline
                    T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec3.inl", 145, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec3.inl", 152, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> const & v)
  {
   this->x = v.x;
   this->y = v.y;
   this->z = v.z;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  this->z *= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator/=(U v)
 {
  this->x /= static_cast<T>(v);
  this->y /= static_cast<T>(v);
  this->z /= static_cast<T>(v);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec3<T, P> & tvec3<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> & tvec3<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> tvec3<T, P>::operator++(int)
 {
  tvec3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> tvec3<T, P>::operator--(int)
 {
  tvec3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)
 {
  this->x %= scalar;
  this->y %= scalar;
  this->z %= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)
 {
  this->x &= scalar;
  this->y &= scalar;
  this->z &= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)
 {
  this->x |= scalar;
  this->y |= scalar;
  this->z |= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)
 {
  this->x ^= scalar;
  this->y ^= scalar;
  this->z ^= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)
 {
  this->x <<= scalar;
  this->y <<= scalar;
  this->z <<= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   -v.x,
   -v.y,
   -v.z);
 }



 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x + scalar.x,
   v.y + scalar.x,
   v.z + scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x + v.x,
   scalar.x + v.y,
   scalar.x + v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x - scalar.x,
   v.y - scalar.x,
   v.z - scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x - v.x,
   scalar.x - v.y,
   scalar.x - v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x * scalar.x,
   v.y * scalar.x,
   v.z * scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x * v.x,
   scalar.x * v.y,
   scalar.x * v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x / scalar.x,
   v.y / scalar.x,
   v.z / scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x / v.x,
   scalar.x / v.y,
   scalar.x / v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }



 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x % scalar,
   v.y % scalar,
   v.z % scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x % scalar.x,
   v.y % scalar.x,
   v.z % scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar % v.x,
   scalar % v.y,
   scalar % v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x % v.x,
   scalar.x % v.y,
   scalar.x % v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x & scalar,
   v.y & scalar,
   v.z & scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x & scalar.x,
   v.y & scalar.x,
   v.z & scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar & v.x,
   scalar & v.y,
   scalar & v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x & v.x,
   scalar.x & v.y,
   scalar.x & v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x | scalar,
   v.y | scalar,
   v.z | scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x | scalar.x,
   v.y | scalar.x,
   v.z | scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar | v.x,
   scalar | v.y,
   scalar | v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x | v.x,
   scalar.x | v.y,
   scalar.x | v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x ^ scalar,
   v.y ^ scalar,
   v.z ^ scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x ^ scalar.x,
   v.y ^ scalar.x,
   v.z ^ scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x ^ v.x,
   scalar.x ^ v.y,
   scalar.x ^ v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x << scalar.x,
   v.y << scalar.x,
   v.z << scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x << v.x,
   scalar.x << v.y,
   scalar.x << v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x >> scalar.x,
   v.y >> scalar.x,
   v.z >> scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x >> v.x,
   scalar.x >> v.y,
   scalar.x >> v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator~(tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   ~v.x,
   ~v.y,
   ~v.z);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
 }

 template <precision P> inline
                    tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)
 {
  return tvec3<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
 }

 template <precision P> inline
                    tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)
 {
  return tvec3<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
 }
}
# 408 "/usr/local/include/glm/detail/type_vec3.hpp" 2 3
# 6 "/usr/local/include/glm/vec3.hpp" 2 3
# 69 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/vec4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_vec4.hpp" 1 3
# 16 "/usr/local/include/glm/detail/type_vec4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec4
 {


  typedef T value_type;
  typedef tvec4<T, P> type;
  typedef tvec4<bool, P> bool_type;
# 71 "/usr/local/include/glm/detail/type_vec4.hpp" 3
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 84 "/usr/local/include/glm/detail/type_vec4.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 4;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec4() ;
                                   tvec4(tvec4<T, P> const& v) ;
  template <precision Q>
                                   tvec4(tvec4<T, Q> const& v);



                                   explicit tvec4(ctor);
                                   explicit tvec4(T scalar);
                                   tvec4(T a, T b, T c, T d);




  template <typename A, typename B, typename C, typename D>
                                   tvec4(A a, B b, C c, D d);
  template <typename A, typename B, typename C, typename D>
                                   tvec4(tvec1<A, P> const& a, tvec1<B, P> const& b, tvec1<C, P> const& c, tvec1<D, P> const& d);




  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec2<A, Q> const & a, B b, C c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(A a, tvec2<B, Q> const & b, C c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(A a, B b, tvec2<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec3<A, Q> const & a, B b);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec4(A a, tvec3<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b);


  template <typename U, precision Q>
                                                tvec4(tvec4<U, Q> const& v);
# 198 "/usr/local/include/glm/detail/type_vec4.hpp" 3
                tvec4<T, P> & operator=(tvec4<T, P> const & v) ;

  template <typename U>
                tvec4<T, P> & operator=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator+=(U scalar);
  template <typename U>
                tvec4<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator+=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator-=(U scalar);
  template <typename U>
                tvec4<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator-=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator*=(U scalar);
  template <typename U>
                tvec4<T, P> & operator*=(tvec1<U, P> const& v);
  template <typename U>
                tvec4<T, P> & operator*=(tvec4<U, P> const& v);
  template <typename U>
                tvec4<T, P> & operator/=(U scalar);
  template <typename U>
                tvec4<T, P> & operator/=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator/=(tvec4<U, P> const & v);



                tvec4<T, P> & operator++();
                tvec4<T, P> & operator--();
                tvec4<T, P> operator++(int);
                tvec4<T, P> operator--(int);



  template <typename U>
                tvec4<T, P> & operator%=(U scalar);
  template <typename U>
                tvec4<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator%=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator&=(U scalar);
  template <typename U>
                tvec4<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator&=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator|=(U scalar);
  template <typename U>
                tvec4<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator|=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator^=(U scalar);
  template <typename U>
                tvec4<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator^=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec4<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator<<=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec4<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator>>=(tvec4<U, P> const & v);
 };



 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v);



 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator~(tvec4<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <precision P>
               tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);

 template <precision P>
               tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec4.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template <>
 struct is_int<uint32>
 {
  enum test {value = ~0};
 };

 template <>
 struct is_int<int32>
 {
  enum test {value = ~0};
 };

 template <>
 struct is_int<uint64>
 {
  enum test {value = ~0};
 };

 template <>
 struct is_int<int64>
 {
  enum test {value = ~0};
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_add
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_sub
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_mul
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_div
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_mod
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 { inline
                     static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
  {
   return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 { inline
                     static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
  {
   return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & v)
  {
   return tvec4<T, P>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}




  template <typename T, precision P> inline
                                        tvec4<T, P>::tvec4()

    : x(0), y(0), z(0), w(0)

  {}



  template <typename T, precision P> inline
                                        tvec4<T, P>::tvec4(tvec4<T, P> const & v)
   : x(v.x), y(v.y), z(v.z), w(v.w)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec4<T, P>::tvec4(tvec4<T, Q> const & v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template <typename T, precision P> inline
                                       tvec4<T, P>::tvec4(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec4<T, P>::tvec4(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, precision P> inline
                                       tvec4<T, P>::tvec4(T a, T b, T c, T d)
  : x(a), y(b), z(c), w(d)
 {}



 template <typename T, precision P>
 template <typename A, typename B, typename C, typename D> inline
                                       tvec4<T, P>::tvec4(A a, B b, C c, D d) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c)),
  w(static_cast<T>(d))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, typename D> inline
                                       tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(c.x)),
  w(static_cast<T>(d.x))
 {}



 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b)),
  w(static_cast<T>(c))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x)),
  w(static_cast<T>(c.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(v.x)),
  z(static_cast<T>(v.y)),
  w(static_cast<T>(s2))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(c.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(s2)),
  z(static_cast<T>(v.x)),
  w(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(c.x)),
  w(static_cast<T>(c.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(a.z)),
  w(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(a.z)),
  w(static_cast<T>(b.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(b.z))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(b.z))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x)),
  w(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z)),
  w(static_cast<T>(v.w))
 {}



 template <typename T, precision P> inline
                    T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec4.inl", 330, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec4.inl", 337, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec4<T, P>& tvec4<T, P>::operator=(tvec4<T, P> const & v)
  {
   this->x = v.x;
   this->y = v.y;
   this->z = v.z;
   this->w = v.w;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P>& tvec4<T, P>::operator=(tvec4<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }



 template <typename T, precision P> inline
                    tvec4<T, P> & tvec4<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> & tvec4<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> tvec4<T, P>::operator++(int)
 {
  tvec4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> tvec4<T, P>::operator--(int)
 {
  tvec4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }



 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v)
 {
  return tvec4<T, P>(0) -= v;
 }



 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) += scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) += v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(v) += scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v2) += v1;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) += v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) -= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) -= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) -= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) -= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) -= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) *= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) *= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(v) *= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v2) *= v1;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) *= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) /= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) /= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) /= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) /= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) /= v2;
 }



 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) %= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) %= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) %= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar.x) %= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) %= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) &= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec4<T, P>(v) &= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) &= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) &= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) &= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) |= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) |= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) |= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) |= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) |= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) ^= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) ^= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) ^= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) ^= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) ^= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) <<= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) <<= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) <<= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) <<= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) <<= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) >>= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) >>= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) >>= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) >>= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) >>= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator~(tvec4<T, P> const & v)
 {
  return detail::compute_vec4_bitwise_not<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return detail::compute_vec4_equal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return detail::compute_vec4_nequal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
 }

 template <precision P> inline
                    tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)
 {
  return tvec4<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template <precision P> inline
                    tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)
 {
  return tvec4<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}
# 453 "/usr/local/include/glm/detail/type_vec4.hpp" 2 3
# 6 "/usr/local/include/glm/vec4.hpp" 2 3
# 70 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/mat2x2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat2x2.hpp" 1 3
# 12 "/usr/local/include/glm/detail/type_mat2x2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x2<T, P> type;
  typedef tmat2x2<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


                tmat2x2() ;
                tmat2x2(tmat2x2<T, P> const & m) ;
  template <precision Q>
                tmat2x2(tmat2x2<T, Q> const & m);

                                   explicit tmat2x2(ctor);
                explicit tmat2x2(T scalar);
                tmat2x2(
   T const & x1, T const & y1,
   T const & x2, T const & y2);
                tmat2x2(
   col_type const & v1,
   col_type const & v2);



  template <typename U, typename V, typename M, typename N>
                tmat2x2(
   U const & x1, V const & y1,
   M const & x2, N const & y2);

  template <typename U, typename V>
                tmat2x2(
   tvec2<U, P> const & v1,
   tvec2<V, P> const & v2);



  template <typename U, precision Q>
                             tmat2x2(tmat2x2<U, Q> const & m);

                             tmat2x2(tmat3x3<T, P> const & x);
                             tmat2x2(tmat4x4<T, P> const & x);
                             tmat2x2(tmat2x3<T, P> const & x);
                             tmat2x2(tmat3x2<T, P> const & x);
                             tmat2x2(tmat2x4<T, P> const & x);
                             tmat2x2(tmat4x2<T, P> const & x);
                             tmat2x2(tmat3x4<T, P> const & x);
                             tmat2x2(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 2;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat2x2<T, P> & operator=(tmat2x2<T, P> const & v) ;

  template <typename U>
                tmat2x2<T, P> & operator=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator+=(U s);
  template <typename U>
                tmat2x2<T, P> & operator+=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator-=(U s);
  template <typename U>
                tmat2x2<T, P> & operator-=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator*=(U s);
  template <typename U>
                tmat2x2<T, P> & operator*=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator/=(U s);
  template <typename U>
                tmat2x2<T, P> & operator/=(tmat2x2<U, P> const & m);



                tmat2x2<T, P> & operator++ ();
                tmat2x2<T, P> & operator-- ();
                tmat2x2<T, P> operator++(int);
                tmat2x2<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat2x2<T, P> operator+(tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(tmat2x2<T, P> const & m);



 template <typename T, precision P>
               tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x2<T, P>::col_type operator*(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x2<T, P>::row_type operator*(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);



 template <typename T, precision P>
               bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat2x2.inl" 1 3



# 1 "/usr/local/include/glm/detail/func_matrix.hpp" 1 3
# 25 "/usr/local/include/glm/detail/func_matrix.hpp" 3
# 1 "/usr/local/include/glm/detail/../mat2x3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat2x3.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat2x3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x3<T, P> type;
  typedef tmat3x2<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


                tmat2x3() ;
                tmat2x3(tmat2x3<T, P> const & m) ;
  template <precision Q>
                tmat2x3(tmat2x3<T, Q> const & m);

                                   explicit tmat2x3(ctor);
                explicit tmat2x3(T scalar);
                tmat2x3(
   T x0, T y0, T z0,
   T x1, T y1, T z1);
                tmat2x3(
   col_type const & v0,
   col_type const & v1);



  template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
                tmat2x3(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2);

  template <typename U, typename V>
                tmat2x3(
   tvec3<U, P> const & v1,
   tvec3<V, P> const & v2);



  template <typename U, precision Q>
                             tmat2x3(tmat2x3<U, Q> const & m);

                             tmat2x3(tmat2x2<T, P> const & x);
                             tmat2x3(tmat3x3<T, P> const & x);
                             tmat2x3(tmat4x4<T, P> const & x);
                             tmat2x3(tmat2x4<T, P> const & x);
                             tmat2x3(tmat3x2<T, P> const & x);
                             tmat2x3(tmat3x4<T, P> const & x);
                             tmat2x3(tmat4x2<T, P> const & x);
                             tmat2x3(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 2;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat2x3<T, P> & operator=(tmat2x3<T, P> const & m) ;

  template <typename U>
                tmat2x3<T, P> & operator=(tmat2x3<U, P> const & m);
  template <typename U>
                tmat2x3<T, P> & operator+=(U s);
  template <typename U>
                tmat2x3<T, P> & operator+=(tmat2x3<U, P> const & m);
  template <typename U>
                tmat2x3<T, P> & operator-=(U s);
  template <typename U>
                tmat2x3<T, P> & operator-=(tmat2x3<U, P> const & m);
  template <typename U>
                tmat2x3<T, P> & operator*=(U s);
  template <typename U>
                tmat2x3<T, P> & operator/=(U s);



                tmat2x3<T, P> & operator++ ();
                tmat2x3<T, P> & operator-- ();
                tmat2x3<T, P> operator++(int);
                tmat2x3<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat2x3<T, P> operator+(tmat2x3<T, P> const & m);

 template <typename T, precision P>
               tmat2x3<T, P> operator-(tmat2x3<T, P> const & m);



 template <typename T, precision P>
               tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x3<T, P>::col_type operator*(tmat2x3<T, P> const & m, typename tmat2x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x3<T, P>::row_type operator*(typename tmat2x3<T, P>::col_type const & v, tmat2x3<T, P> const & m);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat2x3.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat2x3<T, P>::tmat2x3()
  {

    this->value[0] = col_type(1, 0, 0);
    this->value[1] = col_type(0, 1, 0);

  }



  template <typename T, precision P> inline
                     tmat2x3<T, P>::tmat2x3(tmat2x3<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P> inline
                                       tmat2x3<T, P>::tmat2x3(ctor)
 {}

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(T scalar)
 {
  this->value[0] = col_type(scalar, 0, 0);
  this->value[1] = col_type(0, scalar, 0);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2> inline
                    tmat2x3<T, P>::tmat2x3
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2> inline
                    tmat2x3<T, P>::tmat2x3(tvec3<V1, P> const & v1, tvec3<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                     tmat2x3<T, P>::tmat2x3(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat4x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }



 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::col_type & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x3.inl", 160, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::col_type const & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x3.inl", 167, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator+=(tmat2x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator-=(tmat2x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> tmat2x3<T, P>::operator++(int)
 {
  tmat2x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> tmat2x3<T, P>::operator--(int)
 {
  tmat2x3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat2x3<T, P> operator+(tmat2x3<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator-(tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   -m[0],
   -m[1]);
 }



 template <typename T, precision P> inline
                    tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::col_type operator*
 (
  tmat2x3<T, P> const & m,
  typename tmat2x3<T, P>::row_type const & v)
 {
  return typename tmat2x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::row_type operator*
 (
  typename tmat2x3<T, P>::col_type const & v,
  tmat2x3<T, P> const & m)
 {
  return typename tmat2x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   scalar / m[0],
   scalar / m[1]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 164 "/usr/local/include/glm/detail/type_mat2x3.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat2x3.hpp" 2 3


namespace glm
{





 typedef tmat2x3<float, lowp> lowp_mat2x3;






 typedef tmat2x3<float, mediump> mediump_mat2x3;






 typedef tmat2x3<float, highp> highp_mat2x3;

}
# 25 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat2x4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat2x4.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat2x4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x4<T, P> type;
  typedef tmat4x2<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


                tmat2x4() ;
                tmat2x4(tmat2x4<T, P> const & m) ;
  template <precision Q>
                tmat2x4(tmat2x4<T, Q> const & m);

                                   explicit tmat2x4(ctor);
                explicit tmat2x4(T scalar);
                tmat2x4(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1);
                tmat2x4(
   col_type const & v0,
   col_type const & v1);



  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
                tmat2x4(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2);

  template <typename U, typename V>
                tmat2x4(
   tvec4<U, P> const & v1,
   tvec4<V, P> const & v2);



  template <typename U, precision Q>
                             tmat2x4(tmat2x4<U, Q> const & m);

                             tmat2x4(tmat2x2<T, P> const & x);
                             tmat2x4(tmat3x3<T, P> const & x);
                             tmat2x4(tmat4x4<T, P> const & x);
                             tmat2x4(tmat2x3<T, P> const & x);
                             tmat2x4(tmat3x2<T, P> const & x);
                             tmat2x4(tmat3x4<T, P> const & x);
                             tmat2x4(tmat4x2<T, P> const & x);
                             tmat2x4(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 2;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat2x4<T, P> & operator=(tmat2x4<T, P> const & m) ;

  template <typename U>
                tmat2x4<T, P> & operator=(tmat2x4<U, P> const & m);
  template <typename U>
                tmat2x4<T, P> & operator+=(U s);
  template <typename U>
                tmat2x4<T, P> & operator+=(tmat2x4<U, P> const & m);
  template <typename U>
                tmat2x4<T, P> & operator-=(U s);
  template <typename U>
                tmat2x4<T, P> & operator-=(tmat2x4<U, P> const & m);
  template <typename U>
                tmat2x4<T, P> & operator*=(U s);
  template <typename U>
                tmat2x4<T, P> & operator/=(U s);



                tmat2x4<T, P> & operator++ ();
                tmat2x4<T, P> & operator-- ();
                tmat2x4<T, P> operator++(int);
                tmat2x4<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat2x4<T, P> operator+(tmat2x4<T, P> const & m);

 template <typename T, precision P>
               tmat2x4<T, P> operator-(tmat2x4<T, P> const & m);



 template <typename T, precision P>
               tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat2x4.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat2x4<T, P>::tmat2x4()
  {

    this->value[0] = col_type(1, 0, 0, 0);
    this->value[1] = col_type(0, 1, 0, 0);

  }



  template <typename T, precision P> inline
                     tmat2x4<T, P>::tmat2x4(tmat2x4<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P> inline
                                       tmat2x4<T, P>::tmat2x4(ctor)
 {}

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(T scalar)
 {
  value_type const Zero(0);
  this->value[0] = col_type(scalar, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, scalar, Zero, Zero);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2> inline
                    tmat2x4<T, P>::tmat2x4
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2> inline
                    tmat2x4<T, P>::tmat2x4(tvec4<V1, P> const & v1, tvec4<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x4<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat3x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }



 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::col_type & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x4.inl", 161, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::col_type const & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x4.inl", 168, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator+=(tmat2x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator-=(tmat2x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P> & tmat2x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> tmat2x4<T, P>::operator++(int)
 {
  tmat2x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> tmat2x4<T, P>::operator--(int)
 {
  tmat2x4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat2x4<T, P> operator+(tmat2x4<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator-(tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   -m[0],
   -m[1]);
 }



 template <typename T, precision P> inline
                    tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v)
 {
  return typename tmat2x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m)
 {
  return typename tmat2x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  tmat4x4<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   scalar / m[0],
   scalar / m[1]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 166 "/usr/local/include/glm/detail/type_mat2x4.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat2x4.hpp" 2 3


namespace glm
{





 typedef tmat2x4<float, lowp> lowp_mat2x4;






 typedef tmat2x4<float, mediump> mediump_mat2x4;






 typedef tmat2x4<float, highp> highp_mat2x4;

}
# 26 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat3x2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat3x2.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat3x2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x2<T, P> type;
  typedef tmat2x3<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


                tmat3x2() ;
                tmat3x2(tmat3x2<T, P> const & m) ;
  template <precision Q>
                tmat3x2(tmat3x2<T, Q> const & m);

                                   explicit tmat3x2(ctor);
                explicit tmat3x2(T scalar);
                tmat3x2(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2);
                tmat3x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
                tmat3x2(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template <typename V1, typename V2, typename V3>
                tmat3x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3);



  template <typename U, precision Q>
                             tmat3x2(tmat3x2<U, Q> const & m);

                             tmat3x2(tmat2x2<T, P> const & x);
                             tmat3x2(tmat3x3<T, P> const & x);
                             tmat3x2(tmat4x4<T, P> const & x);
                             tmat3x2(tmat2x3<T, P> const & x);
                             tmat3x2(tmat2x4<T, P> const & x);
                             tmat3x2(tmat3x4<T, P> const & x);
                             tmat3x2(tmat4x2<T, P> const & x);
                             tmat3x2(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 3;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat3x2<T, P> & operator=(tmat3x2<T, P> const & m) ;

  template <typename U>
                tmat3x2<T, P> & operator=(tmat3x2<U, P> const & m);
  template <typename U>
                tmat3x2<T, P> & operator+=(U s);
  template <typename U>
                tmat3x2<T, P> & operator+=(tmat3x2<U, P> const & m);
  template <typename U>
                tmat3x2<T, P> & operator-=(U s);
  template <typename U>
                tmat3x2<T, P> & operator-=(tmat3x2<U, P> const & m);
  template <typename U>
                tmat3x2<T, P> & operator*=(U s);
  template <typename U>
                tmat3x2<T, P> & operator/=(U s);



                tmat3x2<T, P> & operator++ ();
                tmat3x2<T, P> & operator-- ();
                tmat3x2<T, P> operator++(int);
                tmat3x2<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat3x2<T, P> operator+(tmat3x2<T, P> const & m);

 template <typename T, precision P>
               tmat3x2<T, P> operator-(tmat3x2<T, P> const & m);



 template <typename T, precision P>
               tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

}



# 1 "/usr/local/include/glm/detail/type_mat3x2.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat3x2<T, P>::tmat3x2()
  {

    this->value[0] = col_type(1, 0);
    this->value[1] = col_type(0, 1);
    this->value[2] = col_type(0, 0);

  }



  template <typename T, precision P> inline
                     tmat3x2<T, P>::tmat3x2(tmat3x2<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P> inline
                                       tmat3x2<T, P>::tmat3x2(ctor)
 {}

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(T scalar)
 {
  this->value[0] = col_type(scalar, 0);
  this->value[1] = col_type(0, scalar);
  this->value[2] = col_type(0, 0);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3> inline
                    tmat3x2<T, P>::tmat3x2
 (
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3> inline
                    tmat3x2<T, P>::tmat3x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat2x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat4x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }



 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::col_type & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x2.inl", 190, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::col_type const & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x2.inl", 197, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator+=(tmat3x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator-=(tmat3x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P> & tmat3x2<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> tmat3x2<T, P>::operator++(int)
 {
  tmat3x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> tmat3x2<T, P>::operator--(int)
 {
  tmat3x2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat3x2<T, P> operator+(tmat3x2<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator-(tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template <typename T, precision P> inline
                    tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v)
 {
  return typename tmat3x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m)
 {
  return typename tmat3x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  tmat2x2<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 172 "/usr/local/include/glm/detail/type_mat3x2.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat3x2.hpp" 2 3


namespace glm
{





 typedef tmat3x2<float, lowp> lowp_mat3x2;






 typedef tmat3x2<float, mediump> mediump_mat3x2;






 typedef tmat3x2<float, highp> highp_mat3x2;

}
# 27 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat3x3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat3x3.hpp" 1 3
# 12 "/usr/local/include/glm/detail/type_mat3x3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x3<T, P> type;
  typedef tmat3x3<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


                tmat3x3() ;
                tmat3x3(tmat3x3<T, P> const & m) ;
  template <precision Q>
                tmat3x3(tmat3x3<T, Q> const & m);

                                   explicit tmat3x3(ctor);
                explicit tmat3x3(T scalar);
                tmat3x3(
   T x0, T y0, T z0,
   T x1, T y1, T z1,
   T x2, T y2, T z2);
                tmat3x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
                tmat3x3(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2,
   X3 x3, Y3 y3, Z3 z3);

  template <typename V1, typename V2, typename V3>
                tmat3x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3);



  template <typename U, precision Q>
                             tmat3x3(tmat3x3<U, Q> const & m);

                             tmat3x3(tmat2x2<T, P> const & x);
                             tmat3x3(tmat4x4<T, P> const & x);
                             tmat3x3(tmat2x3<T, P> const & x);
                             tmat3x3(tmat3x2<T, P> const & x);
                             tmat3x3(tmat2x4<T, P> const & x);
                             tmat3x3(tmat4x2<T, P> const & x);
                             tmat3x3(tmat3x4<T, P> const & x);
                             tmat3x3(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 3;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat3x3<T, P> & operator=(tmat3x3<T, P> const & m) ;

  template <typename U>
                tmat3x3<T, P> & operator=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator+=(U s);
  template <typename U>
                tmat3x3<T, P> & operator+=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator-=(U s);
  template <typename U>
                tmat3x3<T, P> & operator-=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator*=(U s);
  template <typename U>
                tmat3x3<T, P> & operator*=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator/=(U s);
  template <typename U>
                tmat3x3<T, P> & operator/=(tmat3x3<U, P> const & m);



                tmat3x3<T, P> & operator++();
                tmat3x3<T, P> & operator--();
                tmat3x3<T, P> operator++(int);
                tmat3x3<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat3x3<T, P> operator+(tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(tmat3x3<T, P> const & m);



 template <typename T, precision P>
               tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator/(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);



 template <typename T, precision P>
               bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat3x3.inl" 1 3





namespace glm
{



  template <typename T, precision P> inline
                     tmat3x3<T, P>::tmat3x3()
  {

    this->value[0] = col_type(1, 0, 0);
    this->value[1] = col_type(0, 1, 0);
    this->value[2] = col_type(0, 0, 1);

  }



  template <typename T, precision P> inline
                     tmat3x3<T, P>::tmat3x3(tmat3x3<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P> inline
                                       tmat3x3<T, P>::tmat3x3(ctor)
 {}

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(T scalar)
 {
  this->value[0] = col_type(scalar, 0, 0);
  this->value[1] = col_type(0, scalar, 0);
  this->value[2] = col_type(0, 0, scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1,
  T x2, T y2, T z2
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3> inline
                    tmat3x3<T, P>::tmat3x3
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2,
  X3 x3, Y3 y3, Z3 z3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3> inline
                    tmat3x3<T, P>::tmat3x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat2x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat4x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }



 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x3.inl", 192, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type const & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x3.inl", 199, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator+=(tmat3x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator-=(tmat3x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator*=(tmat3x3<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator/=(tmat3x3<U, P> const & m)
 {
  return *this *= inverse(m);
 }



 template <typename T, precision P> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> tmat3x3<T, P>::operator++(int)
 {
  tmat3x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> tmat3x3<T, P>::operator--(int)
 {
  tmat3x3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(tmat3x3<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
 {
  return typename tmat3x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
 {
  return typename tmat3x3<T, P>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator/(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
 {
  return inverse(m) * v;
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
 {
  return v * inverse(m);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  tmat3x3<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }



 template <typename T, precision P> inline
                    bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 189 "/usr/local/include/glm/detail/type_mat3x3.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat3x3.hpp" 2 3


namespace glm
{





 typedef tmat3x3<float, lowp> lowp_mat3;






 typedef tmat3x3<float, mediump> mediump_mat3;






 typedef tmat3x3<float, highp> highp_mat3;






 typedef tmat3x3<float, lowp> lowp_mat3x3;






 typedef tmat3x3<float, mediump> mediump_mat3x3;






 typedef tmat3x3<float, highp> highp_mat3x3;

}
# 28 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat3x4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat3x4.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat3x4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x4<T, P> type;
  typedef tmat4x3<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


                tmat3x4() ;
                tmat3x4(tmat3x4<T, P> const & m) ;
  template <precision Q>
                tmat3x4(tmat3x4<T, Q> const & m);

                                   explicit tmat3x4(ctor);
                explicit tmat3x4(T scalar);
                tmat3x4(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1,
   T x2, T y2, T z2, T w2);
                tmat3x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
                tmat3x4(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2,
   X3 x3, Y3 y3, Z3 z3, W3 w3);

  template <typename V1, typename V2, typename V3>
                tmat3x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3);



  template <typename U, precision Q>
                             tmat3x4(tmat3x4<U, Q> const & m);

                             tmat3x4(tmat2x2<T, P> const & x);
                             tmat3x4(tmat3x3<T, P> const & x);
                             tmat3x4(tmat4x4<T, P> const & x);
                             tmat3x4(tmat2x3<T, P> const & x);
                             tmat3x4(tmat3x2<T, P> const & x);
                             tmat3x4(tmat2x4<T, P> const & x);
                             tmat3x4(tmat4x2<T, P> const & x);
                             tmat3x4(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 3;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat3x4<T, P> & operator=(tmat3x4<T, P> const & m) ;

  template <typename U>
                tmat3x4<T, P> & operator=(tmat3x4<U, P> const & m);
  template <typename U>
                tmat3x4<T, P> & operator+=(U s);
  template <typename U>
                tmat3x4<T, P> & operator+=(tmat3x4<U, P> const & m);
  template <typename U>
                tmat3x4<T, P> & operator-=(U s);
  template <typename U>
                tmat3x4<T, P> & operator-=(tmat3x4<U, P> const & m);
  template <typename U>
                tmat3x4<T, P> & operator*=(U s);
  template <typename U>
                tmat3x4<T, P> & operator/=(U s);



                tmat3x4<T, P> & operator++();
                tmat3x4<T, P> & operator--();
                tmat3x4<T, P> operator++(int);
                tmat3x4<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat3x4<T, P> operator+(tmat3x4<T, P> const & m);

 template <typename T, precision P>
               tmat3x4<T, P> operator-(tmat3x4<T, P> const & m);



 template <typename T, precision P>
               tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x4<T, P>::col_type operator*(tmat3x4<T, P> const & m, typename tmat3x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x4<T, P>::row_type operator*(typename tmat3x4<T, P>::col_type const & v, tmat3x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat3x4.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat3x4<T, P>::tmat3x4()
  {

    this->value[0] = col_type(1, 0, 0, 0);
    this->value[1] = col_type(0, 1, 0, 0);
    this->value[2] = col_type(0, 0, 1, 0);

  }



  template <typename T, precision P> inline
                     tmat3x4<T, P>::tmat3x4(tmat3x4<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P> inline
                                       tmat3x4<T, P>::tmat3x4(ctor)
 {}

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(T scalar)
 {
  this->value[0] = col_type(scalar, 0, 0, 0);
  this->value[1] = col_type(0, scalar, 0, 0);
  this->value[2] = col_type(0, 0, scalar, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1,
  T x2, T y2, T z2, T w2
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3> inline
                    tmat3x4<T, P>::tmat3x4
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2,
  X3 x3, Y3 y3, Z3 z3, W3 w3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3> inline
                    tmat3x4<T, P>::tmat3x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x4<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
 }



 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::col_type & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x4.inl", 190, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::col_type const & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x4.inl", 197, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator+=(tmat3x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator-=(tmat3x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P> & tmat3x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> tmat3x4<T, P>::operator++(int)
 {
  tmat3x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> tmat3x4<T, P>::operator--(int)
 {
  tmat3x4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat3x4<T, P> operator+(tmat3x4<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator-(tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template <typename T, precision P> inline
                    tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::col_type operator*
 (
  tmat3x4<T, P> const & m,
  typename tmat3x4<T, P>::row_type const & v
 )
 {
  return typename tmat3x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::row_type operator*
 (
  typename tmat3x4<T, P>::col_type const & v,
  tmat3x4<T, P> const & m
 )
 {
  return typename tmat3x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  tmat4x4<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 171 "/usr/local/include/glm/detail/type_mat3x4.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat3x4.hpp" 2 3


namespace glm
{





 typedef tmat3x4<float, lowp> lowp_mat3x4;






 typedef tmat3x4<float, mediump> mediump_mat3x4;






 typedef tmat3x4<float, highp> highp_mat3x4;

}
# 29 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat4x2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat4x2.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat4x2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x2<T, P> type;
  typedef tmat2x4<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


                tmat4x2() ;
                tmat4x2(tmat4x2<T, P> const & m) ;
  template <precision Q>
                tmat4x2(tmat4x2<T, Q> const & m);

                                   explicit tmat4x2(ctor);
                explicit tmat4x2(T scalar);
                tmat4x2(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2,
   T x3, T y3);
                tmat4x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3,
   typename X4, typename Y4>
                tmat4x2(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3,
   X4 x4, Y4 y4);

  template <typename V1, typename V2, typename V3, typename V4>
                tmat4x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3,
   tvec2<V4, P> const & v4);



  template <typename U, precision Q>
                             tmat4x2(tmat4x2<U, Q> const & m);

                             tmat4x2(tmat2x2<T, P> const & x);
                             tmat4x2(tmat3x3<T, P> const & x);
                             tmat4x2(tmat4x4<T, P> const & x);
                             tmat4x2(tmat2x3<T, P> const & x);
                             tmat4x2(tmat3x2<T, P> const & x);
                             tmat4x2(tmat2x4<T, P> const & x);
                             tmat4x2(tmat4x3<T, P> const & x);
                             tmat4x2(tmat3x4<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 4;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat4x2<T, P> & operator=(tmat4x2<T, P> const & m) ;

  template <typename U>
                tmat4x2<T, P> & operator=(tmat4x2<U, P> const & m);
  template <typename U>
                tmat4x2<T, P> & operator+=(U s);
  template <typename U>
                tmat4x2<T, P> & operator+=(tmat4x2<U, P> const & m);
  template <typename U>
                tmat4x2<T, P> & operator-=(U s);
  template <typename U>
                tmat4x2<T, P> & operator-=(tmat4x2<U, P> const & m);
  template <typename U>
                tmat4x2<T, P> & operator*=(U s);
  template <typename U>
                tmat4x2<T, P> & operator/=(U s);



                tmat4x2<T, P> & operator++ ();
                tmat4x2<T, P> & operator-- ();
                tmat4x2<T, P> operator++(int);
                tmat4x2<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat4x2<T, P> operator+(tmat4x2<T, P> const & m);

 template <typename T, precision P>
               tmat4x2<T, P> operator-(tmat4x2<T, P> const & m);



 template <typename T, precision P>
               tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat4x2.inl" 1 3



namespace glm
{
# 16 "/usr/local/include/glm/detail/type_mat4x2.inl" 3
  template <typename T, precision P> inline
                     tmat4x2<T, P>::tmat4x2()
  {

    this->value[0] = col_type(1, 0);
    this->value[1] = col_type(0, 1);
    this->value[2] = col_type(0, 0);
    this->value[3] = col_type(0, 0);

  }



  template <typename T, precision P> inline
                     tmat4x2<T, P>::tmat4x2(tmat4x2<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
   this->value[3] = m.value[3];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P> inline
                                       tmat4x2<T, P>::tmat4x2(ctor)
 {}

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(T scalar)
 {
  this->value[0] = col_type(scalar, 0);
  this->value[1] = col_type(0, scalar);
  this->value[2] = col_type(0, 0);
  this->value[3] = col_type(0, 0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2,
  T x3, T y3
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
  this->value[3] = col_type(x3, y3);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3,
  typename X4, typename Y4> inline
                    tmat4x2<T, P>::tmat4x2
 (
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3,
  X4 x4, Y4 y4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4> inline
                    tmat4x2<T, P>::tmat4x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3,
  tvec2<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }



 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::col_type & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x2.inl", 219, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::col_type const & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x2.inl", 226, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator+=(tmat4x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator-=(tmat4x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> tmat4x2<T, P>::operator++(int)
 {
  tmat4x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> tmat4x2<T, P>::operator--(int)
 {
  tmat4x2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat4x2<T, P> operator+(tmat4x2<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator-(tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template <typename T, precision P> inline
                    tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v)
 {
  return typename tmat4x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m)
 {
  return typename tmat4x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  tmat2x2<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 176 "/usr/local/include/glm/detail/type_mat4x2.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat4x2.hpp" 2 3


namespace glm
{





 typedef tmat4x2<float, lowp> lowp_mat4x2;






 typedef tmat4x2<float, mediump> mediump_mat4x2;






 typedef tmat4x2<float, highp> highp_mat4x2;

}
# 30 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat4x3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat4x3.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat4x3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x3<T, P> type;
  typedef tmat3x4<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


                tmat4x3() ;
                tmat4x3(tmat4x3<T, P> const & m) ;
  template <precision Q>
                tmat4x3(tmat4x3<T, Q> const & m);

                                   explicit tmat4x3(ctor);
                explicit tmat4x3(T const & x);
                tmat4x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1,
   T const & x2, T const & y2, T const & z2,
   T const & x3, T const & y3, T const & z3);
                tmat4x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
                tmat4x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3,
   X4 const & x4, Y4 const & y4, Z4 const & z4);

  template <typename V1, typename V2, typename V3, typename V4>
                tmat4x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3,
   tvec3<V4, P> const & v4);



  template <typename U, precision Q>
                             tmat4x3(tmat4x3<U, Q> const & m);

                             tmat4x3(tmat2x2<T, P> const & x);
                             tmat4x3(tmat3x3<T, P> const & x);
                             tmat4x3(tmat4x4<T, P> const & x);
                             tmat4x3(tmat2x3<T, P> const & x);
                             tmat4x3(tmat3x2<T, P> const & x);
                             tmat4x3(tmat2x4<T, P> const & x);
                             tmat4x3(tmat4x2<T, P> const & x);
                             tmat4x3(tmat3x4<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 4;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat4x3<T, P> & operator=(tmat4x3<T, P> const & m) ;

  template <typename U>
                tmat4x3<T, P> & operator=(tmat4x3<U, P> const & m);
  template <typename U>
                tmat4x3<T, P> & operator+=(U s);
  template <typename U>
                tmat4x3<T, P> & operator+=(tmat4x3<U, P> const & m);
  template <typename U>
                tmat4x3<T, P> & operator-=(U s);
  template <typename U>
                tmat4x3<T, P> & operator-=(tmat4x3<U, P> const & m);
  template <typename U>
                tmat4x3<T, P> & operator*=(U s);
  template <typename U>
                tmat4x3<T, P> & operator/=(U s);



                tmat4x3<T, P> & operator++();
                tmat4x3<T, P> & operator--();
                tmat4x3<T, P> operator++(int);
                tmat4x3<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat4x3<T, P> operator+(tmat4x3<T, P> const & m);

 template <typename T, precision P>
               tmat4x3<T, P> operator-(tmat4x3<T, P> const & m);



 template <typename T, precision P>
               tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x3<T, P>::col_type operator*(tmat4x3<T, P> const & m, typename tmat4x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x3<T, P>::row_type operator*(typename tmat4x3<T, P>::col_type const & v, tmat4x3<T, P> const & m);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat4x3.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat4x3<T, P>::tmat4x3()
  {

    this->value[0] = col_type(1, 0, 0);
    this->value[1] = col_type(0, 1, 0);
    this->value[2] = col_type(0, 0, 1);
    this->value[3] = col_type(0, 0, 0);

  }



  template <typename T, precision P> inline
                     tmat4x3<T, P>::tmat4x3(tmat4x3<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
   this->value[3] = m.value[3];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P> inline
                                       tmat4x3<T, P>::tmat4x3(ctor)
 {}

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(T const & s)
 {
  this->value[0] = col_type(s, 0, 0);
  this->value[1] = col_type(0, s, 0);
  this->value[2] = col_type(0, 0, s);
  this->value[3] = col_type(0, 0, 0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1,
  T const & x2, T const & y2, T const & z2,
  T const & x3, T const & y3, T const & z3
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
  this->value[3] = col_type(x3, y3, z3);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3,
  typename X4, typename Y4, typename Z4> inline
                    tmat4x3<T, P>::tmat4x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3,
  X4 const & x4, Y4 const & y4, Z4 const & z4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4> inline
                    tmat4x3<T, P>::tmat4x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3,
  tvec3<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
  this->value[3] = col_type(m[3], 0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }



 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::col_type & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x3.inl", 212, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::col_type const & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x3.inl", 219, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator+=(tmat4x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator-=(tmat4x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> tmat4x3<T, P>::operator++(int)
 {
  tmat4x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> tmat4x3<T, P>::operator--(int)
 {
  tmat4x3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat4x3<T, P> operator+(tmat4x3<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator-(tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template <typename T, precision P> inline
                    tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::col_type operator*
 (
  tmat4x3<T, P> const & m,
  typename tmat4x3<T, P>::row_type const & v)
 {
  return typename tmat4x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::row_type operator*
 (
  typename tmat4x3<T, P>::col_type const & v,
  tmat4x3<T, P> const & m)
 {
  return typename tmat4x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 176 "/usr/local/include/glm/detail/type_mat4x3.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat4x3.hpp" 2 3


namespace glm
{





 typedef tmat4x3<float, lowp> lowp_mat4x3;






 typedef tmat4x3<float, mediump> mediump_mat4x3;






 typedef tmat4x3<float, highp> highp_mat4x3;

}
# 31 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat4x4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat4x4.hpp" 1 3
# 12 "/usr/local/include/glm/detail/type_mat4x4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x4<T, P> type;
  typedef tmat4x4<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


                tmat4x4() ;
                tmat4x4(tmat4x4<T, P> const & m) ;
  template <precision Q>
                tmat4x4(tmat4x4<T, Q> const & m);

                explicit tmat4x4(ctor);
                explicit tmat4x4(T const & x);
                tmat4x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1,
   T const & x2, T const & y2, T const & z2, T const & w2,
   T const & x3, T const & y3, T const & z3, T const & w3);
                tmat4x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
                tmat4x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
   X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
   X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

  template <typename V1, typename V2, typename V3, typename V4>
                tmat4x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3,
   tvec4<V4, P> const & v4);



  template <typename U, precision Q>
                             tmat4x4(tmat4x4<U, Q> const & m);

                             tmat4x4(tmat2x2<T, P> const & x);
                             tmat4x4(tmat3x3<T, P> const & x);
                             tmat4x4(tmat2x3<T, P> const & x);
                             tmat4x4(tmat3x2<T, P> const & x);
                             tmat4x4(tmat2x4<T, P> const & x);
                             tmat4x4(tmat4x2<T, P> const & x);
                             tmat4x4(tmat3x4<T, P> const & x);
                             tmat4x4(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 4;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat4x4<T, P> & operator=(tmat4x4<T, P> const & m) ;

  template <typename U>
                tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator+=(U s);
  template <typename U>
                tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator-=(U s);
  template <typename U>
                tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator*=(U s);
  template <typename U>
                tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator/=(U s);
  template <typename U>
                tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);



                tmat4x4<T, P> & operator++();
                tmat4x4<T, P> & operator--();
                tmat4x4<T, P> operator++(int);
                tmat4x4<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat4x4<T, P> operator+(tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(tmat4x4<T, P> const & m);



 template <typename T, precision P>
               tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);



 template <typename T, precision P>
               bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat4x4.inl" 1 3





namespace glm
{



  template <typename T, precision P> inline
                     tmat4x4<T, P>::tmat4x4()
  {

    this->value[0] = col_type(1, 0, 0, 0);
    this->value[1] = col_type(0, 1, 0, 0);
    this->value[2] = col_type(0, 0, 1, 0);
    this->value[3] = col_type(0, 0, 0, 1);

  }



  template <typename T, precision P> inline
                     tmat4x4<T, P>::tmat4x4(tmat4x4<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(ctor)
 {}

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(T const & s)
 {
  this->value[0] = col_type(s, 0, 0, 0);
  this->value[1] = col_type(0, s, 0, 0);
  this->value[2] = col_type(0, 0, s, 0);
  this->value[3] = col_type(0, 0, 0, s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1,
  T const & x2, T const & y2, T const & z2, T const & w2,
  T const & x3, T const & y3, T const & z3, T const & w3
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
  this->value[3] = col_type(x3, y3, z3, w3);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }

 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat4x4<T, P>::tmat4x4
 (
  tmat4x4<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4> inline
                    tmat4x4<T, P>::tmat4x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
  X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
 )
 {
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;

                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;

                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;

                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;

  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4> inline
                    tmat4x4<T, P>::tmat4x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3,
  tvec4<V4, P> const & v4
 )
 {
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;

  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
  this->value[3] = col_type(m[3], 1);
 }



 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x4.inl", 242, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x4.inl", 249, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<T, P> const & m)
  {


   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)
 {
  return *this *= inverse(m);
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> tmat4x4<T, P>::operator++(int)
 {
  tmat4x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> tmat4x4<T, P>::operator--(int)
 {
  tmat4x4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(tmat4x4<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   s - m[0],
   s - m[1],
   s - m[2],
   s - m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type operator*
 (
  tmat4x4<T, P> const & m,
  typename tmat4x4<T, P>::row_type const & v
 )
 {
# 526 "/usr/local/include/glm/detail/type_mat4x4.inl" 3
  typename tmat4x4<T, P>::col_type const Mov0(v[0]);
  typename tmat4x4<T, P>::col_type const Mov1(v[1]);
  typename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;
  typename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;
  typename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;
  typename tmat4x4<T, P>::col_type const Mov2(v[2]);
  typename tmat4x4<T, P>::col_type const Mov3(v[3]);
  typename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;
  typename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;
  typename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;
  typename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 546 "/usr/local/include/glm/detail/type_mat4x4.inl" 3
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::row_type operator*
 (
  typename tmat4x4<T, P>::col_type const & v,
  tmat4x4<T, P> const & m
 )
 {
  return typename tmat4x4<T, P>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  typename tmat4x4<T, P>::col_type const SrcA0 = m1[0];
  typename tmat4x4<T, P>::col_type const SrcA1 = m1[1];
  typename tmat4x4<T, P>::col_type const SrcA2 = m1[2];
  typename tmat4x4<T, P>::col_type const SrcA3 = m1[3];

  typename tmat4x4<T, P>::col_type const SrcB0 = m2[0];
  typename tmat4x4<T, P>::col_type const SrcB1 = m2[1];
  typename tmat4x4<T, P>::col_type const SrcB2 = m2[2];
  typename tmat4x4<T, P>::col_type const SrcB3 = m2[3];

  tmat4x4<T, P> Result(uninitialize);
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)
 {
  return inverse(m) * v;
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)
 {
  return v * inverse(m);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  tmat4x4<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }



 template <typename T, precision P> inline
                    bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}



# 1 "/usr/local/include/glm/detail/type_mat4x4_simd.inl" 1 3



namespace glm
{

}
# 670 "/usr/local/include/glm/detail/type_mat4x4.inl" 2 3
# 194 "/usr/local/include/glm/detail/type_mat4x4.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat4x4.hpp" 2 3


namespace glm
{





 typedef tmat4x4<float, lowp> lowp_mat4;






 typedef tmat4x4<float, mediump> mediump_mat4;






 typedef tmat4x4<float, highp> highp_mat4;






 typedef tmat4x4<float, lowp> lowp_mat4x4;






 typedef tmat4x4<float, mediump> mediump_mat4x4;






 typedef tmat4x4<float, highp> highp_mat4x4;

}
# 32 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec2>
 {
  typedef tmat2x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec3>
 {
  typedef tmat3x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec4>
 {
  typedef tmat4x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec2>
 {
  typedef tmat2x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec3>
 {
  typedef tmat3x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec4>
 {
  typedef tmat4x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec2>
 {
  typedef tmat2x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec3>
 {
  typedef tmat3x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec4>
 {
  typedef tmat4x4<T, P> type;
 };

}
# 103 "/usr/local/include/glm/detail/func_matrix.hpp" 3
 template <typename T, precision P, template <typename, precision> class matType>
               matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y);
# 114 "/usr/local/include/glm/detail/func_matrix.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
               typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r);
# 134 "/usr/local/include/glm/detail/func_matrix.hpp" 3
 template <typename T, precision P, template <typename, precision> class matType>
               T determinant(matType<T, P> const & m);







 template <typename T, precision P, template <typename, precision> class matType>
               matType<T, P> inverse(matType<T, P> const & m);


}


# 1 "/usr/local/include/glm/detail/func_matrix.inl" 1 3



# 1 "/usr/local/include/glm/detail/../geometric.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_geometric.hpp" 1 3
# 15 "/usr/local/include/glm/detail/func_geometric.hpp" 3
namespace glm
{
# 26 "/usr/local/include/glm/detail/func_geometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               T length(
  vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               T distance(
  vecType<T, P> const & p0,
  vecType<T, P> const & p1);







 template <typename T, precision P, template <typename, precision> class vecType>
               T dot(
  vecType<T, P> const & x,
  vecType<T, P> const & y);







 template <typename T, precision P>
               tvec3<T, P> cross(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y);






 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> normalize(
  vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> faceforward(
  vecType<T, P> const & N,
  vecType<T, P> const & I,
  vecType<T, P> const & Nref);
# 91 "/usr/local/include/glm/detail/func_geometric.hpp" 3
 template <typename genType>
               genType reflect(
  genType const & I,
  genType const & N);
# 104 "/usr/local/include/glm/detail/func_geometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> refract(
  vecType<T, P> const & I,
  vecType<T, P> const & N,
  T eta);


}


# 1 "/usr/local/include/glm/detail/func_geometric.inl" 1 3



# 1 "/usr/local/include/glm/detail/func_exponential.hpp" 1 3
# 13 "/usr/local/include/glm/detail/func_exponential.hpp" 3
# 1 "/usr/local/include/glm/detail/type_vec1.hpp" 1 3
# 17 "/usr/local/include/glm/detail/type_vec1.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec1
 {


  typedef T value_type;
  typedef tvec1<T, P> type;
  typedef tvec1<bool, P> bool_type;
# 70 "/usr/local/include/glm/detail/type_vec1.hpp" 3
   union {T x, r, s;};
# 80 "/usr/local/include/glm/detail/type_vec1.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 1;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec1() ;
                                   tvec1(tvec1<T, P> const & v) ;
  template <precision Q>
                                   tvec1(tvec1<T, Q> const & v);



                                   explicit tvec1(ctor);
                                   explicit tvec1(T scalar);




  template <typename U, precision Q>
                                                tvec1(tvec2<U, Q> const & v);

  template <typename U, precision Q>
                                                tvec1(tvec3<U, Q> const & v);

  template <typename U, precision Q>
                                                tvec1(tvec4<U, Q> const & v);


  template <typename U, precision Q>
                                                tvec1(tvec1<U, Q> const & v);
# 126 "/usr/local/include/glm/detail/type_vec1.hpp" 3
                tvec1<T, P> & operator=(tvec1<T, P> const & v) ;

  template <typename U>
                tvec1<T, P> & operator=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator+=(U scalar);
  template <typename U>
                tvec1<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator-=(U scalar);
  template <typename U>
                tvec1<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator*=(U scalar);
  template <typename U>
                tvec1<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator/=(U scalar);
  template <typename U>
                tvec1<T, P> & operator/=(tvec1<U, P> const & v);



                tvec1<T, P> & operator++();
                tvec1<T, P> & operator--();
                tvec1<T, P> operator++(int);
                tvec1<T, P> operator--(int);



  template <typename U>
                tvec1<T, P> & operator%=(U scalar);
  template <typename U>
                tvec1<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator&=(U scalar);
  template <typename U>
                tvec1<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator|=(U scalar);
  template <typename U>
                tvec1<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator^=(U scalar);
  template <typename U>
                tvec1<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec1<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec1<T, P> & operator>>=(tvec1<U, P> const & v);
 };



 template <typename T, precision P>
               tvec1<T, P> operator+(tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator-(tvec1<T, P> const & v);



 template <typename T, precision P>
               tvec1<T, P> operator+(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator+(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator-(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator-(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator- (tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator*(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator*(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator/(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator/(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator%(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator%(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator&(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator&(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator|(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator|(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator^(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator^(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator<<(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator<<(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator>>(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator>>(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator~(tvec1<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <precision P>
               tvec1<bool, P> operator&&(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2);

 template <precision P>
               tvec1<bool, P> operator||(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec1.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                                        tvec1<T, P>::tvec1()

    : x(0)

  {}



  template <typename T, precision P> inline
                                        tvec1<T, P>::tvec1(tvec1<T, P> const & v)
   : x(v.x)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec1<T, P>::tvec1(tvec1<T, Q> const & v)
  : x(v.x)
 {}



 template <typename T, precision P> inline
                                       tvec1<T, P>::tvec1(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec1<T, P>::tvec1(T scalar)
  : x(scalar)
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec1<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec2<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec3<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec4<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}



 template <typename T, precision P> inline
                    T & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec1.inl", 72, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec1.inl", 79, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec1<T, P> & tvec1<T, P>::operator=(tvec1<T, P> const & v)
  {
   this->x = v.x;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator=(tvec1<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec1<T, P> & tvec1<T, P>::operator++()
 {
  ++this->x;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> & tvec1<T, P>::operator--()
 {
  --this->x;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> tvec1<T, P>::operator++(int)
 {
  tvec1<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> tvec1<T, P>::operator--(int)
 {
  tvec1<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= U(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec1<T, P> operator+(tvec1<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator-(tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   -v.x);
 }



 template <typename T, precision P> inline
                    tvec1<T, P> operator+(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x + scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator+(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar + v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x + v2.x);
 }


 template <typename T, precision P> inline
                    tvec1<T, P> operator-(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x - scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator-(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar - v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator-(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x - v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator*(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x * scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator*(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar * v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x * v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator/(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x / scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator/(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar / v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x / v2.x);
 }



 template <typename T, precision P> inline
                    tvec1<T, P> operator%(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x % scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator%(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar % v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x % v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator&(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x & scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator&(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar & v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x & v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator|(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x | scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator|(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar | v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x | v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator^(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x ^ scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator^(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar ^ v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x ^ v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator<<(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x << scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator<<(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar << v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x << v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator>>(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x >> scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator>>(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar >> v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x >> v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator~(tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   ~v.x);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return (v1.x == v2.x);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return (v1.x != v2.x);
 }

 template <precision P> inline
                    tvec1<bool, P> operator&&(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2)
 {
  return tvec1<bool, P>(v1.x && v2.x);
 }

 template <precision P> inline
                    tvec1<bool, P> operator||(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2)
 {
  return tvec1<bool, P>(v1.x || v2.x);
 }
}
# 301 "/usr/local/include/glm/detail/type_vec1.hpp" 2 3
# 13 "/usr/local/include/glm/detail/func_exponential.hpp" 2 3






namespace glm
{
# 32 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent);
# 42 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> exp(vecType<T, P> const & v);
# 54 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> log(vecType<T, P> const & v);
# 64 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> exp2(vecType<T, P> const & v);
# 75 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> log2(vecType<T, P> const & v);
# 87 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sqrt(vecType<T, P> const & v);
# 97 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> inversesqrt(vecType<T, P> const & v);


}


# 1 "/usr/local/include/glm/detail/func_exponential.inl" 1 3



# 1 "/usr/local/include/glm/detail/func_vector_relational.hpp" 1 3
# 21 "/usr/local/include/glm/detail/func_vector_relational.hpp" 3
namespace glm
{
# 32 "/usr/local/include/glm/detail/func_vector_relational.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <precision P, template <typename, precision> class vecType>
               bool any(vecType<bool, P> const & v);







 template <precision P, template <typename, precision> class vecType>
               bool all(vecType<bool, P> const & v);
# 105 "/usr/local/include/glm/detail/func_vector_relational.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<bool, P> not_(vecType<bool, P> const & v);


}


# 1 "/usr/local/include/glm/detail/func_vector_relational.inl" 1 3





namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 11, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];

  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 23, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 34, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 45, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 56, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 67, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType> inline
                    bool any(vecType<bool, P> const & v)
 {
  bool Result = false;
  for(length_t i = 0; i < v.length(); ++i)
   Result = Result || v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType> inline
                    bool all(vecType<bool, P> const & v)
 {
  bool Result = true;
  for(length_t i = 0; i < v.length(); ++i)
   Result = Result && v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> not_(vecType<bool, P> const & v)
 {
  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < v.length(); ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 111 "/usr/local/include/glm/detail/func_vector_relational.hpp" 2 3
# 4 "/usr/local/include/glm/detail/func_exponential.inl" 2 3

# 1 "/usr/local/include/glm/detail/_vectorize.hpp" 1 3
# 11 "/usr/local/include/glm/detail/_vectorize.hpp" 3
namespace glm{
namespace detail
{
 template <typename R, typename T, precision P, template <typename, precision> class vecType>
 struct functor1{};

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec1>
 { inline
                     static tvec1<R, P> call(R (*Func) (T x), tvec1<T, P> const & v)
  {
   return tvec1<R, P>(Func(v.x));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec2>
 { inline
                     static tvec2<R, P> call(R (*Func) (T x), tvec2<T, P> const & v)
  {
   return tvec2<R, P>(Func(v.x), Func(v.y));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec3>
 { inline
                     static tvec3<R, P> call(R (*Func) (T x), tvec3<T, P> const & v)
  {
   return tvec3<R, P>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec4>
 { inline
                     static tvec4<R, P> call(R (*Func) (T x), tvec4<T, P> const & v)
  {
   return tvec4<R, P>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct functor2{};

 template <typename T, precision P>
 struct functor2<T, P, tvec1>
 { inline
                     static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, tvec1<T, P> const & b)
  {
   return tvec1<T, P>(Func(a.x, b.x));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec2>
 { inline
                     static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, tvec2<T, P> const & b)
  {
   return tvec2<T, P>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec3>
 { inline
                     static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, tvec3<T, P> const & b)
  {
   return tvec3<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct functor2_vec_sca{};

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec1>
 { inline
                     static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, T b)
  {
   return tvec1<T, P>(Func(a.x, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec2>
 { inline
                     static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, T b)
  {
   return tvec2<T, P>(Func(a.x, b), Func(a.y, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec3>
 { inline
                     static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, T b)
  {
   return tvec3<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, T b)
  {
   return tvec4<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };
}
}
# 5 "/usr/local/include/glm/detail/func_exponential.inl" 2 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 8 "/usr/local/include/glm/detail/func_exponential.inl" 2 3


namespace glm{
namespace detail
{



  template <typename genType>
  genType log2(genType Value)
  {
   return std::log(Value) * static_cast<genType>(1.4426950408889634073599246810019);
  }


 template <typename T, precision P, template <class, precision> class vecType, bool isFloat, bool Aligned>
 struct compute_log2
 { inline
                     static vecType<T, P> call(vecType<T, P> const & vec)
  {
   return detail::functor1<T, T, P, vecType>::call(log2, vec);
  }
 };

 template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_sqrt
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(std::sqrt, x);
  }
 };

 template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_inversesqrt
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template <template <class, precision> class vecType, bool Aligned>
 struct compute_inversesqrt<vecType, float, lowp, Aligned>
 { inline
                     static vecType<float, lowp> call(vecType<float, lowp> const & x)
  {
   vecType<float, lowp> tmp(x);
   vecType<float, lowp> xhalf(tmp * 0.5f);
   vecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));
   vecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));
   vecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent)
 {
  return detail::functor2<T, P, vecType>::call(pow, base, exponent);
 }


 using std::exp;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> exp(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(exp, x);
 }


 using std::log;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> log(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(log, x);
 }


 template <typename genType> inline
                    genType exp2(genType x)
 {
                                                                                                        ;

  return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> exp2(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(exp2, x);
 }


 template <typename genType> inline
                    genType log2(genType x)
 {
  return log2(tvec1<genType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> log2(vecType<T, P> const & x)
 {
  return detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
 }


 using std::sqrt;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sqrt(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::compute_sqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> inversesqrt(vecType<T, P> const & x)
 {
                                                                                                         ;
  return detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
 }
}
# 103 "/usr/local/include/glm/detail/func_exponential.hpp" 2 3
# 4 "/usr/local/include/glm/detail/func_geometric.inl" 2 3

# 1 "/usr/local/include/glm/detail/func_common.hpp" 1 3
# 16 "/usr/local/include/glm/detail/func_common.hpp" 3
# 1 "/usr/local/include/glm/detail/_fixes.hpp" 1 3
# 16 "/usr/local/include/glm/detail/func_common.hpp" 2 3


namespace glm
{
# 29 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType abs(genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> abs(vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sign(vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> floor(vecType<T, P> const & x);
# 60 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> trunc(vecType<T, P> const & x);
# 73 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> round(vecType<T, P> const & x);
# 85 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> roundEven(vecType<T, P> const & x);
# 95 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> ceil(vecType<T, P> const & x);







 template <typename genType>
               genType fract(genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fract(vecType<T, P> const & x);
# 117 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType mod(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y);
# 135 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType modf(genType x, genType & i);







 template <typename genType>
               genType min(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> min(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> min(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename genType>
               genType max(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> max(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> max(vecType<T, P> const & x, vecType<T, P> const & y);
# 175 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType clamp(genType x, genType minVal, genType maxVal);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal);
# 226 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a);

 template <typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a);

 template <typename genTypeT, typename genTypeU>
               genTypeT mix(genTypeT x, genTypeT y, genTypeU a);





 template <typename genType>
               genType step(genType edge, genType x);





 template <template <typename, precision> class vecType, typename T, precision P>
               vecType<T, P> step(T edge, vecType<T, P> const & x);





 template <template <typename, precision> class vecType, typename T, precision P>
               vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x);
# 270 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType smoothstep(genType edge0, genType edge1, genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x);
# 291 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isnan(vecType<T, P> const & x);
# 304 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isinf(vecType<T, P> const & x);







               int floatBitsToInt(float const & v);







 template <template <typename, precision> class vecType, precision P>
               vecType<int, P> floatBitsToInt(vecType<float, P> const & v);







               uint floatBitsToUint(float const & v);







 template <template <typename, precision> class vecType, precision P>
               vecType<uint, P> floatBitsToUint(vecType<float, P> const & v);
# 349 "/usr/local/include/glm/detail/func_common.hpp" 3
               float intBitsToFloat(int const & v);
# 359 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <template <typename, precision> class vecType, precision P>
               vecType<float, P> intBitsToFloat(vecType<int, P> const & v);
# 370 "/usr/local/include/glm/detail/func_common.hpp" 3
               float uintBitsToFloat(uint const & v);
# 380 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <template <typename, precision> class vecType, precision P>
               vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v);







 template <typename genType>
               genType fma(genType const & a, genType const & b, genType const & c);
# 406 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType, typename genIType>
               genType frexp(genType const & x, genIType & exp);
# 420 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType, typename genIType>
               genType ldexp(genType const & x, genIType const & exp);


}


# 1 "/usr/local/include/glm/detail/func_common.inl" 1 3
# 11 "/usr/local/include/glm/detail/func_common.inl" 3
namespace glm
{

 template <typename genType> inline
                    genType min(genType x, genType y)
 {
                                                                                                                                                                                          ;
  return x < y ? x : y;
 }


 template <typename genType> inline
                    genType max(genType x, genType y)
 {
                                                                                                                                                                                          ;

  return x > y ? x : y;
 }


 template <> inline
                    int32 abs(int32 x)
 {
  int32 const y = x >> 31;
  return (x ^ y) - y;
 }





  template <typename genType> inline
                     genType round(genType x)
  {
                                                                                                          ;

   return x < static_cast<genType>(0) ? static_cast<genType>(int(x - static_cast<genType>(0.5))) : static_cast<genType>(int(x + static_cast<genType>(0.5)));
  }






  template <typename genType> inline
                     genType trunc(genType x)
  {
                                                                                                          ;

   return x < static_cast<genType>(0) ? -std::floor(-x) : std::floor(x);
  }


}

namespace glm{
namespace detail
{
 template <typename genFIType, bool >
 struct compute_abs
 {};

 template <typename genFIType>
 struct compute_abs<genFIType, true>
 { inline
                     static genFIType call(genFIType x)
  {


                                                                           ;

   return x >= genFIType(0) ? x : -x;

  }
 };
# 98 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename genFIType>
 struct compute_abs<genFIType, false>
 { inline
                     static genFIType call(genFIType x)
  {


                                                                           ;
   return x;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_abs_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(abs, x);
  }
 };

 template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
  {
                                                                                                                                                     ;

   return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_vector<T, bool, P, vecType, Aligned>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<bool, P> const & a)
  {
   vecType<T, P> Result(uninitialize);
   for(length_t i = 0; i < x.length(); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_scalar
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, U const & a)
  {
                                                                                                                                                     ;

   return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_scalar<T, bool, P, vecType, Aligned>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, bool const & a)
  {
   return a ? y : x;
  }
 };

 template <typename T, typename U>
 struct compute_mix
 { inline
                     static T call(T const & x, T const & y, U const & a)
  {
                                                                                                                                                     ;

   return static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));
  }
 };

 template <typename T>
 struct compute_mix<T, bool>
 { inline
                     static T call(T const & x, T const & y, bool const & a)
  {
   return a ? y : x;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool isFloat, bool Aligned>
 struct compute_sign
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return vecType<T, P>(glm::lessThan(vecType<T, P>(0), x)) - vecType<T, P>(glm::lessThan(x, vecType<T, P>(0)));
  }
 };
# 205 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_floor
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(std::floor, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_ceil
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(std::ceil, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_fract
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return x - floor(x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_trunc
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(trunc, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_round
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(round, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mod
 { inline
                     static vecType<T, P> call(vecType<T, P> const & a, vecType<T, P> const & b)
  {
                                                                                                                                                     ;
   return a - b * floor(a / b);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_min_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y)
  {
   return detail::functor2<T, P, vecType>::call(min, x, y);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_max_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y)
  {
   return detail::functor2<T, P, vecType>::call(max, x, y);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_clamp_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
  {
   return min(max(x, minVal), maxVal);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_step_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & edge, vecType<T, P> const & x)
  {
   return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, edge));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_smoothstep_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
  {
                                                                                                                               ;
   vecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
   return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
  }
 };
}

 template <typename genFIType> inline
                    genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> abs(vecType<T, P> const & x)
 {
  return detail::compute_abs_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }



 template <typename genFIType> inline
                    genFIType sign(genFIType x)
 {


                                      ;

  return detail::compute_sign<genFIType, defaultp, tvec1, std::numeric_limits<genFIType>::is_iec559, highp>::call(tvec1<genFIType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sign(vecType<T, P> const & x)
 {


                                      ;

  return detail::compute_sign<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
 }


 using ::std::floor;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> floor(vecType<T, P> const & x)
 {
                                                                                                    ;
  return detail::compute_floor<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> trunc(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::compute_trunc<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> round(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::compute_round<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }
# 377 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename genType> inline
                    genType roundEven(genType x)
 {
                                                                                                             ;

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> roundEven(vecType<T, P> const & x)
 {
                                                                                                       ;
  return detail::functor1<T, T, P, vecType>::call(roundEven, x);
 }


 using ::std::ceil;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> ceil(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::compute_ceil<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType fract(genType x)
 {
  return fract(tvec1<genType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fract(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::compute_fract<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType mod(genType x, genType y)
 {





   return mod(tvec1<genType, defaultp>(x), y).x;

 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mod(vecType<T, P> const & x, T y)
 {
  return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(y));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, y);
 }


 template <typename genType> inline
                    genType modf(genType x, genType & i)
 {
                                                                                                        ;
  return std::modf(x, &i);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> modf(tvec1<T, P> const & x, tvec1<T, P> & i)
 {
  return tvec1<T, P>(
   modf(x.x, i.x));
 }

 template <typename T, precision P> inline
                    tvec2<T, P> modf(tvec2<T, P> const & x, tvec2<T, P> & i)
 {
  return tvec2<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> modf(tvec3<T, P> const & x, tvec3<T, P> & i)
 {
  return tvec3<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> modf(tvec4<T, P> const & x, tvec4<T, P> & i)
 {
  return tvec4<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 514 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> min(vecType<T, P> const & a, T b)
 {
                                                                                                                                                    ;
  return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> min(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
 }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> max(vecType<T, P> const & a, T b)
 {
                                                                                                                                                    ;
  return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> max(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
 }


 template <typename genType> inline
                    genType clamp(genType x, genType minVal, genType maxVal)
 {
                                                                                                                                                                                            ;
  return min(max(x, minVal), maxVal);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal)
 {
                                                                                                                                                                                ;
  return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(minVal), vecType<T, P>(maxVal));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
 {
                                                                                                                                                                                ;
  return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, minVal, maxVal);
 }

 template <typename genTypeT, typename genTypeU> inline
                    genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template <typename T, typename U, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a)
 {
  return detail::compute_mix_scalar<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
 }

 template <typename T, typename U, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
 {
  return detail::compute_mix_vector<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
 }


 template <typename genType> inline
                    genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), glm::lessThan(x, edge));
 }

 template <template <typename, precision> class vecType, typename T, precision P> inline
                    vecType<T, P> step(T edge, vecType<T, P> const & x)
 {
  return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge), x);
 }

 template <template <typename, precision> class vecType, typename T, precision P> inline
                    vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x)
 {
  return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge, x);
 }


 template <typename genType> inline
                    genType smoothstep(genType edge0, genType edge1, genType x)
 {
                                                                                                                                          ;

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x)
 {
  return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge0), vecType<T, P>(edge1), x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
 {
  return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge0, edge1, x);
 }




  template <typename genType> inline
                     bool isnan(genType x)
  {
                                                                                                          ;
# 645 "/usr/local/include/glm/detail/func_common.inl" 3
    return std::isnan(x);

  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isnan(vecType<T, P> const & x)
 {
                                                                                                   ;

  return detail::functor1<bool, T, P, vecType>::call(isnan, x);
 }




  template <typename genType> inline
                     bool isinf(genType x)
  {
                                                                                                          ;
# 678 "/usr/local/include/glm/detail/func_common.inl" 3
     return std::isinf(x);







 }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isinf(vecType<T, P> const & x)
 {
                                                                                                   ;

  return detail::functor1<bool, T, P, vecType>::call(isinf, x);
 } inline

                    int floatBitsToInt(float const & v)
 {
  return reinterpret_cast<int&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<int, P> floatBitsToInt(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));
 } inline

                    uint floatBitsToUint(float const & v)
 {
  return reinterpret_cast<uint&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<uint, P> floatBitsToUint(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));
 } inline

                    float intBitsToFloat(int const & v)
 {
  return reinterpret_cast<float&>(const_cast<int&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<float, P> intBitsToFloat(vecType<int, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));
 } inline

                    float uintBitsToFloat(uint const & v)
 {
  return reinterpret_cast<float&>(const_cast<uint&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));
 }

 template <typename genType> inline
                    genType fma(genType const & a, genType const & b, genType const & c)
 {
  return a * b + c;
 }

 template <typename genType> inline
                    genType frexp(genType x, int & exp)
 {
                                                                                                                                     ;

  return std::frexp(x, &exp);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> frexp(tvec1<T, P> const & x, tvec1<int, P> & exp)
 {
                                                                                                                               ;

  return tvec1<T, P>(std::frexp(x.x, &exp.x));
 }

 template <typename T, precision P> inline
                    tvec2<T, P> frexp(tvec2<T, P> const & x, tvec2<int, P> & exp)
 {
                                                                                                                               ;

  return tvec2<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> frexp(tvec3<T, P> const & x, tvec3<int, P> & exp)
 {
                                                                                                                               ;

  return tvec3<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> frexp(tvec4<T, P> const & x, tvec4<int, P> & exp)
 {
                                                                                                                               ;

  return tvec4<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z),
   frexp(x.w, exp.w));
 }

 template <typename genType> inline
                    genType ldexp(genType const & x, int const & exp)
 {
                                                                                                                                     ;

  return std::ldexp(x, exp);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> ldexp(tvec1<T, P> const & x, tvec1<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec1<T, P>(
   ldexp(x.x, exp.x));
 }

 template <typename T, precision P> inline
                    tvec2<T, P> ldexp(tvec2<T, P> const & x, tvec2<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec2<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> ldexp(tvec3<T, P> const & x, tvec3<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec3<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> ldexp(tvec4<T, P> const & x, tvec4<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec4<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z),
   ldexp(x.w, exp.w));
 }
}
# 426 "/usr/local/include/glm/detail/func_common.hpp" 2 3
# 5 "/usr/local/include/glm/detail/func_geometric.inl" 2 3





namespace glm{
namespace detail
{
 template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_length
 { inline
                     static T call(vecType<T, P> const & v)
  {
   return sqrt(dot(v, v));
  }
 };

 template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_distance
 { inline
                     static T call(vecType<T, P> const & p0, vecType<T, P> const & p1)
  {
   return length(p1 - p0);
  }
 };

 template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_dot{};

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec1, T, P, Aligned>
 { inline
                     static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)
  {
   return a.x * b.x;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec2, T, P, Aligned>
 { inline
                     static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)
  {
   tvec2<T, P> tmp(x * y);
   return tmp.x + tmp.y;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec3, T, P, Aligned>
 { inline
                     static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)
  {
   tvec3<T, P> tmp(x * y);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec4, T, P, Aligned>
 { inline
                     static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)
  {
   tvec4<T, P> tmp(x * y);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_cross
 { inline
                     static tvec3<T, P> call(tvec3<T, P> const & x, tvec3<T, P> const & y)
  {
                                                                                                     ;

   return tvec3<T, P>(
    x.y * y.z - y.y * x.z,
    x.z * y.x - y.z * x.x,
    x.x * y.y - y.x * x.y);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_normalize
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v)
  {
                                                                                                         ;

   return v * inversesqrt(dot(v, v));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_faceforward
 { inline
                     static vecType<T, P> call(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)
  {
                                                                                                         ;

   return dot(Nref, I) < static_cast<T>(0) ? N : -N;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_reflect
 { inline
                     static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N)
  {
   return I - N * dot(N, I) * static_cast<T>(2);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_refract
 { inline
                     static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
  {
   T const dotValue(dot(N, I));
   T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
   return (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));
  }
 };
}


 template <typename genType> inline
                    genType length(genType x)
 {
                                                                                                           ;

  return abs(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T length(vecType<T, P> const & v)
 {
                                                                                                     ;

  return detail::compute_length<vecType, T, P, detail::is_aligned<P>::value>::call(v);
 }


 template <typename genType> inline
                    genType distance(genType const & p0, genType const & p1)
 {
                                                                                                             ;

  return length(p1 - p0);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)
 {
  return detail::compute_distance<vecType, T, P, detail::is_aligned<P>::value>::call(p0, p1);
 }


 template <typename T> inline
                    T dot(T x, T y)
 {
                                                                                                  ;
  return x * y;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T dot(vecType<T, P> const & x, vecType<T, P> const & y)
 {
                                                                                                  ;
  return detail::compute_dot<vecType, T, P, detail::is_aligned<P>::value>::call(x, y);
 }


 template <typename T, precision P> inline
                    tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)
 {
  return detail::compute_cross<T, P, detail::is_aligned<P>::value>::call(x, y);
 }


 template <typename genType> inline
                    genType normalize(genType const & x)
 {
                                                                                                              ;

  return x < genType(0) ? genType(-1) : genType(1);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> normalize(vecType<T, P> const & x)
 {
                                                                                                        ;

  return detail::compute_normalize<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType faceforward(genType const & N, genType const & I, genType const & Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> faceforward(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)
 {
  return detail::compute_faceforward<T, P, vecType, detail::is_aligned<P>::value>::call(N, I, Nref);
 }


 template <typename genType> inline
                    genType reflect(genType const & I, genType const & N)
 {
  return I - N * dot(N, I) * genType(2);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> reflect(vecType<T, P> const & I, vecType<T, P> const & N)
 {
  return detail::compute_reflect<T, P, vecType, detail::is_aligned<P>::value>::call(I, N);
 }


 template <typename genType> inline
                    genType refract(genType const & I, genType const & N, genType eta)
 {
                                                                                                            ;
  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
 {
                                                                                                      ;
  return detail::compute_refract<T, P, vecType, detail::is_aligned<P>::value>::call(I, N, eta);
 }
}
# 113 "/usr/local/include/glm/detail/func_geometric.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../geometric.hpp" 2 3
# 4 "/usr/local/include/glm/detail/func_matrix.inl" 2 3



namespace glm{
namespace detail
{
 template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_matrixCompMult
 { inline
                     static matType<T, P> call(matType<T, P> const& x, matType<T, P> const& y)
  {
   matType<T, P> result(uninitialize);
   for(length_t i = 0; i < result.length(); ++i)
    result[i] = x[i] * y[i];
   return result;
  }
 };

 template <template <class, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_transpose{};

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat2x2, T, P, Aligned>
 { inline
                     static tmat2x2<T, P> call(tmat2x2<T, P> const & m)
  {
   tmat2x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat2x3, T, P, Aligned>
 { inline
                     static tmat3x2<T, P> call(tmat2x3<T, P> const & m)
  {
   tmat3x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat2x4, T, P, Aligned>
 { inline
                     static tmat4x2<T, P> call(tmat2x4<T, P> const & m)
  {
   tmat4x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat3x2, T, P, Aligned>
 { inline
                     static tmat2x3<T, P> call(tmat3x2<T, P> const & m)
  {
   tmat2x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat3x3, T, P, Aligned>
 { inline
                     static tmat3x3<T, P> call(tmat3x3<T, P> const & m)
  {
   tmat3x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat3x4, T, P, Aligned>
 { inline
                     static tmat4x3<T, P> call(tmat3x4<T, P> const & m)
  {
   tmat4x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat4x2, T, P, Aligned>
 { inline
                     static tmat2x4<T, P> call(tmat4x2<T, P> const & m)
  {
   tmat2x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat4x3, T, P, Aligned>
 { inline
                     static tmat3x4<T, P> call(tmat4x3<T, P> const & m)
  {
   tmat3x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat4x4, T, P, Aligned>
 { inline
                     static tmat4x4<T, P> call(tmat4x4<T, P> const & m)
  {
   tmat4x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];

   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   result[3][3] = m[3][3];
   return result;
  }
 };

 template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_determinant{};

 template <typename T, precision P, bool Aligned>
 struct compute_determinant<tmat2x2, T, P, Aligned>
 { inline
                     static T call(tmat2x2<T, P> const & m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_determinant<tmat3x3, T, P, Aligned>
 { inline
                     static T call(tmat3x3<T, P> const & m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_determinant<tmat4x4, T, P, Aligned>
 { inline
                     static T call(tmat4x4<T, P> const & m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   tvec4<T, P> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };

 template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_inverse{};

 template <typename T, precision P, bool Aligned>
 struct compute_inverse<tmat2x2, T, P, Aligned>
 { inline
                     static tmat2x2<T, P> call(tmat2x2<T, P> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   tmat2x2<T, P> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_inverse<tmat3x3, T, P, Aligned>
 { inline
                     static tmat3x3<T, P> call(tmat3x3<T, P> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   tmat3x3<T, P> Inverse(uninitialize);
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_inverse<tmat4x4, T, P, Aligned>
 { inline
                     static tmat4x4<T, P> call(tmat4x4<T, P> const& m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   tvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);
   tvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);
   tvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);
   tvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);
   tvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);
   tvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);

   tvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   tvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   tvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   tvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   tvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   tvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   tvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   tvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   tvec4<T, P> SignA(+1, -1, +1, -1);
   tvec4<T, P> SignB(-1, +1, -1, +1);
   tmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   tvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   tvec4<T, P> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };
}

 template <typename T, precision P, template <typename, precision> class matType> inline
                    matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y)
 {
                                                                                                                                        ;
  return detail::compute_matrixCompMult<matType, T, P, detail::is_aligned<P>::value>::call(x, y);
 }

 template<typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB> inline
                    typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r)
 {
                                                                                                                                      ;

  typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type m(uninitialize);
  for(length_t i = 0; i < m.length(); ++i)
   m[i] = c * r[i];
  return m;
 }

 template <typename T, precision P, template <typename, precision> class matType> inline
                    typename matType<T, P>::transpose_type transpose(matType<T, P> const & m)
 {
                                                                                                                                   ;
  return detail::compute_transpose<matType, T, P, detail::is_aligned<P>::value>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType> inline
                    T determinant(matType<T, P> const & m)
 {
                                                                                                                                     ;
  return detail::compute_determinant<matType, T, P, detail::is_aligned<P>::value>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType> inline
                    matType<T, P> inverse(matType<T, P> const & m)
 {
                                                                                                                                 ;
  return detail::compute_inverse<matType, T, P, detail::is_aligned<P>::value>::call(m);
 }
}
# 149 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3
# 4 "/usr/local/include/glm/detail/type_mat2x2.inl" 2 3


namespace glm
{



  template <typename T, precision P> inline
                     tmat2x2<T, P>::tmat2x2()
  {

    this->value[0] = col_type(1, 0);
    this->value[1] = col_type(0, 1);

  }



  template <typename T, precision P> inline
                     tmat2x2<T, P>::tmat2x2(tmat2x2<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P> inline
                                       tmat2x2<T, P>::tmat2x2(ctor)
 {}

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(T scalar)
 {
  this->value[0] = col_type(scalar, 0);
  this->value[1] = col_type(0, scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <typename X1, typename Y1, typename X2, typename Y2> inline
                    tmat2x2<T, P>::tmat2x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2> inline
                    tmat2x2<T, P>::tmat2x2(tvec2<V1, P> const & v1, tvec2<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat3x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat4x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }



 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x2.inl", 160, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type const & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x2.inl", 167, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator+=(U scalar)
 {
  this->value[0] += scalar;
  this->value[1] += scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator+=(tmat2x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator-=(U scalar)
 {
  this->value[0] -= scalar;
  this->value[1] -= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator-=(tmat2x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator*=(U scalar)
 {
  this->value[0] *= scalar;
  this->value[1] *= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator*=(tmat2x2<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator/=(U scalar)
 {
  this->value[0] /= scalar;
  this->value[1] /= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator/=(tmat2x2<U, P> const & m)
 {
  return *this *= inverse(m);
 }



 template <typename T, precision P> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> tmat2x2<T, P>::operator++(int)
 {
  tmat2x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> tmat2x2<T, P>::operator--(int)
 {
  tmat2x2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(tmat2x2<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   -m[0],
   -m[1]);
 }



 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   scalar - m[0],
   scalar - m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type operator*
 (
  tmat2x2<T, P> const & m,
  typename tmat2x2<T, P>::row_type const & v
 )
 {
  return tvec2<T, P>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::row_type operator*
 (
  typename tmat2x2<T, P>::col_type const & v,
  tmat2x2<T, P> const & m
 )
 {
  return tvec2<T, P>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   scalar / m[0],
   scalar / m[1]);
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v)
 {
  return inverse(m) * v;
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m)
 {
  return v * inverse(m);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  tmat2x2<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }



 template <typename T, precision P> inline
                    bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 182 "/usr/local/include/glm/detail/type_mat2x2.hpp" 2 3
# 6 "/usr/local/include/glm/mat2x2.hpp" 2 3


namespace glm
{





 typedef tmat2x2<float, lowp> lowp_mat2;






 typedef tmat2x2<float, mediump> mediump_mat2;






 typedef tmat2x2<float, highp> highp_mat2;






 typedef tmat2x2<float, lowp> lowp_mat2x2;






 typedef tmat2x2<float, mediump> mediump_mat2x2;






 typedef tmat2x2<float, highp> highp_mat2x2;

}
# 71 "/usr/local/include/glm/glm.hpp" 2 3
# 81 "/usr/local/include/glm/glm.hpp" 3
# 1 "/usr/local/include/glm/trigonometric.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_trigonometric.hpp" 1 3
# 20 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
namespace glm
{
# 31 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
                             vecType<T, P> radians(vecType<T, P> const & degrees);







 template <typename T, precision P, template <typename, precision> class vecType>
                             vecType<T, P> degrees(vecType<T, P> const & radians);
# 50 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sin(vecType<T, P> const & angle);
# 60 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> cos(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> tan(vecType<T, P> const & angle);
# 80 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> asin(vecType<T, P> const & x);
# 91 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> acos(vecType<T, P> const & x);
# 104 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> atan(vecType<T, P> const & y, vecType<T, P> const & x);
# 114 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> atan(vecType<T, P> const & y_over_x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sinh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> cosh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> tanh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> asinh(vecType<T, P> const & x);
# 160 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> acosh(vecType<T, P> const & x);
# 170 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> atanh(vecType<T, P> const & x);


}


# 1 "/usr/local/include/glm/detail/func_trigonometric.inl" 1 3







namespace glm
{

 template <typename genType> inline
                                  genType radians(genType degrees)
 {
                                                                                                          ;

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                                  vecType<T, P> radians(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(radians, v);
 }


 template <typename genType> inline
                                  genType degrees(genType radians)
 {
                                                                                                          ;

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                                  vecType<T, P> degrees(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(degrees, v);
 }


 using ::std::sin;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sin(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(sin, v);
 }


 using std::cos;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cos(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(cos, v);
 }


 using std::tan;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> tan(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(tan, v);
 }


 using std::asin;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asin(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(asin, v);
 }


 using std::acos;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acos(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(acos, v);
 }


 template <typename genType> inline
                    genType atan(genType y, genType x)
 {
                                                                                                       ;

  return ::std::atan2(y, x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> atan(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::functor2<T, P, vecType>::call(::std::atan2, a, b);
 }

 using std::atan;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> atan(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(atan, v);
 }


 using std::sinh;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sinh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(sinh, v);
 }


 using std::cosh;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cosh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(cosh, v);
 }


 using std::tanh;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> tanh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(tanh, v);
 }





  template <typename genType> inline
                     genType asinh(genType x)
  {
                                                                                                         ;

   return (x < static_cast<genType>(0) ? static_cast<genType>(-1) : (x > static_cast<genType>(0) ? static_cast<genType>(1) : static_cast<genType>(0))) * log(std::abs(x) + sqrt(static_cast<genType>(1) + x * x));
  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asinh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(asinh, v);
 }





  template <typename genType> inline
                     genType acosh(genType x)
  {
                                                                                                         ;

   if(x < static_cast<genType>(1))
    return static_cast<genType>(0);
   return log(x + sqrt(x * x - static_cast<genType>(1)));
  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acosh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(acosh, v);
 }





  template <typename genType> inline
                     genType atanh(genType x)
  {
                                                                                                         ;

   if(std::abs(x) >= static_cast<genType>(1))
    return 0;
   return static_cast<genType>(0.5) * log((static_cast<genType>(1) + x) / (static_cast<genType>(1) - x));
  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> atanh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(atanh, v);
 }
}
# 176 "/usr/local/include/glm/detail/func_trigonometric.hpp" 2 3
# 6 "/usr/local/include/glm/trigonometric.hpp" 2 3
# 81 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/exponential.hpp" 1 3
# 82 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/common.hpp" 1 3
# 83 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/packing.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_packing.hpp" 1 3
# 17 "/usr/local/include/glm/detail/func_packing.hpp" 3
namespace glm
{
# 33 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packUnorm2x16(vec2 const & v);
# 46 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packSnorm2x16(vec2 const & v);
# 59 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packUnorm4x8(vec4 const & v);
# 72 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packSnorm4x8(vec4 const & v);
# 85 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec2 unpackUnorm2x16(uint p);
# 98 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec2 unpackSnorm2x16(uint p);
# 111 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec4 unpackUnorm4x8(uint p);
# 124 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec4 unpackSnorm4x8(uint p);
# 134 "/usr/local/include/glm/detail/func_packing.hpp" 3
               double packDouble2x32(uvec2 const & v);
# 143 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uvec2 unpackDouble2x32(double v);
# 153 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packHalf2x16(vec2 const & v);
# 163 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec2 unpackHalf2x16(uint v);


}


# 1 "/usr/local/include/glm/detail/func_packing.inl" 1 3




# 1 "/usr/local/include/glm/detail/type_half.hpp" 1 3







namespace glm{
namespace detail
{
 typedef short hdata;

               float toFloat32(hdata value);
               hdata toFloat16(float const & value);

}
}


# 1 "/usr/local/include/glm/detail/type_half.inl" 1 3



namespace glm{
namespace detail
{ inline
                    float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f *= f;
  return f;
 }

 union uif32
 { inline
                     uif32() :
   i(0)
  {} inline

                     uif32(float f_) :
   f(f_)
  {} inline

                     uif32(uint32 i_) :
   i(i_)
  {}

  float f;
  uint32 i;
 }; inline

                    float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = (unsigned int)(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = (unsigned int)((s << 31) | (e << 23) | m);
  return Result.f;
 } inline

                    hdata toFloat16(float const & f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = (int)Entry.i;
# 124 "/usr/local/include/glm/detail/type_half.inl" 3
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 144 "/usr/local/include/glm/detail/type_half.inl" 3
    return hdata(s);
   }
# 154 "/usr/local/include/glm/detail/type_half.inl" 3
   m = (m | 0x00800000) >> (1 - e);
# 165 "/usr/local/include/glm/detail/type_half.inl" 3
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 196 "/usr/local/include/glm/detail/type_half.inl" 3
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 212 "/usr/local/include/glm/detail/type_half.inl" 3
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 19 "/usr/local/include/glm/detail/type_half.hpp" 2 3
# 5 "/usr/local/include/glm/detail/func_packing.inl" 2 3



namespace glm
{ inline
                    uint packUnorm2x16(vec2 const & v)
 {
  union
  {
   u16 in[2];
   uint out;
  } u;

  u16vec2 result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 } inline

                    vec2 unpackUnorm2x16(uint p)
 {
  union
  {
   uint in;
   u16 out[2];
  } u;

  u.in = p;

  return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
 } inline

                    uint packSnorm2x16(vec2 const & v)
 {
  union
  {
   i16 in[2];
   uint out;
  } u;

  i16vec2 result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 } inline

                    vec2 unpackSnorm2x16(uint p)
 {
  union
  {
   uint in;
   i16 out[2];
  } u;

  u.in = p;

  return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
 } inline

                    uint packUnorm4x8(vec4 const & v)
 {
  union
  {
   u8 in[4];
   uint out;
  } u;

  u8vec4 result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 } inline

                    vec4 unpackUnorm4x8(uint p)
 {
  union
  {
   uint in;
   u8 out[4];
  } u;

  u.in = p;

  return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
 } inline

                    uint packSnorm4x8(vec4 const & v)
 {
  union
  {
   i8 in[4];
   uint out;
  } u;

  i8vec4 result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 } inline

                    glm::vec4 unpackSnorm4x8(uint p)
 {
  union
  {
   uint in;
   i8 out[4];
  } u;

  u.in = p;

  return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
 } inline

                    double packDouble2x32(uvec2 const & v)
 {
  union
  {
   uint in[2];
   double out;
  } u;

  u.in[0] = v[0];
  u.in[1] = v[1];

  return u.out;
 } inline

                    uvec2 unpackDouble2x32(double v)
 {
  union
  {
   double in;
   uint out[2];
  } u;

  u.in = v;

  return uvec2(u.out[0], u.out[1]);
 } inline

                    uint packHalf2x16(vec2 const & v)
 {
  union
  {
   i16 in[2];
   uint out;
  } u;

  u.in[0] = detail::toFloat16(v.x);
  u.in[1] = detail::toFloat16(v.y);

  return u.out;
 } inline

                    vec2 unpackHalf2x16(uint v)
 {
  union
  {
   uint in;
   i16 out[2];
  } u;

  u.in = v;

  return vec2(
   detail::toFloat32(u.out[0]),
   detail::toFloat32(u.out[1]));
 }
}
# 168 "/usr/local/include/glm/detail/func_packing.hpp" 2 3
# 6 "/usr/local/include/glm/packing.hpp" 2 3
# 84 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/matrix.hpp" 1 3
# 86 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/vector_relational.hpp" 1 3
# 87 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/integer.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_integer.hpp" 1 3
# 20 "/usr/local/include/glm/detail/func_integer.hpp" 3
namespace glm
{
# 33 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<uint, P> uaddCarry(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & carry);
# 47 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<uint, P> usubBorrow(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & borrow);
# 61 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               void umulExtended(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & msb,
  vecType<uint, P> & lsb);
# 76 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               void imulExtended(
  vecType<int, P> const & x,
  vecType<int, P> const & y,
  vecType<int, P> & msb,
  vecType<int, P> & lsb);
# 98 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldExtract(
  vecType<T, P> const & Value,
  int Offset,
  int Bits);
# 118 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldInsert(
  vecType<T, P> const & Base,
  vecType<T, P> const & Insert,
  int Offset,
  int Bits);
# 133 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldReverse(vecType<T, P> const & v);







 template <typename genType>
               int bitCount(genType v);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> bitCount(vecType<T, P> const & v);
# 162 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename genIUType>
               int findLSB(genIUType x);
# 173 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> findLSB(vecType<T, P> const & v);
# 185 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename genIUType>
               int findMSB(genIUType x);
# 197 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> findMSB(vecType<T, P> const & v);


}


# 1 "/usr/local/include/glm/detail/func_integer.inl" 1 3
# 20 "/usr/local/include/glm/detail/func_integer.inl" 3
#pragma clang diagnostic ignored "-Wc++11-long-long"



namespace glm{
namespace detail
{
 template <typename T> inline
                    T mask(T Bits)
 {
  return Bits >= sizeof(T) * 8 ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
 struct compute_bitfieldReverseStep
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T, T)
  {
   return v;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
 struct compute_bitfieldReverseStep<T, P, vecType, Aligned, true>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
 struct compute_bitfieldBitCountStep
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T, T)
  {
   return v;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
 struct compute_bitfieldBitCountStep<T, P, vecType, Aligned, true>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template <typename genIUType, size_t Bits>
 struct compute_findLSB
 { inline
                     static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 107 "/usr/local/include/glm/detail/func_integer.inl" 3
 template <typename T, glm::precision P, template <class, glm::precision> class vecType, bool EXEC = true>
 struct compute_findMSB_step_vec
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
 struct compute_findMSB_step_vec<T, P, vecType, false>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, T)
  {
   return x;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, int>
 struct compute_findMSB_vec
 { inline
                     static vecType<int, P> call(vecType<T, P> const & vec)
  {
   vecType<T, P> x(vec);
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vecType<int, P>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 178 "/usr/local/include/glm/detail/func_integer.inl" 3
} inline


                    uint uaddCarry(uint const & x, uint const & y, uint & Carry)
 {
  uint64 const Value64(static_cast<uint64>(x) + static_cast<uint64>(y));
  uint64 const Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
  Carry = Value64 > Max32 ? 1u : 0u;
  return static_cast<uint32>(Value64 % (Max32 + static_cast<uint64>(1)));
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<uint, P> uaddCarry(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Carry)
 {
  vecType<uint64, P> Value64(vecType<uint64, P>(x) + vecType<uint64, P>(y));
  vecType<uint64, P> Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
  Carry = mix(vecType<uint32, P>(0), vecType<uint32, P>(1), greaterThan(Value64, Max32));
  return vecType<uint32,P>(Value64 % (Max32 + static_cast<uint64>(1)));
 } inline


                    uint usubBorrow(uint const & x, uint const & y, uint & Borrow)
 {
                                                                                    ;

  Borrow = x >= y ? static_cast<uint32>(0) : static_cast<uint32>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint32>((static_cast<int64>(1) << static_cast<int64>(32)) + (static_cast<int64>(y) - static_cast<int64>(x)));
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<uint, P> usubBorrow(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Borrow)
 {
  Borrow = mix(vecType<uint, P>(1), vecType<uint, P>(0), greaterThanEqual(x, y));
  vecType<uint, P> const YgeX(y - x);
  vecType<uint, P> const XgeY(vecType<uint32, P>((static_cast<int64>(1) << static_cast<int64>(32)) + (vecType<int64, P>(y) - vecType<int64, P>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 } inline


                    void umulExtended(uint const & x, uint const & y, uint & msb, uint & lsb)
 {
                                                                                    ;

  uint64 Value64 = static_cast<uint64>(x) * static_cast<uint64>(y);
  msb = static_cast<uint>(Value64 >> static_cast<uint64>(32));
  lsb = static_cast<uint>(Value64);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    void umulExtended(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & msb, vecType<uint, P> & lsb)
 {
                                                                                    ;

  vecType<uint64, P> Value64(vecType<uint64, P>(x) * vecType<uint64, P>(y));
  msb = vecType<uint32, P>(Value64 >> static_cast<uint64>(32));
  lsb = vecType<uint32, P>(Value64);
 } inline


                    void imulExtended(int x, int y, int & msb, int & lsb)
 {
                                                                                ;

  int64 Value64 = static_cast<int64>(x) * static_cast<int64>(y);
  msb = static_cast<int>(Value64 >> static_cast<int64>(32));
  lsb = static_cast<int>(Value64);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    void imulExtended(vecType<int, P> const & x, vecType<int, P> const & y, vecType<int, P> & msb, vecType<int, P> & lsb)
 {
                                                                                ;

  vecType<int64, P> Value64(vecType<int64, P>(x) * vecType<int64, P>(y));
  lsb = vecType<int32, P>(Value64 & static_cast<int64>(0xFFFFFFFF));
  msb = vecType<int32, P>((Value64 >> static_cast<int64>(32)) & static_cast<int64>(0xFFFFFFFF));
 }


 template <typename genIUType> inline
                    genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(tvec1<genIUType>(Value), Offset, Bits).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldExtract(vecType<T, P> const & Value, int Offset, int Bits)
 {
                                                                                                       ;

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template <typename genIUType> inline
                    genIUType bitfieldInsert(genIUType const & Base, genIUType const & Insert, int Offset, int Bits)
 {
  return bitfieldInsert(tvec1<genIUType>(Base), tvec1<genIUType>(Insert), Offset, Bits).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldInsert(vecType<T, P> const & Base, vecType<T, P> const & Insert, int Offset, int Bits)
 {
                                                                                                      ;

  T const Mask = static_cast<T>(detail::mask(Bits) << Offset);
  return (Base & ~Mask) | (Insert & Mask);
 }


 template <typename genType> inline
                    genType bitfieldReverse(genType x)
 {
  return bitfieldReverse(glm::tvec1<genType, glm::defaultp>(x)).x;
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType> inline
                    vecType<T, P> bitfieldReverse(vecType<T, P> const & v)
 {
  vecType<T, P> x(v);
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 2>::call(x, T(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 4>::call(x, T(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 8>::call(x, T(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, T(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, T(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, T(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }


 template <typename genType> inline
                    int bitCount(genType x)
 {
  return bitCount(glm::tvec1<genType, glm::defaultp>(x)).x;
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType> inline
                    vecType<int, P> bitCount(vecType<T, P> const & v)
 {
  vecType<typename detail::make_unsigned<T>::type, P> x(*reinterpret_cast<vecType<typename detail::make_unsigned<T>::type, P> const *>(&v));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vecType<int, P>(x);
 }


 template <typename genIUType> inline
                    int findLSB(genIUType Value)
 {
                                                                                                       ;

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<int, P> findLSB(vecType<T, P> const & x)
 {
                                                                                               ;

  return detail::functor1<int, T, P, vecType>::call(findLSB, x);
 }


 template <typename genIUType> inline
                    int findMSB(genIUType x)
 {
                                                                                                       ;

  return findMSB(tvec1<genIUType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<int, P> findMSB(vecType<T, P> const & x)
 {
                                                                                               ;

  return detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(x);
 }
}
# 203 "/usr/local/include/glm/detail/func_integer.hpp" 2 3
# 6 "/usr/local/include/glm/integer.hpp" 2 3
# 88 "/usr/local/include/glm/glm.hpp" 2 3
# 8 "./types.h" 2

using glm::vec2;
using glm::vec3;
using glm::vec4;
using glm::mat3;
using glm::mat4;
# 34 "./types.h"
enum struct PROPERTY_TYPE {

    PROP_i64 , PROP_u64 , PROP_usize , PROP_f64 , PROP_i32 , PROP_u32 , PROP_f32 , PROP_i16 , PROP_u16 , PROP_i8 , PROP_u8 , PROP_bool , PROP_char , PROP_byteptr , PROP_vec2 , PROP_vec3 , PROP_vec4 ,
    COUNT_PROPERTY_TYPE

};
# 16 "run.cpp" 2
# 1 "./config/config_state.cpp" 1
# 16 "./config/config_state.cpp"
    struct ConfigVar {
        PROPERTY_TYPE type;
        const char* name;
        const char* name_space;
        union {

            i64 f_i64 ; u64 f_u64 ; usize f_usize ; f64 f_f64 ; i32 f_i32 ; i32 f_u32 ; i32 f_f32 ; i16 f_i16 ; u16 f_u16 ; i8 f_i8 ; u8 f_u8 ; bool f_bool ; char f_char ; char* f_byteptr ; vec2 f_vec2 ; vec3 f_vec3 ; vec4 f_vec4 ;

        };
        void* ptr;
    };

    void ConfigState_load_runtime(void);
# 45 "./config/config_state.cpp"
# 1 "./config/./config_movement.cpp" 1
# 11 "./config/./config_movement.cpp"
namespace wee { extern f64 WEEf64; }
namespace wee { extern i32 WEEi32; }
namespace ha { extern char HAchar; }


namespace physics { extern f64 GRAVITY_DEFAULT; }
namespace physics { extern f64 GRAVITY_TERRESTRIAL; }
namespace physics { extern f64 GRAVITY_OUTER_SPACE; }
namespace physics { extern f64 gravity; }
# 46 "./config/config_state.cpp" 2
# 17 "run.cpp" 2


# 1 "./file_io.hpp" 1



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 1 3
# 104 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
# 123 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
namespace std {inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;
using ::fclose;
using ::fflush;
using ::fopen;
using ::freopen;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::printf;
using ::scanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;

using ::vfprintf;
using ::vfscanf;
using ::vscanf;
using ::vsscanf;

using ::vprintf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::getchar;

using ::gets;

using ::putc;
using ::putchar;
using ::puts;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;

} }
# 5 "./file_io.hpp" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 1 3
# 93 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;
using ::getenv;
using ::system;
using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
# 159 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long abs( long __x) throw() {return labs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long abs(long long __x) throw() {return llabs(__x);}


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) ldiv_t div( long __x, long __y) throw() {return ldiv(__x, __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) lldiv_t div(long long __x, long long __y) throw() {return lldiv(__x, __y);}



} }
# 6 "./file_io.hpp" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 1 3
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;

using ::memchr;

using ::strchr;

using ::strcspn;

using ::strpbrk;

using ::strrchr;

using ::strspn;

using ::strstr;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strchr( char* __s, int __c) {return ::strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strpbrk( char* __s1, const char* __s2) {return ::strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strrchr( char* __s, int __c) {return ::strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* memchr( void* __s, int __c, size_t __n) {return ::memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strstr( char* __s1, const char* __s2) {return ::strstr(__s1, __s2);}


using ::strtok;
using ::memset;
using ::strerror;
using ::strlen;

} }
# 7 "./file_io.hpp" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 1 3
# 27 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 3
# 1 "/usr/include/errno.h" 1 3 4
# 23 "/usr/include/errno.h" 3 4
# 1 "/usr/include/sys/errno.h" 1 3 4
# 79 "/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}
# 24 "/usr/include/errno.h" 2 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 2 3
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 3
# 8 "./file_io.hpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 1 3
# 435 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 1 3
# 90 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 76 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_mbstate_t.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 77 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/usr/include/wchar.h" 2 3 4
# 89 "/usr/include/wchar.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 90 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/time.h" 1 3 4
# 69 "/usr/include/time.h" 3 4
# 1 "/usr/include/_structs.h" 1 3 4
# 24 "/usr/include/_structs.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 25 "/usr/include/_structs.h" 2 3 4
# 70 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/sys/_types/_clock_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 72 "/usr/include/time.h" 2 3 4



struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 98 "/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone") ;

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock") ;
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime") ;
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime") ;
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime") ;
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep") ;

}
# 92 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/_wctype.h" 1 3 4
# 47 "/usr/include/_wctype.h" 3 4
# 1 "/usr/include/_types/_wctype_t.h" 1 3 4
# 31 "/usr/include/_types/_wctype_t.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 48 "/usr/include/_wctype.h" 2 3 4
# 65 "/usr/include/_wctype.h" 3 4
inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 170 "/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 93 "/usr/include/wchar.h" 2 3 4



extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime") ;
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 169 "/usr/include/wchar.h" 3 4
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 194 "/usr/include/wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 91 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 2 3
# 94 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;


typedef long long streamoff;

template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

} }
# 436 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 1 3
# 107 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 1 3
# 54 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 1 3
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 3


namespace std {inline namespace __1 {






using ::isalnum;







using ::isalpha;







using ::isblank;







using ::iscntrl;







using ::isdigit;







using ::isgraph;







using ::islower;







using ::isprint;







using ::ispunct;







using ::isspace;







using ::isupper;







using ::isxdigit;







using ::tolower;







using ::toupper;


} }
# 55 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 2 3
# 1 "/usr/include/wctype.h" 1 3 4
# 36 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/_types/_wctrans_t.h" 1 3 4
# 31 "/usr/include/_types/_wctrans_t.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 37 "/usr/include/wctype.h" 2 3 4
# 49 "/usr/include/wctype.h" 3 4
inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 117 "/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 56 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 2 3
# 59 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 3


namespace std {inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;






using ::iswalnum;







using ::iswalpha;







using ::iswblank;







using ::iswcntrl;







using ::iswdigit;







using ::iswgraph;







using ::iswlower;







using ::iswprint;







using ::iswpunct;







using ::iswspace;







using ::iswupper;







using ::iswxdigit;







using ::iswctype;







using ::wctype;







using ::towlower;







using ::towupper;







using ::towctrans;







using ::wctrans;


} }
# 108 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 2 3
# 115 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3


namespace std {inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::vwprintf;

using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::vwscanf;

using ::wprintf;
using ::wscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::getwchar;
using ::putwc;
using ::putwchar;
using ::ungetwc;
using ::wcstod;

using ::wcstof;
using ::wcstold;

using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
# 180 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}



using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;

} }
# 439 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 1 3
# 623 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 1 3
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 3


namespace std
{
# 116 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 3
}
# 624 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 1 3
# 157 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple_03" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple_03" 3


namespace std {inline namespace __1 {

template <class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_size;
template <size_t _Ip, class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_element;

} }
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 2 3
# 158 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3
# 162 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3


namespace std {inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}



template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
{
    std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
# 233 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
const _Tp&

move_if_noexcept(_Tp& __x) throw()
{
    return std::__1::move(__x);
}

struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { };

extern const piecewise_construct_t piecewise_construct;




template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;




    __attribute__ ((__visibility__("hidden"), __always_inline__)) pair() : first(), second() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair(const _T1& __x, const _T2& __y)
        : first(__x), second(__y) {}

    template<class _U1, class _U2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair(const pair<_U1, _U2>& __p




                                      )
            : first(__p.first), second(__p.second) {}
# 289 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(const pair& __p)


    {
        first = __p.first;
        second = __p.second;
        return *this;
    }
# 381 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    swap(pair& __p)

    {
        std::__1::iter_swap(&first, &__p.first);
        std::__1::iter_swap(&second, &__p.second);
    }
private:
# 398 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)


{
    __x.swap(__y);
}
# 496 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_T1,_T2>
make_pair(_T1 __x, _T2 __y)
{
    return pair<_T1, _T2>(__x, __y);
}



template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<const pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, const pair<_T1, _T2> >
{
public:
    typedef const _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, const pair<_T1, _T2> >
{
public:
    typedef const _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T1&
    get(pair<_T1, _T2>& __p) throw() {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T1&
    get(const pair<_T1, _T2>& __p) throw() {return __p.first;}
# 568 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T2&
    get(pair<_T1, _T2>& __p) throw() {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T2&
    get(const pair<_T1, _T2>& __p) throw() {return __p.second;}
# 594 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}
# 766 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
} }
# 627 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 1 3
# 594 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 1 3
# 61 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 1 3
# 85 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception() throw() {}
    virtual ~exception() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bad_exception() throw() {}
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
};

typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) throw();
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void unexpected();

typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) throw();
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void terminate() throw();

__attribute__ ((__visibility__("default"))) bool uncaught_exception() throw();

class __attribute__ ((__type_visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);

class __attribute__ ((__type_visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr() throw() : __ptr_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr(nullptr_t) throw() : __ptr_() {}
    exception_ptr(const exception_ptr&) throw();
    exception_ptr& operator=(const exception_ptr&) throw();
    ~exception_ptr() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __ptr_ != std::__1::__get_nullptr_t();}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) throw()
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }

}



class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() throw();


    virtual ~nested_exception() throw();


    __attribute__ ((noreturn)) void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr nested_ptr() const throw() {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{

    throw __nested<typename remove_reference<_Tp>::type>(std::__1::forward<_Tp>(__t));

}

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{

    throw std::__1::forward<_Tp>(__t);

}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep& __e, typename enable_if<
                                   is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep&, typename enable_if<
                                   !is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
}

}
# 62 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 1 3
# 149 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 3


namespace std {inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 2 3
# 67 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);
protected:

    const char* __type_name;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit type_info(const char* __n)

        : __type_name(__n) {}




public:
    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* name() const throw()

        {return __type_name;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool before(const type_info& __arg) const throw()

        {return __type_name < __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t hash_code() const throw()

        {return *reinterpret_cast<const size_t*>(&__type_name);}
# 126 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const type_info& __arg) const throw()

        {return __type_name == __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const type_info& __arg) const throw()
        {return !operator==(__arg);}
# 154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
};

class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
public:
    bad_cast() throw();
    virtual ~bad_cast() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
public:
    bad_typeid() throw();
    virtual ~bad_typeid() throw();
    virtual const char* what() const throw();
};

}
# 595 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 1 3
# 73 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() throw();
    virtual ~bad_array_new_length() throw();
    virtual const char* what() const throw();
};
# 111 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
__attribute__ ((__visibility__("default"))) void __throw_bad_alloc();

struct __attribute__ ((__type_visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;
typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) throw();
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() throw();

}







__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) throw();

__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new (std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new[](std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete (void*, void*) throw() {}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete[](void*, void*) throw() {}
# 598 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 1 3
# 346 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3


namespace std {inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_const<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _ForwardIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIter
next(_ForwardIter __x,
     typename iterator_traits<_ForwardIter>::difference_type __n = 1,
     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)
{
    std::__1::advance(__x, __n);
    return __x;
}

template <class _BidiretionalIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidiretionalIter
prev(_BidiretionalIter __x,
     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,
     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)
{
    std::__1::advance(__x, -__n);
    return __x;
}

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
    mutable _Iter __t;
protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator() : current() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t(__u.base()), current(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {__t = current; return *--__t;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {return &(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator++(int)
        {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator--(int)
        {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator+ (difference_type __n) const
        {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator+=(difference_type __n)
        {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator- (difference_type __n) const
        {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator-=(difference_type __n)
        {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
        {return current[-__n-1];}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename reverse_iterator<_Iter1>::difference_type
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() - __x.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      back_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit back_insert_iterator(_Container& __x) : container(&__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      front_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit front_insert_iterator(_Container& __x) : container(&__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      insert_iterator<_Container>&>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(&__x), iter(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator() : __in_stream_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(&__s)
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp* operator->() const {return &(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
        {return __x.__in_stream_ == __y.__in_stream_;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s)
        : __out_stream_(&__s), __delim_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter)
        : __out_stream_(&__s), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator() throw() : __sbuf_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(istream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(const __proxy& __p) throw()
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* operator->() const {return std::__1::__get_nullptr_t();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(ostream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool failed() const throw() {return __sbuf_ == 0;}





    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);

};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;



    typedef typename iterator_traits<iterator_type>::reference reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator(const move_iterator<_Up>& __u)
        : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {
      return static_cast<reference>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {
      typename iterator_traits<iterator_type>::reference __ref = *__i;
      return &__ref;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator++(int)
        {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator--(int)
        {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator+ (difference_type __n) const
        {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator+=(difference_type __n)
        {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator- (difference_type __n) const
        {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator-=(difference_type __n)
        {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
    {
      return static_cast<reference>(__i[__n]);
    }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename move_iterator<_Iter1>::difference_type
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter>
__attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) throw();

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) move_backward(_B1, _B1, _B2);

template <class _Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter() throw()



    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) throw()
        : __i(__u.base())
    {



    }
# 1149 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw()
    {




        return (pointer)&reinterpret_cast<const volatile char&>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator++() throw()
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator++(int) throw()
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator--() throw()
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator--(int) throw()
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator+ (difference_type __n) const throw()
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator+=(difference_type __n) throw()
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator- (difference_type __n) const throw()
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator-=(difference_type __n) throw()
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const throw()
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator_type base() const throw() {return __i;}

private:






    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(iterator_type __x) throw() : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class vector;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    typename __wrap_iter<_Iter1>::difference_type
    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1>
    friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

    template <class _Tp>
    friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) throw()
{
    __x += __n;
    return __x;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}
# 1529 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
begin(_Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
begin(const _Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
end(_Cp& __c)
{
    return __c.end();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
end(const _Cp& __c)
{
    return __c.end();
}



} }
# 601 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 1 3
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3


namespace std {inline namespace __1 {

template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};
# 80 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
addressof(_Tp& __x) throw()
{
    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
}
# 130 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<typename remove_reference<_Tp>::type>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};



template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) volatile>
{
    typedef _Rp result_type;
};
# 416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}



template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}



template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    typename __apply_cv<_T1, _Rp>::type&
>::type
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return __t1.*__f;
}

template <class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__invoke(_Rp _Tp::*)
{
}
# 837 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _T1, class _Rp, bool>
struct __4th_helper
{
};

template <class _T1, class _Rp>
struct __4th_helper<_T1, _Rp, true>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_T1>()), _Rp>::type type;
};

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __4th_helper<_T1, _Rp,
                      !is_base_of<_Tp,
                                  typename remove_reference<_T1>::type
                                 >::value
                     >::type&
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return (*__t1).*__f;
}
# 874 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()())
__invoke(_Fp __f)
{
    return __f();
}

template <class _Fp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>()))
__invoke(_Fp __f, _A0& __a0)
{
    return __f(__a0);
}

template <class _Fp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1)
{
    return __f(__a0, __a1);
}

template <class _Fp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>(), declval<_A2&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return __f(__a0, __a1, __a2);
}
# 942 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Tp>
struct __has_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Fp, bool = __has_result_type<__weak_result_type<_Fp> >::value>
struct __invoke_return
{
    typedef typename __weak_result_type<_Fp>::result_type type;
};

template <class _Fp>
struct __invoke_return<_Fp, false>
{
    typedef __typeof__(__invoke(std::__1::declval<_Fp>())) type;
};

template <class _Tp, class _A0>
struct __invoke_return0
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>())) type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0*>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Tp, class _A0, class _A1>
struct __invoke_return1
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>())) type;

};

template <class _Tp, class _A0, class _A1, class _A2>
struct __invoke_return2
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>(), std::__1::declval<_A2>())) type;


};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference_wrapper(type& __f) : __f_(&__f) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator type& () const {return *__f_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) type& get() const {return *__f_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename __invoke_return<type&>::type
       operator() () const
       {
           return __invoke(get());
       }

    template <class _A0>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return0<type&, _A0>::type
          operator() (_A0& __a0) const
          {
              return __invoke(get(), __a0);
          }

    template <class _A0, class _A1>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return1<type&, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1) const
          {
              return __invoke(get(), __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return2<type&, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2) const
          {
              return __invoke(get(), __a0, __a1, __a2);
          }
};

template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t)
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t)
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t)
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t)
{
    return cref(__t.get());
}
# 131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 2 3
# 523 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { };


extern const allocator_arg_t allocator_arg;






template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
# 613 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
} }
# 602 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 1 3
# 132 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3


namespace std {inline namespace __1 {
# 1100 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3
} }
# 604 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 613 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 614 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 617 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3


namespace std {inline namespace __1 {



template <class _Tp> class allocator;

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};



template <class _Tp>
struct __has_element_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::element_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};
# 685 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, true>
{
    typedef typename _Sp<_Tp>::element_type type;
};

template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, false>
{
    typedef _Tp type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>
{
    typedef typename _Sp<_Tp, _A0>::element_type type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>
{
    typedef _Tp type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>
{
    typedef _Tp type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>
{
    typedef _Tp type;
};



template <class _Tp>
struct __has_difference_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::difference_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{



    typedef typename _Tp::template rebind<_Up>::other type;

};
# 801 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>
{



    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;

};

template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>
{
    typedef _Sp<_Up> type;
};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;

};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>
{
    typedef _Sp<_Up, _A0> type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;

};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;

};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1, _A2> type;
};



template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;




    template <class _Up> struct rebind
        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;




    template <class _Up> struct rebind {typedef _Up* other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) throw()
        {return std::__1::addressof(__r);}
};



namespace __has_pointer_type_imp
{
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::pointer* = 0);
}

template <class _Tp>
struct __has_pointer_type
    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>
{
};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};

}

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp>
struct __has_const_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;

};

template <class _Tp>
struct __has_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;

};

template <class _Tp>
struct __has_const_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;

};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
__to_raw_pointer(_Tp* __p) throw()
{
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) throw()
{
    return std::__1::__to_raw_pointer(__p.operator->());
}

template <class _Tp>
struct __has_size_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::size_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_move_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_swap
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};
# 1181 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>
{
    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;
};

template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>
{
    typedef _Alloc<_Up> type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>
{
    typedef _Alloc<_Up, _A0> type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1, _A2> type;
};
# 1260 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : true_type
{
};
# 1361 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _Pointer, class _Args>
struct __has_construct
    : false_type
{
};



template <class _Alloc, class _Pointer>
struct __has_destroy
    : false_type
{
};

template <class _Alloc>
struct __has_max_size
    : true_type
{
};

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : false_type
{
};



template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;






    template <class _Tp> struct rebind_alloc
        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};
    template <class _Tp> struct rebind_traits
        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) throw()
        {__a.deallocate(__p, __n);}
# 1452 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p)
            {
                ::new ((void*)__p) _Tp();
            }
    template <class _Tp, class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)
            {
                ::new ((void*)__p) _Tp(__a0);
            }
    template <class _Tp, class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1)
            {
                ::new ((void*)__p) _Tp(__a0, __a1);
            }
    template <class _Tp, class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1, const _A2& __a2)
            {
                ::new ((void*)__p) _Tp(__a0, __a1, __a2);
            }


    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type max_size(const allocator_type& __a) throw()
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), std::__1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
            __begin2 += _Np;
        }

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__1::__to_raw_pointer(__end2-1), std::__1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}
# 1577 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(true_type, const allocator_type& __a)
            {return __a.max_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(false_type, const allocator_type&)
            {return numeric_limits<size_type>::max();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer address(reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {::operator delete((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {::operator delete((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1734 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) throw() {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) throw() {return false;}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(&*__x_) _Tp(__element); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}
};

template <class _Tp>
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) throw()
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void return_temporary_buffer(_Tp* __p) throw() {::operator delete(__p);}

template <class _Tp>
struct auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr<_Up>& __p) throw()
        : __ptr_(__p.release()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr& __p) throw()
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        {reset(__p.release()); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~auto_ptr() throw() {delete __ptr_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp& operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr_ref<_Up>() throw()
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr<_Up>() throw()
        {return auto_ptr<_Up>(release());}
};

template <>
class __attribute__ ((__type_visibility__("default"))) auto_ptr<void>
{
public:
    typedef void element_type;
};

template <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,
                                                     typename remove_cv<_T2>::type>::value,
                                bool = is_empty<_T1>::value

                                       && !__is_final(_T1)

                                ,
                                bool = is_empty<_T2>::value

                                       && !__is_final(_T2)

         >
struct __libcpp_compressed_pair_switch;

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false> {enum {value = 1};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true> {enum {value = 2};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true> {enum {value = 3};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true> {enum {value = 1};};

template <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>
class __libcpp_compressed_pair_imp;

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 0>
{
private:
    _T1 __first_;
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : __first_(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2010 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 1>
    : private _T1
{
private:
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2101 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 2>
    : private _T2
{
private:
    _T1 __first_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)


        : _T2(std::__1::forward<_T2_param>(__t2)), __first_(std::__1::forward<_T1_param>(__t1)) {}
# 2194 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 3>
    : private _T1,
      private _T2
{
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), _T2(std::__1::forward<_T2_param>(__t2)) {}
# 2283 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp&)


    {
    }
};

template <class _T1, class _T2>
class __compressed_pair
    : private __libcpp_compressed_pair_imp<_T1, _T2>
{
    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;
public:
    typedef typename base::_T1_param _T1_param;
    typedef typename base::_T2_param _T2_param;

    typedef typename base::_T1_reference _T1_reference;
    typedef typename base::_T2_reference _T2_reference;

    typedef typename base::_T1_const_reference _T1_const_reference;
    typedef typename base::_T2_const_reference _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T1_param __t1)
        : base(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T2_param __t2)
        : base(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair(_T1_param __t1, _T2_param __t2)
        : base(std::__1::forward<_T1_param>(__t1), std::__1::forward<_T2_param>(__t2)) {}
# 2366 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return base::first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return base::first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return base::second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return base::second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__compressed_pair& __x)


        {base::swap(__x);}
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)


    {__x.swap(__y);}



template <class _Ptr1, class _Ptr2,
          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,
                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type
                        >::value
         >
struct __same_or_less_cv_qualified_imp
    : is_convertible<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>
    : false_type {};

template <class _Ptr1, class _Ptr2, bool = is_scalar<_Ptr1>::value &&
                                         !is_pointer<_Ptr1>::value>
struct __same_or_less_cv_qualified
    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified<_Ptr1, _Ptr2, true>
    : false_type {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete
{



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up>&,
             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator() (_Tp* __ptr) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2424;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2425;
            delete __ptr;
        }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]>
{
public:



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up[]>&,
             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) throw() {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void operator() (_Up* __ptr,
                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2447;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2448;
            delete [] __ptr;
        }
};

template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr(unique_ptr<_Up, _Ep>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2481;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2487;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p) throw()
        : __ptr_(std::__1::move(__p))
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2493;

        }
# 2563 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    template <class _Up, class _Ep>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)
    {
        reset(__u.release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(std::__1::move(__p), std::__1::move(__d)) {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
                typename enable_if<
                                      is_convertible<_Up*, _Tp*>::value &&
                                      is_same<_Dp, default_delete<_Tp> >::value,
                                      unique_ptr&
                                  >::type
        operator=(auto_ptr<_Up> __p)
            {reset(__p.release()); return *this;}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator*() const
        {return *__ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer()) throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) throw()
        {__ptr_.swap(__u.__ptr_);}
};

template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp>
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up>
        unique_ptr(unique_ptr<_Up>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up>
        unique_ptr& operator=(unique_ptr<_Up>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2660;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2666;

        }
# 2758 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p)
        : __ptr_(__p)
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2762;

        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(__p, std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t, deleter_type __d)
        : __ptr_(pointer(), std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(__rv<unique_ptr> __u)
    {
        reset(__u->release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u->get_deleter());
        return *this;
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const
        {return __ptr_.first()[__i];}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }
# 2839 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer())
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}
private:


    template <class _Up>
        explicit unique_ptr(_Up);
    template <class _Up>
        unique_ptr(_Up __u,
                   typename conditional<
                                       is_reference<deleter_type>::value,
                                       deleter_type,
                                       typename add_lvalue_reference<const deleter_type>::type>::type,
                   typename enable_if
                      <
                         is_convertible<_Up, pointer>::value,
                         __nat
                      >::type = __nat());

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) throw() {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(std::__1::__get_nullptr_t(), __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return std::__1::__get_nullptr_t() < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < std::__1::__get_nullptr_t();
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(std::__1::__get_nullptr_t() < __x);
}



template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unique_ptr<_Tp, _Dp>
move(unique_ptr<_Tp, _Dp>& __t)
{
    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));
}
# 3062 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Tp> struct hash;

template <class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    _Size operator()(const void* __key, _Size __len);
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
    case 2:
        __h ^= __data[1] << 8;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    _Size operator()(const void* __key, _Size __len);

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp* __v) const throw()
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) hash<unique_ptr<_Tp, _Dp> >
{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t size;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp* __p, false_type) throw()
        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp*, true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(false_type) throw()
        {++size;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, false_type) throw()
        {size = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t, true_type) throw()
        {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __destruct_n(size_t __s) throw()
        : size(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(_Tp*) throw()
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, _Tp*) throw()
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) throw()
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             throw()
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __f != __l; ++__f, ++__r)
            ::new(&*__r) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __n > 0; ++__f, ++__r, --__n)
            ::new(&*__r) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __f != __l; ++__f)
            ::new(&*__f) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __n > 0; ++__f, --__n)
            ::new(&*__f) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

    return __f;
}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() throw();
    virtual const char* what() const throw();
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__type_visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() throw() = 0;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_count(long __refs = 0) throw()
        : __shared_owners_(__refs) {}

    void __add_shared() throw();
    bool __release_shared() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_owners_ + 1;}
};

class __attribute__ ((__type_visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_weak_count(long __refs = 0) throw()
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:
    void __add_shared() throw();
    void __add_weak() throw();
    void __release_shared() throw();
    void __release_weak() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_count::use_count();}
    __shared_weak_count* lock() throw();






    virtual const void* __get_deleter(const type_info&) const throw();

private:
    virtual void __on_zero_shared_weak() throw() = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}


    virtual const void* __get_deleter(const type_info&) const throw();


private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const throw()
{
    return __t == typeid(_Dp) ? &__data_.first().second() : 0;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw()
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(this, 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:
# 3702 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(__a) {}

    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0)
            : __data_(__a, _Tp(__a0)) {}

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)
            : __data_(__a, _Tp(__a0, __a1)) {}

    template <class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)
            : __data_(__a, _Tp(__a0, __a1, __a2)) {}



private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* get() throw() {return &__data_.second();}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() throw()
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(this, 1);
}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
                      shared_ptr() throw();
                      shared_ptr(nullptr_t) throw();
    template<class _Yp,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        explicit shared_ptr(_Yp* __p);
    template<class _Yp, class _Dp,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        shared_ptr(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a);
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) throw();
    shared_ptr(const shared_ptr& __r) throw();
    template<class _Yp>
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())
                       throw();






    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());
# 3808 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template<class _Yp,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        shared_ptr(auto_ptr<_Yp> __r);
# 3836 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template <class _Yp, class _Dp,
                 class = typename enable_if
                 <
                    !is_array<_Yp>::value &&
                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
                 >::type
             > shared_ptr(unique_ptr<_Yp, _Dp>,
       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());
    template <class _Yp, class _Dp,
                 class = typename enable_if
                 <
                    !is_array<_Yp>::value &&
                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
                 >::type
             >
       shared_ptr(unique_ptr<_Yp, _Dp>,
       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());


    ~shared_ptr();

    shared_ptr& operator=(const shared_ptr& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(const shared_ptr<_Yp>& __r) throw();
# 3883 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template<class _Yp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(auto_ptr<_Yp> __r);

    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type



        operator=(unique_ptr<_Yp, _Dp> __r);


    void swap(shared_ptr& __r) throw();
    void reset() throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool unique() const throw() {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                     operator bool() const throw() {return get() != 0;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}


    template <class _Dp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        _Dp* __get_deleter() const throw()
            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}
# 3976 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    static shared_ptr<_Tp> make_shared();

    template<class _A0>
        static shared_ptr<_Tp> make_shared(_A0&);

    template<class _A0, class _A1>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&);

    template<class _A0, class _A1, class _A2>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);

    template<class _Alloc>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a);

    template<class _Alloc, class _A0>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0);

    template<class _Alloc, class _A0, class _A1>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);

    template<class _Alloc, class _A0, class _A1, class _A2>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);



private:

    template <class _Yp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) throw()
        {
            if (__e)
                __e->__weak_this_ = *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __enable_weak_this(const void*) throw() {}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr(nullptr_t) throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp, class>
shared_ptr<_Tp>::shared_ptr(_Yp* __p)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());
    __hold.release();
    __enable_weak_this(__p);
}

template<class _Tp>
template<class _Yp, class _Dp, class>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());
        __enable_weak_this(__p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc, class>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();
        __enable_weak_this(__p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) throw()
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}
# 4210 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp, class>



shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r)

    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp, class>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

           typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp, class>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

           typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*,
                                 reference_wrapper<typename remove_reference<_Dp>::type>,
                                 allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}
# 4299 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared()
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}



template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}
# 4531 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template <class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::swap(shared_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::reset() throw()
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}
# 4647 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared()
{
    return shared_ptr<_Tp>::make_shared();
}

template<class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0)
{
    return shared_ptr<_Tp>::make_shared(__a0);
}

template<class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1);
}

template<class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);
}

template<class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a)
{
    return shared_ptr<_Tp>::allocate_shared(__a);
}

template<class _Tp, class _Alloc, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0);
}

template<class _Tp, class _Alloc, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);
}

template<class _Tp, class _Alloc, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);
}



template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    typedef typename common_type<_Tp*, _Up*>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return less<_Tp*>()(__x.get(), std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return less<_Tp*>()(std::__1::__get_nullptr_t(), __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return std::__1::__get_nullptr_t() < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return __x < std::__1::__get_nullptr_t();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}



template<class _Dp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) throw()
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
                      weak_ptr() throw();
    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        throw();
    weak_ptr(weak_ptr const& __r) throw();
    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         throw();







    ~weak_ptr();

    weak_ptr& operator=(weak_ptr const& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(weak_ptr<_Yp> const& __r) throw();
# 4964 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(shared_ptr<_Yp> const& __r) throw();

    void swap(weak_ptr& __r) throw();
    void reset() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw()
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool expired() const throw()
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const throw();
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

weak_ptr<_Tp>::weak_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
# 5067 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
# 5124 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::swap(weak_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::reset() throw()
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)

        throw bad_weak_ptr();



}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const throw()
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}

template <class _Tp> struct owner_less;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) throw()
        {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}

    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
# 5394 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
struct __attribute__ ((__type_visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator int() const {return __v_;}
};

__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) pointer_safety get_pointer_safety() throw();
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);

} }
# 628 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 638 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 639 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 642 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3


namespace std {inline namespace __1 {

template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __negate
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __negate() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __negate(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}
};
# 740 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__ctz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_ctz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__ctz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_ctzl(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__ctz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_ctzll(__x));
}


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__clz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_clz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__clz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_clzl (__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__clz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_clzll(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned __x) {return __builtin_popcount (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long __x) {return __builtin_popcountl (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return std::__1::move(__f);
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}



template<class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{

    _ForwardIterator1 __r = __last1;
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1)
                return __r;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (__first2 == __last2)
        return __last1;
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (__first1 == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }

        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
            if (__m1 == __first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
_RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_first_of(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1158 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1235 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{

    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return true;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);


    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1388 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return __first1;
    while (true)
    {

        while (true)
        {
            if (__first1 == __last1)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
                return __first1;
            if (++__m1 == __last1)
                return __last1;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
_RandomAccessIterator1
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;

    _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __first1;
    _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);
    while (true)
    {

        while (true)
        {
            if (__first1 == __s)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
# 1483 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;

         while (true)
         {
             if (++__m2 == __last2)
                 return __first1;
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
# 1534 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (__first == __last)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
_RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1);
    while (true)
    {

        while (true)
        {
            if (__first >= __s)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());
}



template <class _Iter>
struct __libcpp_is_trivial_iterator
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = *__first;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    return std::__1::copy(__first, __first + __n, __result);
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __value_;
    return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
    !is_same<_Tp, bool>::value &&
    is_integral<_Up>::value && sizeof(_Up) == 1,
    _Tp*
>::type
__fill_n(_Tp* __first, _Size __n,_Up __value_)
{
    if (__n > 0)
        std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
    return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, __n, __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __gen();
    return __first;
}



template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            swap(*__first, *__last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}



template <class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Integral
__gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}
# 2571 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}
# 2635 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _ForwardIterator, class _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}
# 2737 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UI, _UI _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UI) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;


    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min
                                          + _Working_result_type(1);




    static const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WDt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WDt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}



template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:

    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __clz(_Rp) - 1;
    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}

class __attribute__ ((__type_visibility__("default"))) __rs_default;

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

class __attribute__ ((__type_visibility__("default"))) __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&);
    ~__rs_default();

    result_type operator()();

    static result_type min() {return _Min;}
    static result_type max() {return _Max;}

    friend __attribute__ ((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        __rs_default __g = __rs_get();
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



               _RandomNumberGenerator& __rand)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        for (--__last; __first < __last; ++__first, --__d)
        {
            difference_type __i = __rand(__d);
            swap(*__first, *(__first + __i));
        }
    }
}

template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



                 _UniformRandomNumberGenerator& __g)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _InputIterator, class _Predicate>
bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template<class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }

        *__first = std::__1::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BirdirectionalIterator>
void
__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    _BirdirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BirdirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BirdirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new(__last2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type*)0);
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new(__j2) value_type(std::__1::move(*__i2));
                __d.__incr((value_type*)0);
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__1::move(*__first1));
                __d.__incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}


template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__1::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}





extern template __attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);






template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}



template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        __merge<_Compare>(move_iterator<value_type*>(__buff),
                          move_iterator<value_type*>(__p),
                          move_iterator<_BidirectionalIterator>(__middle),
                          move_iterator<_BidirectionalIterator>(__last),
                          __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),
                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),
                _RBi(__last), __negate<_Compare>(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;

        for (; true; ++__first, --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
        if (__len1 <= __buff_size || __len2 <= __buff_size)
        {
            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);
            return;
        }
# 4359 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__1::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _Tp>
struct __inplace_merge_switch
{
    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;
};

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
        __h.reset(__buf.first);
    }






    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new (__result) value_type(std::__1::move(*__first2));
            __d.__incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
       __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
         if (__comp(*--__last1, *__first1))
        {
            ::new(__first2) value_type(std::__1::move(*__last1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)0);
        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)0);
        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__push_heap_front(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,
                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        difference_type __p = 0;
        _RandomAccessIterator __pp = __first;
        difference_type __c = 2;
        _RandomAccessIterator __cp = __first + __c;
        if (__c == __len || __comp(*__cp, *(__cp - 1)))
        {
            --__c;
            --__cp;
        }
        if (__comp(*__pp, *__cp))
        {
            value_type __t(std::__1::move(*__pp));
            do
            {
                *__pp = std::__1::move(*__cp);
                __pp = __cp;
                __p = __c;
                __c = (__p + 1) * 2;
                if (__c > __len)
                    break;
                __cp = __first + __c;
                if (__c == __len || __comp(*__cp, *(__cp - 1)))
                {
                    --__c;
                    --__cp;
                }
            } while (__comp(__t, *__cp));
            *__pp = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__push_heap_back(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __push_heap_back<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        __push_heap_front<_Compare>(__first, __last, __comp, __len-1);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {
        __last = __first;
        ++__last;
        for (difference_type __i = 1; __i < __n;)
            __push_heap_back<_Compare>(__first, ++__last, __comp, ++__i);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
        __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    __make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            __push_heap_front<_Compare>(__first, __middle, __comp, __len);
        }
    }
    __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = 0;
        for (; __first != __last && __r != __result_last; ++__first, ++__r, ++__len)
            *__r = *__first;
        __make_heap<_Compare>(__result_first, __r, __comp);
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                __push_heap_front<_Compare>(__result_first, __r, __comp, __len);
            }
        __sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            __selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }


                    if (__nth < __i)
                        return;


                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
            else
            {

                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
        }
not_sorted:

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            if (!__comp(*__first1, *__first2))
                ++__first2;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_left(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_right(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));
}

} }
# 440 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 1 3
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{
private:
    void* __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) throw();
    logic_error& operator=(const logic_error&) throw();

    virtual ~logic_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{
private:
    void* __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) throw();
    runtime_error& operator=(const runtime_error&) throw();

    virtual ~runtime_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}

    virtual ~domain_error() throw();
};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}

    virtual ~invalid_argument() throw();
};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() throw();
};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}

    virtual ~out_of_range() throw();
};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}

    virtual ~range_error() throw();
};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~overflow_error() throw();
};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~underflow_error() throw();
};

}
# 444 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 454 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 455 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 458 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3


namespace std {inline namespace __1 {



template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}



template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type((-1));}
};

template <class _CharT>
int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

template <class _CharT>
_CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
            {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return memcmp(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_t length(const char_type* __s) {return strlen(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)memmove(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)memcpy(__s1, __s2, __n);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)memset(__s, to_int_type(__a), __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type((unsigned char)__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type((-1));}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return wmemcmp(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_t length(const char_type* __s)
        {return wcslen(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)wmemchr(__s, __a, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)wmemmove(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)wmemcpy(__s1, __s2, __n);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)wmemset(__s, __a, __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(((__darwin_wint_t)-1));}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(0xDFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char16_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(0xFFFFFFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char32_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}





template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_first_of(const _CharT *__p, _SizeT __sz,
    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::find_first_of
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_last_of(const _CharT *__p, _SizeT __sz,
    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_first_not_of(const _CharT *__p, _SizeT __sz,
    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == 0)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_first_not_of(const _CharT *__p, _SizeT __sz,
    _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_last_not_of(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == 0)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_last_not_of(const _CharT *__p, _SizeT __sz,
        _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
size_t __attribute__ ((__visibility__("hidden"), __always_inline__)) __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{

    throw length_error("basic_string");



}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{

    throw out_of_range("basic_string");



}





extern template class __attribute__ ((__type_visibility__("default"))) __basic_string_common<true>;
# 1170 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef _Traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef __static_assert_check<sizeof(__static_assert_test<(is_pod<value_type>::value)>)> __t1187;
    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<_CharT, value_type>::value))>)> __t1189;

    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<typename allocator_type::value_type, value_type>::value))>)> __t1191;





    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;

    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
# 1236 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };





    enum {__short_mask = 0x01};
    enum {__long_mask = 0x1ul};


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };



    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string()
                                                                           ;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit basic_string(const allocator_type& __a);
    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);







    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string(const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c, const allocator_type& __a);
    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,
                 const allocator_type& __a = allocator_type());
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);







    ~basic_string();

    basic_string& operator=(const basic_string& __str);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 1358 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw()
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw()
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw()
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw()
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() throw()
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw()
        {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw()
        {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw()
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw()
        {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type size() const throw()
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type length() const throw() {return size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type capacity() const throw()
        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type res_arg = 0);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void shrink_to_fit() throw() {reserve();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool empty() const throw() {return size() == 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __pos) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __pos);

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& append(const basic_string& __str);
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        append(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        append(_ForwardIterator __first, _ForwardIterator __last);





    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void pop_back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(const basic_string& __str);





    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& insert(size_type __pos1, const basic_string& __str);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);






    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            basic_string&
        >::type
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);






    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_string& __str)

                                                                 ;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* c_str() const throw() {return data();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* data() const throw() {return std::__1::__to_raw_pointer(__get_pointer());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __alloc();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const value_type* __s, size_type __pos = 0) const throw();
    size_type find(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const throw();
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const throw();
    size_type rfind(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const basic_string& __str) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const;
    int compare(const value_type* __s) const throw();
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __is_long() const throw()
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1642 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type& __alloc() throw()
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const throw()
        {return __r_.second();}
# 1670 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_short_size(size_type __s) throw()



        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_short_size() const throw()



        {return __r_.first().__s.__size_ >> 1;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_size(size_type __s) throw()
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_size() const throw()
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_size(size_type __s) throw()
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_cap(size_type __s) throw()
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_cap() const throw()
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_pointer(pointer __p) throw()
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_long_pointer() throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_long_pointer() const throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_short_pointer() throw()
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_short_pointer() const throw()
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_pointer() throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_pointer() const throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __zero() throw()
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        size_type __align_it(size_type __s) throw()
            {return __s + (__a-1) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __recommend(size_type __s) throw()
        {return (__s < __min_cap ? __min_cap :
                 __align_it<sizeof(value_type) < __alignment ?
                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}

    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    void __init(const value_type* __s, size_type __sz);
    void __init(size_type __n, value_type __c);

    template <class _InputIterator>
    typename enable_if
    <
         __is_input_iterator <_InputIterator>::value &&
        !__is_forward_iterator<_InputIterator>::value,
        void
    >::type
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    typename enable_if
    <
        __is_forward_iterator<_ForwardIterator>::value,
        void
    >::type
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __erase_to_end(size_type __pos);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() != __str.__alloc())
            {
                clear();
                shrink_to_fit();
            }
            __alloc() = __str.__alloc();
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string&, false_type) throw()
        {}
# 1804 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    __move_assign_alloc(basic_string& __str)



    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string&, false_type)
        throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y)


        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type&, allocator_type&, false_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1891 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string()

{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)
    : __r_(__a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)
    : __r_(__a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}
# 2070 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)
    : __r_(__a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();

    try
    {

    for (; __first != __last; ++__first)
        push_back(*__first);

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    __init(__first, __last);



}
# 2237 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    if (__cap >= __n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        traits_type::move(__p, __s, __n);
        traits_type::assign(__p[__n], value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        size_type __sz = size();
        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
    if (this != &__str)
    {
        __copy_assign_alloc(__str);
        assign(__str);
    }
    return *this;
}
# 2424 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)
{
    return assign(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return assign(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)
{
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer() + __sz;
        for (; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
        traits_type::assign(*__p, value_type());
        __set_size(__sz + __n);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    size_type __old_sz = size();
    difference_type __ip = __pos - begin();
    for (; __first != __last; ++__first)
        push_back(*__first);
    pointer __p = __get_pointer();
    std::__1::rotate(__p + __ip, __p + __old_sz, __p + size());



    return iterator(__p + __ip);

}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:
        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    for (; true; ++__i1, ++__j1)
    {
        if (__i1 == __i2)
        {
            if (__j1 != __j2)
                insert(__i1, __j1, __j2);
            break;
        }
        if (__j1 == __j2)
        {
            erase(__i1, __i2);
            break;
        }
        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::clear() throw()
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const throw()
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)
{
    if (__res_arg > max_size())
        this->__throw_length_error();
    size_type __cap = capacity();
    size_type __sz = size();
    __res_arg = std::__1::max(__res_arg, __sz);
    __res_arg = __recommend(__res_arg);
    if (__res_arg != __cap)
    {
        pointer __new_data, __p;
        bool __was_long, __now_long;
        if (__res_arg == __min_cap - 1)
        {
            __was_long = true;
            __now_long = false;
            __new_data = __get_short_pointer();
            __p = __get_long_pointer();
        }
        else
        {
            if (__res_arg > __cap)
                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
            else
            {

                try
                {

                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);

                }
                catch (...)
                {
                    return;
                }




            }
            __now_long = true;
            __was_long = __is_long();
            __p = __get_pointer();
        }
        traits_type::copy(std::__1::__to_raw_pointer(__new_data),
                          std::__1::__to_raw_pointer(__p), size()+1);
        if (__was_long)
            __alloc_traits::deallocate(__alloc(), __p, __cap+1);
        if (__now_long)
        {
            __set_long_cap(__res_arg+1);
            __set_long_size(__sz);
            __set_long_pointer(__new_data);
        }
        else
            __set_short_size(__sz);
        __invalidate_all_iterators();
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front()
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)


{







    std::__1::swap(__r_.first(), __str.__r_.first());
    __swap_alloc(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const char_type& __x, const char_type& __y) throw()
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const throw()
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz || __sz - __pos < __n)
        return npos;
    if (__n == 0)
        return __pos;
    const value_type* __p = data();
    const value_type* __r = std::__1::search(__p + __pos, __p + __sz, __s, __s + __n,
                                     __traits_eq<traits_type>());
    if (__r == __p + __sz)
        return npos;
    return static_cast<size_type>(__r - __p);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const throw()
{
    return find(__str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const throw()
{
    ((void)0);
    return find(__s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const throw()
{
    size_type __sz = size();
    if (__pos >= __sz)
        return npos;
    const value_type* __p = data();
    const value_type* __r = traits_type::find(__p + __pos, __sz - __pos, __c);
    if (__r == 0)
        return npos;
    return static_cast<size_type>(__r - __p);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const throw()
{
    ((void)0);
    size_type __sz = size();
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const value_type* __p = data();
    const value_type* __r = std::__1::find_end(__p, __p + __pos, __s, __s + __n,
                                       __traits_eq<traits_type>());
    if (__n > 0 && __r == __p + __pos)
        return npos;
    return static_cast<size_type>(__r - __p);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const throw()
{
    return rfind(__str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const throw()
{
    ((void)0);
    return rfind(__s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const throw()
{
    size_type __sz = size();
    if (__sz)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        const value_type* __p = data();
        for (const value_type* __ps = __p + __pos; __ps != __p;)
        {
            if (traits_type::eq(*--__ps, __c))
                return static_cast<size_type>(__ps - __p);
        }
    }
    return npos;
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_first_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const throw()
{
    return std::__1::__find_first_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_first_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const throw()
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_last_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const throw()
{
    return std::__1::__find_last_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_last_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const throw()
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const throw()
{
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const throw()
{
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const throw()
{
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const throw()
{
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const throw()
{
    size_t __lhs_sz = size();
    size_t __rhs_sz = __str.size();
    int __result = traits_type::compare(data(), __str.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    size_type __sz = __str.size();
    if (__pos2 > __sz)
        this->__throw_out_of_range();
    return compare(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2,
                                                                  __sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const throw()
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == 0)
        return false;
    if (data()[size()] != value_type(0))
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) == 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs == __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) > 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}
# 4059 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)

{
    __lhs.swap(__rhs);
}



typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;



__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) string to_string(long double __val);

__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
                   basic_string<_CharT, _Traits, _Allocator>::npos;

template<class _CharT, class _Traits, class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string<_CharT, _Traits, _Allocator> >
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
{
    size_t
        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const throw();
};

template<class _CharT, class _Traits, class _Allocator>
size_t
hash<basic_string<_CharT, _Traits, _Allocator> >::operator()(
        const basic_string<_CharT, _Traits, _Allocator>& __val) const throw()
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}

template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4242 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
extern template class __attribute__ ((__type_visibility__("default"))) basic_string<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_string<wchar_t>;
extern template string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

} }
# 10 "./file_io.hpp" 2

namespace file_io {

std::string read_file(FILE* fp);
std::string open_and_read_file(const char* path, bool* is_valid);
void write_file(FILE* fp, const char* out);
void flush_and_close_file(FILE* fp);

}




# 1 "./file_io.cpp" 1
# 1 "./file_io.hpp" 1
# 2 "./file_io.cpp" 2

namespace file_io {

std::string read_file(FILE* fp)
{
    (*__error()) = 0;

    std::string input = "";
    int status = 0;
    char byte = '\0';

    do {
        status = fread((void*)&byte, sizeof(char), 1, fp);

        if (status == 0) {
            break;
        } else if (status < 0 || (*__error()) > 0) {
            return "";
        }

        input += byte;
    } while(true);

    return input;
}

std::string open_and_read_file(const char* path, bool* is_valid)
{
    FILE* fd = fopen(path, "r");
    if (fd == __null) {
        *is_valid = false;
        return "";
    }

    std::string out = read_file(fd);

    if (ferror(fd) == 0 || (*__error()) > 0) {
        *is_valid = true;
        flush_and_close_file(fd);
    } else {
        *is_valid = false;
    }

    return out;
}


void flush_and_close_file(FILE* fp)
{
    fflush(fp);
    fclose(fp);
}

void write_file(FILE* fp, const char* out)
{
    fwrite((void*)out, sizeof(char), strlen(out), fp);
}

}
# 23 "./file_io.hpp" 2
# 20 "run.cpp" 2


# 1 "./common_utils_cpp.hpp" 1



# 1 "./common_utils.h" 1
# 5 "./common_utils_cpp.hpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 1 3
# 52 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 3


namespace std {inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;
using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;
using ::strftime;

} }
# 7 "./common_utils_cpp.hpp" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 1 3
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 3
# 1 "/usr/include/signal.h" 1 3 4
# 64 "/usr/include/signal.h" 3 4
# 1 "/usr/include/sys/_types/_pthread_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 65 "/usr/include/signal.h" 2 3 4


extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];


extern "C" {
int raise(int);
}


extern "C" {
void (*bsd_signal(int, void (*)(int)))(int);
int kill(pid_t, int) __asm("_" "kill") ;
int killpg(pid_t, int) __asm("_" "killpg") ;
int pthread_kill(pthread_t, int);
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask") ;
int sigaction(int, const struct sigaction * ,
     struct sigaction * );
int sigaddset(sigset_t *, int);
int sigaltstack(const stack_t * , stack_t * ) __asm("_" "sigaltstack") ;
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(const sigset_t *, int);
int sigpause(int) __asm("_" "sigpause") ;
int sigpending(sigset_t *);
int sigprocmask(int, const sigset_t * , sigset_t * );
int sigrelse(int);
void (*sigset(int, void (*)(int)))(int);
int sigsuspend(const sigset_t *) __asm("_" "sigsuspend") ;
int sigwait(const sigset_t * , int * ) __asm("_" "sigwait") ;

void psignal(unsigned int, const char *);
int sigblock(int);
int sigsetmask(int);
int sigvec(int, struct sigvec *, struct sigvec *);

}




inline __attribute__ ((__always_inline__)) int
__sigbits(int __signo)
{
    return __signo > 32 ? 0 : (1 << (__signo - 1));
}
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 2 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 3


namespace std {inline namespace __1 {

using ::sig_atomic_t;
using ::signal;
using ::raise;

} }
# 8 "./common_utils_cpp.hpp" 2
# 1 "/usr/include/sys/stat.h" 1 3 4
# 85 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 86 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 87 "/usr/include/sys/stat.h" 2 3 4

# 1 "/usr/include/sys/_types/_ino_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 89 "/usr/include/sys/stat.h" 2 3 4


# 1 "/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_ino64_t.h" 3 4
typedef __darwin_ino64_t ino64_t;
# 92 "/usr/include/sys/stat.h" 2 3 4



# 1 "/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 96 "/usr/include/sys/stat.h" 2 3 4
# 110 "/usr/include/sys/stat.h" 3 4
struct ostat {
 __uint16_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 __uint16_t st_uid;
 __uint16_t st_gid;
 __uint16_t st_rdev;
 __int32_t st_size;
 struct timespec st_atimespec;
 struct timespec st_mtimespec;
 struct timespec st_ctimespec;
 __int32_t st_blksize;
 __int32_t st_blocks;
 __uint32_t st_flags;
 __uint32_t st_gen;
};
# 182 "/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 221 "/usr/include/sys/stat.h" 3 4
struct stat64 { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 241 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/_types/_s_ifmt.h" 1 3 4
# 242 "/usr/include/sys/stat.h" 2 3 4
# 344 "/usr/include/sys/stat.h" 3 4
extern "C" {

int chmod(const char *, mode_t) __asm("_" "chmod") ;
int fchmod(int, mode_t) __asm("_" "fchmod") ;
int fstat(int, struct stat *) __asm("_" "fstat" "$INODE64");
int lstat(const char *, struct stat *) __asm("_" "lstat" "$INODE64");
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int stat(const char *, struct stat *) __asm("_" "stat" "$INODE64");
int mknod(const char *, mode_t, dev_t);
mode_t umask(mode_t);




# 1 "/usr/include/sys/_types/_filesec_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_filesec_t.h" 3 4
struct _filesec;
typedef struct _filesec *filesec_t;
# 359 "/usr/include/sys/stat.h" 2 3 4

int chflags(const char *, __uint32_t);
int chmodx_np(const char *, filesec_t);
int fchflags(int, __uint32_t);
int fchmodx_np(int, filesec_t);
int fstatx_np(int, struct stat *, filesec_t) __asm("_" "fstatx_np" "$INODE64");
int lchflags(const char *, __uint32_t) __attribute__((availability(macosx,introduced=10.5)));
int lchmod(const char *, mode_t) __attribute__((availability(macosx,introduced=10.5)));
int lstatx_np(const char *, struct stat *, filesec_t) __asm("_" "lstatx_np" "$INODE64");
int mkdirx_np(const char *, filesec_t);
int mkfifox_np(const char *, filesec_t);
int statx_np(const char *, struct stat *, filesec_t) __asm("_" "statx_np" "$INODE64");
int umaskx_np(filesec_t) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)));



int fstatx64_np(int, struct stat64 *, filesec_t) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int lstatx64_np(const char *, struct stat64 *, filesec_t) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int statx64_np(const char *, struct stat64 *, filesec_t) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int fstat64(int, struct stat64 *) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int lstat64(const char *, struct stat64 *) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int stat64(const char *, struct stat64 *) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));



}
# 9 "./common_utils_cpp.hpp" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 23 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/sys/fcntl.h" 1 3 4
# 116 "/usr/include/sys/fcntl.h" 3 4
# 1 "/usr/include/sys/_types/_o_sync.h" 1 3 4
# 117 "/usr/include/sys/fcntl.h" 2 3 4
# 141 "/usr/include/sys/fcntl.h" 3 4
# 1 "/usr/include/sys/_types/_o_dsync.h" 1 3 4
# 142 "/usr/include/sys/fcntl.h" 2 3 4
# 279 "/usr/include/sys/fcntl.h" 3 4
# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
# 280 "/usr/include/sys/fcntl.h" 2 3 4
# 304 "/usr/include/sys/fcntl.h" 3 4
struct flock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
};
# 319 "/usr/include/sys/fcntl.h" 3 4
struct flocktimeout {
 struct flock fl;
 struct timespec timeout;
};
# 332 "/usr/include/sys/fcntl.h" 3 4
struct radvisory {
       off_t ra_offset;
       int ra_count;
};
# 344 "/usr/include/sys/fcntl.h" 3 4
typedef struct fsignatures {
 off_t fs_file_start;
 void *fs_blob_start;
 size_t fs_blob_size;
} fsignatures_t;
# 358 "/usr/include/sys/fcntl.h" 3 4
typedef struct fstore {
 unsigned int fst_flags;
 int fst_posmode;
 off_t fst_offset;
 off_t fst_length;
 off_t fst_bytesalloc;
} fstore_t;



typedef struct fbootstraptransfer {
  off_t fbt_offset;
  size_t fbt_length;
  void *fbt_buffer;
} fbootstraptransfer_t;
# 396 "/usr/include/sys/fcntl.h" 3 4
#pragma pack(4)

struct log2phys {
 unsigned int l2p_flags;
 off_t l2p_contigbytes;


 off_t l2p_devoffset;


};

#pragma pack()
# 421 "/usr/include/sys/fcntl.h" 3 4
typedef enum {
 FILESEC_OWNER = 1,
 FILESEC_GROUP = 2,
 FILESEC_UUID = 3,
 FILESEC_MODE = 4,
 FILESEC_ACL = 5,
 FILESEC_GRPUUID = 6,


 FILESEC_ACL_RAW = 100,
 FILESEC_ACL_ALLOCSIZE = 101
} filesec_property_t;





extern "C" {
int open(const char *, int, ...) __asm("_" "open") ;
int creat(const char *, mode_t) __asm("_" "creat") ;
int fcntl(int, int, ...) __asm("_" "fcntl") ;


int openx_np(const char *, int, filesec_t);

int open_dprotected_np ( const char *, int, int, int, ...);
int flock(int, int);
filesec_t filesec_init(void);
filesec_t filesec_dup(filesec_t);
void filesec_free(filesec_t);
int filesec_get_property(filesec_t, filesec_property_t, void *);
int filesec_query_property(filesec_t, filesec_property_t, int *);
int filesec_set_property(filesec_t, filesec_property_t, const void *);
int filesec_unset_property(filesec_t, filesec_property_t) __attribute__((availability(macosx,introduced=10.6)));



}
# 24 "/usr/include/fcntl.h" 2 3 4
# 10 "./common_utils_cpp.hpp" 2



# 1 "/usr/local/include/glm/gtc/matrix_transform.hpp" 1 3
# 28 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
# 1 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 1 3
# 23 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 3
namespace glm
{





 template <typename genType>
                             genType epsilon();



 template <typename genType>
                             genType zero();



 template <typename genType>
                             genType one();



 template <typename genType>
                             genType pi();



 template <typename genType>
                             genType two_pi();



 template <typename genType>
                             genType root_pi();



 template <typename genType>
                             genType half_pi();



 template <typename genType>
                             genType three_over_two_pi();



 template <typename genType>
                             genType quarter_pi();



 template <typename genType>
                             genType one_over_pi();



 template <typename genType>
                             genType one_over_two_pi();



 template <typename genType>
                             genType two_over_pi();



 template <typename genType>
                             genType four_over_pi();



 template <typename genType>
                             genType two_over_root_pi();



 template <typename genType>
                             genType one_over_root_two();



 template <typename genType>
                             genType root_half_pi();



 template <typename genType>
                             genType root_two_pi();



 template <typename genType>
                             genType root_ln_four();



 template <typename genType>
                             genType e();



 template <typename genType>
                             genType euler();



 template <typename genType>
                             genType root_two();



 template <typename genType>
                             genType root_three();



 template <typename genType>
                             genType root_five();



 template <typename genType>
                             genType ln_two();



 template <typename genType>
                             genType ln_ten();



 template <typename genType>
                             genType ln_ln_two();



 template <typename genType>
                             genType third();



 template <typename genType>
                             genType two_thirds();



 template <typename genType>
                             genType golden_ratio();


}


# 1 "/usr/local/include/glm/gtc/constants.inl" 1 3





namespace glm
{
 template <typename genType> inline
                                  genType epsilon()
 {
  return std::numeric_limits<genType>::epsilon();
 }

 template <typename genType> inline
                                  genType zero()
 {
  return genType(0);
 }

 template <typename genType> inline
                                  genType one()
 {
  return genType(1);
 }

 template <typename genType> inline
                                  genType pi()
 {
  return genType(3.14159265358979323846264338327950288);
 }

 template <typename genType> inline
                                  genType two_pi()
 {
  return genType(6.28318530717958647692528676655900576);
 }

 template <typename genType> inline
                                  genType root_pi()
 {
  return genType(1.772453850905516027);
 }

 template <typename genType> inline
                                  genType half_pi()
 {
  return genType(1.57079632679489661923132169163975144);
 }

 template <typename genType> inline
                                  genType three_over_two_pi()
 {
  return genType(4.71238898038468985769396507491925432);
 }

 template <typename genType> inline
                                  genType quarter_pi()
 {
  return genType(0.785398163397448309615660845819875721);
 }

 template <typename genType> inline
                                  genType one_over_pi()
 {
  return genType(0.318309886183790671537767526745028724);
 }

 template <typename genType> inline
                                  genType one_over_two_pi()
 {
  return genType(0.159154943091895335768883763372514362);
 }

 template <typename genType> inline
                                  genType two_over_pi()
 {
  return genType(0.636619772367581343075535053490057448);
 }

 template <typename genType> inline
                                  genType four_over_pi()
 {
  return genType(1.273239544735162686151070106980114898);
 }

 template <typename genType> inline
                                  genType two_over_root_pi()
 {
  return genType(1.12837916709551257389615890312154517);
 }

 template <typename genType> inline
                                  genType one_over_root_two()
 {
  return genType(0.707106781186547524400844362104849039);
 }

 template <typename genType> inline
                                  genType root_half_pi()
 {
  return genType(1.253314137315500251);
 }

 template <typename genType> inline
                                  genType root_two_pi()
 {
  return genType(2.506628274631000502);
 }

 template <typename genType> inline
                                  genType root_ln_four()
 {
  return genType(1.17741002251547469);
 }

 template <typename genType> inline
                                  genType e()
 {
  return genType(2.71828182845904523536);
 }

 template <typename genType> inline
                                  genType euler()
 {
  return genType(0.577215664901532860606);
 }

 template <typename genType> inline
                                  genType root_two()
 {
  return genType(1.41421356237309504880168872420969808);
 }

 template <typename genType> inline
                                  genType root_three()
 {
  return genType(1.73205080756887729352744634150587236);
 }

 template <typename genType> inline
                                  genType root_five()
 {
  return genType(2.23606797749978969640917366873127623);
 }

 template <typename genType> inline
                                  genType ln_two()
 {
  return genType(0.693147180559945309417232121458176568);
 }

 template <typename genType> inline
                                  genType ln_ten()
 {
  return genType(2.30258509299404568401799145468436421);
 }

 template <typename genType> inline
                                  genType ln_ln_two()
 {
  return genType(-0.3665129205816643);
 }

 template <typename genType> inline
                                  genType third()
 {
  return genType(0.3333333333333333333333333333333333333333);
 }

 template <typename genType> inline
                                  genType two_thirds()
 {
  return genType(0.666666666666666666666666666666666666667);
 }

 template <typename genType> inline
                                  genType golden_ratio()
 {
  return genType(1.61803398874989484820458683436563811);
 }
}
# 176 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 2 3
# 28 "/usr/local/include/glm/gtc/matrix_transform.hpp" 2 3






namespace glm
{
# 57 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> translate(
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v);
# 71 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> rotate(
  tmat4x4<T, P> const & m,
  T angle,
  tvec3<T, P> const & axis);
# 85 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> scale(
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v);
# 101 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> ortho(
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar);
# 121 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> orthoLH(
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar);
# 141 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> orthoRH(
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar);
# 159 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> ortho(
  T left,
  T right,
  T bottom,
  T top);
# 176 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> frustum(
  T left,
  T right,
  T bottom,
  T top,
  T near,
  T far);
# 195 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> frustumLH(
  T left,
  T right,
  T bottom,
  T top,
  T near,
  T far);
# 214 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> frustumRH(
  T left,
  T right,
  T bottom,
  T top,
  T near,
  T far);
# 231 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspective(
  T fovy,
  T aspect,
  T near,
  T far);
# 246 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveRH(
  T fovy,
  T aspect,
  T near,
  T far);
# 261 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveLH(
  T fovy,
  T aspect,
  T near,
  T far);
# 277 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveFov(
  T fov,
  T width,
  T height,
  T near,
  T far);
# 294 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveFovRH(
  T fov,
  T width,
  T height,
  T near,
  T far);
# 311 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveFovLH(
  T fov,
  T width,
  T height,
  T near,
  T far);
# 326 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> infinitePerspective(
  T fovy, T aspect, T near);
# 337 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> infinitePerspectiveLH(
  T fovy, T aspect, T near);
# 348 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> infinitePerspectiveRH(
  T fovy, T aspect, T near);
# 359 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 371 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near, T ep);
# 385 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, typename U, precision P>
               tvec3<T, P> project(
  tvec3<T, P> const & obj,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport);
# 402 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, typename U, precision P>
               tvec3<T, P> unProject(
  tvec3<T, P> const & win,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport);
# 417 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P, typename U>
               tmat4x4<T, P> pickMatrix(
  tvec2<T, P> const & center,
  tvec2<T, P> const & delta,
  tvec4<U, P> const & viewport);
# 430 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> lookAt(
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up);
# 443 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> lookAtRH(
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up);
# 456 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> lookAtLH(
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up);


}


# 1 "/usr/local/include/glm/gtc/matrix_transform.inl" 1 3







namespace glm
{
 template <typename T, precision P> inline
                    tmat4x4<T, P> translate(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
 {
  tmat4x4<T, P> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rotate(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);

  tvec3<T, P> axis(normalize(v));
  tvec3<T, P> temp((T(1) - c) * axis);

  tmat4x4<T, P> Rotate(uninitialize);
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  tmat4x4<T, P> Result(uninitialize);
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rotate_slow(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);
  tmat4x4<T, P> Result;

  tvec3<T, P> axis = normalize(v);

  Result[0][0] = c + (static_cast<T>(1) - c) * axis.x * axis.x;
  Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = static_cast<T>(0);

  Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
  Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = static_cast<T>(0);

  Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
  Result[2][3] = static_cast<T>(0);

  Result[3] = tvec4<T, P>(0, 0, 0, 1);
  return m * Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scale(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
 {
  tmat4x4<T, P> Result(uninitialize);
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scale_slow(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
 {
  tmat4x4<T, P> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> ortho
 (
  T left, T right,
  T bottom, T top,
  T zNear, T zFar
 )
 {



   return orthoRH(left, right, bottom, top, zNear, zFar);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> orthoLH
 (
  T left, T right,
  T bottom, T top,
  T zNear, T zFar
 )
 {
  tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);





   Result[2][2] = static_cast<T>(2) / (zFar - zNear);
   Result[3][2] = - (zFar + zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> orthoRH
 (
  T left, T right,
  T bottom, T top,
  T zNear, T zFar
 )
 {
  tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);





   Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
   Result[3][2] = - (zFar + zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> ortho
 (
  T left, T right,
  T bottom, T top
 )
 {
  tmat4x4<T, defaultp> Result(static_cast<T>(1));
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> frustum
 (
  T left, T right,
  T bottom, T top,
  T nearVal, T farVal
 )
 {



   return frustumRH(left, right, bottom, top, nearVal, farVal);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> frustumLH
 (
  T left, T right,
  T bottom, T top,
  T nearVal, T farVal
 )
 {
  tmat4x4<T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][3] = static_cast<T>(1);





   Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
   Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> frustumRH
 (
  T left, T right,
  T bottom, T top,
  T nearVal, T farVal
 )
 {
  tmat4x4<T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][3] = static_cast<T>(-1);





   Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
   Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH(fovy, aspect, zNear, zFar);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
 {
  (__builtin_expect(!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 260, "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)") : (void)0);

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][3] = - static_cast<T>(1);





   Result[2][2] = - (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
 {
  (__builtin_expect(!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 283, "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)") : (void)0);

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][3] = static_cast<T>(1);





   Result[2][2] = (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH(fov, width, height, zNear, zFar);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
 {
  (__builtin_expect(!(width > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 316, "width > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(height > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 317, "height > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(fov > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 318, "fov > static_cast<T>(0)") : (void)0);

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][3] = - static_cast<T>(1);





   Result[2][2] = - (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
 {
  (__builtin_expect(!(width > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 343, "width > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(height > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 344, "height > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(fov > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 345, "fov > static_cast<T>(0)") : (void)0);

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][3] = static_cast<T>(1);





   Result[2][2] = (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
 {



   return infinitePerspectiveRH(fovy, aspect, zNear);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> infinitePerspectiveRH(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> infinitePerspectiveLH(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }


 template <typename T> inline
                    tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = ep - static_cast<T>(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = (ep - static_cast<T>(2)) * zNear;
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
 {
  return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
 }

 template <typename T, typename U, precision P> inline
                    tvec3<T, P> project
 (
  tvec3<T, P> const & obj,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport
 )
 {
  tvec4<T, P> tmp = tvec4<T, P>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;




   tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);

  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return tvec3<T, P>(tmp);
 }

 template <typename T, typename U, precision P> inline
                    tvec3<T, P> unProject
 (
  tvec3<T, P> const & win,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport
 )
 {
  tmat4x4<T, P> Inverse = inverse(proj * model);

  tvec4<T, P> tmp = tvec4<T, P>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);




   tmp = tmp * static_cast<T>(2) - static_cast<T>(1);


  tvec4<T, P> obj = Inverse * tmp;
  obj /= obj.w;

  return tvec3<T, P>(obj);
 }

 template <typename T, precision P, typename U> inline
                    tmat4x4<T, P> pickMatrix(tvec2<T, P> const & center, tvec2<T, P> const & delta, tvec4<U, P> const & viewport)
 {
  (__builtin_expect(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 494, "delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)") : (void)0);
  tmat4x4<T, P> Result(static_cast<T>(1));

  if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
   return Result;

  tvec3<T, P> Temp(
   (static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
   (static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
   static_cast<T>(0));


  Result = translate(Result, Temp);
  return scale(Result, tvec3<T, P>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> lookAt(tvec3<T, P> const & eye, tvec3<T, P> const & center, tvec3<T, P> const & up)
 {



   return lookAtRH(eye, center, up);

 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> lookAtRH
 (
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up
 )
 {
  tvec3<T, P> const f(normalize(center - eye));
  tvec3<T, P> const s(normalize(cross(f, up)));
  tvec3<T, P> const u(cross(s, f));

  tmat4x4<T, P> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> lookAtLH
 (
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up
 )
 {
  tvec3<T, P> const f(normalize(center - eye));
  tvec3<T, P> const s(normalize(cross(up, f)));
  tvec3<T, P> const u(cross(f, s));

  tmat4x4<T, P> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] = f.x;
  Result[1][2] = f.y;
  Result[2][2] = f.z;
  Result[3][0] = -dot(s, eye);
  Result[3][1] = -dot(u, eye);
  Result[3][2] = -dot(f, eye);
  return Result;
 }
}
# 465 "/usr/local/include/glm/gtc/matrix_transform.hpp" 2 3
# 14 "./common_utils_cpp.hpp" 2
# 1 "/usr/local/include/glm/gtc/type_ptr.hpp" 1 3
# 37 "/usr/local/include/glm/gtc/type_ptr.hpp" 3
# 1 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 1 3
# 28 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
namespace glm
{



 template <typename T, precision P = defaultp>
 struct tquat
 {


  typedef tquat<T, P> type;
  typedef T value_type;
# 67 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
   T x, y, z, w;




  typedef length_t length_type;

                static length_type length(){return 4;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                              tquat() ;
                              tquat(tquat<T, P> const & q) ;
  template <precision Q>
                              tquat(tquat<T, Q> const & q);



                                   explicit tquat(ctor);
                              tquat(T const & s, tvec3<T, P> const & v);
                              tquat(T const & w, T const & x, T const & y, T const & z);



  template <typename U, precision Q>
                                           tquat(tquat<U, Q> const & q);
# 109 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
                tquat(tvec3<T, P> const & u, tvec3<T, P> const & v);


                             tquat(tvec3<T, P> const & eulerAngles);
                             tquat(tmat3x3<T, P> const & m);
                             tquat(tmat4x4<T, P> const & m);



                tquat<T, P> & operator=(tquat<T, P> const & m) ;

  template <typename U>
                tquat<T, P> & operator=(tquat<U, P> const & m);
  template <typename U>
                tquat<T, P> & operator+=(tquat<U, P> const & q);
  template <typename U>
                tquat<T, P> & operator-=(tquat<U, P> const & q);
  template <typename U>
                tquat<T, P> & operator*=(tquat<U, P> const & q);
  template <typename U>
                tquat<T, P> & operator*=(U s);
  template <typename U>
                tquat<T, P> & operator/=(U s);
 };



 template <typename T, precision P>
               tquat<T, P> operator+(tquat<T, P> const & q);

 template <typename T, precision P>
               tquat<T, P> operator-(tquat<T, P> const & q);



 template <typename T, precision P>
               tquat<T, P> operator+(tquat<T, P> const & q, tquat<T, P> const & p);

 template <typename T, precision P>
               tquat<T, P> operator*(tquat<T, P> const & q, tquat<T, P> const & p);

 template <typename T, precision P>
               tvec3<T, P> operator*(tquat<T, P> const & q, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q);

 template <typename T, precision P>
               tvec4<T, P> operator*(tquat<T, P> const & q, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q);

 template <typename T, precision P>
               tquat<T, P> operator*(tquat<T, P> const & q, T const & s);

 template <typename T, precision P>
               tquat<T, P> operator*(T const & s, tquat<T, P> const & q);

 template <typename T, precision P>
               tquat<T, P> operator/(tquat<T, P> const & q, T const & s);



 template <typename T, precision P>
               bool operator==(tquat<T, P> const & q1, tquat<T, P> const & q2);

 template <typename T, precision P>
               bool operator!=(tquat<T, P> const & q1, tquat<T, P> const & q2);




 template <typename T, precision P>
               T length(tquat<T, P> const & q);




 template <typename T, precision P>
               tquat<T, P> normalize(tquat<T, P> const & q);




 template <typename T, precision P, template <typename, precision> class quatType>
               T dot(quatType<T, P> const & x, quatType<T, P> const & y);
# 207 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a);
# 218 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);
# 229 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> slerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);




 template <typename T, precision P>
               tquat<T, P> conjugate(tquat<T, P> const & q);




 template <typename T, precision P>
               tquat<T, P> inverse(tquat<T, P> const & q);
# 251 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & axis);





 template <typename T, precision P>
               tvec3<T, P> eulerAngles(tquat<T, P> const & x);




 template <typename T, precision P>
               T roll(tquat<T, P> const & x);




 template <typename T, precision P>
               T pitch(tquat<T, P> const & x);




 template <typename T, precision P>
               T yaw(tquat<T, P> const & x);




 template <typename T, precision P>
               tmat3x3<T, P> mat3_cast(tquat<T, P> const & x);




 template <typename T, precision P>
               tmat4x4<T, P> mat4_cast(tquat<T, P> const & x);




 template <typename T, precision P>
               tquat<T, P> quat_cast(tmat3x3<T, P> const & x);




 template <typename T, precision P>
               tquat<T, P> quat_cast(tmat4x4<T, P> const & x);




 template <typename T, precision P>
               T angle(tquat<T, P> const & x);




 template <typename T, precision P>
               tvec3<T, P> axis(tquat<T, P> const & x);







 template <typename T, precision P>
               tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & axis);






 template <typename T, precision P>
               tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y);
# 381 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tvec4<bool, P> isnan(tquat<T, P> const & x);
# 391 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tvec4<bool, P> isinf(tquat<T, P> const & x);


}


# 1 "/usr/local/include/glm/gtc/quaternion.inl" 1 3








namespace glm{
namespace detail
{
 template <typename T, precision P, bool Aligned>
 struct compute_dot<tquat, T, P, Aligned>
 {
  static inline T call(tquat<T, P> const& x, tquat<T, P> const& y)
  {
   tvec4<T, P> tmp(x.x * y.x, x.y * y.y, x.z * y.z, x.w * y.w);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_add
 {
  static tquat<T, P> call(tquat<T, P> const& q, tquat<T, P> const& p)
  {
   return tquat<T, P>(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_sub
 {
  static tquat<T, P> call(tquat<T, P> const& q, tquat<T, P> const& p)
  {
   return tquat<T, P>(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_mul_scalar
 {
  static tquat<T, P> call(tquat<T, P> const& q, T s)
  {
   return tquat<T, P>(q.w * s, q.x * s, q.y * s, q.z * s);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_div_scalar
 {
  static tquat<T, P> call(tquat<T, P> const& q, T s)
  {
   return tquat<T, P>(q.w / s, q.x / s, q.y / s, q.z / s);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_mul_vec4
 {
  static tvec4<T, P> call(tquat<T, P> const & q, tvec4<T, P> const & v)
  {
   return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
  }
 };
}



 template <typename T, precision P> inline
                    T & tquat<T, P>::operator[](typename tquat<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 73, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tquat<T, P>::operator[](typename tquat<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 80, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                                   tquat<T, P>::tquat()

    : x(0), y(0), z(0), w(1)

  {}



  template <typename T, precision P> inline
                                   tquat<T, P>::tquat(tquat<T, P> const & q)
   : x(q.x), y(q.y), z(q.z), w(q.w)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                  tquat<T, P>::tquat(tquat<T, Q> const & q)
  : x(q.x), y(q.y), z(q.z), w(q.w)
 {}



 template <typename T, precision P> inline
                                       tquat<T, P>::tquat(ctor)
 {}

 template <typename T, precision P> inline
                                  tquat<T, P>::tquat(T const & s, tvec3<T, P> const & v)
  : x(v.x), y(v.y), z(v.z), w(s)
 {}

 template <typename T, precision P> inline
                                  tquat<T, P>::tquat(T const & w, T const & x, T const & y, T const & z)
  : x(x), y(y), z(z), w(w)
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                  tquat<T, P>::tquat(tquat<U, Q> const & q)
  : x(static_cast<T>(q.x))
  , y(static_cast<T>(q.y))
  , z(static_cast<T>(q.z))
  , w(static_cast<T>(q.w))
 {}
# 153 "/usr/local/include/glm/gtc/quaternion.inl" 3
 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tvec3<T, P> const & u, tvec3<T, P> const & v)
 {
  tvec3<T, P> const LocalW(cross(u, v));
  T Dot = detail::compute_dot<tvec3, T, P, detail::is_aligned<P>::value>::call(u, v);
  tquat<T, P> q(T(1) + Dot, LocalW.x, LocalW.y, LocalW.z);

  *this = normalize(q);
 }

 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tvec3<T, P> const & eulerAngle)
 {
  tvec3<T, P> c = glm::cos(eulerAngle * T(0.5));
  tvec3<T, P> s = glm::sin(eulerAngle * T(0.5));

  this->w = c.x * c.y * c.z + s.x * s.y * s.z;
  this->x = s.x * c.y * c.z - c.x * s.y * s.z;
  this->y = c.x * s.y * c.z + s.x * c.y * s.z;
  this->z = c.x * c.y * s.z - s.x * s.y * c.z;
 }

 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tmat3x3<T, P> const & m)
 {
  *this = quat_cast(m);
 }

 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tmat4x4<T, P> const & m)
 {
  *this = quat_cast(m);
 }
# 201 "/usr/local/include/glm/gtc/quaternion.inl" 3
 template <typename T, precision P> inline
                    tquat<T, P> conjugate(tquat<T, P> const & q)
 {
  return tquat<T, P>(q.w, -q.x, -q.y, -q.z);
 }

 template <typename T, precision P> inline
                    tquat<T, P> inverse(tquat<T, P> const & q)
 {
  return conjugate(q) / dot(q, q);
 }




  template <typename T, precision P> inline
                     tquat<T, P> & tquat<T, P>::operator=(tquat<T, P> const & q)
  {
   this->w = q.w;
   this->x = q.x;
   this->y = q.y;
   this->z = q.z;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator=(tquat<U, P> const & q)
 {
  this->w = static_cast<T>(q.w);
  this->x = static_cast<T>(q.x);
  this->y = static_cast<T>(q.y);
  this->z = static_cast<T>(q.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator+=(tquat<U, P> const& q)
 {
  return (*this = detail::compute_quat_add<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator-=(tquat<U, P> const& q)
 {
  return (*this = detail::compute_quat_sub<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator*=(tquat<U, P> const & r)
 {
  tquat<T, P> const p(*this);
  tquat<T, P> const q(r);

  this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
  this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
  this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
  this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator*=(U s)
 {
  return (*this = detail::compute_quat_mul_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator/=(U s)
 {
  return (*this = detail::compute_quat_div_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
 }



 template <typename T, precision P> inline
                    tquat<T, P> operator+(tquat<T, P> const & q)
 {
  return q;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator-(tquat<T, P> const & q)
 {
  return tquat<T, P>(-q.w, -q.x, -q.y, -q.z);
 }



 template <typename T, precision P> inline
                    tquat<T, P> operator+(tquat<T, P> const & q, tquat<T, P> const & p)
 {
  return tquat<T, P>(q) += p;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator*(tquat<T, P> const & q, tquat<T, P> const & p)
 {
  return tquat<T, P>(q) *= p;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tquat<T, P> const & q, tvec3<T, P> const & v)
 {
  tvec3<T, P> const QuatVector(q.x, q.y, q.z);
  tvec3<T, P> const uv(glm::cross(QuatVector, v));
  tvec3<T, P> const uuv(glm::cross(QuatVector, uv));

  return v + ((uv * q.w) + uuv) * static_cast<T>(2);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tquat<T, P> const& q, tvec4<T, P> const& v)
 {
  return detail::compute_quat_mul_vec4<T, P, detail::is_aligned<P>::value>::call(q, v);
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator*(tquat<T, P> const & q, T const & s)
 {
  return tquat<T, P>(
   q.w * s, q.x * s, q.y * s, q.z * s);
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator*(T const & s, tquat<T, P> const & q)
 {
  return q * s;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator/(tquat<T, P> const & q, T const & s)
 {
  return tquat<T, P>(
   q.w / s, q.x / s, q.y / s, q.z / s);
 }



 template <typename T, precision P> inline
                    bool operator==(tquat<T, P> const & q1, tquat<T, P> const & q2)
 {
  return (q1.x == q2.x) && (q1.y == q2.y) && (q1.z == q2.z) && (q1.w == q2.w);
 }

 template <typename T, precision P> inline
                    bool operator!=(tquat<T, P> const & q1, tquat<T, P> const & q2)
 {
  return (q1.x != q2.x) || (q1.y != q2.y) || (q1.z != q2.z) || (q1.w != q2.w);
 }



 template <typename T, precision P> inline
                    T length(tquat<T, P> const & q)
 {
  return glm::sqrt(dot(q, q));
 }

 template <typename T, precision P> inline
                    tquat<T, P> normalize(tquat<T, P> const & q)
 {
  T len = length(q);
  if(len <= T(0))
   return tquat<T, P>(1, 0, 0, 0);
  T oneOverLen = T(1) / len;
  return tquat<T, P>(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
 }

 template <typename T, precision P> inline
                    tquat<T, P> cross(tquat<T, P> const & q1, tquat<T, P> const & q2)
 {
  return tquat<T, P>(
   q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
   q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
   q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
   q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
 }
# 474 "/usr/local/include/glm/gtc/quaternion.inl" 3
 template <typename T, precision P> inline
                    tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a)
 {
  T cosTheta = dot(x, y);


  if(cosTheta > T(1) - epsilon<T>())
  {

   return tquat<T, P>(
    mix(x.w, y.w, a),
    mix(x.x, y.x, a),
    mix(x.y, y.y, a),
    mix(x.z, y.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((T(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
  }
 }

 template <typename T, precision P> inline
                    tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a)
 {

  (__builtin_expect(!(a >= static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 501, "a >= static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(a <= static_cast<T>(1)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 502, "a <= static_cast<T>(1)") : (void)0);

  return x * (T(1) - a) + (y * a);
 }

 template <typename T, precision P> inline
                    tquat<T, P> slerp(tquat<T, P> const & x, tquat<T, P> const & y, T a)
 {
  tquat<T, P> z = y;

  T cosTheta = dot(x, y);



  if (cosTheta < T(0))
  {
   z = -y;
   cosTheta = -cosTheta;
  }


  if(cosTheta > T(1) - epsilon<T>())
  {

   return tquat<T, P>(
    mix(x.w, z.w, a),
    mix(x.x, z.x, a),
    mix(x.y, z.y, a),
    mix(x.z, z.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((T(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
  }
 }

 template <typename T, precision P> inline
                    tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & v)
 {
  tvec3<T, P> Tmp = v;


  T len = glm::length(Tmp);
  if(abs(len - T(1)) > T(0.001))
  {
   T oneOverLen = static_cast<T>(1) / len;
   Tmp.x *= oneOverLen;
   Tmp.y *= oneOverLen;
   Tmp.z *= oneOverLen;
  }

  T const AngleRad(angle);
  T const Sin = sin(AngleRad * T(0.5));

  return q * tquat<T, P>(cos(AngleRad * T(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);

 }

 template <typename T, precision P> inline
                    tvec3<T, P> eulerAngles(tquat<T, P> const & x)
 {
  return tvec3<T, P>(pitch(x), yaw(x), roll(x));
 }

 template <typename T, precision P> inline
                    T roll(tquat<T, P> const & q)
 {
  return T(atan(T(2) * (q.x * q.y + q.w * q.z), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z));
 }

 template <typename T, precision P> inline
                    T pitch(tquat<T, P> const & q)
 {
  return T(atan(T(2) * (q.y * q.z + q.w * q.x), q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z));
 }

 template <typename T, precision P> inline
                    T yaw(tquat<T, P> const & q)
 {
  return asin(clamp(T(-2) * (q.x * q.z - q.w * q.y), T(-1), T(1)));
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> mat3_cast(tquat<T, P> const & q)
 {
  tmat3x3<T, P> Result(T(1));
  T qxx(q.x * q.x);
  T qyy(q.y * q.y);
  T qzz(q.z * q.z);
  T qxz(q.x * q.z);
  T qxy(q.x * q.y);
  T qyz(q.y * q.z);
  T qwx(q.w * q.x);
  T qwy(q.w * q.y);
  T qwz(q.w * q.z);

  Result[0][0] = T(1) - T(2) * (qyy + qzz);
  Result[0][1] = T(2) * (qxy + qwz);
  Result[0][2] = T(2) * (qxz - qwy);

  Result[1][0] = T(2) * (qxy - qwz);
  Result[1][1] = T(1) - T(2) * (qxx + qzz);
  Result[1][2] = T(2) * (qyz + qwx);

  Result[2][0] = T(2) * (qxz + qwy);
  Result[2][1] = T(2) * (qyz - qwx);
  Result[2][2] = T(1) - T(2) * (qxx + qyy);
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> mat4_cast(tquat<T, P> const & q)
 {
  return tmat4x4<T, P>(mat3_cast(q));
 }

 template <typename T, precision P> inline
                    tquat<T, P> quat_cast(tmat3x3<T, P> const & m)
 {
  T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
  T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
  T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
  T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

  int biggestIndex = 0;
  T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
  if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourXSquaredMinus1;
   biggestIndex = 1;
  }
  if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourYSquaredMinus1;
   biggestIndex = 2;
  }
  if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourZSquaredMinus1;
   biggestIndex = 3;
  }

  T biggestVal = sqrt(fourBiggestSquaredMinus1 + T(1)) * T(0.5);
  T mult = static_cast<T>(0.25) / biggestVal;

  tquat<T, P> Result(uninitialize);
  switch(biggestIndex)
  {
  case 0:
   Result.w = biggestVal;
   Result.x = (m[1][2] - m[2][1]) * mult;
   Result.y = (m[2][0] - m[0][2]) * mult;
   Result.z = (m[0][1] - m[1][0]) * mult;
   break;
  case 1:
   Result.w = (m[1][2] - m[2][1]) * mult;
   Result.x = biggestVal;
   Result.y = (m[0][1] + m[1][0]) * mult;
   Result.z = (m[2][0] + m[0][2]) * mult;
   break;
  case 2:
   Result.w = (m[2][0] - m[0][2]) * mult;
   Result.x = (m[0][1] + m[1][0]) * mult;
   Result.y = biggestVal;
   Result.z = (m[1][2] + m[2][1]) * mult;
   break;
  case 3:
   Result.w = (m[0][1] - m[1][0]) * mult;
   Result.x = (m[2][0] + m[0][2]) * mult;
   Result.y = (m[1][2] + m[2][1]) * mult;
   Result.z = biggestVal;
   break;

  default:
   (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 678, "false") : (void)0);
   break;
  }
  return Result;
 }

 template <typename T, precision P> inline
                    tquat<T, P> quat_cast(tmat4x4<T, P> const & m4)
 {
  return quat_cast(tmat3x3<T, P>(m4));
 }

 template <typename T, precision P> inline
                    T angle(tquat<T, P> const & x)
 {
  return acos(x.w) * T(2);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> axis(tquat<T, P> const & x)
 {
  T tmp1 = static_cast<T>(1) - x.w * x.w;
  if(tmp1 <= static_cast<T>(0))
   return tvec3<T, P>(0, 0, 1);
  T tmp2 = static_cast<T>(1) / sqrt(tmp1);
  return tvec3<T, P>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
 }

 template <typename T, precision P> inline
                    tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & v)
 {
  tquat<T, P> Result(uninitialize);

  T const a(angle);
  T const s = glm::sin(a * static_cast<T>(0.5));

  Result.w = glm::cos(a * static_cast<T>(0.5));
  Result.x = v.x * s;
  Result.y = v.y * s;
  Result.z = v.z * s;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isnan(tquat<T, P> const& q)
 {
                                                                                                   ;

  return tvec4<bool, P>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isinf(tquat<T, P> const& q)
 {
                                                                                                   ;

  return tvec4<bool, P>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
 }
}
# 397 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 2 3
# 37 "/usr/local/include/glm/gtc/type_ptr.hpp" 2 3
# 56 "/usr/local/include/glm/gtc/type_ptr.hpp" 3
namespace glm
{





 template<typename genType>
               typename genType::value_type const * value_ptr(genType const & vec);



 template<typename T>
               tvec2<T, defaultp> make_vec2(T const * const ptr);



 template<typename T>
               tvec3<T, defaultp> make_vec3(T const * const ptr);



 template<typename T>
               tvec4<T, defaultp> make_vec4(T const * const ptr);



 template<typename T>
               tmat2x2<T, defaultp> make_mat2x2(T const * const ptr);



 template<typename T>
               tmat2x3<T, defaultp> make_mat2x3(T const * const ptr);



 template<typename T>
               tmat2x4<T, defaultp> make_mat2x4(T const * const ptr);



 template<typename T>
               tmat3x2<T, defaultp> make_mat3x2(T const * const ptr);



 template<typename T>
               tmat3x3<T, defaultp> make_mat3x3(T const * const ptr);



 template<typename T>
               tmat3x4<T, defaultp> make_mat3x4(T const * const ptr);



 template<typename T>
               tmat4x2<T, defaultp> make_mat4x2(T const * const ptr);



 template<typename T>
               tmat4x3<T, defaultp> make_mat4x3(T const * const ptr);



 template<typename T>
               tmat4x4<T, defaultp> make_mat4x4(T const * const ptr);



 template<typename T>
               tmat2x2<T, defaultp> make_mat2(T const * const ptr);



 template<typename T>
               tmat3x3<T, defaultp> make_mat3(T const * const ptr);



 template<typename T>
               tmat4x4<T, defaultp> make_mat4(T const * const ptr);



 template<typename T>
               tquat<T, defaultp> make_quat(T const * const ptr);


}


# 1 "/usr/local/include/glm/gtc/type_ptr.inl" 1 3





namespace glm
{





 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tvec2<T, P> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tvec2<T, P> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tvec3<T, P> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tvec3<T, P> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tvec4<T, P> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tvec4<T, P> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat2x2<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat2x2<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat3x3<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat3x3<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat4x4<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat4x4<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat2x3<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat2x3<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat3x2<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat3x2<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat2x4<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat2x4<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat4x2<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat4x2<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat3x4<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat3x4<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat4x3<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr(tmat4x3<T, P> & mat)
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tquat<T, P> const & q
 )
 {
  return &(q[0]);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tquat<T, P> & q
 )
 {
  return &(q[0]);
 }



 template <typename T> inline
                    tvec2<T, defaultp> make_vec2(T const * const ptr)
 {
  tvec2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tvec3<T, defaultp> make_vec3(T const * const ptr)
 {
  tvec3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tvec4<T, defaultp> make_vec4(T const * const ptr)
 {
  tvec4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x2<T, defaultp> make_mat2x2(T const * const ptr)
 {
  tmat2x2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x3<T, defaultp> make_mat2x3(T const * const ptr)
 {
  tmat2x3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x4<T, defaultp> make_mat2x4(T const * const ptr)
 {
  tmat2x4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat3x2<T, defaultp> make_mat3x2(T const * const ptr)
 {
  tmat3x2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat3x3<T, defaultp> make_mat3x3(T const * const ptr)
 {
  tmat3x3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat3x4<T, defaultp> make_mat3x4(T const * const ptr)
 {
  tmat3x4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat4x2<T, defaultp> make_mat4x2(T const * const ptr)
 {
  tmat4x2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat4x3<T, defaultp> make_mat4x3(T const * const ptr)
 {
  tmat4x3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat4x4<T, defaultp> make_mat4x4(T const * const ptr)
 {
  tmat4x4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x2<T, defaultp> make_mat2(T const * const ptr)
 {
  return make_mat2x2(ptr);
 }



 template <typename T> inline
                    tmat3x3<T, defaultp> make_mat3(T const * const ptr)
 {
  return make_mat3x3(ptr);
 }



 template <typename T> inline
                    tmat4x4<T, defaultp> make_mat4(T const * const ptr)
 {
  return make_mat4x4(ptr);
 }



 template <typename T> inline
                    tquat<T, defaultp> make_quat(T const * const ptr)
 {
  tquat<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));
  return Result;
 }


}
# 149 "/usr/local/include/glm/gtc/type_ptr.hpp" 2 3
# 15 "./common_utils_cpp.hpp" 2
# 1 "/usr/local/include/glm/ext.hpp" 1 3
# 37 "/usr/local/include/glm/ext.hpp" 3
# 1 "/usr/local/include/glm/./gtc/bitfield.hpp" 1 3
# 27 "/usr/local/include/glm/./gtc/bitfield.hpp" 3
namespace glm
{






 template <typename genIUType>
               genIUType mask(genIUType Bits);




 template <typename T, precision P, template <typename, precision> class vecIUType>
               vecIUType<T, P> mask(vecIUType<T, P> const & v);




 template <typename genIUType>
               genIUType bitfieldRotateRight(genIUType In, int Shift);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldRotateRight(vecType<T, P> const & In, int Shift);




 template <typename genIUType>
               genIUType bitfieldRotateLeft(genIUType In, int Shift);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldRotateLeft(vecType<T, P> const & In, int Shift);




 template <typename genIUType>
               genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldFillOne(vecType<T, P> const & Value, int FirstBit, int BitCount);




 template <typename genIUType>
               genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldFillZero(vecType<T, P> const & Value, int FirstBit, int BitCount);






               int16 bitfieldInterleave(int8 x, int8 y);






               uint16 bitfieldInterleave(uint8 x, uint8 y);






               int32 bitfieldInterleave(int16 x, int16 y);






               uint32 bitfieldInterleave(uint16 x, uint16 y);






               int64 bitfieldInterleave(int32 x, int32 y);






               uint64 bitfieldInterleave(uint32 x, uint32 y);






               int32 bitfieldInterleave(int8 x, int8 y, int8 z);






               uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z);






               int64 bitfieldInterleave(int16 x, int16 y, int16 z);






               uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z);






               int64 bitfieldInterleave(int32 x, int32 y, int32 z);






               uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z);






               int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w);






               uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w);






               int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w);






               uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w);


}


# 1 "/usr/local/include/glm/gtc/bitfield.inl" 1 3



# 1 "/usr/local/include/glm/gtc/../simd/integer.h" 1 3
 inline






                   glm_uvec4 glm_i128_interleave(glm_uvec4 x)
{
 glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
 glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
 glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
 glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
 glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);

 glm_uvec4 Reg1;
 glm_uvec4 Reg2;




 Reg1 = x;



 Reg2 = __extension__ ({
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (2)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask4);



 Reg2 = __extension__ ({
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (1)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask3);



 Reg2 = _mm_slli_epi32(Reg1, 4);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask2);



 Reg2 = _mm_slli_epi32(Reg1, 2);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask1);



 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask0);


 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg2 = __extension__ ({
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg2);
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_psrldqi128(__a, (8)*8); });
 Reg1 = _mm_or_si128(Reg1, Reg2);

 return Reg1;
} inline

                   glm_uvec4 glm_i128_interleave2(glm_uvec4 x, glm_uvec4 y)
{
 glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
 glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
 glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
 glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
 glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);

 glm_uvec4 Reg1;
 glm_uvec4 Reg2;



 Reg1 = _mm_unpacklo_epi64(x, y);



 Reg2 = __extension__ ({
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (2)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask4);



 Reg2 = __extension__ ({
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (1)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask3);



 Reg2 = _mm_slli_epi32(Reg1, 4);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask2);



 Reg2 = _mm_slli_epi32(Reg1, 2);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask1);



 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask0);


 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg2 = __extension__ ({
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg2);
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_psrldqi128(__a, (8)*8); });
 Reg1 = _mm_or_si128(Reg1, Reg2);

 return Reg1;
}
# 4 "/usr/local/include/glm/gtc/bitfield.inl" 2 3


namespace glm{
namespace detail
{
 template <typename PARAM, typename RET>
               RET bitfieldInterleave(PARAM x, PARAM y);

 template <typename PARAM, typename RET>
               RET bitfieldInterleave(PARAM x, PARAM y, PARAM z);

 template <typename PARAM, typename RET>
               RET bitfieldInterleave(PARAM x, PARAM y, PARAM z, PARAM w);

 template <> inline
                    glm::uint16 bitfieldInterleave(glm::uint8 x, glm::uint8 y)
 {
  glm::uint16 REG1(x);
  glm::uint16 REG2(y);

  REG1 = ((REG1 << 4) | REG1) & glm::uint16(0x0F0F);
  REG2 = ((REG2 << 4) | REG2) & glm::uint16(0x0F0F);

  REG1 = ((REG1 << 2) | REG1) & glm::uint16(0x3333);
  REG2 = ((REG2 << 2) | REG2) & glm::uint16(0x3333);

  REG1 = ((REG1 << 1) | REG1) & glm::uint16(0x5555);
  REG2 = ((REG2 << 1) | REG2) & glm::uint16(0x5555);

  return REG1 | (REG2 << 1);
 }

 template <> inline
                    glm::uint32 bitfieldInterleave(glm::uint16 x, glm::uint16 y)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);

  REG1 = ((REG1 << 8) | REG1) & glm::uint32(0x00FF00FF);
  REG2 = ((REG2 << 8) | REG2) & glm::uint32(0x00FF00FF);

  REG1 = ((REG1 << 4) | REG1) & glm::uint32(0x0F0F0F0F);
  REG2 = ((REG2 << 4) | REG2) & glm::uint32(0x0F0F0F0F);

  REG1 = ((REG1 << 2) | REG1) & glm::uint32(0x33333333);
  REG2 = ((REG2 << 2) | REG2) & glm::uint32(0x33333333);

  REG1 = ((REG1 << 1) | REG1) & glm::uint32(0x55555555);
  REG2 = ((REG2 << 1) | REG2) & glm::uint32(0x55555555);

  return REG1 | (REG2 << 1);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);

  REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x0000FFFF0000FFFFull);
  REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x0000FFFF0000FFFFull);

  REG1 = ((REG1 << 8) | REG1) & glm::uint64(0x00FF00FF00FF00FFull);
  REG2 = ((REG2 << 8) | REG2) & glm::uint64(0x00FF00FF00FF00FFull);

  REG1 = ((REG1 << 4) | REG1) & glm::uint64(0x0F0F0F0F0F0F0F0Full);
  REG2 = ((REG2 << 4) | REG2) & glm::uint64(0x0F0F0F0F0F0F0F0Full);

  REG1 = ((REG1 << 2) | REG1) & glm::uint64(0x3333333333333333ull);
  REG2 = ((REG2 << 2) | REG2) & glm::uint64(0x3333333333333333ull);

  REG1 = ((REG1 << 1) | REG1) & glm::uint64(0x5555555555555555ull);
  REG2 = ((REG2 << 1) | REG2) & glm::uint64(0x5555555555555555ull);

  return REG1 | (REG2 << 1);
 }

 template <> inline
                    glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);
  glm::uint32 REG3(z);

  REG1 = ((REG1 << 16) | REG1) & glm::uint32(0x00FF0000FF0000FF);
  REG2 = ((REG2 << 16) | REG2) & glm::uint32(0x00FF0000FF0000FF);
  REG3 = ((REG3 << 16) | REG3) & glm::uint32(0x00FF0000FF0000FF);

  REG1 = ((REG1 << 8) | REG1) & glm::uint32(0xF00F00F00F00F00F);
  REG2 = ((REG2 << 8) | REG2) & glm::uint32(0xF00F00F00F00F00F);
  REG3 = ((REG3 << 8) | REG3) & glm::uint32(0xF00F00F00F00F00F);

  REG1 = ((REG1 << 4) | REG1) & glm::uint32(0x30C30C30C30C30C3);
  REG2 = ((REG2 << 4) | REG2) & glm::uint32(0x30C30C30C30C30C3);
  REG3 = ((REG3 << 4) | REG3) & glm::uint32(0x30C30C30C30C30C3);

  REG1 = ((REG1 << 2) | REG1) & glm::uint32(0x9249249249249249);
  REG2 = ((REG2 << 2) | REG2) & glm::uint32(0x9249249249249249);
  REG3 = ((REG3 << 2) | REG3) & glm::uint32(0x9249249249249249);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);

  REG1 = ((REG1 << 32) | REG1) & glm::uint64(0xFFFF00000000FFFFull);
  REG2 = ((REG2 << 32) | REG2) & glm::uint64(0xFFFF00000000FFFFull);
  REG3 = ((REG3 << 32) | REG3) & glm::uint64(0xFFFF00000000FFFFull);

  REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x00FF0000FF0000FFull);
  REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x00FF0000FF0000FFull);
  REG3 = ((REG3 << 16) | REG3) & glm::uint64(0x00FF0000FF0000FFull);

  REG1 = ((REG1 << 8) | REG1) & glm::uint64(0xF00F00F00F00F00Full);
  REG2 = ((REG2 << 8) | REG2) & glm::uint64(0xF00F00F00F00F00Full);
  REG3 = ((REG3 << 8) | REG3) & glm::uint64(0xF00F00F00F00F00Full);

  REG1 = ((REG1 << 4) | REG1) & glm::uint64(0x30C30C30C30C30C3ull);
  REG2 = ((REG2 << 4) | REG2) & glm::uint64(0x30C30C30C30C30C3ull);
  REG3 = ((REG3 << 4) | REG3) & glm::uint64(0x30C30C30C30C30C3ull);

  REG1 = ((REG1 << 2) | REG1) & glm::uint64(0x9249249249249249ull);
  REG2 = ((REG2 << 2) | REG2) & glm::uint64(0x9249249249249249ull);
  REG3 = ((REG3 << 2) | REG3) & glm::uint64(0x9249249249249249ull);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y, glm::uint32 z)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);

  REG1 = ((REG1 << 32) | REG1) & glm::uint64(0xFFFF00000000FFFFull);
  REG2 = ((REG2 << 32) | REG2) & glm::uint64(0xFFFF00000000FFFFull);
  REG3 = ((REG3 << 32) | REG3) & glm::uint64(0xFFFF00000000FFFFull);

  REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x00FF0000FF0000FFull);
  REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x00FF0000FF0000FFull);
  REG3 = ((REG3 << 16) | REG3) & glm::uint64(0x00FF0000FF0000FFull);

  REG1 = ((REG1 << 8) | REG1) & glm::uint64(0xF00F00F00F00F00Full);
  REG2 = ((REG2 << 8) | REG2) & glm::uint64(0xF00F00F00F00F00Full);
  REG3 = ((REG3 << 8) | REG3) & glm::uint64(0xF00F00F00F00F00Full);

  REG1 = ((REG1 << 4) | REG1) & glm::uint64(0x30C30C30C30C30C3ull);
  REG2 = ((REG2 << 4) | REG2) & glm::uint64(0x30C30C30C30C30C3ull);
  REG3 = ((REG3 << 4) | REG3) & glm::uint64(0x30C30C30C30C30C3ull);

  REG1 = ((REG1 << 2) | REG1) & glm::uint64(0x9249249249249249ull);
  REG2 = ((REG2 << 2) | REG2) & glm::uint64(0x9249249249249249ull);
  REG3 = ((REG3 << 2) | REG3) & glm::uint64(0x9249249249249249ull);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template <> inline
                    glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z, glm::uint8 w)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);
  glm::uint32 REG3(z);
  glm::uint32 REG4(w);

  REG1 = ((REG1 << 12) | REG1) & glm::uint32(0x000F000F000F000F);
  REG2 = ((REG2 << 12) | REG2) & glm::uint32(0x000F000F000F000F);
  REG3 = ((REG3 << 12) | REG3) & glm::uint32(0x000F000F000F000F);
  REG4 = ((REG4 << 12) | REG4) & glm::uint32(0x000F000F000F000F);

  REG1 = ((REG1 << 6) | REG1) & glm::uint32(0x0303030303030303);
  REG2 = ((REG2 << 6) | REG2) & glm::uint32(0x0303030303030303);
  REG3 = ((REG3 << 6) | REG3) & glm::uint32(0x0303030303030303);
  REG4 = ((REG4 << 6) | REG4) & glm::uint32(0x0303030303030303);

  REG1 = ((REG1 << 3) | REG1) & glm::uint32(0x1111111111111111);
  REG2 = ((REG2 << 3) | REG2) & glm::uint32(0x1111111111111111);
  REG3 = ((REG3 << 3) | REG3) & glm::uint32(0x1111111111111111);
  REG4 = ((REG4 << 3) | REG4) & glm::uint32(0x1111111111111111);

  return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z, glm::uint16 w)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);
  glm::uint64 REG4(w);

  REG1 = ((REG1 << 24) | REG1) & glm::uint64(0x000000FF000000FFull);
  REG2 = ((REG2 << 24) | REG2) & glm::uint64(0x000000FF000000FFull);
  REG3 = ((REG3 << 24) | REG3) & glm::uint64(0x000000FF000000FFull);
  REG4 = ((REG4 << 24) | REG4) & glm::uint64(0x000000FF000000FFull);

  REG1 = ((REG1 << 12) | REG1) & glm::uint64(0x000F000F000F000Full);
  REG2 = ((REG2 << 12) | REG2) & glm::uint64(0x000F000F000F000Full);
  REG3 = ((REG3 << 12) | REG3) & glm::uint64(0x000F000F000F000Full);
  REG4 = ((REG4 << 12) | REG4) & glm::uint64(0x000F000F000F000Full);

  REG1 = ((REG1 << 6) | REG1) & glm::uint64(0x0303030303030303ull);
  REG2 = ((REG2 << 6) | REG2) & glm::uint64(0x0303030303030303ull);
  REG3 = ((REG3 << 6) | REG3) & glm::uint64(0x0303030303030303ull);
  REG4 = ((REG4 << 6) | REG4) & glm::uint64(0x0303030303030303ull);

  REG1 = ((REG1 << 3) | REG1) & glm::uint64(0x1111111111111111ull);
  REG2 = ((REG2 << 3) | REG2) & glm::uint64(0x1111111111111111ull);
  REG3 = ((REG3 << 3) | REG3) & glm::uint64(0x1111111111111111ull);
  REG4 = ((REG4 << 3) | REG4) & glm::uint64(0x1111111111111111ull);

  return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
 }
}

 template <typename genIUType> inline
                    genIUType mask(genIUType Bits)
 {
                                                                                                     ;

  return Bits >= sizeof(genIUType) * 8 ? ~static_cast<genIUType>(0) : (static_cast<genIUType>(1) << Bits) - static_cast<genIUType>(1);
 }

 template <typename T, precision P, template <typename, precision> class vecIUType> inline
                    vecIUType<T, P> mask(vecIUType<T, P> const& v)
 {
                                                                                             ;

  return detail::functor1<T, T, P, vecIUType>::call(mask, v);
 }

 template <typename genIType> inline
                    genIType bitfieldRotateRight(genIType In, int Shift)
 {
                                                                                                                   ;

  int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
  return (In << static_cast<genIType>(Shift)) | (In >> static_cast<genIType>(BitSize - Shift));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldRotateRight(vecType<T, P> const & In, int Shift)
 {
                                                                                                            ;

  int const BitSize = static_cast<int>(sizeof(T) * 8);
  return (In << static_cast<T>(Shift)) | (In >> static_cast<T>(BitSize - Shift));
 }

 template <typename genIType> inline
                    genIType bitfieldRotateLeft(genIType In, int Shift)
 {
                                                                                                                  ;

  int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
  return (In >> static_cast<genIType>(Shift)) | (In << static_cast<genIType>(BitSize - Shift));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldRotateLeft(vecType<T, P> const& In, int Shift)
 {
                                                                                                           ;

  int const BitSize = static_cast<int>(sizeof(T) * 8);
  return (In >> static_cast<T>(Shift)) | (In << static_cast<T>(BitSize - Shift));
 }

 template <typename genIUType> inline
                    genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount)
 {
  return Value | static_cast<genIUType>(mask(BitCount) << FirstBit);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldFillOne(vecType<T, P> const& Value, int FirstBit, int BitCount)
 {
  return Value | static_cast<T>(mask(BitCount) << FirstBit);
 }

 template <typename genIUType> inline
                    genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount)
 {
  return Value & static_cast<genIUType>(~(mask(BitCount) << FirstBit));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldFillZero(vecType<T, P> const& Value, int FirstBit, int BitCount)
 {
  return Value & static_cast<T>(~(mask(BitCount) << FirstBit));
 } inline

                    int16 bitfieldInterleave(int8 x, int8 y)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y;

  union sign16
  {
   int16 i;
   uint16 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 } inline

                    uint16 bitfieldInterleave(uint8 x, uint8 y)
 {
  return detail::bitfieldInterleave<uint8, uint16>(x, y);
 } inline

                    int32 bitfieldInterleave(int16 x, int16 y)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 } inline

                    uint32 bitfieldInterleave(uint16 x, uint16 y)
 {
  return detail::bitfieldInterleave<uint16, uint32>(x, y);
 } inline

                    int64 bitfieldInterleave(int32 x, int32 y)
 {
  union sign32
  {
   int32 i;
   uint32 u;
  } sign_x, sign_y;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint32 x, uint32 y)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y);
 } inline

                    int32 bitfieldInterleave(int8 x, int8 y, int8 z)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y, sign_z;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 } inline

                    uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z)
 {
  return detail::bitfieldInterleave<uint8, uint32>(x, y, z);
 } inline

                    int64 bitfieldInterleave(int16 x, int16 y, int16 z)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y, sign_z;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
 } inline

                    int64 bitfieldInterleave(int32 x, int32 y, int32 z)
 {
  union sign16
  {
   int32 i;
   uint32 u;
  } sign_x, sign_y, sign_z;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
 } inline

                    int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y, sign_z, sign_w;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  sign_w.i = w;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

  return result.i;
 } inline

                    uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w)
 {
  return detail::bitfieldInterleave<uint8, uint32>(x, y, z, w);
 } inline

                    int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y, sign_z, sign_w;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  sign_w.i = w;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w)
 {
  return detail::bitfieldInterleave<uint16, uint64>(x, y, z, w);
 }
}
# 207 "/usr/local/include/glm/./gtc/bitfield.hpp" 2 3
# 37 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/color_space.hpp" 1 3
# 28 "/usr/local/include/glm/./gtc/color_space.hpp" 3
namespace glm
{





 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertLinearToSRGB(vecType<T, P> const & ColorLinear);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertLinearToSRGB(vecType<T, P> const & ColorLinear, T Gamma);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertSRGBToLinear(vecType<T, P> const & ColorSRGB);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertSRGBToLinear(vecType<T, P> const & ColorSRGB, T Gamma);


}


# 1 "/usr/local/include/glm/gtc/color_space.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_rgbToSrgb
 { inline
                     static vecType<T, P> call(vecType<T, P> const& ColorRGB, T GammaCorrection)
  {
   vecType<T, P> const ClampedColor(clamp(ColorRGB, static_cast<T>(0), static_cast<T>(1)));

   return mix(
    pow(ClampedColor, vecType<T, P>(GammaCorrection)) * static_cast<T>(1.055) - static_cast<T>(0.055),
    ClampedColor * static_cast<T>(12.92),
    lessThan(ClampedColor, vecType<T, P>(static_cast<T>(0.0031308))));
  }
 };

 template <typename T, precision P>
 struct compute_rgbToSrgb<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const& ColorRGB, T GammaCorrection)
  {
   return tvec4<T, P>(compute_rgbToSrgb<T, P, tvec3>::call(tvec3<T, P>(ColorRGB), GammaCorrection), ColorRGB.w);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_srgbToRgb
 { inline
                     static vecType<T, P> call(vecType<T, P> const& ColorSRGB, T Gamma)
  {
   return mix(
    pow((ColorSRGB + static_cast<T>(0.055)) * static_cast<T>(0.94786729857819905213270142180095), vecType<T, P>(Gamma)),
    ColorSRGB * static_cast<T>(0.07739938080495356037151702786378),
    lessThanEqual(ColorSRGB, vecType<T, P>(static_cast<T>(0.04045))));
  }
 };

 template <typename T, precision P>
 struct compute_srgbToRgb<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const& ColorSRGB, T Gamma)
  {
   return tvec4<T, P>(compute_srgbToRgb<T, P, tvec3>::call(tvec3<T, P>(ColorSRGB), Gamma), ColorSRGB.w);
  }
 };
}

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertLinearToSRGB(vecType<T, P> const& ColorLinear)
 {
  return detail::compute_rgbToSrgb<T, P, vecType>::call(ColorLinear, static_cast<T>(0.41666));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertLinearToSRGB(vecType<T, P> const& ColorLinear, T Gamma)
 {
  return detail::compute_rgbToSrgb<T, P, vecType>::call(ColorLinear, static_cast<T>(1) / Gamma);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertSRGBToLinear(vecType<T, P> const& ColorSRGB)
 {
  return detail::compute_srgbToRgb<T, P, vecType>::call(ColorSRGB, static_cast<T>(2.4));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertSRGBToLinear(vecType<T, P> const& ColorSRGB, T Gamma)
 {
  return detail::compute_srgbToRgb<T, P, vecType>::call(ColorSRGB, Gamma);
 }
}
# 56 "/usr/local/include/glm/./gtc/color_space.hpp" 2 3
# 38 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/epsilon.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/epsilon.hpp" 3
namespace glm
{







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> epsilonEqual(
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  T const & epsilon);





 template <typename genType>
               bool epsilonEqual(
  genType const & x,
  genType const & y,
  genType const & epsilon);





 template <typename genType>
               typename genType::boolType epsilonNotEqual(
  genType const & x,
  genType const & y,
  typename genType::value_type const & epsilon);





 template <typename genType>
               bool epsilonNotEqual(
  genType const & x,
  genType const & y,
  genType const & epsilon);


}


# 1 "/usr/local/include/glm/gtc/epsilon.inl" 1 3
# 12 "/usr/local/include/glm/gtc/epsilon.inl" 3
namespace glm
{
 template <> inline
                    bool epsilonEqual
 (
  float const & x,
  float const & y,
  float const & epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template <> inline
                    bool epsilonEqual
 (
  double const & x,
  double const & y,
  double const & epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template <> inline
                    bool epsilonNotEqual
 (
  float const & x,
  float const & y,
  float const & epsilon
 )
 {
  return abs(x - y) >= epsilon;
 }

 template <> inline
                    bool epsilonNotEqual
 (
  double const & x,
  double const & y,
  double const & epsilon
 )
 {
  return abs(x - y) >= epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  T const & epsilon
 )
 {
  return lessThan(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  vecType<T, P> const & epsilon
 )
 {
  return lessThan(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonNotEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  T const & epsilon
 )
 {
  return greaterThanEqual(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonNotEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  vecType<T, P> const & epsilon
 )
 {
  return greaterThanEqual(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> epsilonEqual
 (
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & epsilon
 )
 {
  tvec4<T, P> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), tvec4<T, P>(epsilon));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> epsilonNotEqual
 (
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & epsilon
 )
 {
  tvec4<T, P> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), tvec4<T, P>(epsilon));
 }
}
# 73 "/usr/local/include/glm/./gtc/epsilon.hpp" 2 3
# 40 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/functions.hpp" 1 3
# 26 "/usr/local/include/glm/./gtc/functions.hpp" 3
namespace glm
{






 template <typename T>
               T gauss(
  T x,
  T ExpectedValue,
  T StandardDeviation);




 template <typename T, precision P>
               T gauss(
  tvec2<T, P> const& Coord,
  tvec2<T, P> const& ExpectedValue,
  tvec2<T, P> const& StandardDeviation);


}


# 1 "/usr/local/include/glm/gtc/functions.inl" 1 3





namespace glm
{
 template <typename T> inline
                    T gauss
 (
  T x,
  T ExpectedValue,
  T StandardDeviation
 )
 {
  return exp(-((x - ExpectedValue) * (x - ExpectedValue)) / (static_cast<T>(2) * StandardDeviation * StandardDeviation)) / (StandardDeviation * sqrt(static_cast<T>(6.28318530717958647692528676655900576)));
 }

 template <typename T, precision P> inline
                    T gauss
 (
  tvec2<T, P> const& Coord,
  tvec2<T, P> const& ExpectedValue,
  tvec2<T, P> const& StandardDeviation
 )
 {
  tvec2<T, P> const Squared = ((Coord - ExpectedValue) * (Coord - ExpectedValue)) / (static_cast<T>(2) * StandardDeviation * StandardDeviation);
  return exp(-(Squared.x + Squared.y));
 }
}
# 52 "/usr/local/include/glm/./gtc/functions.hpp" 2 3
# 41 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/integer.hpp" 1 3
# 28 "/usr/local/include/glm/./gtc/integer.hpp" 3
namespace glm
{





 template <typename genIUType>
               genIUType log2(genIUType x);
# 46 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename genIUType>
               genIUType mod(genIUType x, genIUType y);
# 58 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, T y);
# 70 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y);
# 83 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> iround(vecType<T, P> const & x);
# 96 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<uint, P> uround(vecType<T, P> const & x);


}


# 1 "/usr/local/include/glm/gtc/integer.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_log2<T, P, vecType, false, Aligned>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & vec)
  {


   return vecType<T, P>(detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(vec));
  }
 };
# 35 "/usr/local/include/glm/gtc/integer.inl" 3
}
 template <typename genType> inline
                    int iround(genType x)
 {
                                                                                                          ;
  (__builtin_expect(!(static_cast<genType>(0.0) <= x), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 40, "static_cast<genType>(0.0) <= x") : (void)0);

  return static_cast<int>(x + static_cast<genType>(0.5));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<int, P> iround(vecType<T, P> const& x)
 {
                                                                                                    ;
  (__builtin_expect(!(all(lessThanEqual(vecType<T, P>(0), x))), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 49, "all(lessThanEqual(vecType<T, P>(0), x))") : (void)0);

  return vecType<int, P>(x + static_cast<T>(0.5));
 }

 template <typename genType> inline
                    uint uround(genType x)
 {
                                                                                                          ;
  (__builtin_expect(!(static_cast<genType>(0.0) <= x), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 58, "static_cast<genType>(0.0) <= x") : (void)0);

  return static_cast<uint>(x + static_cast<genType>(0.5));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<uint, P> uround(vecType<T, P> const& x)
 {
                                                                                                    ;
  (__builtin_expect(!(all(lessThanEqual(vecType<T, P>(0), x))), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 67, "all(lessThanEqual(vecType<T, P>(0), x))") : (void)0);

  return vecType<uint, P>(x + static_cast<T>(0.5));
 }
}
# 102 "/usr/local/include/glm/./gtc/integer.hpp" 2 3
# 42 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/matrix_access.hpp" 1 3
# 21 "/usr/local/include/glm/./gtc/matrix_access.hpp" 3
namespace glm
{





 template <typename genType>
               typename genType::row_type row(
  genType const & m,
  length_t index);



 template <typename genType>
               genType row(
  genType const & m,
  length_t index,
  typename genType::row_type const & x);



 template <typename genType>
               typename genType::col_type column(
  genType const & m,
  length_t index);



 template <typename genType>
               genType column(
  genType const & m,
  length_t index,
  typename genType::col_type const & x);


}


# 1 "/usr/local/include/glm/gtc/matrix_access.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType row
 (
  genType const & m,
  length_t index,
  typename genType::row_type const & x
 )
 {
  (__builtin_expect(!(index >= 0 && index < m[0].length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 14, "index >= 0 && index < m[0].length()") : (void)0);

  genType Result = m;
  for(length_t i = 0; i < m.length(); ++i)
   Result[i][index] = x[i];
  return Result;
 }

 template <typename genType> inline
                    typename genType::row_type row
 (
  genType const & m,
  length_t index
 )
 {
  (__builtin_expect(!(index >= 0 && index < m[0].length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 29, "index >= 0 && index < m[0].length()") : (void)0);

  typename genType::row_type Result;
  for(length_t i = 0; i < m.length(); ++i)
   Result[i] = m[i][index];
  return Result;
 }

 template <typename genType> inline
                    genType column
 (
  genType const & m,
  length_t index,
  typename genType::col_type const & x
 )
 {
  (__builtin_expect(!(index >= 0 && index < m.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 45, "index >= 0 && index < m.length()") : (void)0);

  genType Result = m;
  Result[index] = x;
  return Result;
 }

 template <typename genType> inline
                    typename genType::col_type column
 (
  genType const & m,
  length_t index
 )
 {
  (__builtin_expect(!(index >= 0 && index < m.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 59, "index >= 0 && index < m.length()") : (void)0);

  return m[index];
 }
}
# 59 "/usr/local/include/glm/./gtc/matrix_access.hpp" 2 3
# 43 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 1 3
# 29 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
namespace glm
{





 typedef tmat2x2<int, highp> highp_imat2;



 typedef tmat3x3<int, highp> highp_imat3;



 typedef tmat4x4<int, highp> highp_imat4;



 typedef tmat2x2<int, highp> highp_imat2x2;



 typedef tmat2x3<int, highp> highp_imat2x3;



 typedef tmat2x4<int, highp> highp_imat2x4;



 typedef tmat3x2<int, highp> highp_imat3x2;



 typedef tmat3x3<int, highp> highp_imat3x3;



 typedef tmat3x4<int, highp> highp_imat3x4;



 typedef tmat4x2<int, highp> highp_imat4x2;



 typedef tmat4x3<int, highp> highp_imat4x3;



 typedef tmat4x4<int, highp> highp_imat4x4;




 typedef tmat2x2<int, mediump> mediump_imat2;



 typedef tmat3x3<int, mediump> mediump_imat3;



 typedef tmat4x4<int, mediump> mediump_imat4;




 typedef tmat2x2<int, mediump> mediump_imat2x2;



 typedef tmat2x3<int, mediump> mediump_imat2x3;



 typedef tmat2x4<int, mediump> mediump_imat2x4;



 typedef tmat3x2<int, mediump> mediump_imat3x2;



 typedef tmat3x3<int, mediump> mediump_imat3x3;



 typedef tmat3x4<int, mediump> mediump_imat3x4;



 typedef tmat4x2<int, mediump> mediump_imat4x2;



 typedef tmat4x3<int, mediump> mediump_imat4x3;



 typedef tmat4x4<int, mediump> mediump_imat4x4;




 typedef tmat2x2<int, lowp> lowp_imat2;



 typedef tmat3x3<int, lowp> lowp_imat3;



 typedef tmat4x4<int, lowp> lowp_imat4;




 typedef tmat2x2<int, lowp> lowp_imat2x2;



 typedef tmat2x3<int, lowp> lowp_imat2x3;



 typedef tmat2x4<int, lowp> lowp_imat2x4;



 typedef tmat3x2<int, lowp> lowp_imat3x2;



 typedef tmat3x3<int, lowp> lowp_imat3x3;



 typedef tmat3x4<int, lowp> lowp_imat3x4;



 typedef tmat4x2<int, lowp> lowp_imat4x2;



 typedef tmat4x3<int, lowp> lowp_imat4x3;



 typedef tmat4x4<int, lowp> lowp_imat4x4;




 typedef tmat2x2<uint, highp> highp_umat2;



 typedef tmat3x3<uint, highp> highp_umat3;



 typedef tmat4x4<uint, highp> highp_umat4;



 typedef tmat2x2<uint, highp> highp_umat2x2;



 typedef tmat2x3<uint, highp> highp_umat2x3;



 typedef tmat2x4<uint, highp> highp_umat2x4;



 typedef tmat3x2<uint, highp> highp_umat3x2;



 typedef tmat3x3<uint, highp> highp_umat3x3;



 typedef tmat3x4<uint, highp> highp_umat3x4;



 typedef tmat4x2<uint, highp> highp_umat4x2;



 typedef tmat4x3<uint, highp> highp_umat4x3;



 typedef tmat4x4<uint, highp> highp_umat4x4;




 typedef tmat2x2<uint, mediump> mediump_umat2;



 typedef tmat3x3<uint, mediump> mediump_umat3;



 typedef tmat4x4<uint, mediump> mediump_umat4;




 typedef tmat2x2<uint, mediump> mediump_umat2x2;



 typedef tmat2x3<uint, mediump> mediump_umat2x3;



 typedef tmat2x4<uint, mediump> mediump_umat2x4;



 typedef tmat3x2<uint, mediump> mediump_umat3x2;



 typedef tmat3x3<uint, mediump> mediump_umat3x3;



 typedef tmat3x4<uint, mediump> mediump_umat3x4;



 typedef tmat4x2<uint, mediump> mediump_umat4x2;



 typedef tmat4x3<uint, mediump> mediump_umat4x3;



 typedef tmat4x4<uint, mediump> mediump_umat4x4;




 typedef tmat2x2<uint, lowp> lowp_umat2;



 typedef tmat3x3<uint, lowp> lowp_umat3;



 typedef tmat4x4<uint, lowp> lowp_umat4;




 typedef tmat2x2<uint, lowp> lowp_umat2x2;



 typedef tmat2x3<uint, lowp> lowp_umat2x3;



 typedef tmat2x4<uint, lowp> lowp_umat2x4;



 typedef tmat3x2<uint, lowp> lowp_umat3x2;



 typedef tmat3x3<uint, lowp> lowp_umat3x3;



 typedef tmat3x4<uint, lowp> lowp_umat3x4;



 typedef tmat4x2<uint, lowp> lowp_umat4x2;



 typedef tmat4x3<uint, lowp> lowp_umat4x3;



 typedef tmat4x4<uint, lowp> lowp_umat4x4;
# 361 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
 typedef mediump_imat2 imat2;



 typedef mediump_imat3 imat3;



 typedef mediump_imat4 imat4;



 typedef mediump_imat2x2 imat2x2;



 typedef mediump_imat2x3 imat2x3;



 typedef mediump_imat2x4 imat2x4;



 typedef mediump_imat3x2 imat3x2;



 typedef mediump_imat3x3 imat3x3;



 typedef mediump_imat3x4 imat3x4;



 typedef mediump_imat4x2 imat4x2;



 typedef mediump_imat4x3 imat4x3;



 typedef mediump_imat4x4 imat4x4;
# 438 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
 typedef mediump_umat2 umat2;



 typedef mediump_umat3 umat3;



 typedef mediump_umat4 umat4;



 typedef mediump_umat2x2 umat2x2;



 typedef mediump_umat2x3 umat2x3;



 typedef mediump_umat2x4 umat2x4;



 typedef mediump_umat3x2 umat3x2;



 typedef mediump_umat3x3 umat3x3;



 typedef mediump_umat3x4 umat3x4;



 typedef mediump_umat4x2 umat4x2;



 typedef mediump_umat4x3 umat4x3;



 typedef mediump_umat4x4 umat4x4;



}
# 44 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 3
namespace glm
{
# 35 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 3
 template <typename genType>
               genType affineInverse(genType const & m);






 template <typename genType>
               genType inverseTranspose(genType const & m);


}


# 1 "/usr/local/include/glm/gtc/matrix_inverse.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> affineInverse(tmat3x3<T, P> const & m)
 {
  tmat2x2<T, P> const Inv(inverse(tmat2x2<T, P>(m)));

  return tmat3x3<T, P>(
   tvec3<T, P>(Inv[0], static_cast<T>(0)),
   tvec3<T, P>(Inv[1], static_cast<T>(0)),
   tvec3<T, P>(-Inv * tvec2<T, P>(m[2]), static_cast<T>(1)));
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> affineInverse(tmat4x4<T, P> const & m)
 {
  tmat3x3<T, P> const Inv(inverse(tmat3x3<T, P>(m)));

  return tmat4x4<T, P>(
   tvec4<T, P>(Inv[0], static_cast<T>(0)),
   tvec4<T, P>(Inv[1], static_cast<T>(0)),
   tvec4<T, P>(Inv[2], static_cast<T>(0)),
   tvec4<T, P>(-Inv * tvec3<T, P>(m[3]), static_cast<T>(1)));
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> inverseTranspose(tmat2x2<T, P> const & m)
 {
  T Determinant = m[0][0] * m[1][1] - m[1][0] * m[0][1];

  tmat2x2<T, P> Inverse(
   + m[1][1] / Determinant,
   - m[0][1] / Determinant,
   - m[1][0] / Determinant,
   + m[0][0] / Determinant);

  return Inverse;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> inverseTranspose(tmat3x3<T, P> const & m)
 {
  T Determinant =
   + m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
   - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
   + m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

  tmat3x3<T, P> Inverse(uninitialize);
  Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
  Inverse[0][1] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
  Inverse[0][2] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
  Inverse[1][0] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
  Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
  Inverse[1][2] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
  Inverse[2][0] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  Inverse[2][1] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
  Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
  Inverse /= Determinant;

  return Inverse;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> inverseTranspose(tmat4x4<T, P> const & m)
 {
  T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T SubFactor11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
  T SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
  T SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
  T SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
  T SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
  T SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  tmat4x4<T, P> Inverse(uninitialize);
  Inverse[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);
  Inverse[0][1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);
  Inverse[0][2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);
  Inverse[0][3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);

  Inverse[1][0] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);
  Inverse[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);
  Inverse[1][2] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);
  Inverse[1][3] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);

  Inverse[2][0] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);
  Inverse[2][1] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);
  Inverse[2][2] = + (m[0][0] * SubFactor11 - m[0][1] * SubFactor09 + m[0][3] * SubFactor12);
  Inverse[2][3] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor12);

  Inverse[3][0] = - (m[0][1] * SubFactor13 - m[0][2] * SubFactor14 + m[0][3] * SubFactor15);
  Inverse[3][1] = + (m[0][0] * SubFactor13 - m[0][2] * SubFactor16 + m[0][3] * SubFactor17);
  Inverse[3][2] = - (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][3] * SubFactor18);
  Inverse[3][3] = + (m[0][0] * SubFactor15 - m[0][1] * SubFactor17 + m[0][2] * SubFactor18);

  T Determinant =
   + m[0][0] * Inverse[0][0]
   + m[0][1] * Inverse[0][1]
   + m[0][2] * Inverse[0][2]
   + m[0][3] * Inverse[0][3];

  Inverse /= Determinant;

  return Inverse;
 }
}
# 49 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 2 3
# 45 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/noise.hpp" 1 3
# 21 "/usr/local/include/glm/./gtc/noise.hpp" 3
# 1 "/usr/local/include/glm/gtc/../detail/_noise.hpp" 1 3
# 11 "/usr/local/include/glm/gtc/../detail/_noise.hpp" 3
namespace glm{
namespace detail
{
 template <typename T> inline
                    T mod289(T const & x)
 {
  return x - floor(x * static_cast<T>(1.0) / static_cast<T>(289.0)) * static_cast<T>(289.0);
 }

 template <typename T> inline
                    T permute(T const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> permute(tvec2<T, P> const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> permute(tvec3<T, P> const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template <typename T, precision P> inline
                    tvec4<T, P> permute(tvec4<T, P> const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }







 template <typename T> inline
                    T taylorInvSqrt(T const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> taylorInvSqrt(tvec2<T, P> const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> taylorInvSqrt(tvec3<T, P> const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> taylorInvSqrt(tvec4<T, P> const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }
# 81 "/usr/local/include/glm/gtc/../detail/_noise.hpp" 3
 template <typename T, precision P> inline
                    tvec2<T, P> fade(tvec2<T, P> const & t)
 {
  return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> fade(tvec3<T, P> const & t)
 {
  return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> fade(tvec4<T, P> const & t)
 {
  return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
 }







}
}
# 21 "/usr/local/include/glm/./gtc/noise.hpp" 2 3
# 33 "/usr/local/include/glm/./gtc/noise.hpp" 3
namespace glm
{





 template <typename T, precision P, template<typename, precision> class vecType>
               T perlin(
  vecType<T, P> const & p);



 template <typename T, precision P, template<typename, precision> class vecType>
               T perlin(
  vecType<T, P> const & p,
  vecType<T, P> const & rep);



 template <typename T, precision P, template<typename, precision> class vecType>
               T simplex(
  vecType<T, P> const & p);


}


# 1 "/usr/local/include/glm/gtc/noise.inl" 1 3








namespace glm{
namespace gtc
{
 template <typename T, precision P> inline
                    tvec4<T, P> grad4(T const & j, tvec4<T, P> const & ip)
 {
  tvec3<T, P> pXYZ = floor(fract(tvec3<T, P>(j) * tvec3<T, P>(ip)) * T(7)) * ip[2] - T(1);
  T pW = static_cast<T>(1.5) - dot(abs(pXYZ), tvec3<T, P>(1));
  tvec4<T, P> s = tvec4<T, P>(lessThan(tvec4<T, P>(pXYZ, pW), tvec4<T, P>(0.0)));
  pXYZ = pXYZ + (tvec3<T, P>(s) * T(2) - T(1)) * s.w;
  return tvec4<T, P>(pXYZ, pW);
 }
}


 template <typename T, precision P> inline
                    T perlin(tvec2<T, P> const & Position)
 {
  tvec4<T, P> Pi = glm::floor(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) + tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  tvec4<T, P> Pf = glm::fract(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) - tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, tvec4<T, P>(289));
  tvec4<T, P> ix(Pi.x, Pi.z, Pi.x, Pi.z);
  tvec4<T, P> iy(Pi.y, Pi.y, Pi.w, Pi.w);
  tvec4<T, P> fx(Pf.x, Pf.z, Pf.x, Pf.z);
  tvec4<T, P> fy(Pf.y, Pf.y, Pf.w, Pf.w);

  tvec4<T, P> i = detail::permute(detail::permute(ix) + iy);

  tvec4<T, P> gx = static_cast<T>(2) * glm::fract(i / T(41)) - T(1);
  tvec4<T, P> gy = glm::abs(gx) - T(0.5);
  tvec4<T, P> tx = glm::floor(gx + T(0.5));
  gx = gx - tx;

  tvec2<T, P> g00(gx.x, gy.x);
  tvec2<T, P> g10(gx.y, gy.y);
  tvec2<T, P> g01(gx.z, gy.z);
  tvec2<T, P> g11(gx.w, gy.w);

  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  T n00 = dot(g00, tvec2<T, P>(fx.x, fy.x));
  T n10 = dot(g10, tvec2<T, P>(fx.y, fy.y));
  T n01 = dot(g01, tvec2<T, P>(fx.z, fy.z));
  T n11 = dot(g11, tvec2<T, P>(fx.w, fy.w));

  tvec2<T, P> fade_xy = detail::fade(tvec2<T, P>(Pf.x, Pf.y));
  tvec2<T, P> n_x = mix(tvec2<T, P>(n00, n01), tvec2<T, P>(n10, n11), fade_xy.x);
  T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return T(2.3) * n_xy;
 }


 template <typename T, precision P> inline
                    T perlin(tvec3<T, P> const & Position)
 {
  tvec3<T, P> Pi0 = floor(Position);
  tvec3<T, P> Pi1 = Pi0 + T(1);
  Pi0 = detail::mod289(Pi0);
  Pi1 = detail::mod289(Pi1);
  tvec3<T, P> Pf0 = fract(Position);
  tvec3<T, P> Pf1 = Pf0 - T(1);
  tvec4<T, P> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy = tvec4<T, P>(tvec2<T, P>(Pi0.y), tvec2<T, P>(Pi1.y));
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);

  tvec4<T, P> gx0 = ixy0 * T(1.0 / 7.0);
  tvec4<T, P> gy0 = fract(floor(gx0) * T(1.0 / 7.0)) - T(0.5);
  gx0 = fract(gx0);
  tvec4<T, P> gz0 = tvec4<T, P>(0.5) - abs(gx0) - abs(gy0);
  tvec4<T, P> sz0 = step(gz0, tvec4<T, P>(0.0));
  gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
  gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

  tvec4<T, P> gx1 = ixy1 * T(1.0 / 7.0);
  tvec4<T, P> gy1 = fract(floor(gx1) * T(1.0 / 7.0)) - T(0.5);
  gx1 = fract(gx1);
  tvec4<T, P> gz1 = tvec4<T, P>(0.5) - abs(gx1) - abs(gy1);
  tvec4<T, P> sz1 = step(gz1, tvec4<T, P>(0.0));
  gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
  gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

  tvec3<T, P> g000(gx0.x, gy0.x, gz0.x);
  tvec3<T, P> g100(gx0.y, gy0.y, gz0.y);
  tvec3<T, P> g010(gx0.z, gy0.z, gz0.z);
  tvec3<T, P> g110(gx0.w, gy0.w, gz0.w);
  tvec3<T, P> g001(gx1.x, gy1.x, gz1.x);
  tvec3<T, P> g101(gx1.y, gy1.y, gz1.y);
  tvec3<T, P> g011(gx1.z, gy1.z, gz1.z);
  tvec3<T, P> g111(gx1.w, gy1.w, gz1.w);

  tvec4<T, P> norm0 = detail::taylorInvSqrt(tvec4<T, P>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  tvec4<T, P> norm1 = detail::taylorInvSqrt(tvec4<T, P>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  T n000 = dot(g000, Pf0);
  T n100 = dot(g100, tvec3<T, P>(Pf1.x, Pf0.y, Pf0.z));
  T n010 = dot(g010, tvec3<T, P>(Pf0.x, Pf1.y, Pf0.z));
  T n110 = dot(g110, tvec3<T, P>(Pf1.x, Pf1.y, Pf0.z));
  T n001 = dot(g001, tvec3<T, P>(Pf0.x, Pf0.y, Pf1.z));
  T n101 = dot(g101, tvec3<T, P>(Pf1.x, Pf0.y, Pf1.z));
  T n011 = dot(g011, tvec3<T, P>(Pf0.x, Pf1.y, Pf1.z));
  T n111 = dot(g111, Pf1);

  tvec3<T, P> fade_xyz = detail::fade(Pf0);
  tvec4<T, P> n_z = mix(tvec4<T, P>(n000, n100, n010, n110), tvec4<T, P>(n001, n101, n011, n111), fade_xyz.z);
  tvec2<T, P> n_yz = mix(tvec2<T, P>(n_z.x, n_z.y), tvec2<T, P>(n_z.z, n_z.w), fade_xyz.y);
  T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return T(2.2) * n_xyz;
 }
# 209 "/usr/local/include/glm/gtc/noise.inl" 3
 template <typename T, precision P> inline
                    T perlin(tvec4<T, P> const & Position)
 {
  tvec4<T, P> Pi0 = floor(Position);
  tvec4<T, P> Pi1 = Pi0 + T(1);
  Pi0 = mod(Pi0, tvec4<T, P>(289));
  Pi1 = mod(Pi1, tvec4<T, P>(289));
  tvec4<T, P> Pf0 = fract(Position);
  tvec4<T, P> Pf1 = Pf0 - T(1);
  tvec4<T, P> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);
  tvec4<T, P> iw0(Pi0.w);
  tvec4<T, P> iw1(Pi1.w);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);
  tvec4<T, P> ixy00 = detail::permute(ixy0 + iw0);
  tvec4<T, P> ixy01 = detail::permute(ixy0 + iw1);
  tvec4<T, P> ixy10 = detail::permute(ixy1 + iw0);
  tvec4<T, P> ixy11 = detail::permute(ixy1 + iw1);

  tvec4<T, P> gx00 = ixy00 / T(7);
  tvec4<T, P> gy00 = floor(gx00) / T(7);
  tvec4<T, P> gz00 = floor(gy00) / T(6);
  gx00 = fract(gx00) - T(0.5);
  gy00 = fract(gy00) - T(0.5);
  gz00 = fract(gz00) - T(0.5);
  tvec4<T, P> gw00 = tvec4<T, P>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  tvec4<T, P> sw00 = step(gw00, tvec4<T, P>(0.0));
  gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
  gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

  tvec4<T, P> gx01 = ixy01 / T(7);
  tvec4<T, P> gy01 = floor(gx01) / T(7);
  tvec4<T, P> gz01 = floor(gy01) / T(6);
  gx01 = fract(gx01) - T(0.5);
  gy01 = fract(gy01) - T(0.5);
  gz01 = fract(gz01) - T(0.5);
  tvec4<T, P> gw01 = tvec4<T, P>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  tvec4<T, P> sw01 = step(gw01, tvec4<T, P>(0.0));
  gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
  gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

  tvec4<T, P> gx10 = ixy10 / T(7);
  tvec4<T, P> gy10 = floor(gx10) / T(7);
  tvec4<T, P> gz10 = floor(gy10) / T(6);
  gx10 = fract(gx10) - T(0.5);
  gy10 = fract(gy10) - T(0.5);
  gz10 = fract(gz10) - T(0.5);
  tvec4<T, P> gw10 = tvec4<T, P>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  tvec4<T, P> sw10 = step(gw10, tvec4<T, P>(0));
  gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
  gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

  tvec4<T, P> gx11 = ixy11 / T(7);
  tvec4<T, P> gy11 = floor(gx11) / T(7);
  tvec4<T, P> gz11 = floor(gy11) / T(6);
  gx11 = fract(gx11) - T(0.5);
  gy11 = fract(gy11) - T(0.5);
  gz11 = fract(gz11) - T(0.5);
  tvec4<T, P> gw11 = tvec4<T, P>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  tvec4<T, P> sw11 = step(gw11, tvec4<T, P>(0.0));
  gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
  gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

  tvec4<T, P> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
  tvec4<T, P> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
  tvec4<T, P> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
  tvec4<T, P> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
  tvec4<T, P> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
  tvec4<T, P> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
  tvec4<T, P> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
  tvec4<T, P> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
  tvec4<T, P> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
  tvec4<T, P> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
  tvec4<T, P> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
  tvec4<T, P> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
  tvec4<T, P> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
  tvec4<T, P> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
  tvec4<T, P> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
  tvec4<T, P> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

  tvec4<T, P> norm00 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  tvec4<T, P> norm01 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  tvec4<T, P> norm10 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  tvec4<T, P> norm11 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  T n0000 = dot(g0000, Pf0);
  T n1000 = dot(g1000, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
  T n0100 = dot(g0100, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
  T n1100 = dot(g1100, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
  T n0010 = dot(g0010, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
  T n1010 = dot(g1010, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  T n0110 = dot(g0110, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
  T n1110 = dot(g1110, tvec4<T, P>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
  T n0001 = dot(g0001, tvec4<T, P>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
  T n1001 = dot(g1001, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
  T n0101 = dot(g0101, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  T n1101 = dot(g1101, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
  T n0011 = dot(g0011, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
  T n1011 = dot(g1011, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
  T n0111 = dot(g0111, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
  T n1111 = dot(g1111, Pf1);

  tvec4<T, P> fade_xyzw = detail::fade(Pf0);
  tvec4<T, P> n_0w = mix(tvec4<T, P>(n0000, n1000, n0100, n1100), tvec4<T, P>(n0001, n1001, n0101, n1101), fade_xyzw.w);
  tvec4<T, P> n_1w = mix(tvec4<T, P>(n0010, n1010, n0110, n1110), tvec4<T, P>(n0011, n1011, n0111, n1111), fade_xyzw.w);
  tvec4<T, P> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  tvec2<T, P> n_yzw = mix(tvec2<T, P>(n_zw.x, n_zw.y), tvec2<T, P>(n_zw.z, n_zw.w), fade_xyzw.y);
  T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return T(2.2) * n_xyzw;
 }


 template <typename T, precision P> inline
                    T perlin(tvec2<T, P> const & Position, tvec2<T, P> const & rep)
 {
  tvec4<T, P> Pi = floor(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) + tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  tvec4<T, P> Pf = fract(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) - tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, tvec4<T, P>(rep.x, rep.y, rep.x, rep.y));
  Pi = mod(Pi, tvec4<T, P>(289));
  tvec4<T, P> ix(Pi.x, Pi.z, Pi.x, Pi.z);
  tvec4<T, P> iy(Pi.y, Pi.y, Pi.w, Pi.w);
  tvec4<T, P> fx(Pf.x, Pf.z, Pf.x, Pf.z);
  tvec4<T, P> fy(Pf.y, Pf.y, Pf.w, Pf.w);

  tvec4<T, P> i = detail::permute(detail::permute(ix) + iy);

  tvec4<T, P> gx = static_cast<T>(2) * fract(i / T(41)) - T(1);
  tvec4<T, P> gy = abs(gx) - T(0.5);
  tvec4<T, P> tx = floor(gx + T(0.5));
  gx = gx - tx;

  tvec2<T, P> g00(gx.x, gy.x);
  tvec2<T, P> g10(gx.y, gy.y);
  tvec2<T, P> g01(gx.z, gy.z);
  tvec2<T, P> g11(gx.w, gy.w);

  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  T n00 = dot(g00, tvec2<T, P>(fx.x, fy.x));
  T n10 = dot(g10, tvec2<T, P>(fx.y, fy.y));
  T n01 = dot(g01, tvec2<T, P>(fx.z, fy.z));
  T n11 = dot(g11, tvec2<T, P>(fx.w, fy.w));

  tvec2<T, P> fade_xy = detail::fade(tvec2<T, P>(Pf.x, Pf.y));
  tvec2<T, P> n_x = mix(tvec2<T, P>(n00, n01), tvec2<T, P>(n10, n11), fade_xy.x);
  T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return T(2.3) * n_xy;
 }


 template <typename T, precision P> inline
                    T perlin(tvec3<T, P> const & Position, tvec3<T, P> const & rep)
 {
  tvec3<T, P> Pi0 = mod(floor(Position), rep);
  tvec3<T, P> Pi1 = mod(Pi0 + tvec3<T, P>(T(1)), rep);
  Pi0 = mod(Pi0, tvec3<T, P>(289));
  Pi1 = mod(Pi1, tvec3<T, P>(289));
  tvec3<T, P> Pf0 = fract(Position);
  tvec3<T, P> Pf1 = Pf0 - tvec3<T, P>(T(1));
  tvec4<T, P> ix = tvec4<T, P>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy = tvec4<T, P>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);

  tvec4<T, P> gx0 = ixy0 / T(7);
  tvec4<T, P> gy0 = fract(floor(gx0) / T(7)) - T(0.5);
  gx0 = fract(gx0);
  tvec4<T, P> gz0 = tvec4<T, P>(0.5) - abs(gx0) - abs(gy0);
  tvec4<T, P> sz0 = step(gz0, tvec4<T, P>(0));
  gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
  gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

  tvec4<T, P> gx1 = ixy1 / T(7);
  tvec4<T, P> gy1 = fract(floor(gx1) / T(7)) - T(0.5);
  gx1 = fract(gx1);
  tvec4<T, P> gz1 = tvec4<T, P>(0.5) - abs(gx1) - abs(gy1);
  tvec4<T, P> sz1 = step(gz1, tvec4<T, P>(T(0)));
  gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
  gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

  tvec3<T, P> g000 = tvec3<T, P>(gx0.x, gy0.x, gz0.x);
  tvec3<T, P> g100 = tvec3<T, P>(gx0.y, gy0.y, gz0.y);
  tvec3<T, P> g010 = tvec3<T, P>(gx0.z, gy0.z, gz0.z);
  tvec3<T, P> g110 = tvec3<T, P>(gx0.w, gy0.w, gz0.w);
  tvec3<T, P> g001 = tvec3<T, P>(gx1.x, gy1.x, gz1.x);
  tvec3<T, P> g101 = tvec3<T, P>(gx1.y, gy1.y, gz1.y);
  tvec3<T, P> g011 = tvec3<T, P>(gx1.z, gy1.z, gz1.z);
  tvec3<T, P> g111 = tvec3<T, P>(gx1.w, gy1.w, gz1.w);

  tvec4<T, P> norm0 = detail::taylorInvSqrt(tvec4<T, P>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  tvec4<T, P> norm1 = detail::taylorInvSqrt(tvec4<T, P>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  T n000 = dot(g000, Pf0);
  T n100 = dot(g100, tvec3<T, P>(Pf1.x, Pf0.y, Pf0.z));
  T n010 = dot(g010, tvec3<T, P>(Pf0.x, Pf1.y, Pf0.z));
  T n110 = dot(g110, tvec3<T, P>(Pf1.x, Pf1.y, Pf0.z));
  T n001 = dot(g001, tvec3<T, P>(Pf0.x, Pf0.y, Pf1.z));
  T n101 = dot(g101, tvec3<T, P>(Pf1.x, Pf0.y, Pf1.z));
  T n011 = dot(g011, tvec3<T, P>(Pf0.x, Pf1.y, Pf1.z));
  T n111 = dot(g111, Pf1);

  tvec3<T, P> fade_xyz = detail::fade(Pf0);
  tvec4<T, P> n_z = mix(tvec4<T, P>(n000, n100, n010, n110), tvec4<T, P>(n001, n101, n011, n111), fade_xyz.z);
  tvec2<T, P> n_yz = mix(tvec2<T, P>(n_z.x, n_z.y), tvec2<T, P>(n_z.z, n_z.w), fade_xyz.y);
  T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return T(2.2) * n_xyz;
 }


 template <typename T, precision P> inline
                    T perlin(tvec4<T, P> const & Position, tvec4<T, P> const & rep)
 {
  tvec4<T, P> Pi0 = mod(floor(Position), rep);
  tvec4<T, P> Pi1 = mod(Pi0 + T(1), rep);
  tvec4<T, P> Pf0 = fract(Position);
  tvec4<T, P> Pf1 = Pf0 - T(1);
  tvec4<T, P> ix = tvec4<T, P>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy = tvec4<T, P>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);
  tvec4<T, P> iw0(Pi0.w);
  tvec4<T, P> iw1(Pi1.w);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);
  tvec4<T, P> ixy00 = detail::permute(ixy0 + iw0);
  tvec4<T, P> ixy01 = detail::permute(ixy0 + iw1);
  tvec4<T, P> ixy10 = detail::permute(ixy1 + iw0);
  tvec4<T, P> ixy11 = detail::permute(ixy1 + iw1);

  tvec4<T, P> gx00 = ixy00 / T(7);
  tvec4<T, P> gy00 = floor(gx00) / T(7);
  tvec4<T, P> gz00 = floor(gy00) / T(6);
  gx00 = fract(gx00) - T(0.5);
  gy00 = fract(gy00) - T(0.5);
  gz00 = fract(gz00) - T(0.5);
  tvec4<T, P> gw00 = tvec4<T, P>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  tvec4<T, P> sw00 = step(gw00, tvec4<T, P>(0));
  gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
  gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

  tvec4<T, P> gx01 = ixy01 / T(7);
  tvec4<T, P> gy01 = floor(gx01) / T(7);
  tvec4<T, P> gz01 = floor(gy01) / T(6);
  gx01 = fract(gx01) - T(0.5);
  gy01 = fract(gy01) - T(0.5);
  gz01 = fract(gz01) - T(0.5);
  tvec4<T, P> gw01 = tvec4<T, P>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  tvec4<T, P> sw01 = step(gw01, tvec4<T, P>(0.0));
  gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
  gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

  tvec4<T, P> gx10 = ixy10 / T(7);
  tvec4<T, P> gy10 = floor(gx10) / T(7);
  tvec4<T, P> gz10 = floor(gy10) / T(6);
  gx10 = fract(gx10) - T(0.5);
  gy10 = fract(gy10) - T(0.5);
  gz10 = fract(gz10) - T(0.5);
  tvec4<T, P> gw10 = tvec4<T, P>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  tvec4<T, P> sw10 = step(gw10, tvec4<T, P>(0.0));
  gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
  gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

  tvec4<T, P> gx11 = ixy11 / T(7);
  tvec4<T, P> gy11 = floor(gx11) / T(7);
  tvec4<T, P> gz11 = floor(gy11) / T(6);
  gx11 = fract(gx11) - T(0.5);
  gy11 = fract(gy11) - T(0.5);
  gz11 = fract(gz11) - T(0.5);
  tvec4<T, P> gw11 = tvec4<T, P>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  tvec4<T, P> sw11 = step(gw11, tvec4<T, P>(T(0)));
  gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
  gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

  tvec4<T, P> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
  tvec4<T, P> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
  tvec4<T, P> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
  tvec4<T, P> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
  tvec4<T, P> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
  tvec4<T, P> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
  tvec4<T, P> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
  tvec4<T, P> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
  tvec4<T, P> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
  tvec4<T, P> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
  tvec4<T, P> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
  tvec4<T, P> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
  tvec4<T, P> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
  tvec4<T, P> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
  tvec4<T, P> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
  tvec4<T, P> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

  tvec4<T, P> norm00 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  tvec4<T, P> norm01 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  tvec4<T, P> norm10 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  tvec4<T, P> norm11 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  T n0000 = dot(g0000, Pf0);
  T n1000 = dot(g1000, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
  T n0100 = dot(g0100, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
  T n1100 = dot(g1100, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
  T n0010 = dot(g0010, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
  T n1010 = dot(g1010, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  T n0110 = dot(g0110, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
  T n1110 = dot(g1110, tvec4<T, P>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
  T n0001 = dot(g0001, tvec4<T, P>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
  T n1001 = dot(g1001, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
  T n0101 = dot(g0101, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  T n1101 = dot(g1101, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
  T n0011 = dot(g0011, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
  T n1011 = dot(g1011, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
  T n0111 = dot(g0111, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
  T n1111 = dot(g1111, Pf1);

  tvec4<T, P> fade_xyzw = detail::fade(Pf0);
  tvec4<T, P> n_0w = mix(tvec4<T, P>(n0000, n1000, n0100, n1100), tvec4<T, P>(n0001, n1001, n0101, n1101), fade_xyzw.w);
  tvec4<T, P> n_1w = mix(tvec4<T, P>(n0010, n1010, n0110, n1110), tvec4<T, P>(n0011, n1011, n0111, n1111), fade_xyzw.w);
  tvec4<T, P> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  tvec2<T, P> n_yzw = mix(tvec2<T, P>(n_zw.x, n_zw.y), tvec2<T, P>(n_zw.z, n_zw.w), fade_xyzw.y);
  T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return T(2.2) * n_xyzw;
 }

 template <typename T, precision P> inline
                    T simplex(glm::tvec2<T, P> const & v)
 {
  tvec4<T, P> const C = tvec4<T, P>(
   T( 0.211324865405187),
   T( 0.366025403784439),
   T(-0.577350269189626),
   T( 0.024390243902439));


  tvec2<T, P> i = floor(v + dot(v, tvec2<T, P>(C[1])));
  tvec2<T, P> x0 = v - i + dot(i, tvec2<T, P>(C[0]));




  tvec2<T, P> i1 = (x0.x > x0.y) ? tvec2<T, P>(1, 0) : tvec2<T, P>(0, 1);



  tvec4<T, P> x12 = tvec4<T, P>(x0.x, x0.y, x0.x, x0.y) + tvec4<T, P>(C.x, C.x, C.z, C.z);
  x12 = tvec4<T, P>(tvec2<T, P>(x12) - i1, x12.z, x12.w);


  i = mod(i, tvec2<T, P>(289));
  tvec3<T, P> p = detail::permute(
   detail::permute(i.y + tvec3<T, P>(T(0), i1.y, T(1)))
   + i.x + tvec3<T, P>(T(0), i1.x, T(1)));

  tvec3<T, P> m = max(tvec3<T, P>(0.5) - tvec3<T, P>(
   dot(x0, x0),
   dot(tvec2<T, P>(x12.x, x12.y), tvec2<T, P>(x12.x, x12.y)),
   dot(tvec2<T, P>(x12.z, x12.w), tvec2<T, P>(x12.z, x12.w))), tvec3<T, P>(0));
  m = m * m ;
  m = m * m ;




  tvec3<T, P> x = static_cast<T>(2) * fract(p * C.w) - T(1);
  tvec3<T, P> h = abs(x) - T(0.5);
  tvec3<T, P> ox = floor(x + T(0.5));
  tvec3<T, P> a0 = x - ox;



  m *= static_cast<T>(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);


  tvec3<T, P> g;
  g.x = a0.x * x0.x + h.x * x0.y;

  g.y = a0.y * x12.x + h.y * x12.y;
  g.z = a0.z * x12.z + h.z * x12.w;
  return T(130) * dot(m, g);
 }

 template <typename T, precision P> inline
                    T simplex(tvec3<T, P> const & v)
 {
  tvec2<T, P> const C(1.0 / 6.0, 1.0 / 3.0);
  tvec4<T, P> const D(0.0, 0.5, 1.0, 2.0);


  tvec3<T, P> i(floor(v + dot(v, tvec3<T, P>(C.y))));
  tvec3<T, P> x0(v - i + dot(i, tvec3<T, P>(C.x)));


  tvec3<T, P> g(step(tvec3<T, P>(x0.y, x0.z, x0.x), x0));
  tvec3<T, P> l(T(1) - g);
  tvec3<T, P> i1(min(g, tvec3<T, P>(l.z, l.x, l.y)));
  tvec3<T, P> i2(max(g, tvec3<T, P>(l.z, l.x, l.y)));





  tvec3<T, P> x1(x0 - i1 + C.x);
  tvec3<T, P> x2(x0 - i2 + C.y);
  tvec3<T, P> x3(x0 - D.y);


  i = detail::mod289(i);
  tvec4<T, P> p(detail::permute(detail::permute(detail::permute(
   i.z + tvec4<T, P>(T(0), i1.z, i2.z, T(1))) +
   i.y + tvec4<T, P>(T(0), i1.y, i2.y, T(1))) +
   i.x + tvec4<T, P>(T(0), i1.x, i2.x, T(1))));



  T n_ = static_cast<T>(0.142857142857);
  tvec3<T, P> ns(n_ * tvec3<T, P>(D.w, D.y, D.z) - tvec3<T, P>(D.x, D.z, D.x));

  tvec4<T, P> j(p - T(49) * floor(p * ns.z * ns.z));

  tvec4<T, P> x_(floor(j * ns.z));
  tvec4<T, P> y_(floor(j - T(7) * x_));

  tvec4<T, P> x(x_ * ns.x + ns.y);
  tvec4<T, P> y(y_ * ns.x + ns.y);
  tvec4<T, P> h(T(1) - abs(x) - abs(y));

  tvec4<T, P> b0(x.x, x.y, y.x, y.y);
  tvec4<T, P> b1(x.z, x.w, y.z, y.w);



  tvec4<T, P> s0(floor(b0) * T(2) + T(1));
  tvec4<T, P> s1(floor(b1) * T(2) + T(1));
  tvec4<T, P> sh(-step(h, tvec4<T, P>(0.0)));

  tvec4<T, P> a0 = tvec4<T, P>(b0.x, b0.z, b0.y, b0.w) + tvec4<T, P>(s0.x, s0.z, s0.y, s0.w) * tvec4<T, P>(sh.x, sh.x, sh.y, sh.y);
  tvec4<T, P> a1 = tvec4<T, P>(b1.x, b1.z, b1.y, b1.w) + tvec4<T, P>(s1.x, s1.z, s1.y, s1.w) * tvec4<T, P>(sh.z, sh.z, sh.w, sh.w);

  tvec3<T, P> p0(a0.x, a0.y, h.x);
  tvec3<T, P> p1(a0.z, a0.w, h.y);
  tvec3<T, P> p2(a1.x, a1.y, h.z);
  tvec3<T, P> p3(a1.z, a1.w, h.w);


  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;


  tvec4<T, P> m = max(T(0.6) - tvec4<T, P>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), tvec4<T, P>(0));
  m = m * m;
  return T(42) * dot(m * m, tvec4<T, P>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
 }

 template <typename T, precision P> inline
                    T simplex(tvec4<T, P> const & v)
 {
  tvec4<T, P> const C(
   0.138196601125011,
   0.276393202250021,
   0.414589803375032,
   -0.447213595499958);


  T const F4 = static_cast<T>(0.309016994374947451);


  tvec4<T, P> i = floor(v + dot(v, vec4(F4)));
  tvec4<T, P> x0 = v - i + dot(i, vec4(C.x));




  tvec4<T, P> i0;
  tvec3<T, P> isX = step(tvec3<T, P>(x0.y, x0.z, x0.w), tvec3<T, P>(x0.x));
  tvec3<T, P> isYZ = step(tvec3<T, P>(x0.z, x0.w, x0.w), tvec3<T, P>(x0.y, x0.y, x0.z));



  i0 = tvec4<T, P>(isX.x + isX.y + isX.z, T(1) - isX);

  i0.y += isYZ.x + isYZ.y;

  i0.z += static_cast<T>(1) - isYZ.x;
  i0.w += static_cast<T>(1) - isYZ.y;
  i0.z += isYZ.z;
  i0.w += static_cast<T>(1) - isYZ.z;


  tvec4<T, P> i3 = clamp(i0, T(0), T(1));
  tvec4<T, P> i2 = clamp(i0 - T(1), T(0), T(1));
  tvec4<T, P> i1 = clamp(i0 - T(2), T(0), T(1));






  tvec4<T, P> x1 = x0 - i1 + C.x;
  tvec4<T, P> x2 = x0 - i2 + C.y;
  tvec4<T, P> x3 = x0 - i3 + C.z;
  tvec4<T, P> x4 = x0 + C.w;


  i = mod(i, tvec4<T, P>(289));
  T j0 = detail::permute(detail::permute(detail::permute(detail::permute(i.w) + i.z) + i.y) + i.x);
  tvec4<T, P> j1 = detail::permute(detail::permute(detail::permute(detail::permute(
   i.w + tvec4<T, P>(i1.w, i2.w, i3.w, T(1))) +
   i.z + tvec4<T, P>(i1.z, i2.z, i3.z, T(1))) +
   i.y + tvec4<T, P>(i1.y, i2.y, i3.y, T(1))) +
   i.x + tvec4<T, P>(i1.x, i2.x, i3.x, T(1)));



  tvec4<T, P> ip = tvec4<T, P>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));

  tvec4<T, P> p0 = gtc::grad4(j0, ip);
  tvec4<T, P> p1 = gtc::grad4(j1.x, ip);
  tvec4<T, P> p2 = gtc::grad4(j1.y, ip);
  tvec4<T, P> p3 = gtc::grad4(j1.z, ip);
  tvec4<T, P> p4 = gtc::grad4(j1.w, ip);


  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= detail::taylorInvSqrt(dot(p4, p4));


  tvec3<T, P> m0 = max(T(0.6) - tvec3<T, P>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), tvec3<T, P>(0));
  tvec2<T, P> m1 = max(T(0.6) - tvec2<T, P>(dot(x3, x3), dot(x4, x4) ), tvec2<T, P>(0));
  m0 = m0 * m0;
  m1 = m1 * m1;
  return T(49) *
   (dot(m0 * m0, tvec3<T, P>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) +
   dot(m1 * m1, tvec2<T, P>(dot(p3, x3), dot(p4, x4))));
 }
}
# 60 "/usr/local/include/glm/./gtc/noise.hpp" 2 3
# 47 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/packing.hpp" 1 3
# 17 "/usr/local/include/glm/./gtc/packing.hpp" 3
# 1 "/usr/local/include/glm/gtc/type_precision.hpp" 1 3
# 22 "/usr/local/include/glm/gtc/type_precision.hpp" 3
# 1 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 1 3
# 22 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
namespace glm
{



 typedef highp_vec1_t highp_vec1;




 typedef mediump_vec1_t mediump_vec1;




 typedef lowp_vec1_t lowp_vec1;




 typedef highp_dvec1_t highp_dvec1;




 typedef mediump_dvec1_t mediump_dvec1;




 typedef lowp_dvec1_t lowp_dvec1;




 typedef highp_ivec1_t highp_ivec1;




 typedef mediump_ivec1_t mediump_ivec1;




 typedef lowp_ivec1_t lowp_ivec1;




 typedef highp_uvec1_t highp_uvec1;




 typedef mediump_uvec1_t mediump_uvec1;




 typedef lowp_uvec1_t lowp_uvec1;




 typedef highp_bvec1_t highp_bvec1;




 typedef mediump_bvec1_t mediump_bvec1;




 typedef lowp_bvec1_t lowp_bvec1;
# 111 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_bvec1 bvec1;
# 123 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_vec1 vec1;
# 135 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_dvec1 dvec1;
# 147 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_ivec1 ivec1;
# 159 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_uvec1 uvec1;


}


# 1 "/usr/local/include/glm/gtc/vec1.inl" 1 3
# 164 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 2 3
# 22 "/usr/local/include/glm/gtc/type_precision.hpp" 2 3
# 40 "/usr/local/include/glm/gtc/type_precision.hpp" 3
namespace glm
{
# 50 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;




 typedef detail::int8 int8;



 typedef detail::int16 int16;



 typedef detail::int32 int32;



 typedef detail::int64 int64;
# 217 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef detail::int8 int8_t;



 typedef detail::int16 int16_t;



 typedef detail::int32 int32_t;



 typedef detail::int64 int64_t;




 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;




 typedef tvec1<i8, defaultp> i8vec1;



 typedef tvec2<i8, defaultp> i8vec2;



 typedef tvec3<i8, defaultp> i8vec3;



 typedef tvec4<i8, defaultp> i8vec4;




 typedef tvec1<i16, defaultp> i16vec1;



 typedef tvec2<i16, defaultp> i16vec2;



 typedef tvec3<i16, defaultp> i16vec3;



 typedef tvec4<i16, defaultp> i16vec4;




 typedef tvec1<i32, defaultp> i32vec1;



 typedef tvec2<i32, defaultp> i32vec2;



 typedef tvec3<i32, defaultp> i32vec3;



 typedef tvec4<i32, defaultp> i32vec4;




 typedef tvec1<i64, defaultp> i64vec1;



 typedef tvec2<i64, defaultp> i64vec2;



 typedef tvec3<i64, defaultp> i64vec3;



 typedef tvec4<i64, defaultp> i64vec4;







 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;



 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;



 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;



 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;



 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;



 typedef detail::uint8 uint8;



 typedef detail::uint16 uint16;



 typedef detail::uint32 uint32;



 typedef detail::uint64 uint64;
# 488 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef detail::uint8 uint8_t;



 typedef detail::uint16 uint16_t;



 typedef detail::uint32 uint32_t;



 typedef detail::uint64 uint64_t;




 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;





 typedef tvec1<u8, defaultp> u8vec1;



 typedef tvec2<u8, defaultp> u8vec2;



 typedef tvec3<u8, defaultp> u8vec3;



 typedef tvec4<u8, defaultp> u8vec4;




 typedef tvec1<u16, defaultp> u16vec1;



 typedef tvec2<u16, defaultp> u16vec2;



 typedef tvec3<u16, defaultp> u16vec3;



 typedef tvec4<u16, defaultp> u16vec4;




 typedef tvec1<u32, defaultp> u32vec1;



 typedef tvec2<u32, defaultp> u32vec2;



 typedef tvec3<u32, defaultp> u32vec3;



 typedef tvec4<u32, defaultp> u32vec4;




 typedef tvec1<u64, defaultp> u64vec1;



 typedef tvec2<u64, defaultp> u64vec2;



 typedef tvec3<u64, defaultp> u64vec3;



 typedef tvec4<u64, defaultp> u64vec4;







 typedef detail::float32 float32;



 typedef detail::float64 float64;




 typedef detail::float32 float32_t;



 typedef detail::float64 float64_t;




 typedef float32 f32;



 typedef float64 f64;




 typedef tvec1<float, defaultp> fvec1;



 typedef tvec2<float, defaultp> fvec2;



 typedef tvec3<float, defaultp> fvec3;



 typedef tvec4<float, defaultp> fvec4;




 typedef tvec1<f32, defaultp> f32vec1;



 typedef tvec2<f32, defaultp> f32vec2;



 typedef tvec3<f32, defaultp> f32vec3;



 typedef tvec4<f32, defaultp> f32vec4;




 typedef tvec1<f64, defaultp> f64vec1;



 typedef tvec2<f64, defaultp> f64vec2;



 typedef tvec3<f64, defaultp> f64vec3;



 typedef tvec4<f64, defaultp> f64vec4;
# 679 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> fmat2;



 typedef tmat3x3<f32, defaultp> fmat3;



 typedef tmat4x4<f32, defaultp> fmat4;
# 696 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> fmat2x2;



 typedef tmat2x3<f32, defaultp> fmat2x3;



 typedef tmat2x4<f32, defaultp> fmat2x4;



 typedef tmat3x2<f32, defaultp> fmat3x2;



 typedef tmat3x3<f32, defaultp> fmat3x3;



 typedef tmat3x4<f32, defaultp> fmat3x4;



 typedef tmat4x2<f32, defaultp> fmat4x2;



 typedef tmat4x3<f32, defaultp> fmat4x3;



 typedef tmat4x4<f32, defaultp> fmat4x4;
# 737 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> f32mat2;



 typedef tmat3x3<f32, defaultp> f32mat3;



 typedef tmat4x4<f32, defaultp> f32mat4;
# 754 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> f32mat2x2;



 typedef tmat2x3<f32, defaultp> f32mat2x3;



 typedef tmat2x4<f32, defaultp> f32mat2x4;



 typedef tmat3x2<f32, defaultp> f32mat3x2;



 typedef tmat3x3<f32, defaultp> f32mat3x3;



 typedef tmat3x4<f32, defaultp> f32mat3x4;



 typedef tmat4x2<f32, defaultp> f32mat4x2;



 typedef tmat4x3<f32, defaultp> f32mat4x3;



 typedef tmat4x4<f32, defaultp> f32mat4x4;
# 795 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f64, defaultp> f64mat2;



 typedef tmat3x3<f64, defaultp> f64mat3;



 typedef tmat4x4<f64, defaultp> f64mat4;
# 812 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f64, defaultp> f64mat2x2;



 typedef tmat2x3<f64, defaultp> f64mat2x3;



 typedef tmat2x4<f64, defaultp> f64mat2x4;



 typedef tmat3x2<f64, defaultp> f64mat3x2;



 typedef tmat3x3<f64, defaultp> f64mat3x3;



 typedef tmat3x4<f64, defaultp> f64mat3x4;



 typedef tmat4x2<f64, defaultp> f64mat4x2;



 typedef tmat4x3<f64, defaultp> f64mat4x3;



 typedef tmat4x4<f64, defaultp> f64mat4x4;







 typedef tquat<f32, defaultp> f32quat;



 typedef tquat<f64, defaultp> f64quat;


}


# 1 "/usr/local/include/glm/gtc/type_precision.inl" 1 3



namespace glm
{

}
# 861 "/usr/local/include/glm/gtc/type_precision.hpp" 2 3
# 17 "/usr/local/include/glm/./gtc/packing.hpp" 2 3






namespace glm
{
# 39 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint8 packUnorm1x8(float v);
# 51 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackUnorm1x8(uint8 p);
# 67 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packUnorm2x8(vec2 const & v);
# 83 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec2 unpackUnorm2x8(uint16 p);
# 96 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint8 packSnorm1x8(float s);
# 109 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackSnorm1x8(uint8 p);
# 125 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packSnorm2x8(vec2 const & v);
# 141 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec2 unpackSnorm2x8(uint16 p);
# 154 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packUnorm1x16(float v);
# 167 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackUnorm1x16(uint16 p);
# 183 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint64 packUnorm4x16(vec4 const & v);
# 199 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackUnorm4x16(uint64 p);
# 212 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packSnorm1x16(float v);
# 225 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackSnorm1x16(uint16 p);
# 241 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint64 packSnorm4x16(vec4 const & v);
# 257 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackSnorm4x16(uint64 p);
# 268 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packHalf1x16(float v);
# 279 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackHalf1x16(uint16 v);
# 292 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint64 packHalf4x16(vec4 const & v);
# 305 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackHalf4x16(uint64 p);
# 318 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packI3x10_1x2(ivec4 const & v);
# 329 "/usr/local/include/glm/./gtc/packing.hpp" 3
               ivec4 unpackI3x10_1x2(uint32 p);
# 342 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packU3x10_1x2(uvec4 const & v);
# 353 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uvec4 unpackU3x10_1x2(uint32 p);
# 371 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packSnorm3x10_1x2(vec4 const & v);
# 388 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackSnorm3x10_1x2(uint32 p);
# 406 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packUnorm3x10_1x2(vec4 const & v);
# 423 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackUnorm3x10_1x2(uint32 p);
# 434 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packF2x11_1x10(vec3 const & v);
# 444 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec3 unpackF2x11_1x10(uint32 p);
# 456 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packF3x9_E1x5(vec3 const & v);
# 466 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec3 unpackF3x9_E1x5(uint32 p);
# 476 "/usr/local/include/glm/./gtc/packing.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<uint16, P> packHalf(vecType<float, P> const & v);
# 486 "/usr/local/include/glm/./gtc/packing.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<float, P> unpackHalf(vecType<uint16, P> const & p);





 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<uintType, P> packUnorm(vecType<floatType, P> const & v);





 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<floatType, P> unpackUnorm(vecType<uintType, P> const & v);





 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<intType, P> packSnorm(vecType<floatType, P> const & v);





 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<floatType, P> unpackSnorm(vecType<intType, P> const & v);





               uint8 packUnorm2x4(vec2 const & v);





               vec2 unpackUnorm2x4(uint8 p);





               uint16 packUnorm4x4(vec4 const & v);





               vec4 unpackUnorm4x4(uint16 p);





               uint16 packUnorm1x5_1x6_1x5(vec3 const & v);





               vec3 unpackUnorm1x5_1x6_1x5(uint16 p);





               uint16 packUnorm3x5_1x1(vec4 const & v);





               vec4 unpackUnorm3x5_1x1(uint16 p);





               uint8 packUnorm2x3_1x2(vec3 const & v);





               vec3 unpackUnorm2x3_1x2(uint8 p);

}


# 1 "/usr/local/include/glm/gtc/packing.inl" 1 3
# 12 "/usr/local/include/glm/gtc/packing.inl" 3
namespace glm{
namespace detail
{ inline
                    glm::uint16 float2half(glm::uint32 f)
 {
# 27 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((f >> 16) & 0x8000) |
   ((((f & 0x7f800000) - 0x38000000) >> 13) & 0x7c00) |
   ((f >> 13) & 0x03ff);
 } inline

                    glm::uint32 float2packed11(glm::uint32 f)
 {
# 46 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((f & 0x7f800000) - 0x38000000) >> 17) & 0x07c0) |
   ((f >> 17) & 0x003f);
 } inline

                    glm::uint32 packed11ToFloat(glm::uint32 p)
 {
# 64 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((p & 0x07c0) << 17) + 0x38000000) & 0x7f800000) |
   ((p & 0x003f) << 17);
 } inline

                    glm::uint32 float2packed10(glm::uint32 f)
 {
# 85 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((f & 0x7f800000) - 0x38000000) >> 18) & 0x03E0) |
   ((f >> 18) & 0x001f);
 } inline

                    glm::uint32 packed10ToFloat(glm::uint32 p)
 {
# 106 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((p & 0x03E0) << 18) + 0x38000000) & 0x7f800000) |
   ((p & 0x001f) << 18);
 } inline

                    glm::uint half2float(glm::uint h)
 {
  return ((h & 0x8000) << 16) | ((( h & 0x7c00) + 0x1C000) << 13) | ((h & 0x03FF) << 13);
 } inline

                    glm::uint floatTo11bit(float x)
 {
  if(x == 0.0f)
   return 0u;
  else if(glm::isnan(x))
   return ~0u;
  else if(glm::isinf(x))
   return 0x1Fu << 6u;

  uint Pack = 0u;
  memcpy(&Pack, &x, sizeof(Pack));
  return float2packed11(Pack);
 } inline

                    float packed11bitToFloat(glm::uint x)
 {
  if(x == 0)
   return 0.0f;
  else if(x == ((1 << 11) - 1))
   return ~0;
  else if(x == (0x1f << 6))
   return ~0;

  uint Result = packed11ToFloat(x);

  float Temp = 0;
  memcpy(&Temp, &Result, sizeof(Temp));
  return Temp;
 } inline

                    glm::uint floatTo10bit(float x)
 {
  if(x == 0.0f)
   return 0u;
  else if(glm::isnan(x))
   return ~0u;
  else if(glm::isinf(x))
   return 0x1Fu << 5u;

  uint Pack = 0;
  memcpy(&Pack, &x, sizeof(Pack));
  return float2packed10(Pack);
 } inline

                    float packed10bitToFloat(glm::uint x)
 {
  if(x == 0)
   return 0.0f;
  else if(x == ((1 << 10) - 1))
   return ~0;
  else if(x == (0x1f << 5))
   return ~0;

  uint Result = packed10ToFloat(x);

  float Temp = 0;
  memcpy(&Temp, &Result, sizeof(Temp));
  return Temp;
 }






 union u3u3u2
 {
  struct
  {
   uint x : 3;
   uint y : 3;
   uint z : 2;
  } data;
  uint8 pack;
 };

 union u4u4
 {
  struct
  {
   uint x : 4;
   uint y : 4;
  } data;
  uint8 pack;
 };

 union u4u4u4u4
 {
  struct
  {
   uint x : 4;
   uint y : 4;
   uint z : 4;
   uint w : 4;
  } data;
  uint16 pack;
 };

 union u5u6u5
 {
  struct
  {
   uint x : 5;
   uint y : 6;
   uint z : 5;
  } data;
  uint16 pack;
 };

 union u5u5u5u1
 {
  struct
  {
   uint x : 5;
   uint y : 5;
   uint z : 5;
   uint w : 1;
  } data;
  uint16 pack;
 };

 union u10u10u10u2
 {
  struct
  {
   uint x : 10;
   uint y : 10;
   uint z : 10;
   uint w : 2;
  } data;
  uint32 pack;
 };

 union i10i10i10i2
 {
  struct
  {
   int x : 10;
   int y : 10;
   int z : 10;
   int w : 2;
  } data;
  uint32 pack;
 };

 union u9u9u9e5
 {
  struct
  {
   uint x : 9;
   uint y : 9;
   uint z : 9;
   uint w : 5;
  } data;
  uint32 pack;
 };

 template <precision P, template <typename, precision> class vecType>
 struct compute_half
 {};

 template <precision P>
 struct compute_half<P, tvec1>
 { inline
                     static tvec1<uint16, P> pack(tvec1<float, P> const & v)
  {
   int16 const Unpack(detail::toFloat16(v.x));
   u16vec1 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec1<float, P> unpack(tvec1<uint16, P> const & v)
  {
   i16vec1 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec1<float, P>(detail::toFloat32(v.x));
  }
 };

 template <precision P>
 struct compute_half<P, tvec2>
 { inline
                     static tvec2<uint16, P> pack(tvec2<float, P> const & v)
  {
   tvec2<int16, P> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y));
   u16vec2 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec2<float, P> unpack(tvec2<uint16, P> const & v)
  {
   i16vec2 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec2<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y));
  }
 };

 template <precision P>
 struct compute_half<P, tvec3>
 { inline
                     static tvec3<uint16, P> pack(tvec3<float, P> const & v)
  {
   tvec3<int16, P> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z));
   u16vec3 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec3<float, P> unpack(tvec3<uint16, P> const & v)
  {
   i16vec3 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec3<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z));
  }
 };

 template <precision P>
 struct compute_half<P, tvec4>
 { inline
                     static tvec4<uint16, P> pack(tvec4<float, P> const & v)
  {
   tvec4<int16, P> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z), detail::toFloat16(v.w));
   u16vec4 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec4<float, P> unpack(tvec4<uint16, P> const & v)
  {
   i16vec4 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec4<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z), detail::toFloat32(v.w));
  }
 };
} inline

                    uint8 packUnorm1x8(float v)
 {
  return static_cast<uint8>(round(clamp(v, 0.0f, 1.0f) * 255.0f));
 } inline

                    float unpackUnorm1x8(uint8 p)
 {
  float const Unpack(p);
  return Unpack * static_cast<float>(0.0039215686274509803921568627451);
 } inline

                    uint16 packUnorm2x8(vec2 const & v)
 {
  u8vec2 const Topack(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  uint16 Unpack = 0;
  memcpy(&Unpack, &Topack, sizeof(Unpack));
  return Unpack;
 } inline

                    vec2 unpackUnorm2x8(uint16 p)
 {
  u8vec2 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return vec2(Unpack) * float(0.0039215686274509803921568627451);
 } inline

                    uint8 packSnorm1x8(float v)
 {
  int8 const Topack(static_cast<int8>(round(clamp(v ,-1.0f, 1.0f) * 127.0f)));
  uint8 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    float unpackSnorm1x8(uint8 p)
 {
  int8 Unpack = 0;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   static_cast<float>(Unpack) * 0.00787401574803149606299212598425f,
   -1.0f, 1.0f);
 } inline

                    uint16 packSnorm2x8(vec2 const & v)
 {
  i8vec2 const Topack(round(clamp(v, -1.0f, 1.0f) * 127.0f));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    vec2 unpackSnorm2x8(uint16 p)
 {
  i8vec2 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   vec2(Unpack) * 0.00787401574803149606299212598425f,
   -1.0f, 1.0f);
 } inline

                    uint16 packUnorm1x16(float s)
 {
  return static_cast<uint16>(round(clamp(s, 0.0f, 1.0f) * 65535.0f));
 } inline

                    float unpackUnorm1x16(uint16 p)
 {
  float const Unpack(p);
  return Unpack * 1.5259021896696421759365224689097e-5f;
 } inline

                    uint64 packUnorm4x16(vec4 const & v)
 {
  u16vec4 const Topack(round(clamp(v , 0.0f, 1.0f) * 65535.0f));
  uint64 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    vec4 unpackUnorm4x16(uint64 p)
 {
  u16vec4 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return vec4(Unpack) * 1.5259021896696421759365224689097e-5f;
 } inline

                    uint16 packSnorm1x16(float v)
 {
  int16 const Topack = static_cast<int16>(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    float unpackSnorm1x16(uint16 p)
 {
  int16 Unpack = 0;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   static_cast<float>(Unpack) * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 } inline

                    uint64 packSnorm4x16(vec4 const & v)
 {
  i16vec4 const Topack(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
  uint64 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    vec4 unpackSnorm4x16(uint64 p)
 {
  i16vec4 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   vec4(Unpack) * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 } inline

                    uint16 packHalf1x16(float v)
 {
  int16 const Topack(detail::toFloat16(v));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    float unpackHalf1x16(uint16 v)
 {
  int16 Unpack = 0;
  memcpy(&Unpack, &v, sizeof(Unpack));
  return detail::toFloat32(Unpack);
 } inline

                    uint64 packHalf4x16(glm::vec4 const & v)
 {
  i16vec4 const Unpack(
   detail::toFloat16(v.x),
   detail::toFloat16(v.y),
   detail::toFloat16(v.z),
   detail::toFloat16(v.w));
  uint64 Packed = 0;
  memcpy(&Packed, &Unpack, sizeof(Packed));
  return Packed;
 } inline

                    glm::vec4 unpackHalf4x16(uint64 v)
 {
  i16vec4 Unpack(uninitialize);
  memcpy(&Unpack, &v, sizeof(Unpack));
  return vec4(
   detail::toFloat32(Unpack.x),
   detail::toFloat32(Unpack.y),
   detail::toFloat32(Unpack.z),
   detail::toFloat32(Unpack.w));
 } inline

                    uint32 packI3x10_1x2(ivec4 const & v)
 {
  detail::i10i10i10i2 Result;
  Result.data.x = v.x;
  Result.data.y = v.y;
  Result.data.z = v.z;
  Result.data.w = v.w;
  return Result.pack;
 } inline

                    ivec4 unpackI3x10_1x2(uint32 v)
 {
  detail::i10i10i10i2 Unpack;
  Unpack.pack = v;
  return ivec4(
   Unpack.data.x,
   Unpack.data.y,
   Unpack.data.z,
   Unpack.data.w);
 } inline

                    uint32 packU3x10_1x2(uvec4 const & v)
 {
  detail::u10u10u10u2 Result;
  Result.data.x = v.x;
  Result.data.y = v.y;
  Result.data.z = v.z;
  Result.data.w = v.w;
  return Result.pack;
 } inline

                    uvec4 unpackU3x10_1x2(uint32 v)
 {
  detail::u10u10u10u2 Unpack;
  Unpack.pack = v;
  return uvec4(
   Unpack.data.x,
   Unpack.data.y,
   Unpack.data.z,
   Unpack.data.w);
 } inline

                    uint32 packSnorm3x10_1x2(vec4 const & v)
 {
  detail::i10i10i10i2 Result;
  Result.data.x = int(round(clamp(v.x,-1.0f, 1.0f) * 511.f));
  Result.data.y = int(round(clamp(v.y,-1.0f, 1.0f) * 511.f));
  Result.data.z = int(round(clamp(v.z,-1.0f, 1.0f) * 511.f));
  Result.data.w = int(round(clamp(v.w,-1.0f, 1.0f) * 1.f));
  return Result.pack;
 } inline

                    vec4 unpackSnorm3x10_1x2(uint32 v)
 {
  detail::i10i10i10i2 Unpack;
  Unpack.pack = v;
  vec4 Result;
  Result.x = clamp(float(Unpack.data.x) / 511.f, -1.0f, 1.0f);
  Result.y = clamp(float(Unpack.data.y) / 511.f, -1.0f, 1.0f);
  Result.z = clamp(float(Unpack.data.z) / 511.f, -1.0f, 1.0f);
  Result.w = clamp(float(Unpack.data.w) / 1.f, -1.0f, 1.0f);
  return Result;
 } inline

                    uint32 packUnorm3x10_1x2(vec4 const & v)
 {
  uvec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(1023.f, 1023.f, 1023.f, 3.f)));

  detail::u10u10u10u2 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 } inline

                    vec4 unpackUnorm3x10_1x2(uint32 v)
 {
  vec4 const ScaleFactors(1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 3.f);

  detail::u10u10u10u2 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactors;
 } inline

                    uint32 packF2x11_1x10(vec3 const & v)
 {
  return
   ((detail::floatTo11bit(v.x) & ((1 << 11) - 1)) << 0) |
   ((detail::floatTo11bit(v.y) & ((1 << 11) - 1)) << 11) |
   ((detail::floatTo10bit(v.z) & ((1 << 10) - 1)) << 22);
 } inline

                    vec3 unpackF2x11_1x10(uint32 v)
 {
  return vec3(
   detail::packed11bitToFloat(v >> 0),
   detail::packed11bitToFloat(v >> 11),
   detail::packed10bitToFloat(v >> 22));
 } inline

                    uint32 packF3x9_E1x5(vec3 const & v)
 {
  float const SharedExpMax = (pow(2.0f, 9.0f - 1.0f) / pow(2.0f, 9.0f)) * pow(2.0f, 31.f - 15.f);
  vec3 const Color = clamp(v, 0.0f, SharedExpMax);
  float const MaxColor = max(Color.x, max(Color.y, Color.z));

  float const ExpSharedP = max(-15.f - 1.f, floor(log2(MaxColor))) + 1.0f + 15.f;
  float const MaxShared = floor(MaxColor / pow(2.0f, (ExpSharedP - 16.f - 9.f)) + 0.5f);
  float const ExpShared = MaxShared == pow(2.0f, 9.0f) ? ExpSharedP + 1.0f : ExpSharedP;

  uvec3 const ColorComp(floor(Color / pow(2.f, (ExpShared - 15.f - 9.f)) + 0.5f));

  detail::u9u9u9e5 Unpack;
  Unpack.data.x = ColorComp.x;
  Unpack.data.y = ColorComp.y;
  Unpack.data.z = ColorComp.z;
  Unpack.data.w = uint(ExpShared);
  return Unpack.pack;
 } inline

                    vec3 unpackF3x9_E1x5(uint32 v)
 {
  detail::u9u9u9e5 Unpack;
  Unpack.pack = v;

  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * pow(2.0f, Unpack.data.w - 15.f - 9.f);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<uint16, P> packHalf(vecType<float, P> const & v)
 {
  return detail::compute_half<P, vecType>::pack(v);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<float, P> unpackHalf(vecType<uint16, P> const & v)
 {
  return detail::compute_half<P, vecType>::unpack(v);
 }

 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<uintType, P> packUnorm(vecType<floatType, P> const & v)
 {
                                                                                                  ;
                                                                                                         ;

  return vecType<uintType, P>(round(clamp(v, static_cast<floatType>(0), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<uintType>::max())));
 }

 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<floatType, P> unpackUnorm(vecType<uintType, P> const & v)
 {
                                                                                                  ;
                                                                                                         ;

  return vecType<float, P>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<uintType>::max()));
 }

 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<intType, P> packSnorm(vecType<floatType, P> const & v)
 {
                                                                                                 ;
                                                                                                         ;

  return vecType<intType, P>(round(clamp(v , static_cast<floatType>(-1), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<intType>::max())));
 }

 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<floatType, P> unpackSnorm(vecType<intType, P> const & v)
 {
                                                                                                 ;
                                                                                                         ;

  return clamp(vecType<floatType, P>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<intType>::max())), static_cast<floatType>(-1), static_cast<floatType>(1));
 } inline

                    uint8 packUnorm2x4(vec2 const & v)
 {
  u32vec2 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
  detail::u4u4 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  return Result.pack;
 } inline

                    vec2 unpackUnorm2x4(uint8 v)
 {
  float const ScaleFactor(1.f / 15.f);
  detail::u4u4 Unpack;
  Unpack.pack = v;
  return vec2(Unpack.data.x, Unpack.data.y) * ScaleFactor;
 } inline

                    uint16 packUnorm4x4(vec4 const & v)
 {
  u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
  detail::u4u4u4u4 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 } inline

                    vec4 unpackUnorm4x4(uint16 v)
 {
  float const ScaleFactor(1.f / 15.f);
  detail::u4u4u4u4 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
 } inline

                    uint16 packUnorm1x5_1x6_1x5(vec3 const & v)
 {
  u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(31.f, 63.f, 31.f)));
  detail::u5u6u5 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  return Result.pack;
 } inline

                    vec3 unpackUnorm1x5_1x6_1x5(uint16 v)
 {
  vec3 const ScaleFactor(1.f / 31.f, 1.f / 63.f, 1.f / 31.f);
  detail::u5u6u5 Unpack;
  Unpack.pack = v;
  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
 } inline

                    uint16 packUnorm3x5_1x1(vec4 const & v)
 {
  u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(31.f, 31.f, 31.f, 1.f)));
  detail::u5u5u5u1 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 } inline

                    vec4 unpackUnorm3x5_1x1(uint16 v)
 {
  vec4 const ScaleFactor(1.f / 31.f, 1.f / 31.f, 1.f / 31.f, 1.f);
  detail::u5u5u5u1 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
 } inline

                    uint8 packUnorm2x3_1x2(vec3 const & v)
 {
  u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(7.f, 7.f, 3.f)));
  detail::u3u3u2 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  return Result.pack;
 } inline

                    vec3 unpackUnorm2x3_1x2(uint8 v)
 {
  vec3 const ScaleFactor(1.f / 7.f, 1.f / 7.f, 1.f / 3.f);
  detail::u3u3u2 Unpack;
  Unpack.pack = v;
  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
 }
}
# 579 "/usr/local/include/glm/./gtc/packing.hpp" 2 3
# 48 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/random.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/random.hpp" 3
namespace glm
{
# 36 "/usr/local/include/glm/./gtc/random.hpp" 3
 template <typename genTYpe>
               genTYpe linearRand(
  genTYpe Min,
  genTYpe Max);
# 48 "/usr/local/include/glm/./gtc/random.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> linearRand(
  vecType<T, P> const & Min,
  vecType<T, P> const & Max);






 template <typename genType>
               genType gaussRand(
  genType Mean,
  genType Deviation);





 template <typename T>
               tvec2<T, defaultp> circularRand(
  T Radius);





 template <typename T>
               tvec3<T, defaultp> sphericalRand(
  T Radius);





 template <typename T>
               tvec2<T, defaultp> diskRand(
  T Radius);





 template <typename T>
               tvec3<T, defaultp> ballRand(
  T Radius);


}


# 1 "/usr/local/include/glm/gtc/random.inl" 1 3







# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 8 "/usr/local/include/glm/gtc/random.inl" 2 3


namespace glm{
namespace detail
{
 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_rand
 { inline
                     static vecType<T, P> call();
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec1>
 { inline
                     static tvec1<uint8, P> call()
  {
   return tvec1<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec2>
 { inline
                     static tvec2<uint8, P> call()
  {
   return tvec2<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec3>
 { inline
                     static tvec3<uint8, P> call()
  {
   return tvec3<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec4>
 { inline
                     static tvec4<uint8, P> call()
  {
   return tvec4<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_rand<uint16, P, vecType>
 { inline
                     static vecType<uint16, P> call()
  {
   return
    (vecType<uint16, P>(compute_rand<uint8, P, vecType>::call()) << static_cast<uint16>(8)) |
    (vecType<uint16, P>(compute_rand<uint8, P, vecType>::call()) << static_cast<uint16>(0));
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_rand<uint32, P, vecType>
 { inline
                     static vecType<uint32, P> call()
  {
   return
    (vecType<uint32, P>(compute_rand<uint16, P, vecType>::call()) << static_cast<uint32>(16)) |
    (vecType<uint32, P>(compute_rand<uint16, P, vecType>::call()) << static_cast<uint32>(0));
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_rand<uint64, P, vecType>
 { inline
                     static vecType<uint64, P> call()
  {
   return
    (vecType<uint64, P>(compute_rand<uint32, P, vecType>::call()) << static_cast<uint64>(32)) |
    (vecType<uint64, P>(compute_rand<uint32, P, vecType>::call()) << static_cast<uint64>(0));
  }
 };

 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_linearRand
 { inline
                     static vecType<T, P> call(vecType<T, P> const & Min, vecType<T, P> const & Max);
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int8, P, vecType>
 { inline
                     static vecType<int8, P> call(vecType<int8, P> const & Min, vecType<int8, P> const & Max)
  {
   return (vecType<int8, P>(compute_rand<uint8, P, vecType>::call() % vecType<uint8, P>(Max + static_cast<int8>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint8, P, vecType>
 { inline
                     static vecType<uint8, P> call(vecType<uint8, P> const & Min, vecType<uint8, P> const & Max)
  {
   return (compute_rand<uint8, P, vecType>::call() % (Max + static_cast<uint8>(1) - Min)) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int16, P, vecType>
 { inline
                     static vecType<int16, P> call(vecType<int16, P> const & Min, vecType<int16, P> const & Max)
  {
   return (vecType<int16, P>(compute_rand<uint16, P, vecType>::call() % vecType<uint16, P>(Max + static_cast<int16>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint16, P, vecType>
 { inline
                     static vecType<uint16, P> call(vecType<uint16, P> const & Min, vecType<uint16, P> const & Max)
  {
   return (compute_rand<uint16, P, vecType>::call() % (Max + static_cast<uint16>(1) - Min)) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int32, P, vecType>
 { inline
                     static vecType<int32, P> call(vecType<int32, P> const & Min, vecType<int32, P> const & Max)
  {
   return (vecType<int32, P>(compute_rand<uint32, P, vecType>::call() % vecType<uint32, P>(Max + static_cast<int32>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint32, P, vecType>
 { inline
                     static vecType<uint32, P> call(vecType<uint32, P> const & Min, vecType<uint32, P> const & Max)
  {
   return (compute_rand<uint32, P, vecType>::call() % (Max + static_cast<uint32>(1) - Min)) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int64, P, vecType>
 { inline
                     static vecType<int64, P> call(vecType<int64, P> const & Min, vecType<int64, P> const & Max)
  {
   return (vecType<int64, P>(compute_rand<uint64, P, vecType>::call() % vecType<uint64, P>(Max + static_cast<int64>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint64, P, vecType>
 { inline
                     static vecType<uint64, P> call(vecType<uint64, P> const & Min, vecType<uint64, P> const & Max)
  {
   return (compute_rand<uint64, P, vecType>::call() % (Max + static_cast<uint64>(1) - Min)) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<float, lowp, vecType>
 { inline
                     static vecType<float, lowp> call(vecType<float, lowp> const & Min, vecType<float, lowp> const & Max)
  {
   return vecType<float, lowp>(compute_rand<uint8, lowp, vecType>::call()) / static_cast<float>(std::numeric_limits<uint8>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<float, mediump, vecType>
 { inline
                     static vecType<float, mediump> call(vecType<float, mediump> const & Min, vecType<float, mediump> const & Max)
  {
   return vecType<float, mediump>(compute_rand<uint16, mediump, vecType>::call()) / static_cast<float>(std::numeric_limits<uint16>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<float, highp, vecType>
 { inline
                     static vecType<float, highp> call(vecType<float, highp> const & Min, vecType<float, highp> const & Max)
  {
   return vecType<float, highp>(compute_rand<uint32, highp, vecType>::call()) / static_cast<float>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<double, lowp, vecType>
 { inline
                     static vecType<double, lowp> call(vecType<double, lowp> const & Min, vecType<double, lowp> const & Max)
  {
   return vecType<double, lowp>(compute_rand<uint16, lowp, vecType>::call()) / static_cast<double>(std::numeric_limits<uint16>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<double, mediump, vecType>
 { inline
                     static vecType<double, mediump> call(vecType<double, mediump> const & Min, vecType<double, mediump> const & Max)
  {
   return vecType<double, mediump>(compute_rand<uint32, mediump, vecType>::call()) / static_cast<double>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<double, highp, vecType>
 { inline
                     static vecType<double, highp> call(vecType<double, highp> const & Min, vecType<double, highp> const & Max)
  {
   return vecType<double, highp>(compute_rand<uint64, highp, vecType>::call()) / static_cast<double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<long double, lowp, vecType>
 { inline
                     static vecType<long double, lowp> call(vecType<long double, lowp> const & Min, vecType<long double, lowp> const & Max)
  {
   return vecType<long double, lowp>(compute_rand<uint32, lowp, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<long double, mediump, vecType>
 { inline
                     static vecType<long double, mediump> call(vecType<long double, mediump> const & Min, vecType<long double, mediump> const & Max)
  {
   return vecType<long double, mediump>(compute_rand<uint64, mediump, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<long double, highp, vecType>
 { inline
                     static vecType<long double, highp> call(vecType<long double, highp> const & Min, vecType<long double, highp> const & Max)
  {
   return vecType<long double, highp>(compute_rand<uint64, highp, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };
}

 template <typename genType> inline
                    genType linearRand(genType Min, genType Max)
 {
  return detail::compute_linearRand<genType, highp, tvec1>::call(
   tvec1<genType, highp>(Min),
   tvec1<genType, highp>(Max)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> linearRand(vecType<T, P> const & Min, vecType<T, P> const & Max)
 {
  return detail::compute_linearRand<T, P, vecType>::call(Min, Max);
 }

 template <typename genType> inline
                    genType gaussRand(genType Mean, genType Deviation)
 {
  genType w, x1, x2;

  do
  {
   x1 = linearRand(genType(-1), genType(1));
   x2 = linearRand(genType(-1), genType(1));

   w = x1 * x1 + x2 * x2;
  } while(w > genType(1));

  return x2 * Deviation * Deviation * sqrt((genType(-2) * log(w)) / w) + Mean;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> gaussRand(vecType<T, P> const & Mean, vecType<T, P> const & Deviation)
 {
  return detail::functor2<T, P, vecType>::call(gaussRand, Mean, Deviation);
 }

 template <typename T> inline
                    tvec2<T, defaultp> diskRand(T Radius)
 {
  tvec2<T, defaultp> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(
    tvec2<T, defaultp>(-Radius),
    tvec2<T, defaultp>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template <typename T> inline
                    tvec3<T, defaultp> ballRand(T Radius)
 {
  tvec3<T, defaultp> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(
    tvec3<T, defaultp>(-Radius),
    tvec3<T, defaultp>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template <typename T> inline
                    tvec2<T, defaultp> circularRand(T Radius)
 {
  T a = linearRand(T(0), T(6.283185307179586476925286766559f));
  return tvec2<T, defaultp>(cos(a), sin(a)) * Radius;
 }

 template <typename T> inline
                    tvec3<T, defaultp> sphericalRand(T Radius)
 {
  T z = linearRand(T(-1), T(1));
  T a = linearRand(T(0), T(6.283185307179586476925286766559f));

  T r = sqrt(T(1) - z * z);

  T x = r * cos(a);
  T y = r * sin(a);

  return tvec3<T, defaultp>(x, y, z) * Radius;
 }
}
# 98 "/usr/local/include/glm/./gtc/random.hpp" 2 3
# 50 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/reciprocal.hpp" 1 3
# 22 "/usr/local/include/glm/./gtc/reciprocal.hpp" 3
namespace glm
{
# 33 "/usr/local/include/glm/./gtc/reciprocal.hpp" 3
 template <typename genType>
               genType sec(genType angle);







 template <typename genType>
               genType csc(genType angle);







 template <typename genType>
               genType cot(genType angle);







 template <typename genType>
               genType asec(genType x);







 template <typename genType>
               genType acsc(genType x);







 template <typename genType>
               genType acot(genType x);






 template <typename genType>
               genType sech(genType angle);






 template <typename genType>
               genType csch(genType angle);






 template <typename genType>
               genType coth(genType angle);







 template <typename genType>
               genType asech(genType x);







 template <typename genType>
               genType acsch(genType x);







 template <typename genType>
               genType acoth(genType x);


}


# 1 "/usr/local/include/glm/gtc/reciprocal.inl" 1 3






namespace glm
{

 template <typename genType> inline
                    genType sec(genType angle)
 {
                                                                                                       ;
  return genType(1) / glm::cos(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sec(vecType<T, P> const & x)
 {
                                                                                                 ;
  return detail::functor1<T, T, P, vecType>::call(sec, x);
 }


 template <typename genType> inline
                    genType csc(genType angle)
 {
                                                                                                       ;
  return genType(1) / glm::sin(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> csc(vecType<T, P> const & x)
 {
                                                                                                 ;
  return detail::functor1<T, T, P, vecType>::call(csc, x);
 }


 template <typename genType> inline
                    genType cot(genType angle)
 {
                                                                                                       ;

  genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
  return glm::tan(pi_over_2 - angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cot(vecType<T, P> const & x)
 {
                                                                                                 ;
  return detail::functor1<T, T, P, vecType>::call(cot, x);
 }


 template <typename genType> inline
                    genType asec(genType x)
 {
                                                                                                        ;
  return acos(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asec(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(asec, x);
 }


 template <typename genType> inline
                    genType acsc(genType x)
 {
                                                                                                        ;
  return asin(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acsc(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(acsc, x);
 }


 template <typename genType> inline
                    genType acot(genType x)
 {
                                                                                                        ;

  genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
  return pi_over_2 - atan(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acot(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(acot, x);
 }


 template <typename genType> inline
                    genType sech(genType angle)
 {
                                                                                                        ;
  return genType(1) / glm::cosh(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sech(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(sech, x);
 }


 template <typename genType> inline
                    genType csch(genType angle)
 {
                                                                                                        ;
  return genType(1) / glm::sinh(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> csch(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(csch, x);
 }


 template <typename genType> inline
                    genType coth(genType angle)
 {
                                                                                                        ;
  return glm::cosh(angle) / glm::sinh(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> coth(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(coth, x);
 }


 template <typename genType> inline
                    genType asech(genType x)
 {
                                                                                                         ;
  return acosh(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asech(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::functor1<T, T, P, vecType>::call(asech, x);
 }


 template <typename genType> inline
                    genType acsch(genType x)
 {
                                                                                                         ;
  return acsch(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acsch(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::functor1<T, T, P, vecType>::call(acsch, x);
 }


 template <typename genType> inline
                    genType acoth(genType x)
 {
                                                                                                         ;
  return atanh(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acoth(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::functor1<T, T, P, vecType>::call(acoth, x);
 }
}
# 135 "/usr/local/include/glm/./gtc/reciprocal.hpp" 2 3
# 51 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/round.hpp" 1 3
# 28 "/usr/local/include/glm/./gtc/round.hpp" 3
namespace glm
{






 template <typename genIUType>
               bool isPowerOfTwo(genIUType Value);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isPowerOfTwo(vecType<T, P> const & value);





 template <typename genIUType>
               genIUType ceilPowerOfTwo(genIUType Value);





 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> ceilPowerOfTwo(vecType<T, P> const & value);





 template <typename genIUType>
               genIUType floorPowerOfTwo(genIUType Value);





 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> floorPowerOfTwo(vecType<T, P> const & value);




 template <typename genIUType>
               genIUType roundPowerOfTwo(genIUType Value);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> roundPowerOfTwo(vecType<T, P> const & value);




 template <typename genIUType>
               bool isMultiple(genIUType Value, genIUType Multiple);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isMultiple(vecType<T, P> const & Value, T Multiple);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isMultiple(vecType<T, P> const & Value, vecType<T, P> const & Multiple);
# 110 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename genType>
               genType ceilMultiple(genType Source, genType Multiple);
# 120 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> ceilMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple);
# 130 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename genType>
               genType floorMultiple(
  genType Source,
  genType Multiple);
# 142 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> floorMultiple(
  vecType<T, P> const & Source,
  vecType<T, P> const & Multiple);
# 154 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename genType>
               genType roundMultiple(
  genType Source,
  genType Multiple);
# 166 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> roundMultiple(
  vecType<T, P> const & Source,
  vecType<T, P> const & Multiple);


}


# 1 "/usr/local/include/glm/gtc/round.inl" 1 3





namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType, bool compute = false>
 struct compute_ceilShift
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T)
  {
   return v;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_ceilShift<T, P, vecType, true>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T Shift)
  {
   return v | (v >> Shift);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool isSigned = true>
 struct compute_ceilPowerOfTwo
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
                                                                                                                        ;

   vecType<T, P> const Sign(sign(x));

   vecType<T, P> v(abs(x));

   v = v - static_cast<T>(1);
   v = v | (v >> static_cast<T>(1));
   v = v | (v >> static_cast<T>(2));
   v = v | (v >> static_cast<T>(4));
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 2>::call(v, 8);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 4>::call(v, 16);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 8>::call(v, 32);
   return (v + static_cast<T>(1)) * Sign;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_ceilPowerOfTwo<T, P, vecType, false>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
                                                                                                                        ;

   vecType<T, P> v(x);

   v = v - static_cast<T>(1);
   v = v | (v >> static_cast<T>(1));
   v = v | (v >> static_cast<T>(2));
   v = v | (v >> static_cast<T>(4));
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 2>::call(v, 8);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 4>::call(v, 16);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 8>::call(v, 32);
   return v + static_cast<T>(1);
  }
 };

 template <bool is_float, bool is_signed>
 struct compute_ceilMultiple{};

 template <>
 struct compute_ceilMultiple<true, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source > genType(0))
    return Source + (Multiple - std::fmod(Source, Multiple));
   else
    return Source + std::fmod(-Source, Multiple);
  }
 };

 template <>
 struct compute_ceilMultiple<false, false>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   genType Tmp = Source - genType(1);
   return Tmp + (Multiple - (Tmp % Multiple));
  }
 };

 template <>
 struct compute_ceilMultiple<false, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source > genType(0))
   {
    genType Tmp = Source - genType(1);
    return Tmp + (Multiple - (Tmp % Multiple));
   }
   else
    return Source + (-Source % Multiple);
  }
 };

 template <bool is_float, bool is_signed>
 struct compute_floorMultiple{};

 template <>
 struct compute_floorMultiple<true, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - std::fmod(Source, Multiple);
   else
    return Source - std::fmod(Source, Multiple) - Multiple;
  }
 };

 template <>
 struct compute_floorMultiple<false, false>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template <>
 struct compute_floorMultiple<false, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template <bool is_float, bool is_signed>
 struct compute_roundMultiple{};

 template <>
 struct compute_roundMultiple<true, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - std::fmod(Source, Multiple);
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - std::fmod(Tmp, Multiple) - Multiple;
   }
  }
 };

 template <>
 struct compute_roundMultiple<false, false>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template <>
 struct compute_roundMultiple<false, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };
}




 template <typename genType> inline
                    bool isPowerOfTwo(genType Value)
 {
  genType const Result = glm::abs(Value);
  return !(Result & (Result - 1));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isPowerOfTwo(vecType<T, P> const & Value)
 {
  vecType<T, P> const Result(abs(Value));
  return equal(Result & (Result - 1), vecType<T, P>(0));
 }




 template <typename genType> inline
                    genType ceilPowerOfTwo(genType value)
 {
  return detail::compute_ceilPowerOfTwo<genType, defaultp, tvec1, std::numeric_limits<genType>::is_signed>::call(tvec1<genType, defaultp>(value)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> ceilPowerOfTwo(vecType<T, P> const & v)
 {
  return detail::compute_ceilPowerOfTwo<T, P, vecType, std::numeric_limits<T>::is_signed>::call(v);
 }




 template <typename genType> inline
                    genType floorPowerOfTwo(genType value)
 {
  return isPowerOfTwo(value) ? value : static_cast<genType>(1) << findMSB(value);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> floorPowerOfTwo(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(floorPowerOfTwo, v);
 }




 template <typename genIUType> inline
                    genIUType roundPowerOfTwo(genIUType value)
 {
  if(isPowerOfTwo(value))
   return value;

  genIUType const prev = static_cast<genIUType>(1) << findMSB(value);
  genIUType const next = prev << static_cast<genIUType>(1);
  return (next - value) < (value - prev) ? next : prev;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> roundPowerOfTwo(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(roundPowerOfTwo, v);
 }




 template <typename genType> inline
                    bool isMultiple(genType Value, genType Multiple)
 {
  return isMultiple(tvec1<genType>(Value), tvec1<genType>(Multiple)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isMultiple(vecType<T, P> const & Value, T Multiple)
 {
  return (Value % Multiple) == vecType<T, P>(0);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isMultiple(vecType<T, P> const & Value, vecType<T, P> const & Multiple)
 {
  return (Value % Multiple) == vecType<T, P>(0);
 }




 template <typename genType> inline
                    genType ceilMultiple(genType Source, genType Multiple)
 {
  return detail::compute_ceilMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> ceilMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple)
 {
  return detail::functor2<T, P, vecType>::call(ceilMultiple, Source, Multiple);
 }




 template <typename genType> inline
                    genType floorMultiple(genType Source, genType Multiple)
 {
  return detail::compute_floorMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> floorMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple)
 {
  return detail::functor2<T, P, vecType>::call(floorMultiple, Source, Multiple);
 }




 template <typename genType> inline
                    genType roundMultiple(genType Source, genType Multiple)
 {
  return detail::compute_roundMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> roundMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple)
 {
  return detail::functor2<T, P, vecType>::call(roundMultiple, Source, Multiple);
 }
}
# 174 "/usr/local/include/glm/./gtc/round.hpp" 2 3
# 52 "/usr/local/include/glm/ext.hpp" 2 3




# 1 "/usr/local/include/glm/./gtc/ulp.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/ulp.hpp" 3
namespace glm
{





 template <typename genType>
               genType next_float(genType const & x);



 template <typename genType>
               genType prev_float(genType const & x);



 template <typename genType>
               genType next_float(genType const & x, uint const & Distance);



 template <typename genType>
               genType prev_float(genType const & x, uint const & Distance);



 template <typename T>
               uint float_distance(T const & x, T const & y);



 template<typename T, template<typename> class vecType>
               vecType<uint> float_distance(vecType<T> const & x, vecType<T> const & y);


}


# 1 "/usr/local/include/glm/gtc/ulp.inl" 1 3
# 21 "/usr/local/include/glm/gtc/ulp.inl" 3
typedef union
{
 float value;

 unsigned int word;
} ieee_float_shape_type;

typedef union
{
 double value;
 struct
 {
  glm::detail::int32 lsw;
  glm::detail::int32 msw;
 } parts;
} ieee_double_shape_type;
# 68 "/usr/local/include/glm/gtc/ulp.inl" 3
namespace glm{
namespace detail
{ inline
                    float nextafterf(float x, float y)
 {
  volatile float t;
  glm::detail::int32 hx, hy, ix, iy;

  do { ieee_float_shape_type gf_u; gf_u.value = (x); (hx) = gf_u.word; } while (0);
  do { ieee_float_shape_type gf_u; gf_u.value = (y); (hy) = gf_u.word; } while (0);
  ix = hx&0x7fffffff;
  iy = hy&0x7fffffff;

  if((ix>0x7f800000) ||
   (iy>0x7f800000))
   return x+y;
  if(x==y) return y;
  if(ix==0) {
   do { ieee_float_shape_type sf_u; sf_u.word = ((hy&0x80000000)|1); (x) = sf_u.value; } while (0);
   t = x*x;
   if(t==x) return t; else return x;
  }
  if(hx>=0) {
   if(hx>hy) {
    hx -= 1;
   } else {
    hx += 1;
   }
  } else {
   if(hy>=0||hx>hy){
    hx -= 1;
   } else {
    hx += 1;
   }
  }
  hy = hx&0x7f800000;
  if(hy>=0x7f800000) return x+x;
  if(hy<0x00800000) {
   t = x*x;
   if(t!=x) {
    do { ieee_float_shape_type sf_u; sf_u.word = (hx); (y) = sf_u.value; } while (0);
    return y;
   }
  }
  do { ieee_float_shape_type sf_u; sf_u.word = (hx); (x) = sf_u.value; } while (0);
  return x;
 } inline

                    double nextafter(double x, double y)
 {
  volatile double t;
  glm::detail::int32 hx, hy, ix, iy;
  glm::detail::uint32 lx, ly;

  do { ieee_double_shape_type ew_u; ew_u.value = (x); (hx) = ew_u.parts.msw; (lx) = ew_u.parts.lsw; } while (0);
  do { ieee_double_shape_type ew_u; ew_u.value = (y); (hy) = ew_u.parts.msw; (ly) = ew_u.parts.lsw; } while (0);
  ix = hx & 0x7fffffff;
  iy = hy & 0x7fffffff;

  if(((ix>=0x7ff00000)&&((ix-0x7ff00000)|lx)!=0) ||
   ((iy>=0x7ff00000)&&((iy-0x7ff00000)|ly)!=0))
   return x+y;
  if(x==y) return y;
  if((ix|lx)==0) {
   do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hy & 0x80000000); iw_u.parts.lsw = (1); (x) = iw_u.value; } while (0);
   t = x*x;
   if(t==x) return t; else return x;
  }
  if(hx>=0) {
   if(hx>hy||((hx==hy)&&(lx>ly))) {
    if(lx==0) hx -= 1;
    lx -= 1;
   } else {
    lx += 1;
    if(lx==0) hx += 1;
   }
  } else {
   if(hy>=0||hx>hy||((hx==hy)&&(lx>ly))){
    if(lx==0) hx -= 1;
    lx -= 1;
   } else {
    lx += 1;
    if(lx==0) hx += 1;
   }
  }
  hy = hx&0x7ff00000;
  if(hy>=0x7ff00000) return x+x;
  if(hy<0x00100000) {
   t = x*x;
   if(t!=x) {
    do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (y) = iw_u.value; } while (0);
    return y;
   }
  }
  do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (x) = iw_u.value; } while (0);
  return x;
 }
}
}





namespace glm
{
 template <> inline
                    float next_float(float const & x)
 {







   return nextafterf(x, 3.40282347e+38F);

 }

 template <> inline
                    double next_float(double const & x)
 {







   return nextafter(x, 1.7976931348623157e+308);

 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> next_float(vecType<T, P> const & x)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = next_float(x[i]);
  return Result;
 } inline

                    float prev_float(float const & x)
 {







   return nextafterf(x, 1.17549435e-38F);

 } inline

                    double prev_float(double const & x)
 {







   return nextafter(x, 2.2250738585072014e-308);

 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> prev_float(vecType<T, P> const & x)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prev_float(x[i]);
  return Result;
 }

 template <typename T> inline
                    T next_float(T const & x, uint const & ulps)
 {
  T temp = x;
  for(uint i = 0; i < ulps; ++i)
   temp = next_float(temp);
  return temp;
 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> next_float(vecType<T, P> const & x, vecType<uint, P> const & ulps)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = next_float(x[i], ulps[i]);
  return Result;
 }

 template <typename T> inline
                    T prev_float(T const & x, uint const & ulps)
 {
  T temp = x;
  for(uint i = 0; i < ulps; ++i)
   temp = prev_float(temp);
  return temp;
 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> prev_float(vecType<T, P> const & x, vecType<uint, P> const & ulps)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prev_float(x[i], ulps[i]);
  return Result;
 }

 template <typename T> inline
                    uint float_distance(T const & x, T const & y)
 {
  uint ulp = 0;

  if(x < y)
  {
   T temp = x;
   while(temp != y)
   {
    ++ulp;
    temp = next_float(temp);
   }
  }
  else if(y < x)
  {
   T temp = y;
   while(temp != x)
   {
    ++ulp;
    temp = next_float(temp);
   }
  }
  else
  {

  }

  return ulp;
 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<uint, P> float_distance(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  vecType<uint, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = float_distance(x[i], y[i]);
  return Result;
 }
}
# 63 "/usr/local/include/glm/./gtc/ulp.hpp" 2 3
# 56 "/usr/local/include/glm/ext.hpp" 2 3






# 1 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 3
namespace glm
{





 template<typename T, typename U, precision P>
               U associatedMin(T x, U a, T y, U b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               tvec2<U, P> associatedMin(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  T x, const vecType<U, P>& a,
  T y, const vecType<U, P>& b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b);



 template<typename T, typename U>
               U associatedMin(
  T x, U a,
  T y, U b,
  T z, U c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c);



 template<typename T, typename U>
               U associatedMin(
  T x, U a,
  T y, U b,
  T z, U c,
  T w, U d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c,
  vecType<T, P> const & w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b,
  T z, vecType<U, P> const & c,
  T w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b,
  vecType<T, P> const & z, U c,
  vecType<T, P> const & w, U d);



 template<typename T, typename U>
               U associatedMax(T x, U a, T y, U b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               tvec2<U, P> associatedMax(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> associatedMax(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b);



 template<typename T, typename U>
               U associatedMax(
  T x, U a,
  T y, U b,
  T z, U c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> associatedMax(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b,
  T z, vecType<U, P> const & c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b,
  vecType<T, P> const & z, U c);



 template<typename T, typename U>
               U associatedMax(
  T x, U a,
  T y, U b,
  T z, U c,
  T w, U d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c,
  vecType<T, P> const & w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b,
  T z, vecType<U, P> const & c,
  T w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b,
  vecType<T, P> const & z, U c,
  vecType<T, P> const & w, U d);


}


# 1 "/usr/local/include/glm/./gtx/associated_min_max.inl" 1 3



namespace glm{


template<typename T, typename U, precision P> inline
                   U associatedMin(T x, U a, T y, U b)
{
 return x < y ? a : b;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   tvec2<U, P> associatedMin
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] < y[i] ? a[i] : b[i];
 return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 T x, const vecType<U, P>& a,
 T y, const vecType<U, P>& b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x < y ? a[i] : b[i];
 return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] < y[i] ? a : b;
 return Result;
}


template<typename T, typename U> inline
                   U associatedMin
(
 T x, U a,
 T y, U b,
 T z, U c
)
{
 U Result = x < y ? (x < z ? a : c) : (y < z ? b : c);
 return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] < y[i] ? (x[i] < z[i] ? a[i] : c[i]) : (y[i] < z[i] ? b[i] : c[i]);
 return Result;
}


template<typename T, typename U> inline
                   U associatedMin
(
 T x, U a,
 T y, U b,
 T z, U c,
 T w, U d
)
{
 T Test1 = min(x, y);
 T Test2 = min(z, w);;
 U Result1 = x < y ? a : b;
 U Result2 = z < w ? c : d;
 U Result = Test1 < Test2 ? Result1 : Result2;
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c,
 vecType<T, P> const & w, vecType<U, P> const & d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = min(x[i], y[i]);
  T Test2 = min(z[i], w[i]);
  U Result1 = x[i] < y[i] ? a[i] : b[i];
  U Result2 = z[i] < w[i] ? c[i] : d[i];
  Result[i] = Test1 < Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b,
 T z, vecType<U, P> const & c,
 T w, vecType<U, P> const & d
)
{
 T Test1 = min(x, y);
 T Test2 = min(z, w);

 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  U Result1 = x < y ? a[i] : b[i];
  U Result2 = z < w ? c[i] : d[i];
  Result[i] = Test1 < Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b,
 vecType<T, P> const & z, U c,
 vecType<T, P> const & w, U d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = min(x[i], y[i]);
  T Test2 = min(z[i], w[i]);;
  U Result1 = x[i] < y[i] ? a : b;
  U Result2 = z[i] < w[i] ? c : d;
  Result[i] = Test1 < Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U> inline
                   U associatedMax(T x, U a, T y, U b)
{
 return x > y ? a : b;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   tvec2<U, P> associatedMax
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? a[i] : b[i];
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<T, P> associatedMax
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x > y ? a[i] : b[i];
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b
)
{
 vecType<T, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? a : b;
 return Result;
}


template<typename T, typename U> inline
                   U associatedMax
(
 T x, U a,
 T y, U b,
 T z, U c
)
{
 U Result = x > y ? (x > z ? a : c) : (y > z ? b : c);
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? (x[i] > z[i] ? a[i] : c[i]) : (y[i] > z[i] ? b[i] : c[i]);
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<T, P> associatedMax
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b,
 T z, vecType<U, P> const & c
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x > y ? (x > z ? a[i] : c[i]) : (y > z ? b[i] : c[i]);
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b,
 vecType<T, P> const & z, U c
)
{
 vecType<T, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? (x[i] > z[i] ? a : c) : (y[i] > z[i] ? b : c);
 return Result;
}


template<typename T, typename U> inline
                   U associatedMax
(
 T x, U a,
 T y, U b,
 T z, U c,
 T w, U d
)
{
 T Test1 = max(x, y);
 T Test2 = max(z, w);;
 U Result1 = x > y ? a : b;
 U Result2 = z > w ? c : d;
 U Result = Test1 > Test2 ? Result1 : Result2;
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c,
 vecType<T, P> const & w, vecType<U, P> const & d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = max(x[i], y[i]);
  T Test2 = max(z[i], w[i]);
  U Result1 = x[i] > y[i] ? a[i] : b[i];
  U Result2 = z[i] > w[i] ? c[i] : d[i];
  Result[i] = Test1 > Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b,
 T z, vecType<U, P> const & c,
 T w, vecType<U, P> const & d
)
{
 T Test1 = max(x, y);
 T Test2 = max(z, w);

 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  U Result1 = x > y ? a[i] : b[i];
  U Result2 = z > w ? c[i] : d[i];
  Result[i] = Test1 > Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b,
 vecType<T, P> const & z, U c,
 vecType<T, P> const & w, U d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = max(x[i], y[i]);
  T Test2 = max(z[i], w[i]);;
  U Result1 = x[i] > y[i] ? a : b;
  U Result2 = z[i] > w[i] ? c : d;
  Result[i] = Test1 > Test2 ? Result1 : Result2;
 }
 return Result;
}
}
# 202 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 2 3
# 62 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/bit.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/bit.hpp" 3
namespace glm
{




 template <typename genIUType>
               genIUType highestBitValue(genIUType Value);


 template <typename genIUType>
               genIUType lowestBitValue(genIUType Value);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> highestBitValue(vecType<T, P> const & value);






 template <typename genIUType>
 __attribute__((__deprecated__)) genIUType powerOfTwoAbove(genIUType Value);






 template <typename T, precision P, template <typename, precision> class vecType>
 __attribute__((__deprecated__)) vecType<T, P> powerOfTwoAbove(vecType<T, P> const & value);






 template <typename genIUType>
 __attribute__((__deprecated__)) genIUType powerOfTwoBelow(genIUType Value);






 template <typename T, precision P, template <typename, precision> class vecType>
 __attribute__((__deprecated__)) vecType<T, P> powerOfTwoBelow(vecType<T, P> const & value);






 template <typename genIUType>
 __attribute__((__deprecated__)) genIUType powerOfTwoNearest(genIUType Value);






 template <typename T, precision P, template <typename, precision> class vecType>
 __attribute__((__deprecated__)) vecType<T, P> powerOfTwoNearest(vecType<T, P> const & value);


}



# 1 "/usr/local/include/glm/./gtx/bit.inl" 1 3



namespace glm
{



 template <typename genIUType> inline
                    genIUType highestBitValue(genIUType Value)
 {
  genIUType tmp = Value;
  genIUType result = genIUType(0);
  while(tmp)
  {
   result = (tmp & (~tmp + 1));
   tmp &= ~result;
  }
  return result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> highestBitValue(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(highestBitValue, v);
 }




 template <typename genIUType> inline
                    genIUType lowestBitValue(genIUType Value)
 {
  return (Value & (~Value + 1));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> lowestBitValue(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(lowestBitValue, v);
 }




 template <typename genType> inline
                    genType powerOfTwoAbove(genType value)
 {
  return isPowerOfTwo(value) ? value : highestBitValue(value) << 1;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> powerOfTwoAbove(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(powerOfTwoAbove, v);
 }




 template <typename genType> inline
                    genType powerOfTwoBelow(genType value)
 {
  return isPowerOfTwo(value) ? value : highestBitValue(value);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> powerOfTwoBelow(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(powerOfTwoBelow, v);
 }




 template <typename genType> inline
                    genType powerOfTwoNearest(genType value)
 {
  if(isPowerOfTwo(value))
   return value;

  genType const prev = highestBitValue(value);
  genType const next = prev << 1;
  return (next - value) < (value - prev) ? next : prev;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> powerOfTwoNearest(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(powerOfTwoNearest, v);
 }

}
# 94 "/usr/local/include/glm/./gtx/bit.hpp" 2 3
# 63 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/closest_point.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/closest_point.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> closestPointOnLine(
  tvec3<T, P> const & point,
  tvec3<T, P> const & a,
  tvec3<T, P> const & b);


 template <typename T, precision P>
               tvec2<T, P> closestPointOnLine(
  tvec2<T, P> const & point,
  tvec2<T, P> const & a,
  tvec2<T, P> const & b);


}


# 1 "/usr/local/include/glm/./gtx/closest_point.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> closestPointOnLine
 (
  tvec3<T, P> const & point,
  tvec3<T, P> const & a,
  tvec3<T, P> const & b
 )
 {
  T LineLength = distance(a, b);
  tvec3<T, P> Vector = point - a;
  tvec3<T, P> LineDirection = (b - a) / LineLength;


  T Distance = dot(Vector, LineDirection);

  if(Distance <= T(0)) return a;
  if(Distance >= LineLength) return b;
  return a + LineDirection * Distance;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> closestPointOnLine
 (
  tvec2<T, P> const & point,
  tvec2<T, P> const & a,
  tvec2<T, P> const & b
 )
 {
  T LineLength = distance(a, b);
  tvec2<T, P> Vector = point - a;
  tvec2<T, P> LineDirection = (b - a) / LineLength;


  T Distance = dot(Vector, LineDirection);

  if(Distance <= T(0)) return a;
  if(Distance >= LineLength) return b;
  return a + LineDirection * Distance;
 }

}
# 45 "/usr/local/include/glm/./gtx/closest_point.hpp" 2 3
# 64 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/color_space.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/color_space.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> rgbColor(
  tvec3<T, P> const & hsvValue);



 template <typename T, precision P>
               tvec3<T, P> hsvColor(
  tvec3<T, P> const & rgbValue);



 template <typename T>
               tmat4x4<T, defaultp> saturation(
  T const s);



 template <typename T, precision P>
               tvec3<T, P> saturation(
  T const s,
  tvec3<T, P> const & color);



 template <typename T, precision P>
               tvec4<T, P> saturation(
  T const s,
  tvec4<T, P> const & color);



 template <typename T, precision P>
               T luminosity(
  tvec3<T, P> const & color);


}


# 1 "/usr/local/include/glm/./gtx/color_space.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> rgbColor(const tvec3<T, P>& hsvColor)
 {
  tvec3<T, P> hsv = hsvColor;
  tvec3<T, P> rgbColor;

  if(hsv.y == static_cast<T>(0))

   rgbColor = tvec3<T, P>(hsv.z);
  else
  {
   T sector = floor(hsv.x / T(60));
   T frac = (hsv.x / T(60)) - sector;

   T o = hsv.z * (T(1) - hsv.y);
   T p = hsv.z * (T(1) - hsv.y * frac);
   T q = hsv.z * (T(1) - hsv.y * (T(1) - frac));

   switch(int(sector))
   {
   default:
   case 0:
    rgbColor.r = hsv.z;
    rgbColor.g = q;
    rgbColor.b = o;
    break;
   case 1:
    rgbColor.r = p;
    rgbColor.g = hsv.z;
    rgbColor.b = o;
    break;
   case 2:
    rgbColor.r = o;
    rgbColor.g = hsv.z;
    rgbColor.b = q;
    break;
   case 3:
    rgbColor.r = o;
    rgbColor.g = p;
    rgbColor.b = hsv.z;
    break;
   case 4:
    rgbColor.r = q;
    rgbColor.g = o;
    rgbColor.b = hsv.z;
    break;
   case 5:
    rgbColor.r = hsv.z;
    rgbColor.g = o;
    rgbColor.b = p;
    break;
   }
  }

  return rgbColor;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> hsvColor(const tvec3<T, P>& rgbColor)
 {
  tvec3<T, P> hsv = rgbColor;
  float Min = min(min(rgbColor.r, rgbColor.g), rgbColor.b);
  float Max = max(max(rgbColor.r, rgbColor.g), rgbColor.b);
  float Delta = Max - Min;

  hsv.z = Max;

  if(Max != static_cast<T>(0))
  {
   hsv.y = Delta / hsv.z;
   T h = static_cast<T>(0);

   if(rgbColor.r == Max)

    h = static_cast<T>(0) + T(60) * (rgbColor.g - rgbColor.b) / Delta;
   else if(rgbColor.g == Max)

    h = static_cast<T>(120) + T(60) * (rgbColor.b - rgbColor.r) / Delta;
   else

    h = static_cast<T>(240) + T(60) * (rgbColor.r - rgbColor.g) / Delta;

   if(h < T(0))
    hsv.x = h + T(360);
   else
    hsv.x = h;
  }
  else
  {

   hsv.y = static_cast<T>(0);
   hsv.x = static_cast<T>(0);
  }

  return hsv;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> saturation(T const s)
 {
  tvec3<T, defaultp> rgbw = tvec3<T, defaultp>(T(0.2126), T(0.7152), T(0.0722));

  tvec3<T, defaultp> const col((T(1) - s) * rgbw);

  tmat4x4<T, defaultp> result(T(1));
  result[0][0] = col.x + s;
  result[0][1] = col.x;
  result[0][2] = col.x;
  result[1][0] = col.y;
  result[1][1] = col.y + s;
  result[1][2] = col.y;
  result[2][0] = col.z;
  result[2][1] = col.z;
  result[2][2] = col.z + s;
  return result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> saturation(const T s, const tvec3<T, P>& color)
 {
  return tvec3<T, P>(saturation(s) * tvec4<T, P>(color, T(0)));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> saturation(const T s, const tvec4<T, P>& color)
 {
  return saturation(s) * color;
 }

 template <typename T, precision P> inline
                    T luminosity(const tvec3<T, P>& color)
 {
  const tvec3<T, P> tmp = tvec3<T, P>(0.33, 0.59, 0.11);
  return dot(color, tmp);
 }
}
# 68 "/usr/local/include/glm/./gtx/color_space.hpp" 2 3
# 65 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> rgb2YCoCg(
  tvec3<T, P> const & rgbColor);



 template <typename T, precision P>
               tvec3<T, P> YCoCg2rgb(
  tvec3<T, P> const & YCoCgColor);




 template <typename T, precision P>
               tvec3<T, P> rgb2YCoCgR(
  tvec3<T, P> const & rgbColor);




 template <typename T, precision P>
               tvec3<T, P> YCoCgR2rgb(
  tvec3<T, P> const & YCoCgColor);


}


# 1 "/usr/local/include/glm/./gtx/color_space_YCoCg.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> rgb2YCoCg
 (
  tvec3<T, P> const & rgbColor
 )
 {
  tvec3<T, P> result;
  result.x = rgbColor.r / T(4) + rgbColor.g / T(2) + rgbColor.b / T(4);
  result.y = rgbColor.r / T(2) + rgbColor.g * T(0) - rgbColor.b / T(2);
  result.z = - rgbColor.r / T(4) + rgbColor.g / T(2) - rgbColor.b / T(4);
  return result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> YCoCg2rgb
 (
  tvec3<T, P> const & YCoCgColor
 )
 {
  tvec3<T, P> result;
  result.r = YCoCgColor.x + YCoCgColor.y - YCoCgColor.z;
  result.g = YCoCgColor.x + YCoCgColor.z;
  result.b = YCoCgColor.x - YCoCgColor.y - YCoCgColor.z;
  return result;
 }

 template <typename T, precision P, bool isInteger>
 class compute_YCoCgR {
 public:
  static inline tvec3<T, P> rgb2YCoCgR
  (
   tvec3<T, P> const & rgbColor
  )
  {
   tvec3<T, P> result;
   result.x = rgbColor.g / T(2) + (rgbColor.r + rgbColor.b) / T(4);
   result.y = rgbColor.r - rgbColor.b;
   result.z = rgbColor.g - (rgbColor.r + rgbColor.b) / T(2);
   return result;
  }

  static inline tvec3<T, P> YCoCgR2rgb
  (
   tvec3<T, P> const & YCoCgRColor
  )
  {
   tvec3<T, P> result;
   T tmp = YCoCgRColor.x - (YCoCgRColor.z / T(2));
   result.g = YCoCgRColor.z + tmp;
   result.b = tmp - (YCoCgRColor.y / T(2));
   result.r = result.b + YCoCgRColor.y;
   return result;
  }
 };

 template <typename T, precision P>
 class compute_YCoCgR<T, P, true> {
 public:
  static inline tvec3<T, P> rgb2YCoCgR
  (
   tvec3<T, P> const & rgbColor
  )
  {
   tvec3<T, P> result;
   result.y = rgbColor.r - rgbColor.b;
   T tmp = rgbColor.b + (result.y >> 1);
   result.z = rgbColor.g - tmp;
   result.x = tmp + (result.z >> 1);
   return result;
  }

  static inline tvec3<T, P> YCoCgR2rgb
  (
   tvec3<T, P> const & YCoCgRColor
  )
  {
   tvec3<T, P> result;
   T tmp = YCoCgRColor.x - (YCoCgRColor.z >> 1);
   result.g = YCoCgRColor.z + tmp;
   result.b = tmp - (YCoCgRColor.y >> 1);
   result.r = result.b + YCoCgRColor.y;
   return result;
  }
 };

 template <typename T, precision P> inline
                    tvec3<T, P> rgb2YCoCgR
 (
  tvec3<T, P> const & rgbColor
 )
 {
  return compute_YCoCgR<T, P, std::numeric_limits<T>::is_integer>::rgb2YCoCgR(rgbColor);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> YCoCgR2rgb
 (
  tvec3<T, P> const & YCoCgRColor
 )
 {
  return compute_YCoCgR<T, P, std::numeric_limits<T>::is_integer>::YCoCgR2rgb(YCoCgRColor);
 }
}
# 56 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 2 3
# 66 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/compatibility.hpp" 1 3
# 33 "/usr/local/include/glm/./gtx/compatibility.hpp" 3
namespace glm
{



 template <typename T> inline T lerp(T x, T y, T a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec2<T, P> lerp(const tvec2<T, P>& x, const tvec2<T, P>& y, T a){return mix(x, y, a);}

 template <typename T, precision P> inline tvec3<T, P> lerp(const tvec3<T, P>& x, const tvec3<T, P>& y, T a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec4<T, P> lerp(const tvec4<T, P>& x, const tvec4<T, P>& y, T a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec2<T, P> lerp(const tvec2<T, P>& x, const tvec2<T, P>& y, const tvec2<T, P>& a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec3<T, P> lerp(const tvec3<T, P>& x, const tvec3<T, P>& y, const tvec3<T, P>& a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec4<T, P> lerp(const tvec4<T, P>& x, const tvec4<T, P>& y, const tvec4<T, P>& a){return mix(x, y, a);}

 template <typename T, precision P> inline T saturate(T x){return clamp(x, T(0), T(1));}
 template <typename T, precision P> inline tvec2<T, P> saturate(const tvec2<T, P>& x){return clamp(x, T(0), T(1));}
 template <typename T, precision P> inline tvec3<T, P> saturate(const tvec3<T, P>& x){return clamp(x, T(0), T(1));}
 template <typename T, precision P> inline tvec4<T, P> saturate(const tvec4<T, P>& x){return clamp(x, T(0), T(1));}

 template <typename T, precision P> inline T atan2(T x, T y){return atan(x, y);}
 template <typename T, precision P> inline tvec2<T, P> atan2(const tvec2<T, P>& x, const tvec2<T, P>& y){return atan(x, y);}
 template <typename T, precision P> inline tvec3<T, P> atan2(const tvec3<T, P>& x, const tvec3<T, P>& y){return atan(x, y);}
 template <typename T, precision P> inline tvec4<T, P> atan2(const tvec4<T, P>& x, const tvec4<T, P>& y){return atan(x, y);}

 template <typename genType> bool isfinite(genType const & x);
 template <typename T, precision P> tvec1<bool, P> isfinite(const tvec1<T, P>& x);
 template <typename T, precision P> tvec2<bool, P> isfinite(const tvec2<T, P>& x);
 template <typename T, precision P> tvec3<bool, P> isfinite(const tvec3<T, P>& x);
 template <typename T, precision P> tvec4<bool, P> isfinite(const tvec4<T, P>& x);

 typedef bool bool1;
 typedef tvec2<bool, highp> bool2;
 typedef tvec3<bool, highp> bool3;
 typedef tvec4<bool, highp> bool4;

 typedef bool bool1x1;
 typedef tmat2x2<bool, highp> bool2x2;
 typedef tmat2x3<bool, highp> bool2x3;
 typedef tmat2x4<bool, highp> bool2x4;
 typedef tmat3x2<bool, highp> bool3x2;
 typedef tmat3x3<bool, highp> bool3x3;
 typedef tmat3x4<bool, highp> bool3x4;
 typedef tmat4x2<bool, highp> bool4x2;
 typedef tmat4x3<bool, highp> bool4x3;
 typedef tmat4x4<bool, highp> bool4x4;

 typedef int int1;
 typedef tvec2<int, highp> int2;
 typedef tvec3<int, highp> int3;
 typedef tvec4<int, highp> int4;

 typedef int int1x1;
 typedef tmat2x2<int, highp> int2x2;
 typedef tmat2x3<int, highp> int2x3;
 typedef tmat2x4<int, highp> int2x4;
 typedef tmat3x2<int, highp> int3x2;
 typedef tmat3x3<int, highp> int3x3;
 typedef tmat3x4<int, highp> int3x4;
 typedef tmat4x2<int, highp> int4x2;
 typedef tmat4x3<int, highp> int4x3;
 typedef tmat4x4<int, highp> int4x4;

 typedef float float1;
 typedef tvec2<float, highp> float2;
 typedef tvec3<float, highp> float3;
 typedef tvec4<float, highp> float4;

 typedef float float1x1;
 typedef tmat2x2<float, highp> float2x2;
 typedef tmat2x3<float, highp> float2x3;
 typedef tmat2x4<float, highp> float2x4;
 typedef tmat3x2<float, highp> float3x2;
 typedef tmat3x3<float, highp> float3x3;
 typedef tmat3x4<float, highp> float3x4;
 typedef tmat4x2<float, highp> float4x2;
 typedef tmat4x3<float, highp> float4x3;
 typedef tmat4x4<float, highp> float4x4;

 typedef double double1;
 typedef tvec2<double, highp> double2;
 typedef tvec3<double, highp> double3;
 typedef tvec4<double, highp> double4;

 typedef double double1x1;
 typedef tmat2x2<double, highp> double2x2;
 typedef tmat2x3<double, highp> double2x3;
 typedef tmat2x4<double, highp> double2x4;
 typedef tmat3x2<double, highp> double3x2;
 typedef tmat3x3<double, highp> double3x3;
 typedef tmat3x4<double, highp> double3x4;
 typedef tmat4x2<double, highp> double4x2;
 typedef tmat4x3<double, highp> double4x3;
 typedef tmat4x4<double, highp> double4x4;


}


# 1 "/usr/local/include/glm/./gtx/compatibility.inl" 1 3





namespace glm
{

 template <typename genType> inline
                    bool isfinite(
  genType const & x)
 {







   if (std::numeric_limits<genType>::is_integer || std::denorm_absent == std::numeric_limits<genType>::has_denorm)
    return std::numeric_limits<genType>::min() <= x && std::numeric_limits<genType>::max() >= x;
   else
    return -std::numeric_limits<genType>::max() <= x && std::numeric_limits<genType>::max() >= x;

 }

 template <typename T, precision P> inline
                    tvec1<bool, P> isfinite(
  tvec1<T, P> const & x)
 {
  return tvec1<bool, P>(
   isfinite(x.x));
 }

 template <typename T, precision P> inline
                    tvec2<bool, P> isfinite(
  tvec2<T, P> const & x)
 {
  return tvec2<bool, P>(
   isfinite(x.x),
   isfinite(x.y));
 }

 template <typename T, precision P> inline
                    tvec3<bool, P> isfinite(
  tvec3<T, P> const & x)
 {
  return tvec3<bool, P>(
   isfinite(x.x),
   isfinite(x.y),
   isfinite(x.z));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isfinite(
  tvec4<T, P> const & x)
 {
  return tvec4<bool, P>(
   isfinite(x.x),
   isfinite(x.y),
   isfinite(x.z),
   isfinite(x.w));
 }

}
# 130 "/usr/local/include/glm/./gtx/compatibility.hpp" 2 3
# 67 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/component_wise.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/component_wise.hpp" 3
namespace glm
{






 template <typename floatType, typename T, precision P, template <typename, precision> class vecType>
               vecType<floatType, P> compNormalize(vecType<T, P> const & v);




 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<T, P> compScale(vecType<floatType, P> const & v);



 template <typename genType>
               typename genType::value_type compAdd(genType const & v);



 template <typename genType>
               typename genType::value_type compMul(genType const & v);



 template <typename genType>
               typename genType::value_type compMin(genType const & v);



 template <typename genType>
               typename genType::value_type compMax(genType const & v);


}


# 1 "/usr/local/include/glm/./gtx/component_wise.inl" 1 3





namespace glm{
namespace detail
{
 template <typename T, typename floatType, precision P, template <typename, precision> class vecType, bool isInteger, bool signedType>
 struct compute_compNormalize
 {};

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compNormalize<T, floatType, P, vecType, true, true>
 { inline
                     static vecType<floatType, P> call(vecType<T, P> const & v)
  {
   floatType const Min = static_cast<floatType>(std::numeric_limits<T>::min());
   floatType const Max = static_cast<floatType>(std::numeric_limits<T>::max());
   return (vecType<floatType, P>(v) - Min) / (Max - Min) * static_cast<floatType>(2) - static_cast<floatType>(1);
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compNormalize<T, floatType, P, vecType, true, false>
 { inline
                     static vecType<floatType, P> call(vecType<T, P> const & v)
  {
   return vecType<floatType, P>(v) / static_cast<floatType>(std::numeric_limits<T>::max());
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compNormalize<T, floatType, P, vecType, false, true>
 { inline
                     static vecType<floatType, P> call(vecType<T, P> const & v)
  {
   return v;
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType, bool isInteger, bool signedType>
 struct compute_compScale
 {};

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compScale<T, floatType, P, vecType, true, true>
 { inline
                     static vecType<T, P> call(vecType<floatType, P> const & v)
  {
   floatType const Max = static_cast<floatType>(std::numeric_limits<T>::max()) + static_cast<floatType>(0.5);
   vecType<floatType, P> const Scaled(v * Max);
   vecType<T, P> const Result(Scaled - static_cast<floatType>(0.5));
   return Result;
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compScale<T, floatType, P, vecType, true, false>
 { inline
                     static vecType<T, P> call(vecType<floatType, P> const & v)
  {
   return vecType<T, P>(vecType<floatType, P>(v) * static_cast<floatType>(std::numeric_limits<T>::max()));
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compScale<T, floatType, P, vecType, false, true>
 { inline
                     static vecType<T, P> call(vecType<floatType, P> const & v)
  {
   return v;
  }
 };
}

 template <typename floatType, typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<floatType, P> compNormalize(vecType<T, P> const & v)
 {
                                                                                                                                                      ;

  return detail::compute_compNormalize<T, floatType, P, vecType, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
 }

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> compScale(vecType<floatType, P> const & v)
 {
                                                                                                                                                  ;

  return detail::compute_compScale<T, floatType, P, vecType, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compAdd(vecType<T, P> const & v)
 {
  T Result(0);
  for(length_t i = 0, n = v.length(); i < n; ++i)
   Result += v[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compMul(vecType<T, P> const & v)
 {
  T Result(1);
  for(length_t i = 0, n = v.length(); i < n; ++i)
   Result *= v[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compMin(vecType<T, P> const & v)
 {
  T Result(v[0]);
  for(length_t i = 1, n = v.length(); i < n; ++i)
   Result = min(Result, v[i]);
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compMax(vecType<T, P> const & v)
 {
  T Result(v[0]);
  for(length_t i = 1, n = v.length(); i < n; ++i)
   Result = max(Result, v[i]);
  return Result;
 }
}
# 65 "/usr/local/include/glm/./gtx/component_wise.hpp" 2 3
# 68 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 1 3
# 28 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 3
namespace glm
{



 template <typename T, precision P = defaultp>
 struct tdualquat
 {


  typedef T value_type;
  typedef glm::tquat<T, P> part_type;



  glm::tquat<T, P> real, dual;



  typedef length_t length_type;

                static length_type length(){return 2;}

                part_type & operator[](length_type i);
                part_type const & operator[](length_type i) const;



                              tdualquat() ;
                              tdualquat(tdualquat<T, P> const & d) ;
  template <precision Q>
                              tdualquat(tdualquat<T, Q> const & d);



                                   explicit tdualquat(ctor);
                              tdualquat(tquat<T, P> const & real);
                              tdualquat(tquat<T, P> const & orientation, tvec3<T, P> const & translation);
                              tdualquat(tquat<T, P> const & real, tquat<T, P> const & dual);



  template <typename U, precision Q>
                                           tdualquat(tdualquat<U, Q> const & q);

                             tdualquat(tmat2x4<T, P> const & holder_mat);
                             tdualquat(tmat3x4<T, P> const & aug_mat);



                tdualquat<T, P> & operator=(tdualquat<T, P> const & m) ;

  template <typename U>
                tdualquat<T, P> & operator=(tdualquat<U, P> const & m);
  template <typename U>
                tdualquat<T, P> & operator*=(U s);
  template <typename U>
                tdualquat<T, P> & operator/=(U s);
 };



 template <typename T, precision P>
               tdualquat<T, P> operator+(tdualquat<T, P> const & q);

 template <typename T, precision P>
               tdualquat<T, P> operator-(tdualquat<T, P> const & q);



 template <typename T, precision P>
               tdualquat<T, P> operator+(tdualquat<T, P> const & q, tdualquat<T, P> const & p);

 template <typename T, precision P>
               tdualquat<T, P> operator*(tdualquat<T, P> const & q, tdualquat<T, P> const & p);

 template <typename T, precision P>
               tvec3<T, P> operator*(tdualquat<T, P> const & q, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v, tdualquat<T, P> const & q);

 template <typename T, precision P>
               tvec4<T, P> operator*(tdualquat<T, P> const & q, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v, tdualquat<T, P> const & q);

 template <typename T, precision P>
               tdualquat<T, P> operator*(tdualquat<T, P> const & q, T const & s);

 template <typename T, precision P>
               tdualquat<T, P> operator*(T const & s, tdualquat<T, P> const & q);

 template <typename T, precision P>
               tdualquat<T, P> operator/(tdualquat<T, P> const & q, T const & s);



 template <typename T, precision P>
               bool operator==(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2);

 template <typename T, precision P>
               bool operator!=(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2);




 template <typename T, precision P>
               tdualquat<T, P> normalize(tdualquat<T, P> const & q);




 template <typename T, precision P>
               tdualquat<T, P> lerp(tdualquat<T, P> const & x, tdualquat<T, P> const & y, T const & a);




 template <typename T, precision P>
               tdualquat<T, P> inverse(tdualquat<T, P> const & q);




 template <typename T, precision P>
               tmat2x4<T, P> mat2x4_cast(tdualquat<T, P> const & x);




 template <typename T, precision P>
               tmat3x4<T, P> mat3x4_cast(tdualquat<T, P> const & x);




 template <typename T, precision P>
               tdualquat<T, P> dualquat_cast(tmat2x4<T, P> const & x);




 template <typename T, precision P>
               tdualquat<T, P> dualquat_cast(tmat3x4<T, P> const & x);





 typedef tdualquat<float, lowp> lowp_dualquat;




 typedef tdualquat<float, mediump> mediump_dualquat;




 typedef tdualquat<float, highp> highp_dualquat;





 typedef tdualquat<float, lowp> lowp_fdualquat;




 typedef tdualquat<float, mediump> mediump_fdualquat;




 typedef tdualquat<float, highp> highp_fdualquat;





 typedef tdualquat<double, lowp> lowp_ddualquat;




 typedef tdualquat<double, mediump> mediump_ddualquat;




 typedef tdualquat<double, highp> highp_ddualquat;






 typedef highp_fdualquat dualquat;




 typedef highp_fdualquat fdualquat;
# 252 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 3
 typedef highp_ddualquat ddualquat;
# 264 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 3
}


# 1 "/usr/local/include/glm/./gtx/dual_quaternion.inl" 1 3






namespace glm
{


 template <typename T, precision P> inline
                    typename tdualquat<T, P>::part_type & tdualquat<T, P>::operator[](typename tdualquat<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 14, "i >= 0 && i < this->length()") : (void)0);
  return (&real)[i];
 }

 template <typename T, precision P> inline
                    typename tdualquat<T, P>::part_type const & tdualquat<T, P>::operator[](typename tdualquat<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 21, "i >= 0 && i < this->length()") : (void)0);
  return (&real)[i];
 }




  template <typename T, precision P> inline
                                   tdualquat<T, P>::tdualquat()

    : real(tquat<T, P>())
    , dual(tquat<T, P>(0, 0, 0, 0))

  {}



  template <typename T, precision P> inline
                                   tdualquat<T, P>::tdualquat(tdualquat<T, P> const & d)
   : real(d.real)
   , dual(d.dual)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                  tdualquat<T, P>::tdualquat(tdualquat<T, Q> const & d)
  : real(d.real)
  , dual(d.dual)
 {}



 template <typename T, precision P> inline
                                       tdualquat<T, P>::tdualquat(ctor)
 {}

 template <typename T, precision P> inline
                                  tdualquat<T, P>::tdualquat(tquat<T, P> const & r)
  : real(r), dual(tquat<T, P>(0, 0, 0, 0))
 {}

 template <typename T, precision P> inline
                                  tdualquat<T, P>::tdualquat(tquat<T, P> const & q, tvec3<T, P> const& p)
  : real(q), dual(
   T(-0.5) * ( p.x*q.x + p.y*q.y + p.z*q.z),
   T(+0.5) * ( p.x*q.w + p.y*q.z - p.z*q.y),
   T(+0.5) * (-p.x*q.z + p.y*q.w + p.z*q.x),
   T(+0.5) * ( p.x*q.y - p.y*q.x + p.z*q.w))
 {}

 template <typename T, precision P> inline
                                  tdualquat<T, P>::tdualquat(tquat<T, P> const & r, tquat<T, P> const & d)
  : real(r), dual(d)
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                  tdualquat<T, P>::tdualquat(tdualquat<U, Q> const & q)
  : real(q.real)
  , dual(q.dual)
 {}

 template <typename T, precision P> inline
                    tdualquat<T, P>::tdualquat(tmat2x4<T, P> const & m)
 {
  *this = dualquat_cast(m);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P>::tdualquat(tmat3x4<T, P> const & m)
 {
  *this = dualquat_cast(m);
 }




  template <typename T, precision P> inline
                     tdualquat<T, P> & tdualquat<T, P>::operator=(tdualquat<T, P> const & q)
  {
   this->real = q.real;
   this->dual = q.dual;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tdualquat<T, P> & tdualquat<T, P>::operator=(tdualquat<U, P> const & q)
 {
  this->real = q.real;
  this->dual = q.dual;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tdualquat<T, P> & tdualquat<T, P>::operator*=(U s)
 {
  this->real *= static_cast<T>(s);
  this->dual *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tdualquat<T, P> & tdualquat<T, P>::operator/=(U s)
 {
  this->real /= static_cast<T>(s);
  this->dual /= static_cast<T>(s);
  return *this;
 }



 template <typename T, precision P> inline
                    tdualquat<T, P> operator+(tdualquat<T, P> const & q)
 {
  return q;
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator-(tdualquat<T, P> const & q)
 {
  return tdualquat<T, P>(-q.real, -q.dual);
 }



 template <typename T, precision P> inline
                    tdualquat<T, P> operator+(tdualquat<T, P> const & q, tdualquat<T, P> const & p)
 {
  return tdualquat<T, P>(q.real + p.real,q.dual + p.dual);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator*(tdualquat<T, P> const & p, tdualquat<T, P> const & o)
 {
  return tdualquat<T, P>(p.real * o.real,p.real * o.dual + p.dual * o.real);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tdualquat<T, P> const & q, tvec3<T, P> const & v)
 {
  tvec3<T, P> const real_v3(q.real.x,q.real.y,q.real.z);
  tvec3<T, P> const dual_v3(q.dual.x,q.dual.y,q.dual.z);
  return (cross(real_v3, cross(real_v3,v) + v * q.real.w + dual_v3) + dual_v3 * q.real.w - real_v3 * q.dual.w) * T(2) + v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, tdualquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tdualquat<T, P> const & q, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v, tdualquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator*(tdualquat<T, P> const & q, T const & s)
 {
  return tdualquat<T, P>(q.real * s, q.dual * s);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator*(T const & s, tdualquat<T, P> const & q)
 {
  return q * s;
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator/(tdualquat<T, P> const & q, T const & s)
 {
  return tdualquat<T, P>(q.real / s, q.dual / s);
 }



 template <typename T, precision P> inline
                    bool operator==(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2)
 {
  return (q1.real == q2.real) && (q1.dual == q2.dual);
 }

 template <typename T, precision P> inline
                    bool operator!=(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2)
 {
  return (q1.real != q2.dual) || (q1.real != q2.dual);
 }



 template <typename T, precision P> inline
                    tdualquat<T, P> normalize(tdualquat<T, P> const & q)
 {
  return q / length(q.real);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> lerp(tdualquat<T, P> const & x, tdualquat<T, P> const & y, T const & a)
 {


  (__builtin_expect(!(a >= static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 236, "a >= static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(a <= static_cast<T>(1)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 237, "a <= static_cast<T>(1)") : (void)0);
  T const k = dot(x.real,y.real) < static_cast<T>(0) ? -a : a;
  T const one(1);
  return tdualquat<T, P>(x * (one - a) + y * k);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> inverse(tdualquat<T, P> const & q)
 {
  const glm::tquat<T, P> real = conjugate(q.real);
  const glm::tquat<T, P> dual = conjugate(q.dual);
  return tdualquat<T, P>(real, dual + (real * (-2.0f * dot(real,dual))));
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> mat2x4_cast(tdualquat<T, P> const & x)
 {
  return tmat2x4<T, P>( x[0].x, x[0].y, x[0].z, x[0].w, x[1].x, x[1].y, x[1].z, x[1].w );
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> mat3x4_cast(tdualquat<T, P> const & x)
 {
  tquat<T, P> r = x.real / length2(x.real);

  tquat<T, P> const rr(r.w * x.real.w, r.x * x.real.x, r.y * x.real.y, r.z * x.real.z);
  r *= static_cast<T>(2);

  T const xy = r.x * x.real.y;
  T const xz = r.x * x.real.z;
  T const yz = r.y * x.real.z;
  T const wx = r.w * x.real.x;
  T const wy = r.w * x.real.y;
  T const wz = r.w * x.real.z;

  tvec4<T, P> const a(
   rr.w + rr.x - rr.y - rr.z,
   xy - wz,
   xz + wy,
   -(x.dual.w * r.x - x.dual.x * r.w + x.dual.y * r.z - x.dual.z * r.y));

  tvec4<T, P> const b(
   xy + wz,
   rr.w + rr.y - rr.x - rr.z,
   yz - wx,
   -(x.dual.w * r.y - x.dual.x * r.z - x.dual.y * r.w + x.dual.z * r.x));

  tvec4<T, P> const c(
   xz - wy,
   yz + wx,
   rr.w + rr.z - rr.x - rr.y,
   -(x.dual.w * r.z + x.dual.x * r.y - x.dual.y * r.x - x.dual.z * r.w));

  return tmat3x4<T, P>(a, b, c);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> dualquat_cast(tmat2x4<T, P> const & x)
 {
  return tdualquat<T, P>(
   tquat<T, P>( x[0].w, x[0].x, x[0].y, x[0].z ),
   tquat<T, P>( x[1].w, x[1].x, x[1].y, x[1].z ));
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> dualquat_cast(tmat3x4<T, P> const & x)
 {
  tquat<T, P> real(uninitialize);

  T const trace = x[0].x + x[1].y + x[2].z;
  if(trace > static_cast<T>(0))
  {
   T const r = sqrt(T(1) + trace);
   T const invr = static_cast<T>(0.5) / r;
   real.w = static_cast<T>(0.5) * r;
   real.x = (x[2].y - x[1].z) * invr;
   real.y = (x[0].z - x[2].x) * invr;
   real.z = (x[1].x - x[0].y) * invr;
  }
  else if(x[0].x > x[1].y && x[0].x > x[2].z)
  {
   T const r = sqrt(T(1) + x[0].x - x[1].y - x[2].z);
   T const invr = static_cast<T>(0.5) / r;
   real.x = static_cast<T>(0.5)*r;
   real.y = (x[1].x + x[0].y) * invr;
   real.z = (x[0].z + x[2].x) * invr;
   real.w = (x[2].y - x[1].z) * invr;
  }
  else if(x[1].y > x[2].z)
  {
   T const r = sqrt(T(1) + x[1].y - x[0].x - x[2].z);
   T const invr = static_cast<T>(0.5) / r;
   real.x = (x[1].x + x[0].y) * invr;
   real.y = static_cast<T>(0.5) * r;
   real.z = (x[2].y + x[1].z) * invr;
   real.w = (x[0].z - x[2].x) * invr;
  }
  else
  {
   T const r = sqrt(T(1) + x[2].z - x[0].x - x[1].y);
   T const invr = static_cast<T>(0.5) / r;
   real.x = (x[0].z + x[2].x) * invr;
   real.y = (x[2].y + x[1].z) * invr;
   real.z = static_cast<T>(0.5) * r;
   real.w = (x[1].x - x[0].y) * invr;
  }

  tquat<T, P> dual(uninitialize);
  dual.x = static_cast<T>(0.5) * ( x[0].w * real.w + x[1].w * real.z - x[2].w * real.y);
  dual.y = static_cast<T>(0.5) * (-x[0].w * real.z + x[1].w * real.w + x[2].w * real.x);
  dual.z = static_cast<T>(0.5) * ( x[0].w * real.y - x[1].w * real.x + x[2].w * real.w);
  dual.w = -static_cast<T>(0.5) * ( x[0].w * real.x + x[1].w * real.y + x[2].w * real.z);
  return tdualquat<T, P>(real, dual);
 }
}
# 266 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 2 3
# 69 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/euler_angles.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/euler_angles.hpp" 3
namespace glm
{





 template <typename T>
               tmat4x4<T, defaultp> eulerAngleX(
  T const & angleX);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleY(
  T const & angleY);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleZ(
  T const & angleZ);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleXY(
  T const & angleX,
  T const & angleY);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleYX(
  T const & angleY,
  T const & angleX);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleXZ(
  T const & angleX,
  T const & angleZ);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleZX(
  T const & angle,
  T const & angleX);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleYZ(
  T const & angleY,
  T const & angleZ);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleZY(
  T const & angleZ,
  T const & angleY);



    template <typename T>
                  tmat4x4<T, defaultp> eulerAngleXYZ(
        T const & t1,
        T const & t2,
        T const & t3);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleYXZ(
  T const & yaw,
  T const & pitch,
  T const & roll);



 template <typename T>
               tmat4x4<T, defaultp> yawPitchRoll(
  T const & yaw,
  T const & pitch,
  T const & roll);



 template <typename T>
               tmat2x2<T, defaultp> orientate2(T const & angle);



 template <typename T>
               tmat3x3<T, defaultp> orientate3(T const & angle);



 template <typename T, precision P>
               tmat3x3<T, P> orientate3(tvec3<T, P> const & angles);



 template <typename T, precision P>
               tmat4x4<T, P> orientate4(tvec3<T, P> const & angles);



    template <typename T>
                  void extractEulerAngleXYZ(tmat4x4<T, defaultp> const & M,
                                            T & t1,
                                            T & t2,
                                            T & t3);


}


# 1 "/usr/local/include/glm/./gtx/euler_angles.inl" 1 3





namespace glm
{
 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleX
 (
  T const & angleX
 )
 {
  T cosX = glm::cos(angleX);
  T sinX = glm::sin(angleX);

  return tmat4x4<T, defaultp>(
   T(1), T(0), T(0), T(0),
   T(0), cosX, sinX, T(0),
   T(0),-sinX, cosX, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleY
 (
  T const & angleY
 )
 {
  T cosY = glm::cos(angleY);
  T sinY = glm::sin(angleY);

  return tmat4x4<T, defaultp>(
   cosY, T(0), -sinY, T(0),
   T(0), T(1), T(0), T(0),
   sinY, T(0), cosY, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleZ
 (
  T const & angleZ
 )
 {
  T cosZ = glm::cos(angleZ);
  T sinZ = glm::sin(angleZ);

  return tmat4x4<T, defaultp>(
   cosZ, sinZ, T(0), T(0),
   -sinZ, cosZ, T(0), T(0),
   T(0), T(0), T(1), T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleXY
 (
  T const & angleX,
  T const & angleY
 )
 {
  T cosX = glm::cos(angleX);
  T sinX = glm::sin(angleX);
  T cosY = glm::cos(angleY);
  T sinY = glm::sin(angleY);

  return tmat4x4<T, defaultp>(
   cosY, -sinX * -sinY, cosX * -sinY, T(0),
   T(0), cosX, sinX, T(0),
   sinY, -sinX * cosY, cosX * cosY, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleYX
 (
  T const & angleY,
  T const & angleX
 )
 {
  T cosX = glm::cos(angleX);
  T sinX = glm::sin(angleX);
  T cosY = glm::cos(angleY);
  T sinY = glm::sin(angleY);

  return tmat4x4<T, defaultp>(
   cosY, 0, -sinY, T(0),
   sinY * sinX, cosX, cosY * sinX, T(0),
   sinY * cosX, -sinX, cosY * cosX, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleXZ
 (
  T const & angleX,
  T const & angleZ
 )
 {
  return eulerAngleX(angleX) * eulerAngleZ(angleZ);
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleZX
 (
  T const & angleZ,
  T const & angleX
 )
 {
  return eulerAngleZ(angleZ) * eulerAngleX(angleX);
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleYZ
 (
  T const & angleY,
  T const & angleZ
 )
 {
  return eulerAngleY(angleY) * eulerAngleZ(angleZ);
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleZY
 (
  T const & angleZ,
  T const & angleY
 )
 {
  return eulerAngleZ(angleZ) * eulerAngleY(angleY);
 }

    template <typename T> inline
                       tmat4x4<T, defaultp> eulerAngleXYZ
    (
     T const & t1,
     T const & t2,
     T const & t3
     )
    {
        T c1 = glm::cos(-t1);
        T c2 = glm::cos(-t2);
        T c3 = glm::cos(-t3);
        T s1 = glm::sin(-t1);
        T s2 = glm::sin(-t2);
        T s3 = glm::sin(-t3);

        tmat4x4<T, defaultp> Result;
        Result[0][0] = c2 * c3;
        Result[0][1] =-c1 * s3 + s1 * s2 * c3;
        Result[0][2] = s1 * s3 + c1 * s2 * c3;
        Result[0][3] = static_cast<T>(0);
        Result[1][0] = c2 * s3;
        Result[1][1] = c1 * c3 + s1 * s2 * s3;
        Result[1][2] =-s1 * c3 + c1 * s2 * s3;
        Result[1][3] = static_cast<T>(0);
        Result[2][0] =-s2;
        Result[2][1] = s1 * c2;
        Result[2][2] = c1 * c2;
        Result[2][3] = static_cast<T>(0);
        Result[3][0] = static_cast<T>(0);
        Result[3][1] = static_cast<T>(0);
        Result[3][2] = static_cast<T>(0);
        Result[3][3] = static_cast<T>(1);
        return Result;
    }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleYXZ
 (
  T const & yaw,
  T const & pitch,
  T const & roll
 )
 {
  T tmp_ch = glm::cos(yaw);
  T tmp_sh = glm::sin(yaw);
  T tmp_cp = glm::cos(pitch);
  T tmp_sp = glm::sin(pitch);
  T tmp_cb = glm::cos(roll);
  T tmp_sb = glm::sin(roll);

  tmat4x4<T, defaultp> Result;
  Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
  Result[0][1] = tmp_sb * tmp_cp;
  Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
  Result[0][3] = static_cast<T>(0);
  Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
  Result[1][1] = tmp_cb * tmp_cp;
  Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
  Result[1][3] = static_cast<T>(0);
  Result[2][0] = tmp_sh * tmp_cp;
  Result[2][1] = -tmp_sp;
  Result[2][2] = tmp_ch * tmp_cp;
  Result[2][3] = static_cast<T>(0);
  Result[3][0] = static_cast<T>(0);
  Result[3][1] = static_cast<T>(0);
  Result[3][2] = static_cast<T>(0);
  Result[3][3] = static_cast<T>(1);
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> yawPitchRoll
 (
  T const & yaw,
  T const & pitch,
  T const & roll
 )
 {
  T tmp_ch = glm::cos(yaw);
  T tmp_sh = glm::sin(yaw);
  T tmp_cp = glm::cos(pitch);
  T tmp_sp = glm::sin(pitch);
  T tmp_cb = glm::cos(roll);
  T tmp_sb = glm::sin(roll);

  tmat4x4<T, defaultp> Result;
  Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
  Result[0][1] = tmp_sb * tmp_cp;
  Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
  Result[0][3] = static_cast<T>(0);
  Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
  Result[1][1] = tmp_cb * tmp_cp;
  Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
  Result[1][3] = static_cast<T>(0);
  Result[2][0] = tmp_sh * tmp_cp;
  Result[2][1] = -tmp_sp;
  Result[2][2] = tmp_ch * tmp_cp;
  Result[2][3] = static_cast<T>(0);
  Result[3][0] = static_cast<T>(0);
  Result[3][1] = static_cast<T>(0);
  Result[3][2] = static_cast<T>(0);
  Result[3][3] = static_cast<T>(1);
  return Result;
 }

 template <typename T> inline
                    tmat2x2<T, defaultp> orientate2
 (
  T const & angle
 )
 {
  T c = glm::cos(angle);
  T s = glm::sin(angle);

  tmat2x2<T, defaultp> Result;
  Result[0][0] = c;
  Result[0][1] = s;
  Result[1][0] = -s;
  Result[1][1] = c;
  return Result;
 }

 template <typename T> inline
                    tmat3x3<T, defaultp> orientate3
 (
  T const & angle
 )
 {
  T c = glm::cos(angle);
  T s = glm::sin(angle);

  tmat3x3<T, defaultp> Result;
  Result[0][0] = c;
  Result[0][1] = s;
  Result[0][2] = 0.0f;
  Result[1][0] = -s;
  Result[1][1] = c;
  Result[1][2] = 0.0f;
  Result[2][0] = 0.0f;
  Result[2][1] = 0.0f;
  Result[2][2] = 1.0f;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> orientate3
 (
  tvec3<T, P> const & angles
 )
 {
  return tmat3x3<T, P>(yawPitchRoll(angles.z, angles.x, angles.y));
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> orientate4
 (
  tvec3<T, P> const & angles
 )
 {
  return yawPitchRoll(angles.z, angles.x, angles.y);
 }

    template <typename T>
                  void extractEulerAngleXYZ(tmat4x4<T, defaultp> const & M,
                                            T & t1,
                                            T & t2,
                                            T & t3)
    {
        float T1 = glm::atan2<T, defaultp>(M[2][1], M[2][2]);
        float C2 = glm::sqrt(M[0][0]*M[0][0] + M[1][0]*M[1][0]);
        float T2 = glm::atan2<T, defaultp>(-M[2][0], C2);
        float S1 = glm::sin(T1);
        float C1 = glm::cos(T1);
        float T3 = glm::atan2<T, defaultp>(S1*M[0][2] - C1*M[0][1], C1*M[1][1] - S1*M[1][2 ]);
        t1 = -T1;
        t2 = -T2;
        t3 = -T3;
    }
}
# 143 "/usr/local/include/glm/./gtx/euler_angles.hpp" 2 3
# 70 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/extend.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/extend.hpp" 3
namespace glm
{





 template <typename genType>
               genType extend(
  genType const & Origin,
  genType const & Source,
  typename genType::value_type const Length);


}


# 1 "/usr/local/include/glm/./gtx/extend.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType extend
 (
  genType const & Origin,
  genType const & Source,
  genType const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> extend
 (
  tvec2<T, P> const & Origin,
  tvec2<T, P> const & Source,
  T const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> extend
 (
  tvec3<T, P> const & Origin,
  tvec3<T, P> const & Source,
  T const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> extend
 (
  tvec4<T, P> const & Origin,
  tvec4<T, P> const & Source,
  T const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }
}
# 38 "/usr/local/include/glm/./gtx/extend.hpp" 2 3
# 71 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 3
namespace glm
{





 template <typename T>
               T min(
  T const & x,
  T const & y,
  T const & z);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z);



 template <typename T>
               T min(
  T const & x,
  T const & y,
  T const & z,
  T const & w);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w);



 template <typename T>
               T max(
  T const & x,
  T const & y,
  T const & z);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z);



 template <typename T>
               T max(
  T const & x,
  T const & y,
  T const & z,
  T const & w);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w);


}


# 1 "/usr/local/include/glm/./gtx/extended_min_max.inl" 1 3



namespace glm
{
 template <typename T> inline
                    T min(
  T const & x,
  T const & y,
  T const & z)
 {
  return glm::min(glm::min(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z
 )
 {
  return glm::min(glm::min(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z
 )
 {
  return glm::min(glm::min(x, y), z);
 }

 template <typename T> inline
                    T min
 (
  T const & x,
  T const & y,
  T const & z,
  T const & w
 )
 {
  return glm::min(glm::min(x, y), glm::min(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w
 )
 {
  return glm::min(glm::min(x, y), glm::min(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w
 )
 {
  return glm::min(glm::min(x, y), glm::min(z, w));
 }

 template <typename T> inline
                    T max(
  T const & x,
  T const & y,
  T const & z)
 {
  return glm::max(glm::max(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z
 )
 {
  return glm::max(glm::max(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z
 )
 {
  return glm::max(glm::max(x, y), z);
 }

 template <typename T> inline
                    T max
 (
  T const & x,
  T const & y,
  T const & z,
  T const & w
 )
 {
  return glm::max(glm::max(x, y), glm::max(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w
 )
 {
  return glm::max(glm::max(x, y), glm::max(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w
 )
 {
  return glm::max(glm::max(x, y), glm::max(z, w));
 }

}
# 133 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 2 3
# 72 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 3
namespace glm
{





 template <typename genType>
               genType fastPow(genType x, genType y);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastPow(vecType<T, P> const & x, vecType<T, P> const & y);



 template <typename genTypeT, typename genTypeU>
               genTypeT fastPow(genTypeT x, genTypeU y);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastPow(vecType<T, P> const & x);



 template <typename T>
               T fastExp(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastExp(vecType<T, P> const & x);



 template <typename T>
               T fastLog(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastLog(vecType<T, P> const & x);



 template <typename T>
               T fastExp2(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastExp2(vecType<T, P> const & x);



 template <typename T>
               T fastLog2(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastLog2(vecType<T, P> const & x);


}


# 1 "/usr/local/include/glm/./gtx/fast_exponential.inl" 1 3



namespace glm
{

 template <typename genType> inline
                    genType fastPow(genType x, genType y)
 {
  return exp(y * log(x));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastPow(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return exp(y * log(x));
 }

 template <typename T> inline
                    T fastPow(T x, int y)
 {
  T f = static_cast<T>(1);
  for(int i = 0; i < y; ++i)
   f *= x;
  return f;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastPow(vecType<T, P> const & x, vecType<int, P> const & y)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = x.length(); i < n; ++i)
   Result[i] = fastPow(x[i], y[i]);
  return Result;
 }



 template <typename T> inline
                    T fastExp(T x)
 {


  T x2 = x * x;
  T x3 = x2 * x;
  T x4 = x3 * x;
  T x5 = x4 * x;
  return T(1) + x + (x2 * T(0.5)) + (x3 * T(0.1666666667)) + (x4 * T(0.041666667)) + (x5 * T(0.008333333333));
 }
# 84 "/usr/local/include/glm/./gtx/fast_exponential.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastExp(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastExp, x);
 }


 template <typename genType> inline
                    genType fastLog(genType x)
 {
  return std::log(x);
 }
# 106 "/usr/local/include/glm/./gtx/fast_exponential.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastLog(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastLog, x);
 }


 template <typename genType> inline
                    genType fastExp2(genType x)
 {
  return fastExp(0.69314718055994530941723212145818f * x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastExp2(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastExp2, x);
 }


 template <typename genType> inline
                    genType fastLog2(genType x)
 {
  return fastLog(x) / 0.69314718055994530941723212145818f;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastLog2(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastLog2, x);
 }
}
# 91 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 2 3
# 73 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 1 3
# 26 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 3
namespace glm
{






 template <typename genType>
               genType fastSqrt(genType x);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastSqrt(vecType<T, P> const & x);




 template <typename genType>
               genType fastInverseSqrt(genType x);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastInverseSqrt(vecType<T, P> const & x);




 template <typename genType>
               genType fastLength(genType x);




 template <typename T, precision P, template <typename, precision> class vecType>
               T fastLength(vecType<T, P> const & x);




 template <typename genType>
               genType fastDistance(genType x, genType y);




 template <typename T, precision P, template <typename, precision> class vecType>
               T fastDistance(vecType<T, P> const & x, vecType<T, P> const & y);




 template <typename genType>
               genType fastNormalize(genType const & x);


}


# 1 "/usr/local/include/glm/./gtx/fast_square_root.inl" 1 3



namespace glm
{

 template <typename genType> inline
                    genType fastSqrt(genType x)
 {
                                                                                                           ;

  return genType(1) / fastInverseSqrt(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastSqrt(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastSqrt, x);
 }


 template <typename genType> inline
                    genType fastInverseSqrt(genType x)
 {




   return detail::compute_inversesqrt<tvec1, genType, highp, detail::is_aligned<highp>::value>::call(tvec1<genType, lowp>(x)).x;

 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastInverseSqrt(vecType<T, P> const & x)
 {
  return detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType fastLength(genType x)
 {
                                                                                                              ;

  return abs(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T fastLength(vecType<T, P> const & x)
 {
                                                                                                        ;

  return fastSqrt(dot(x, x));
 }


 template <typename genType> inline
                    genType fastDistance(genType x, genType y)
 {
  return fastLength(y - x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T fastDistance(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return fastLength(y - x);
 }


 template <typename genType> inline
                    genType fastNormalize(genType x)
 {
  return x > genType(0) ? genType(1) : -genType(1);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastNormalize(vecType<T, P> const & x)
 {
  return x * fastInverseSqrt(dot(x, x));
 }
}
# 88 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 2 3
# 74 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 3
namespace glm
{





 template <typename T>
               T wrapAngle(T angle);



 template <typename T>
               T fastSin(T angle);



 template <typename T>
               T fastCos(T angle);




 template <typename T>
               T fastTan(T angle);




 template <typename T>
               T fastAsin(T angle);




 template <typename T>
               T fastAcos(T angle);




 template <typename T>
               T fastAtan(T y, T x);




 template <typename T>
               T fastAtan(T angle);


}


# 1 "/usr/local/include/glm/./gtx/fast_trigonometry.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> taylorCos(vecType<T, P> const & x)
 {
  return static_cast<T>(1)
   - (x * x) / 2.f
   + (x * x * x * x) / 24.f
   - (x * x * x * x * x * x) / 720.f
   + (x * x * x * x * x * x * x * x) / 40320.f;
 }

 template <typename T> inline
                    T cos_52s(T x)
 {
  T const xx(x * x);
  return (T(0.9999932946) + xx * (T(-0.4999124376) + xx * (T(0.0414877472) + xx * T(-0.0012712095))));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cos_52s(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(cos_52s, x);
 }
}


 template <typename T> inline
                    T wrapAngle(T angle)
 {
  return abs<T>(mod<T>(angle, two_pi<T>()));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> wrapAngle(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(wrapAngle, x);
 }


 template <typename T> inline
                    T fastCos(T x)
 {
  T const angle(wrapAngle<T>(x));

  if(angle < half_pi<T>())
   return detail::cos_52s(angle);
  if(angle < pi<T>())
   return -detail::cos_52s(pi<T>() - angle);
  if(angle < (T(3) * half_pi<T>()))
   return -detail::cos_52s(angle - pi<T>());

  return detail::cos_52s(two_pi<T>() - angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastCos(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastCos, x);
 }


 template <typename T> inline
                    T fastSin(T x)
 {
  return fastCos<T>(half_pi<T>() - x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastSin(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastSin, x);
 }


 template <typename T> inline
                    T fastTan(T x)
 {
  return x + (x * x * x * T(0.3333333333)) + (x * x * x * x * x * T(0.1333333333333)) + (x * x * x * x * x * x * x * T(0.0539682539));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastTan(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastTan, x);
 }


 template <typename T> inline
                    T fastAsin(T x)
 {
  return x + (x * x * x * T(0.166666667)) + (x * x * x * x * x * T(0.075)) + (x * x * x * x * x * x * x * T(0.0446428571)) + (x * x * x * x * x * x * x * x * x * T(0.0303819444));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAsin(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastAsin, x);
 }


 template <typename T> inline
                    T fastAcos(T x)
 {
  return T(1.5707963267948966192313216916398) - fastAsin(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAcos(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastAcos, x);
 }


 template <typename T> inline
                    T fastAtan(T y, T x)
 {
  T sgn = sign(y) * sign(x);
  return abs(fastAtan(y / x)) * sgn;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAtan(vecType<T, P> const & y, vecType<T, P> const & x)
 {
  return detail::functor2<T, P, vecType>::call(fastAtan, y, x);
 }

 template <typename T> inline
                    T fastAtan(T x)
 {
  return x - (x * x * x * T(0.333333333333)) + (x * x * x * x * x * T(0.2)) - (x * x * x * x * x * x * x * T(0.1428571429)) + (x * x * x * x * x * x * x * x * x * T(0.111111111111)) - (x * x * x * x * x * x * x * x * x * x * x * T(0.0909090909));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAtan(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastAtan, x);
 }
}
# 75 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 2 3
# 75 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 1 3
# 17 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 3
namespace glm{
namespace gtx
{






 template <typename genType>
               genType pow2(genType const & x);




 template <typename genType>
               genType pow3(genType const & x);




 template <typename genType>
               genType pow4(genType const & x);


}
}


# 1 "/usr/local/include/glm/./gtx/optimum_pow.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType pow2(genType const & x)
 {
  return x * x;
 }

 template <typename genType> inline
                    genType pow3(genType const & x)
 {
  return x * x * x;
 }

 template <typename genType> inline
                    genType pow4(genType const & x)
 {
  return (x * x) * (x * x);
 }
}
# 50 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 2 3
# 17 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 2 3






namespace glm
{





 template <typename T, precision P>
               T radialGradient(
  tvec2<T, P> const & Center,
  T const & Radius,
  tvec2<T, P> const & Focal,
  tvec2<T, P> const & Position);



 template <typename T, precision P>
               T linearGradient(
  tvec2<T, P> const & Point0,
  tvec2<T, P> const & Point1,
  tvec2<T, P> const & Position);


}


# 1 "/usr/local/include/glm/./gtx/gradient_paint.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    T radialGradient
 (
  tvec2<T, P> const & Center,
  T const & Radius,
  tvec2<T, P> const & Focal,
  tvec2<T, P> const & Position
 )
 {
  tvec2<T, P> F = Focal - Center;
  tvec2<T, P> D = Position - Focal;
  T Radius2 = pow2(Radius);
  T Fx2 = pow2(F.x);
  T Fy2 = pow2(F.y);

  T Numerator = (D.x * F.x + D.y * F.y) + sqrt(Radius2 * (pow2(D.x) + pow2(D.y)) - pow2(D.x * F.y - D.y * F.x));
  T Denominator = Radius2 - (Fx2 + Fy2);
  return Numerator / Denominator;
 }

 template <typename T, precision P> inline
                    T linearGradient
 (
  tvec2<T, P> const & Point0,
  tvec2<T, P> const & Point1,
  tvec2<T, P> const & Position
 )
 {
  tvec2<T, P> Dist = Point1 - Point0;
  return (Dist.x * (Position.x - Point0.x) + Dist.y * (Position.y - Point0.y)) / glm::dot(Dist, Dist);
 }
}
# 48 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 2 3
# 76 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 3
namespace glm
{





 template <typename T, precision P>
               bool rightHanded(
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal);



 template <typename T, precision P>
               bool leftHanded(
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal);


}


# 1 "/usr/local/include/glm/./gtx/handed_coordinate_space.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    bool rightHanded
 (
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal
 )
 {
  return dot(cross(normal, tangent), binormal) > T(0);
 }

 template <typename T, precision P> inline
                    bool leftHanded
 (
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal
 )
 {
  return dot(cross(normal, tangent), binormal) < T(0);
 }
}
# 46 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 2 3
# 77 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/integer.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/integer.hpp" 3
namespace glm
{





               int pow(int x, int y);



               int sqrt(int x);



               unsigned int floor_log2(unsigned int x);



               int mod(int x, int y);



 template <typename genType>
               genType factorial(genType const & x);



 typedef signed int sint;



               uint pow(uint x, uint y);



               uint sqrt(uint x);



               uint mod(uint x, uint y);



               uint nlz(uint x);


}


# 1 "/usr/local/include/glm/./gtx/integer.inl" 1 3



namespace glm
{ inline

                    int pow(int x, int y)
 {
  if(y == 0)
   return 1;
  int result = x;
  for(int i = 1; i < y; ++i)
   result *= x;
  return result;
 } inline


                    int sqrt(int x)
 {
  if(x <= 1) return x;

  int NextTrial = x >> 1;
  int CurrentAnswer;

  do
  {
   CurrentAnswer = NextTrial;
   NextTrial = (NextTrial + x / NextTrial) >> 1;
  } while(NextTrial < CurrentAnswer);

  return CurrentAnswer;
 }


namespace detail
{ inline
                    unsigned int ones32(unsigned int x)
 {




  x -= ((x >> 1) & 0x55555555);
  x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
  x = (((x >> 4) + x) & 0x0f0f0f0f);
  x += (x >> 8);
  x += (x >> 16);
  return(x & 0x0000003f);
 }
} inline
# 66 "/usr/local/include/glm/./gtx/integer.inl" 3
                    int mod(int x, int y)
 {
  return x - y * (x / y);
 }


 template <typename genType> inline
                    genType factorial(genType const & x)
 {
  genType Temp = x;
  genType Result;
  for(Result = 1; Temp > 1; --Temp)
   Result *= Temp;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> factorial(
  tvec2<T, P> const & x)
 {
  return tvec2<T, P>(
   factorial(x.x),
   factorial(x.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> factorial(
  tvec3<T, P> const & x)
 {
  return tvec3<T, P>(
   factorial(x.x),
   factorial(x.y),
   factorial(x.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> factorial(
  tvec4<T, P> const & x)
 {
  return tvec4<T, P>(
   factorial(x.x),
   factorial(x.y),
   factorial(x.z),
   factorial(x.w));
 } inline

                    uint pow(uint x, uint y)
 {
  uint result = x;
  for(uint i = 1; i < y; ++i)
   result *= x;
  return result;
 } inline

                    uint sqrt(uint x)
 {
  if(x <= 1) return x;

  uint NextTrial = x >> 1;
  uint CurrentAnswer;

  do
  {
   CurrentAnswer = NextTrial;
   NextTrial = (NextTrial + x / NextTrial) >> 1;
  } while(NextTrial < CurrentAnswer);

  return CurrentAnswer;
 } inline

                    uint mod(uint x, uint y)
 {
  return x - y * (x / y);
 } inline
# 151 "/usr/local/include/glm/./gtx/integer.inl" 3
                    unsigned int nlz(unsigned int x)
 {
  int y, m, n;

  y = -int(x >> 16);
  m = (y >> 16) & 16;
  n = 16 - m;
  x = x >> m;

  y = x - 0x100;
  m = (y >> 16) & 8;
  n = n + m;
  x = x << m;

  y = x - 0x1000;
  m = (y >> 16) & 4;
  n = n + m;
  x = x << m;

  y = x - 0x4000;
  m = (y >> 16) & 2;
  n = n + m;
  x = x << m;

  y = x >> 14;
  m = y & ~(y >> 1);
  return unsigned(n + 2 - m);
 }



}
# 72 "/usr/local/include/glm/./gtx/integer.hpp" 2 3
# 78 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/intersect.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/intersect.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 1 3
# 24 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 3
namespace glm
{





 template <typename T, precision P, template <typename, precision> class vecType>
               bool areCollinear(vecType<T, P> const & v0, vecType<T, P> const & v1, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool areOrthogonal(vecType<T, P> const & v0, vecType<T, P> const & v1, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool isNormalized(vecType<T, P> const & v, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool isNull(vecType<T, P> const & v, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isCompNull(vecType<T, P> const & v, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool areOrthonormal(vecType<T, P> const & v0, vecType<T, P> const & v1, T const & epsilon);


}


# 1 "/usr/local/include/glm/./gtx/vector_query.inl" 1 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 4 "/usr/local/include/glm/./gtx/vector_query.inl" 2 3


namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_areCollinear{};

 template <typename T, precision P>
 struct compute_areCollinear<T, P, tvec2>
 { inline
                     static bool call(tvec2<T, P> const & v0, tvec2<T, P> const & v1, T const & epsilon)
  {
   return length(cross(tvec3<T, P>(v0, static_cast<T>(0)), tvec3<T, P>(v1, static_cast<T>(0)))) < epsilon;
  }
 };

 template <typename T, precision P>
 struct compute_areCollinear<T, P, tvec3>
 { inline
                     static bool call(tvec3<T, P> const & v0, tvec3<T, P> const & v1, T const & epsilon)
  {
   return length(cross(v0, v1)) < epsilon;
  }
 };

 template <typename T, precision P>
 struct compute_areCollinear<T, P, tvec4>
 { inline
                     static bool call(tvec4<T, P> const & v0, tvec4<T, P> const & v1, T const & epsilon)
  {
   return length(cross(tvec3<T, P>(v0), tvec3<T, P>(v1))) < epsilon;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_isCompNull{};

 template <typename T, precision P>
 struct compute_isCompNull<T, P, tvec2>
 { inline
                     static tvec2<bool, P> call(tvec2<T, P> const & v, T const & epsilon)
  {
   return tvec2<bool, P>(
    (abs(v.x) < epsilon),
    (abs(v.y) < epsilon));
  }
 };

 template <typename T, precision P>
 struct compute_isCompNull<T, P, tvec3>
 { inline
                     static tvec3<bool, P> call(tvec3<T, P> const & v, T const & epsilon)
  {
   return tvec3<bool, P>(
    (abs(v.x) < epsilon),
    (abs(v.y) < epsilon),
    (abs(v.z) < epsilon));
  }
 };

 template <typename T, precision P>
 struct compute_isCompNull<T, P, tvec4>
 { inline
                     static tvec4<bool, P> call(tvec4<T, P> const & v, T const & epsilon)
  {
   return tvec4<bool, P>(
    (abs(v.x) < epsilon),
    (abs(v.y) < epsilon),
    (abs(v.z) < epsilon),
    (abs(v.w) < epsilon));
  }
 };

}

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool areCollinear
 (
  vecType<T, P> const & v0,
  vecType<T, P> const & v1,
  T const & epsilon
 )
 {
                                                                                                          ;

  return detail::compute_areCollinear<T, P, vecType>::call(v0, v1, epsilon);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool areOrthogonal
 (
  vecType<T, P> const & v0,
  vecType<T, P> const & v1,
  T const & epsilon
 )
 {
                                                                                                           ;

  return abs(dot(v0, v1)) <= max(
   static_cast<T>(1),
   length(v0)) * max(static_cast<T>(1), length(v1)) * epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool isNormalized
 (
  vecType<T, P> const & v,
  T const & epsilon
 )
 {
                                                                                                          ;

  return abs(length(v) - static_cast<T>(1)) <= static_cast<T>(2) * epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool isNull
 (
  vecType<T, P> const & v,
  T const & epsilon
 )
 {
                                                                                                    ;

  return length(v) <= epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isCompNull
 (
  vecType<T, P> const & v,
  T const & epsilon
 )
 {
                                                                                                        ;

  return detail::compute_isCompNull<T, P, vecType>::call(v, epsilon);
 }

 template <typename T, precision P> inline
                    tvec2<bool, P> isCompNull
 (
  tvec2<T, P> const & v,
  T const & epsilon)
 {
  return tvec2<bool, P>(
   abs(v.x) < epsilon,
   abs(v.y) < epsilon);
 }

 template <typename T, precision P> inline
                    tvec3<bool, P> isCompNull
 (
  tvec3<T, P> const & v,
  T const & epsilon
 )
 {
  return tvec3<bool, P>(
   abs(v.x) < epsilon,
   abs(v.y) < epsilon,
   abs(v.z) < epsilon);
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isCompNull
 (
  tvec4<T, P> const & v,
  T const & epsilon
 )
 {
  return tvec4<bool, P>(
   abs(v.x) < epsilon,
   abs(v.y) < epsilon,
   abs(v.z) < epsilon,
   abs(v.w) < epsilon);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool areOrthonormal
 (
  vecType<T, P> const & v0,
  vecType<T, P> const & v1,
  T const & epsilon
 )
 {
  return isNormalized(v0, epsilon) && isNormalized(v1, epsilon) && (abs(dot(v0, v1)) <= epsilon);
 }

}
# 62 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 2 3
# 22 "/usr/local/include/glm/./gtx/intersect.hpp" 2 3






namespace glm
{






 template <typename genType>
               bool intersectRayPlane(
  genType const & orig, genType const & dir,
  genType const & planeOrig, genType const & planeNormal,
  typename genType::value_type & intersectionDistance);



 template <typename genType>
               bool intersectRayTriangle(
  genType const & orig, genType const & dir,
  genType const & vert0, genType const & vert1, genType const & vert2,
  genType & baryPosition);



 template <typename genType>
               bool intersectLineTriangle(
  genType const & orig, genType const & dir,
  genType const & vert0, genType const & vert1, genType const & vert2,
  genType & position);




 template <typename genType>
               bool intersectRaySphere(
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, typename genType::value_type const sphereRadiusSquered,
  typename genType::value_type & intersectionDistance);



 template <typename genType>
               bool intersectRaySphere(
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, const typename genType::value_type sphereRadius,
  genType & intersectionPosition, genType & intersectionNormal);



 template <typename genType>
               bool intersectLineSphere(
  genType const & point0, genType const & point1,
  genType const & sphereCenter, typename genType::value_type sphereRadius,
  genType & intersectionPosition1, genType & intersectionNormal1,
  genType & intersectionPosition2 = genType(), genType & intersectionNormal2 = genType());


}


# 1 "/usr/local/include/glm/./gtx/intersect.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    bool intersectRayPlane
 (
  genType const & orig, genType const & dir,
  genType const & planeOrig, genType const & planeNormal,
  typename genType::value_type & intersectionDistance
 )
 {
  typename genType::value_type d = glm::dot(dir, planeNormal);
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();

  if(d < -Epsilon)
  {
   intersectionDistance = glm::dot(planeOrig - orig, planeNormal) / d;
   return true;
  }

  return false;
 }

 template <typename genType> inline
                    bool intersectRayTriangle
 (
  genType const & orig, genType const & dir,
  genType const & v0, genType const & v1, genType const & v2,
  genType & baryPosition
 )
 {
  genType e1 = v1 - v0;
  genType e2 = v2 - v0;

  genType p = glm::cross(dir, e2);

  typename genType::value_type a = glm::dot(e1, p);

  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
  if(a < Epsilon && a > -Epsilon)
   return false;

  typename genType::value_type f = typename genType::value_type(1.0f) / a;

  genType s = orig - v0;
  baryPosition.x = f * glm::dot(s, p);
  if(baryPosition.x < typename genType::value_type(0.0f))
   return false;
  if(baryPosition.x > typename genType::value_type(1.0f))
   return false;

  genType q = glm::cross(s, e1);
  baryPosition.y = f * glm::dot(dir, q);
  if(baryPosition.y < typename genType::value_type(0.0f))
   return false;
  if(baryPosition.y + baryPosition.x > typename genType::value_type(1.0f))
   return false;

  baryPosition.z = f * glm::dot(e2, q);

  return baryPosition.z >= typename genType::value_type(0.0f);
 }

 template <typename genType> inline
                    bool intersectLineTriangle
 (
  genType const & orig, genType const & dir,
  genType const & vert0, genType const & vert1, genType const & vert2,
  genType & position
 )
 {
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();

  genType edge1 = vert1 - vert0;
  genType edge2 = vert2 - vert0;

  genType pvec = cross(dir, edge2);

  float det = dot(edge1, pvec);

  if (det > -Epsilon && det < Epsilon)
   return false;
  float inv_det = typename genType::value_type(1) / det;

  genType tvec = orig - vert0;

  position.y = dot(tvec, pvec) * inv_det;
  if (position.y < typename genType::value_type(0) || position.y > typename genType::value_type(1))
   return false;

  genType qvec = cross(tvec, edge1);

  position.z = dot(dir, qvec) * inv_det;
  if (position.z < typename genType::value_type(0) || position.y + position.z > typename genType::value_type(1))
   return false;

  position.x = dot(edge2, qvec) * inv_det;

  return true;
 }

 template <typename genType> inline
                    bool intersectRaySphere
 (
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, const typename genType::value_type sphereRadiusSquered,
  typename genType::value_type & intersectionDistance
 )
 {
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
  genType diff = sphereCenter - rayStarting;
  typename genType::value_type t0 = dot(diff, rayNormalizedDirection);
  typename genType::value_type dSquared = dot(diff, diff) - t0 * t0;
  if( dSquared > sphereRadiusSquered )
  {
   return false;
  }
  typename genType::value_type t1 = sqrt( sphereRadiusSquered - dSquared );
  intersectionDistance = t0 > t1 + Epsilon ? t0 - t1 : t0 + t1;
  return intersectionDistance > Epsilon;
 }

 template <typename genType> inline
                    bool intersectRaySphere
 (
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, const typename genType::value_type sphereRadius,
  genType & intersectionPosition, genType & intersectionNormal
 )
 {
  typename genType::value_type distance;
  if( intersectRaySphere( rayStarting, rayNormalizedDirection, sphereCenter, sphereRadius * sphereRadius, distance ) )
  {
   intersectionPosition = rayStarting + rayNormalizedDirection * distance;
   intersectionNormal = (intersectionPosition - sphereCenter) / sphereRadius;
   return true;
  }
  return false;
 }

 template <typename genType> inline
                    bool intersectLineSphere
 (
  genType const & point0, genType const & point1,
  genType const & sphereCenter, typename genType::value_type sphereRadius,
  genType & intersectionPoint1, genType & intersectionNormal1,
  genType & intersectionPoint2, genType & intersectionNormal2
 )
 {
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
  genType dir = normalize(point1 - point0);
  genType diff = sphereCenter - point0;
  typename genType::value_type t0 = dot(diff, dir);
  typename genType::value_type dSquared = dot(diff, diff) - t0 * t0;
  if( dSquared > sphereRadius * sphereRadius )
  {
   return false;
  }
  typename genType::value_type t1 = sqrt( sphereRadius * sphereRadius - dSquared );
  if( t0 < t1 + Epsilon )
   t1 = -t1;
  intersectionPoint1 = point0 + dir * (t0 - t1);
  intersectionNormal1 = (intersectionPoint1 - sphereCenter) / sphereRadius;
  intersectionPoint2 = point0 + dir * (t0 + t1);
  intersectionNormal2 = (intersectionPoint2 - sphereCenter) / sphereRadius;
  return true;
 }
}
# 87 "/usr/local/include/glm/./gtx/intersect.hpp" 2 3
# 79 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/log_base.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/log_base.hpp" 3
namespace glm
{





 template <typename genType>
               genType log(
  genType const & x,
  genType const & base);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sign(
  vecType<T, P> const & x,
  vecType<T, P> const & base);


}


# 1 "/usr/local/include/glm/./gtx/log_base.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType log(genType const & x, genType const & base)
 {
  (__builtin_expect(!(x != genType(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/log_base.inl", 9, "x != genType(0)") : (void)0);
  return glm::log(x) / glm::log(base);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> log(vecType<T, P> const & x, vecType<T, P> const & base)
 {
  return glm::log(x) / glm::log(base);
 }
}
# 44 "/usr/local/include/glm/./gtx/log_base.hpp" 2 3
# 80 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat3x3<T, P> matrixCross3(
  tvec3<T, P> const & x);



 template <typename T, precision P>
               tmat4x4<T, P> matrixCross4(
  tvec3<T, P> const & x);


}


# 1 "/usr/local/include/glm/./gtx/matrix_cross_product.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> matrixCross3
 (
  tvec3<T, P> const & x
 )
 {
  tmat3x3<T, P> Result(T(0));
  Result[0][1] = x.z;
  Result[1][0] = -x.z;
  Result[0][2] = -x.y;
  Result[2][0] = x.y;
  Result[1][2] = x.x;
  Result[2][1] = -x.x;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> matrixCross4
 (
  tvec3<T, P> const & x
 )
 {
  tmat4x4<T, P> Result(T(0));
  Result[0][1] = x.z;
  Result[1][0] = -x.z;
  Result[0][2] = -x.y;
  Result[2][0] = x.y;
  Result[1][2] = x.x;
  Result[2][1] = -x.x;
  return Result;
 }

}
# 43 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 2 3
# 81 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 3
namespace glm
{





 template <typename T, precision P>
               void axisAngle(
  tmat4x4<T, P> const & mat,
  tvec3<T, P> & axis,
  T & angle);



 template <typename T, precision P>
               tmat4x4<T, P> axisAngleMatrix(
  tvec3<T, P> const & axis,
  T const angle);



 template <typename T, precision P>
               tmat4x4<T, P> extractMatrixRotation(
  tmat4x4<T, P> const & mat);




 template <typename T, precision P>
               tmat4x4<T, P> interpolate(
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2,
  T const delta);


}


# 1 "/usr/local/include/glm/./gtx/matrix_interpolation.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    void axisAngle
 (
  tmat4x4<T, P> const & mat,
  tvec3<T, P> & axis,
  T & angle
 )
 {
  T epsilon = (T)0.01;
  T epsilon2 = (T)0.1;

  if((abs(mat[1][0] - mat[0][1]) < epsilon) && (abs(mat[2][0] - mat[0][2]) < epsilon) && (abs(mat[2][1] - mat[1][2]) < epsilon))
  {
   if ((abs(mat[1][0] + mat[0][1]) < epsilon2) && (abs(mat[2][0] + mat[0][2]) < epsilon2) && (abs(mat[2][1] + mat[1][2]) < epsilon2) && (abs(mat[0][0] + mat[1][1] + mat[2][2] - (T)3.0) < epsilon2))
   {
    angle = (T)0.0;
    axis.x = (T)1.0;
    axis.y = (T)0.0;
    axis.z = (T)0.0;
    return;
   }
   angle = static_cast<T>(3.1415926535897932384626433832795);
   T xx = (mat[0][0] + (T)1.0) / (T)2.0;
   T yy = (mat[1][1] + (T)1.0) / (T)2.0;
   T zz = (mat[2][2] + (T)1.0) / (T)2.0;
   T xy = (mat[1][0] + mat[0][1]) / (T)4.0;
   T xz = (mat[2][0] + mat[0][2]) / (T)4.0;
   T yz = (mat[2][1] + mat[1][2]) / (T)4.0;
   if((xx > yy) && (xx > zz))
   {
    if (xx < epsilon) {
     axis.x = (T)0.0;
     axis.y = (T)0.7071;
     axis.z = (T)0.7071;
    } else {
     axis.x = sqrt(xx);
     axis.y = xy / axis.x;
     axis.z = xz / axis.x;
    }
   }
   else if (yy > zz)
   {
    if (yy < epsilon) {
     axis.x = (T)0.7071;
     axis.y = (T)0.0;
     axis.z = (T)0.7071;
    } else {
     axis.y = sqrt(yy);
     axis.x = xy / axis.y;
     axis.z = yz / axis.y;
    }
   }
   else
   {
    if (zz < epsilon) {
     axis.x = (T)0.7071;
     axis.y = (T)0.7071;
     axis.z = (T)0.0;
    } else {
     axis.z = sqrt(zz);
     axis.x = xz / axis.z;
     axis.y = yz / axis.z;
    }
   }
   return;
  }
  T s = sqrt((mat[2][1] - mat[1][2]) * (mat[2][1] - mat[1][2]) + (mat[2][0] - mat[0][2]) * (mat[2][0] - mat[0][2]) + (mat[1][0] - mat[0][1]) * (mat[1][0] - mat[0][1]));
  if (glm::abs(s) < T(0.001))
   s = (T)1.0;
  angle = acos((mat[0][0] + mat[1][1] + mat[2][2] - (T)1.0) / (T)2.0);
  axis.x = (mat[1][2] - mat[2][1]) / s;
  axis.y = (mat[2][0] - mat[0][2]) / s;
  axis.z = (mat[0][1] - mat[1][0]) / s;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> axisAngleMatrix
 (
  tvec3<T, P> const & axis,
  T const angle
 )
 {
  T c = cos(angle);
  T s = sin(angle);
  T t = static_cast<T>(1) - c;
  tvec3<T, P> n = normalize(axis);

  return tmat4x4<T, P>(
   t * n.x * n.x + c, t * n.x * n.y + n.z * s, t * n.x * n.z - n.y * s, T(0),
   t * n.x * n.y - n.z * s, t * n.y * n.y + c, t * n.y * n.z + n.x * s, T(0),
   t * n.x * n.z + n.y * s, t * n.y * n.z - n.x * s, t * n.z * n.z + c, T(0),
   T(0), T(0), T(0), T(1)
  );
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> extractMatrixRotation
 (
  tmat4x4<T, P> const & mat
 )
 {
  return tmat4x4<T, P>(
   mat[0][0], mat[0][1], mat[0][2], 0.0,
   mat[1][0], mat[1][1], mat[1][2], 0.0,
   mat[2][0], mat[2][1], mat[2][2], 0.0,
   0.0, 0.0, 0.0, 1.0
  );
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> interpolate
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2,
  T const delta
 )
 {
  tmat4x4<T, P> m1rot = extractMatrixRotation(m1);
  tmat4x4<T, P> dltRotation = m2 * transpose(m1rot);
  tvec3<T, P> dltAxis;
  T dltAngle;
  axisAngle(dltRotation, dltAxis, dltAngle);
  tmat4x4<T, P> out = axisAngleMatrix(dltAxis, dltAngle * delta) * m1rot;
  out[3][0] = m1[3][0] + delta * (m2[3][0] - m1[3][0]);
  out[3][1] = m1[3][1] + delta * (m2[3][1] - m1[3][1]);
  out[3][2] = m1[3][2] + delta * (m2[3][2] - m1[3][2]);
  return out;
 }
}
# 61 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 2 3
# 82 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat2x2<T, P> rowMajor2(
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2);



 template <typename T, precision P>
               tmat2x2<T, P> rowMajor2(
  tmat2x2<T, P> const & m);



 template <typename T, precision P>
               tmat3x3<T, P> rowMajor3(
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3);



 template <typename T, precision P>
               tmat3x3<T, P> rowMajor3(
  tmat3x3<T, P> const & m);



 template <typename T, precision P>
               tmat4x4<T, P> rowMajor4(
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2,
  tvec4<T, P> const & v3,
  tvec4<T, P> const & v4);



 template <typename T, precision P>
               tmat4x4<T, P> rowMajor4(
  tmat4x4<T, P> const & m);



 template <typename T, precision P>
               tmat2x2<T, P> colMajor2(
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2);



 template <typename T, precision P>
               tmat2x2<T, P> colMajor2(
  tmat2x2<T, P> const & m);



 template <typename T, precision P>
               tmat3x3<T, P> colMajor3(
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3);



 template <typename T, precision P>
               tmat3x3<T, P> colMajor3(
  tmat3x3<T, P> const & m);



 template <typename T, precision P>
               tmat4x4<T, P> colMajor4(
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2,
  tvec4<T, P> const & v3,
  tvec4<T, P> const & v4);



 template <typename T, precision P>
               tmat4x4<T, P> colMajor4(
  tmat4x4<T, P> const & m);


}


# 1 "/usr/local/include/glm/./gtx/matrix_major_storage.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat2x2<T, P> rowMajor2
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  tmat2x2<T, P> Result;
  Result[0][0] = v1.x;
  Result[1][0] = v1.y;
  Result[0][1] = v2.x;
  Result[1][1] = v2.y;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> rowMajor2(
  const tmat2x2<T, P>& m)
 {
  tmat2x2<T, P> Result;
  Result[0][0] = m[0][0];
  Result[0][1] = m[1][0];
  Result[1][0] = m[0][1];
  Result[1][1] = m[1][1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> rowMajor3(
  const tvec3<T, P>& v1,
  const tvec3<T, P>& v2,
  const tvec3<T, P>& v3)
 {
  tmat3x3<T, P> Result;
  Result[0][0] = v1.x;
  Result[1][0] = v1.y;
  Result[2][0] = v1.z;
  Result[0][1] = v2.x;
  Result[1][1] = v2.y;
  Result[2][1] = v2.z;
  Result[0][2] = v3.x;
  Result[1][2] = v3.y;
  Result[2][2] = v3.z;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> rowMajor3(
  const tmat3x3<T, P>& m)
 {
  tmat3x3<T, P> Result;
  Result[0][0] = m[0][0];
  Result[0][1] = m[1][0];
  Result[0][2] = m[2][0];
  Result[1][0] = m[0][1];
  Result[1][1] = m[1][1];
  Result[1][2] = m[2][1];
  Result[2][0] = m[0][2];
  Result[2][1] = m[1][2];
  Result[2][2] = m[2][2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rowMajor4(
  const tvec4<T, P>& v1,
  const tvec4<T, P>& v2,
  const tvec4<T, P>& v3,
  const tvec4<T, P>& v4)
 {
  tmat4x4<T, P> Result;
  Result[0][0] = v1.x;
  Result[1][0] = v1.y;
  Result[2][0] = v1.z;
  Result[3][0] = v1.w;
  Result[0][1] = v2.x;
  Result[1][1] = v2.y;
  Result[2][1] = v2.z;
  Result[3][1] = v2.w;
  Result[0][2] = v3.x;
  Result[1][2] = v3.y;
  Result[2][2] = v3.z;
  Result[3][2] = v3.w;
  Result[0][3] = v4.x;
  Result[1][3] = v4.y;
  Result[2][3] = v4.z;
  Result[3][3] = v4.w;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rowMajor4(
  const tmat4x4<T, P>& m)
 {
  tmat4x4<T, P> Result;
  Result[0][0] = m[0][0];
  Result[0][1] = m[1][0];
  Result[0][2] = m[2][0];
  Result[0][3] = m[3][0];
  Result[1][0] = m[0][1];
  Result[1][1] = m[1][1];
  Result[1][2] = m[2][1];
  Result[1][3] = m[3][1];
  Result[2][0] = m[0][2];
  Result[2][1] = m[1][2];
  Result[2][2] = m[2][2];
  Result[2][3] = m[3][2];
  Result[3][0] = m[0][3];
  Result[3][1] = m[1][3];
  Result[3][2] = m[2][3];
  Result[3][3] = m[3][3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> colMajor2(
  const tvec2<T, P>& v1,
  const tvec2<T, P>& v2)
 {
  return tmat2x2<T, P>(v1, v2);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> colMajor2(
  const tmat2x2<T, P>& m)
 {
  return tmat2x2<T, P>(m);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> colMajor3(
  const tvec3<T, P>& v1,
  const tvec3<T, P>& v2,
  const tvec3<T, P>& v3)
 {
  return tmat3x3<T, P>(v1, v2, v3);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> colMajor3(
  const tmat3x3<T, P>& m)
 {
  return tmat3x3<T, P>(m);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> colMajor4(
  const tvec4<T, P>& v1,
  const tvec4<T, P>& v2,
  const tvec4<T, P>& v3,
  const tvec4<T, P>& v4)
 {
  return tmat4x4<T, P>(v1, v2, v3, v4);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> colMajor4(
  const tmat4x4<T, P>& m)
 {
  return tmat4x4<T, P>(m);
 }
}
# 115 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 2 3
# 83 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat2x2<T, P> diagonal2x2(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat2x3<T, P> diagonal2x3(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat2x4<T, P> diagonal2x4(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat3x2<T, P> diagonal3x2(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat3x3<T, P> diagonal3x3(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               tmat3x4<T, P> diagonal3x4(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               tmat4x2<T, P> diagonal4x2(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat4x3<T, P> diagonal4x3(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               tmat4x4<T, P> diagonal4x4(
  tvec4<T, P> const & v);


}


# 1 "/usr/local/include/glm/./gtx/matrix_operation.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat2x2<T, P> diagonal2x2
 (
  tvec2<T, P> const & v
 )
 {
  tmat2x2<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> diagonal2x3
 (
  tvec2<T, P> const & v
 )
 {
  tmat2x3<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> diagonal2x4
 (
  tvec2<T, P> const & v
 )
 {
  tmat2x4<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> diagonal3x2
 (
  tvec2<T, P> const & v
 )
 {
  tmat3x2<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> diagonal3x3
 (
  tvec3<T, P> const & v
 )
 {
  tmat3x3<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> diagonal3x4
 (
  tvec3<T, P> const & v
 )
 {
  tmat3x4<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> diagonal4x4
 (
  tvec4<T, P> const & v
 )
 {
  tmat4x4<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  Result[3][3] = v[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> diagonal4x3
 (
  tvec3<T, P> const & v
 )
 {
  tmat4x3<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> diagonal4x2
 (
  tvec2<T, P> const & v
 )
 {
  tmat4x2<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }
}
# 84 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 2 3
# 84 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_query.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/matrix_query.hpp" 3
namespace glm
{





 template<typename T, precision P>
               bool isNull(tmat2x2<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNull(tmat3x3<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNull(tmat4x4<T, P> const & m, T const & epsilon);



 template<typename T, precision P, template <typename, precision> class matType>
               bool isIdentity(matType<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNormalized(tmat2x2<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNormalized(tmat3x3<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNormalized(tmat4x4<T, P> const & m, T const & epsilon);



 template<typename T, precision P, template <typename, precision> class matType>
               bool isOrthogonal(matType<T, P> const & m, T const & epsilon);


}


# 1 "/usr/local/include/glm/./gtx/matrix_query.inl" 1 3



namespace glm
{
 template<typename T, precision P> inline
                    bool isNull(tmat2x2<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m.length() ; ++i)
   result = isNull(m[i], epsilon);
  return result;
 }

 template<typename T, precision P> inline
                    bool isNull(tmat3x3<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m.length() ; ++i)
   result = isNull(m[i], epsilon);
  return result;
 }

 template<typename T, precision P> inline
                    bool isNull(tmat4x4<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m.length() ; ++i)
   result = isNull(m[i], epsilon);
  return result;
 }

 template<typename T, precision P, template <typename, precision> class matType> inline
                    bool isIdentity(matType<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m[0].length() ; ++i)
  {
   for(length_t j = 0; result && j < i ; ++j)
    result = abs(m[i][j]) <= epsilon;
   if(result)
    result = abs(m[i][i] - 1) <= epsilon;
   for(length_t j = i + 1; result && j < m.length(); ++j)
    result = abs(m[i][j]) <= epsilon;
  }
  return result;
 }

 template<typename T, precision P> inline
                    bool isNormalized(tmat2x2<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i = 0; result && i < m.length(); ++i)
   result = isNormalized(m[i], epsilon);
  for(length_t i = 0; result && i < m.length(); ++i)
  {
   typename tmat2x2<T, P>::col_type v;
   for(length_t j = 0; j < m.length(); ++j)
    v[j] = m[j][i];
   result = isNormalized(v, epsilon);
  }
  return result;
 }

 template<typename T, precision P> inline
                    bool isNormalized(tmat3x3<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i = 0; result && i < m.length(); ++i)
   result = isNormalized(m[i], epsilon);
  for(length_t i = 0; result && i < m.length(); ++i)
  {
   typename tmat3x3<T, P>::col_type v;
   for(length_t j = 0; j < m.length(); ++j)
    v[j] = m[j][i];
   result = isNormalized(v, epsilon);
  }
  return result;
 }

 template<typename T, precision P> inline
                    bool isNormalized(tmat4x4<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i = 0; result && i < m.length(); ++i)
   result = isNormalized(m[i], epsilon);
  for(length_t i = 0; result && i < m.length(); ++i)
  {
   typename tmat4x4<T, P>::col_type v;
   for(length_t j = 0; j < m.length(); ++j)
    v[j] = m[j][i];
   result = isNormalized(v, epsilon);
  }
  return result;
 }

 template<typename T, precision P, template <typename, precision> class matType> inline
                    bool isOrthogonal(matType<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i(0); result && i < m.length() - 1; ++i)
  for(length_t j(i + 1); result && j < m.length(); ++j)
   result = areOrthogonal(m[i], m[j], epsilon);

  if(result)
  {
   matType<T, P> tmp = transpose(m);
   for(length_t i(0); result && i < m.length() - 1 ; ++i)
   for(length_t j(i + 1); result && j < m.length(); ++j)
    result = areOrthogonal(tmp[i], tmp[j], epsilon);
  }
  return result;
 }
}
# 73 "/usr/local/include/glm/./gtx/matrix_query.hpp" 2 3
# 85 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/mixed_product.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/mixed_product.hpp" 3
namespace glm
{




 template <typename T, precision P>
               T mixedProduct(
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3);


}


# 1 "/usr/local/include/glm/./gtx/mixed_product.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    T mixedProduct
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3
 )
 {
  return dot(cross(v1, v2), v3);
 }
}
# 37 "/usr/local/include/glm/./gtx/mixed_product.hpp" 2 3
# 86 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/norm.hpp" 1 3
# 18 "/usr/local/include/glm/./gtx/norm.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 1 3
# 26 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 3
namespace glm
{






 template<typename T, precision P>
               tvec3<T, P> cross(
  tquat<T, P> const & q,
  tvec3<T, P> const & v);




 template<typename T, precision P>
               tvec3<T, P> cross(
  tvec3<T, P> const & v,
  tquat<T, P> const & q);





 template<typename T, precision P>
               tquat<T, P> squad(
  tquat<T, P> const & q1,
  tquat<T, P> const & q2,
  tquat<T, P> const & s1,
  tquat<T, P> const & s2,
  T const & h);




 template<typename T, precision P>
               tquat<T, P> intermediate(
  tquat<T, P> const & prev,
  tquat<T, P> const & curr,
  tquat<T, P> const & next);




 template<typename T, precision P>
               tquat<T, P> exp(
  tquat<T, P> const & q);




 template<typename T, precision P>
               tquat<T, P> log(
  tquat<T, P> const & q);




 template<typename T, precision P>
               tquat<T, P> pow(
  tquat<T, P> const & x,
  T const & y);
# 100 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 3
 template<typename T, precision P>
               tvec3<T, P> rotate(
  tquat<T, P> const & q,
  tvec3<T, P> const & v);




 template<typename T, precision P>
               tvec4<T, P> rotate(
  tquat<T, P> const & q,
  tvec4<T, P> const & v);




 template<typename T, precision P>
               T extractRealComponent(
  tquat<T, P> const & q);




 template<typename T, precision P>
               tmat3x3<T, P> toMat3(
  tquat<T, P> const & x){return mat3_cast(x);}




 template<typename T, precision P>
               tmat4x4<T, P> toMat4(
  tquat<T, P> const & x){return mat4_cast(x);}




 template<typename T, precision P>
               tquat<T, P> toQuat(
  tmat3x3<T, P> const & x){return quat_cast(x);}




 template<typename T, precision P>
               tquat<T, P> toQuat(
  tmat4x4<T, P> const & x){return quat_cast(x);}




 template<typename T, precision P>
               tquat<T, P> shortMix(
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & a);




 template<typename T, precision P>
               tquat<T, P> fastMix(
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & a);






 template<typename T, precision P>
               tquat<T, P> rotation(
  tvec3<T, P> const & orig,
  tvec3<T, P> const & dest);




 template<typename T, precision P>
               T length2(tquat<T, P> const & q);


}


# 1 "/usr/local/include/glm/./gtx/quaternion.inl" 1 3






namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> cross(tvec3<T, P> const& v, tquat<T, P> const& q)
 {
  return inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> cross(tquat<T, P> const& q, tvec3<T, P> const& v)
 {
  return q * v;
 }

 template <typename T, precision P> inline
                    tquat<T, P> squad
 (
  tquat<T, P> const & q1,
  tquat<T, P> const & q2,
  tquat<T, P> const & s1,
  tquat<T, P> const & s2,
  T const & h)
 {
  return mix(mix(q1, q2, h), mix(s1, s2, h), static_cast<T>(2) * (static_cast<T>(1) - h) * h);
 }

 template <typename T, precision P> inline
                    tquat<T, P> intermediate
 (
  tquat<T, P> const & prev,
  tquat<T, P> const & curr,
  tquat<T, P> const & next
 )
 {
  tquat<T, P> invQuat = inverse(curr);
  return exp((log(next + invQuat) + log(prev + invQuat)) / static_cast<T>(-4)) * curr;
 }

 template <typename T, precision P> inline
                    tquat<T, P> exp(tquat<T, P> const& q)
 {
  tvec3<T, P> u(q.x, q.y, q.z);
  T const Angle = glm::length(u);
  if (Angle < epsilon<T>())
   return tquat<T, P>();

  tvec3<T, P> const v(u / Angle);
  return tquat<T, P>(cos(Angle), sin(Angle) * v);
 }

 template <typename T, precision P> inline
                    tquat<T, P> log(tquat<T, P> const& q)
 {
  tvec3<T, P> u(q.x, q.y, q.z);
  T Vec3Len = length(u);

  if (Vec3Len < epsilon<T>())
  {
   if(q.w > static_cast<T>(0))
    return tquat<T, P>(log(q.w), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
   else if(q.w < static_cast<T>(0))
    return tquat<T, P>(log(-q.w), pi<T>(), static_cast<T>(0), static_cast<T>(0));
   else
    return tquat<T, P>(std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity());
  }
  else
  {
   T t = atan(Vec3Len, T(q.w)) / Vec3Len;
   T QuatLen2 = Vec3Len * Vec3Len + q.w * q.w;
   return tquat<T, P>(static_cast<T>(0.5) * log(QuatLen2), t * q.x, t * q.y, t * q.z);
  }
 }

 template <typename T, precision P> inline
                    tquat<T, P> pow(tquat<T, P> const & x, T const & y)
 {


  if(y > -epsilon<T>() && y < epsilon<T>())
   return tquat<T, P>(1,0,0,0);


  T magnitude = sqrt(x.x * x.x + x.y * x.y + x.z * x.z + x.w *x.w);



  if(abs(x.w / magnitude) > static_cast<T>(1) - epsilon<T>() && abs(x.w / magnitude) < static_cast<T>(1) + epsilon<T>())
   return tquat<T, P>(pow(x.w, y),0,0,0);

  T Angle = acos(x.w / magnitude);
  T NewAngle = Angle * y;
  T Div = sin(NewAngle) / sin(Angle);
  T Mag = pow(magnitude, y - static_cast<T>(1));

  return tquat<T, P>(cos(NewAngle) * magnitude * Mag, x.x * Div * Mag, x.y * Div * Mag, x.z * Div * Mag);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotate(tquat<T, P> const& q, tvec3<T, P> const& v)
 {
  return q * v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotate(tquat<T, P> const& q, tvec4<T, P> const& v)
 {
  return q * v;
 }

 template <typename T, precision P> inline
                    T extractRealComponent(tquat<T, P> const& q)
 {
  T w = static_cast<T>(1) - q.x * q.x - q.y * q.y - q.z * q.z;
  if(w < T(0))
   return T(0);
  else
   return -sqrt(w);
 }

 template <typename T, precision P> inline
                    T length2(tquat<T, P> const& q)
 {
  return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
 }

 template <typename T, precision P> inline
                    tquat<T, P> shortMix(tquat<T, P> const& x, tquat<T, P> const& y, T const& a)
 {
  if(a <= static_cast<T>(0)) return x;
  if(a >= static_cast<T>(1)) return y;

  T fCos = dot(x, y);
  tquat<T, P> y2(y);
  if(fCos < static_cast<T>(0))
  {
   y2 = -y;
   fCos = -fCos;
  }


  T k0, k1;
  if(fCos > (static_cast<T>(1) - epsilon<T>()))
  {
   k0 = static_cast<T>(1) - a;
   k1 = static_cast<T>(0) + a;
  }
  else
  {
   T fSin = sqrt(T(1) - fCos * fCos);
   T fAngle = atan(fSin, fCos);
   T fOneOverSin = static_cast<T>(1) / fSin;
   k0 = sin((static_cast<T>(1) - a) * fAngle) * fOneOverSin;
   k1 = sin((static_cast<T>(0) + a) * fAngle) * fOneOverSin;
  }

  return tquat<T, P>(
   k0 * x.w + k1 * y2.w,
   k0 * x.x + k1 * y2.x,
   k0 * x.y + k1 * y2.y,
   k0 * x.z + k1 * y2.z);
 }

 template <typename T, precision P> inline
                    tquat<T, P> fastMix(tquat<T, P> const& x, tquat<T, P> const& y, T const & a)
 {
  return glm::normalize(x * (static_cast<T>(1) - a) + (y * a));
 }

 template <typename T, precision P> inline
                    tquat<T, P> rotation(tvec3<T, P> const& orig, tvec3<T, P> const& dest)
 {
  T cosTheta = dot(orig, dest);
  tvec3<T, P> rotationAxis;

  if(cosTheta >= static_cast<T>(1) - epsilon<T>())
   return quat();

  if(cosTheta < static_cast<T>(-1) + epsilon<T>())
  {





   rotationAxis = cross(tvec3<T, P>(0, 0, 1), orig);
   if(length2(rotationAxis) < epsilon<T>())
    rotationAxis = cross(tvec3<T, P>(1, 0, 0), orig);

   rotationAxis = normalize(rotationAxis);
   return angleAxis(pi<T>(), rotationAxis);
  }


  rotationAxis = cross(orig, dest);

  T s = sqrt((T(1) + cosTheta) * static_cast<T>(2));
  T invs = static_cast<T>(1) / s;

  return tquat<T, P>(
   s * static_cast<T>(0.5f),
   rotationAxis.x * invs,
   rotationAxis.y * invs,
   rotationAxis.z * invs);
 }

}
# 185 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 2 3
# 18 "/usr/local/include/glm/./gtx/norm.hpp" 2 3






namespace glm
{





 template <typename T, precision P, template <typename, precision> class vecType>
               T length2(
  vecType<T, P> const & x);



 template <typename T, precision P, template <typename, precision> class vecType>
               T distance2(
  vecType<T, P> const & p0,
  vecType<T, P> const & p1);



 template <typename T, precision P>
               T l1Norm(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y);



 template <typename T, precision P>
               T l1Norm(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               T l2Norm(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y);



 template <typename T, precision P>
               T l2Norm(
  tvec3<T, P> const & x);



 template <typename T, precision P>
               T lxNorm(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  unsigned int Depth);



 template <typename T, precision P>
               T lxNorm(
  tvec3<T, P> const & x,
  unsigned int Depth);


}


# 1 "/usr/local/include/glm/./gtx/norm.inl" 1 3





namespace glm{
namespace detail
{
 template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_length2
 { inline
                     static T call(vecType<T, P> const & v)
  {
   return dot(v, v);
  }
 };
}

 template <typename genType> inline
                    genType length2(genType x)
 {
                                                                                                            ;
  return x * x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T length2(vecType<T, P> const & v)
 {
                                                                                                      ;
  return detail::compute_length2<vecType, T, P, detail::is_aligned<P>::value>::call(v);
 }

 template <typename T> inline
                    T distance2(T p0, T p1)
 {
                                                                                                        ;
  return length2(p1 - p0);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T distance2(vecType<T, P> const & p0, vecType<T, P> const & p1)
 {
                                                                                                        ;
  return length2(p1 - p0);
 }

 template <typename T, precision P> inline
                    T l1Norm
 (
  tvec3<T, P> const & a,
  tvec3<T, P> const & b
 )
 {
  return abs(b.x - a.x) + abs(b.y - a.y) + abs(b.z - a.z);
 }

 template <typename T, precision P> inline
                    T l1Norm
 (
  tvec3<T, P> const & v
 )
 {
  return abs(v.x) + abs(v.y) + abs(v.z);
 }

 template <typename T, precision P> inline
                    T l2Norm
 (
  tvec3<T, P> const & a,
  tvec3<T, P> const & b
 )
 {
  return length(b - a);
 }

 template <typename T, precision P> inline
                    T l2Norm
 (
  tvec3<T, P> const & v
 )
 {
  return length(v);
 }

 template <typename T, precision P> inline
                    T lxNorm
 (
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  unsigned int Depth
 )
 {
  return pow(pow(y.x - x.x, T(Depth)) + pow(y.y - x.y, T(Depth)) + pow(y.z - x.z, T(Depth)), T(1) / T(Depth));
 }

 template <typename T, precision P> inline
                    T lxNorm
 (
  tvec3<T, P> const & v,
  unsigned int Depth
 )
 {
  return pow(pow(v.x, T(Depth)) + pow(v.y, T(Depth)) + pow(v.z, T(Depth)), T(1) / T(Depth));
 }

}
# 86 "/usr/local/include/glm/./gtx/norm.hpp" 2 3
# 87 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/normal.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/normal.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> triangleNormal(
  tvec3<T, P> const & p1,
  tvec3<T, P> const & p2,
  tvec3<T, P> const & p3);


}


# 1 "/usr/local/include/glm/./gtx/normal.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> triangleNormal
 (
  tvec3<T, P> const & p1,
  tvec3<T, P> const & p2,
  tvec3<T, P> const & p3
 )
 {
  return normalize(cross(p1 - p2, p1 - p3));
 }
}
# 39 "/usr/local/include/glm/./gtx/normal.hpp" 2 3
# 88 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 3
namespace glm
{







 template <typename T, precision P, template <typename, precision> class vecType>
               T normalizeDot(vecType<T, P> const & x, vecType<T, P> const & y);





 template <typename T, precision P, template <typename, precision> class vecType>
               T fastNormalizeDot(vecType<T, P> const & x, vecType<T, P> const & y);


}


# 1 "/usr/local/include/glm/./gtx/normalize_dot.inl" 1 3



namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T normalizeDot(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return glm::dot(x, y) * glm::inversesqrt(glm::dot(x, x) * glm::dot(y, y));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T fastNormalizeDot(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return glm::dot(x, y) * glm::fastInverseSqrt(glm::dot(x, x) * glm::dot(y, y));
 }
}
# 45 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 2 3
# 89 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/number_precision.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/number_precision.hpp" 3
namespace glm{
namespace gtx
{






 typedef u8 u8vec1;
 typedef u16 u16vec1;
 typedef u32 u32vec1;
 typedef u64 u64vec1;




 typedef f32 f32vec1;
 typedef f64 f64vec1;




 typedef f32 f32mat1;
 typedef f32 f32mat1x1;
 typedef f64 f64mat1;
 typedef f64 f64mat1x1;


}
}


# 1 "/usr/local/include/glm/./gtx/number_precision.inl" 1 3



namespace glm
{

}
# 57 "/usr/local/include/glm/./gtx/number_precision.hpp" 2 3
# 90 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 3
namespace glm
{






 template <typename T, precision P>
               tmat3x3<T, P> orthonormalize(tmat3x3<T, P> const & m);




 template <typename T, precision P>
               tvec3<T, P> orthonormalize(tvec3<T, P> const & x, tvec3<T, P> const & y);


}


# 1 "/usr/local/include/glm/./gtx/orthonormalize.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> orthonormalize(tmat3x3<T, P> const & m)
 {
  tmat3x3<T, P> r = m;

  r[0] = normalize(r[0]);

  T d0 = dot(r[0], r[1]);
  r[1] -= r[0] * d0;
  r[1] = normalize(r[1]);

  T d1 = dot(r[1], r[2]);
  d0 = dot(r[0], r[2]);
  r[2] -= r[0] * d0 + r[1] * d1;
  r[2] = normalize(r[2]);

  return r;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> orthonormalize(tvec3<T, P> const & x, tvec3<T, P> const & y)
 {
  return normalize(x - y * dot(y, x));
 }
}
# 45 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 2 3
# 92 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/perpendicular.hpp" 1 3
# 18 "/usr/local/include/glm/./gtx/perpendicular.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 3
namespace glm
{






 template <typename vecType>
               vecType proj(vecType const & x, vecType const & Normal);


}


# 1 "/usr/local/include/glm/./gtx/projection.inl" 1 3



namespace glm
{
 template <typename vecType> inline
                    vecType proj(vecType const & x, vecType const & Normal)
 {
  return glm::dot(x, Normal) / glm::dot(Normal, Normal) * Normal;
 }
}
# 36 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 2 3
# 18 "/usr/local/include/glm/./gtx/perpendicular.hpp" 2 3






namespace glm
{





 template <typename vecType>
               vecType perp(
  vecType const & x,
  vecType const & Normal);


}


# 1 "/usr/local/include/glm/./gtx/perpendicular.inl" 1 3



namespace glm
{
 template <typename vecType> inline
                    vecType perp
 (
  vecType const & x,
  vecType const & Normal
 )
 {
  return x - proj(x, Normal);
 }
}
# 39 "/usr/local/include/glm/./gtx/perpendicular.hpp" 2 3
# 93 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 3
namespace glm
{






 template <typename T, precision P>
               tvec3<T, P> polar(
  tvec3<T, P> const & euclidean);




 template <typename T, precision P>
               tvec3<T, P> euclidean(
  tvec2<T, P> const & polar);


}


# 1 "/usr/local/include/glm/./gtx/polar_coordinates.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> polar
 (
  tvec3<T, P> const & euclidean
 )
 {
  T const Length(length(euclidean));
  tvec3<T, P> const tmp(euclidean / Length);
  T const xz_dist(sqrt(tmp.x * tmp.x + tmp.z * tmp.z));

  return tvec3<T, P>(
   asin(tmp.y),
   atan(tmp.x, tmp.z),
   xz_dist);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> euclidean
 (
  tvec2<T, P> const & polar
 )
 {
  T const latitude(polar.x);
  T const longitude(polar.y);

  return tvec3<T, P>(
   cos(latitude) * sin(longitude),
   sin(latitude),
   cos(latitude) * cos(longitude));
 }

}
# 44 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 2 3
# 94 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtx/raw_data.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/raw_data.hpp" 3
namespace glm
{





 typedef detail::uint8 byte;



 typedef detail::uint16 word;



 typedef detail::uint32 dword;



 typedef detail::uint64 qword;


}


# 1 "/usr/local/include/glm/./gtx/raw_data.inl" 1 3
# 47 "/usr/local/include/glm/./gtx/raw_data.hpp" 2 3
# 97 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 1 3
# 18 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 1 3
# 26 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 3
namespace glm
{






 template <typename T, precision P>
               tmat4x4<T, P> translate(
  tvec3<T, P> const & v);




 template <typename T, precision P>
               tmat4x4<T, P> rotate(
  T angle,
  tvec3<T, P> const & v);




 template <typename T, precision P>
               tmat4x4<T, P> scale(
  tvec3<T, P> const & v);


}


# 1 "/usr/local/include/glm/./gtx/transform.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat4x4<T, P> translate(tvec3<T, P> const & v)
 {
  return translate(tmat4x4<T, P>(static_cast<T>(1)), v);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rotate(T angle, tvec3<T, P> const & v)
 {
  return rotate(tmat4x4<T, P>(static_cast<T>(1)), angle, v);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scale(tvec3<T, P> const & v)
 {
  return scale(tmat4x4<T, P>(static_cast<T>(1)), v);
 }

}
# 56 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 2 3
# 18 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 2 3






namespace glm
{
# 36 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 3
 template <typename T, precision P>
               tvec3<T, P> slerp(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  T const & a);



 template <typename T, precision P>
               tvec2<T, P> rotate(
  tvec2<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec3<T, P> rotate(
  tvec3<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal);



 template <typename T, precision P>
               tvec4<T, P> rotate(
  tvec4<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal);



 template <typename T, precision P>
               tvec3<T, P> rotateX(
  tvec3<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec3<T, P> rotateY(
  tvec3<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec3<T, P> rotateZ(
  tvec3<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec4<T, P> rotateX(
  tvec4<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec4<T, P> rotateY(
  tvec4<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec4<T, P> rotateZ(
  tvec4<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tmat4x4<T, P> orientation(
  tvec3<T, P> const & Normal,
  tvec3<T, P> const & Up);


}


# 1 "/usr/local/include/glm/./gtx/rotate_vector.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> slerp
 (
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  T const & a
 )
 {

  T CosAlpha = dot(x, y);

  T Alpha = acos(CosAlpha);

  T SinAlpha = sin(Alpha);

  T t1 = sin((static_cast<T>(1) - a) * Alpha) / SinAlpha;
  T t2 = sin(a * Alpha) / SinAlpha;


  return x * t1 + y * t2;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> rotate
 (
  tvec2<T, P> const & v,
  T const & angle
 )
 {
  tvec2<T, P> Result;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos - v.y * Sin;
  Result.y = v.x * Sin + v.y * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotate
 (
  tvec3<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal
 )
 {
  return tmat3x3<T, P>(glm::rotate(angle, normal)) * v;
 }
# 66 "/usr/local/include/glm/./gtx/rotate_vector.inl" 3
 template <typename T, precision P> inline
                    tvec4<T, P> rotate
 (
  tvec4<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal
 )
 {
  return rotate(angle, normal) * v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotateX
 (
  tvec3<T, P> const & v,
  T const & angle
 )
 {
  tvec3<T, P> Result(v);
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.y = v.y * Cos - v.z * Sin;
  Result.z = v.y * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotateY
 (
  tvec3<T, P> const & v,
  T const & angle
 )
 {
  tvec3<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos + v.z * Sin;
  Result.z = -v.x * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotateZ
 (
  tvec3<T, P> const & v,
  T const & angle
 )
 {
  tvec3<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos - v.y * Sin;
  Result.y = v.x * Sin + v.y * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotateX
 (
  tvec4<T, P> const & v,
  T const & angle
 )
 {
  tvec4<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.y = v.y * Cos - v.z * Sin;
  Result.z = v.y * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotateY
 (
  tvec4<T, P> const & v,
  T const & angle
 )
 {
  tvec4<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos + v.z * Sin;
  Result.z = -v.x * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotateZ
 (
  tvec4<T, P> const & v,
  T const & angle
 )
 {
  tvec4<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos - v.y * Sin;
  Result.y = v.x * Sin + v.y * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> orientation
 (
  tvec3<T, P> const & Normal,
  tvec3<T, P> const & Up
 )
 {
  if(all(equal(Normal, Up)))
   return tmat4x4<T, P>(T(1));

  tvec3<T, P> RotationAxis = cross(Up, Normal);
  T Angle = acos(dot(Normal, Up));

  return rotate(Angle, RotationAxis);
 }
}
# 117 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 2 3
# 98 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/spline.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/spline.hpp" 3
namespace glm
{





 template <typename genType>
               genType catmullRom(
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s);



 template <typename genType>
               genType hermite(
  genType const & v1,
  genType const & t1,
  genType const & v2,
  genType const & t2,
  typename genType::value_type const & s);



 template <typename genType>
               genType cubic(
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s);


}


# 1 "/usr/local/include/glm/./gtx/spline.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType catmullRom
 (
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s
 )
 {
  typename genType::value_type s1 = s;
  typename genType::value_type s2 = pow2(s);
  typename genType::value_type s3 = pow3(s);

  typename genType::value_type f1 = -s3 + typename genType::value_type(2) * s2 - s;
  typename genType::value_type f2 = typename genType::value_type(3) * s3 - typename genType::value_type(5) * s2 + typename genType::value_type(2);
  typename genType::value_type f3 = typename genType::value_type(-3) * s3 + typename genType::value_type(4) * s2 + s;
  typename genType::value_type f4 = s3 - s2;

  return (f1 * v1 + f2 * v2 + f3 * v3 + f4 * v4) / typename genType::value_type(2);

 }

 template <typename genType> inline
                    genType hermite
 (
  genType const & v1,
  genType const & t1,
  genType const & v2,
  genType const & t2,
  typename genType::value_type const & s
 )
 {
  typename genType::value_type s1 = s;
  typename genType::value_type s2 = pow2(s);
  typename genType::value_type s3 = pow3(s);

  typename genType::value_type f1 = typename genType::value_type(2) * s3 - typename genType::value_type(3) * s2 + typename genType::value_type(1);
  typename genType::value_type f2 = typename genType::value_type(-2) * s3 + typename genType::value_type(3) * s2;
  typename genType::value_type f3 = s3 - typename genType::value_type(2) * s2 + s;
  typename genType::value_type f4 = s3 - s2;

  return f1 * v1 + f2 * v2 + f3 * t1 + f4 * t2;
 }

 template <typename genType> inline
                    genType cubic
 (
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s
 )
 {
  return ((v1 * s + v2) * s + v3) * s + v4;
 }
}
# 61 "/usr/local/include/glm/./gtx/spline.hpp" 2 3
# 99 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/std_based_type.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/std_based_type.hpp" 3
namespace glm
{





 typedef tvec1<std::size_t, defaultp> size1;



 typedef tvec2<std::size_t, defaultp> size2;



 typedef tvec3<std::size_t, defaultp> size3;



 typedef tvec4<std::size_t, defaultp> size4;



 typedef tvec1<std::size_t, defaultp> size1_t;



 typedef tvec2<std::size_t, defaultp> size2_t;



 typedef tvec3<std::size_t, defaultp> size3_t;



 typedef tvec4<std::size_t, defaultp> size4_t;


}


# 1 "/usr/local/include/glm/./gtx/std_based_type.inl" 1 3



namespace glm
{

}
# 63 "/usr/local/include/glm/./gtx/std_based_type.hpp" 2 3
# 100 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/string_cast.hpp" 1 3
# 34 "/usr/local/include/glm/./gtx/string_cast.hpp" 3
namespace glm
{





 template <template <typename, precision> class matType, typename T, precision P>
               std::string to_string(matType<T, P> const & x);


}


# 1 "/usr/local/include/glm/./gtx/string_cast.inl" 1 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdarg" 1 3
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdarg" 3


namespace std {inline namespace __1 {

using ::va_list;

} }
# 4 "/usr/local/include/glm/./gtx/string_cast.inl" 2 3



namespace glm{
namespace detail
{ inline
                    std::string format(const char* msg, ...)
 {
  std::size_t const STRING_BUFFER(4096);
  char text[STRING_BUFFER];
  va_list list;

  if(msg == 0)
   return std::string();

  __builtin_va_start(list, msg);



   vsprintf(text, msg, list);

  __builtin_va_end(list);

  return std::string(text);
 }

 static const char* LabelTrue = "true";
 static const char* LabelFalse = "false";

 template <typename T, bool isFloat = false>
 struct literal
 { inline
                     static char const * value() {return "%d";};
 };

 template <typename T>
 struct literal<T, true>
 { inline
                     static char const * value() {return "%f";};
 };
# 59 "/usr/local/include/glm/./gtx/string_cast.inl" 3
 template <typename T>
 struct prefix{};

 template <>
 struct prefix<float>
 { inline
                     static char const * value() {return "";};
 };

 template <>
 struct prefix<double>
 { inline
                     static char const * value() {return "d";};
 };

 template <>
 struct prefix<bool>
 { inline
                     static char const * value() {return "b";};
 };

 template <>
 struct prefix<uint8_t>
 { inline
                     static char const * value() {return "u8";};
 };

 template <>
 struct prefix<int8_t>
 { inline
                     static char const * value() {return "i8";};
 };

 template <>
 struct prefix<uint16_t>
 { inline
                     static char const * value() {return "u16";};
 };

 template <>
 struct prefix<int16_t>
 { inline
                     static char const * value() {return "i16";};
 };

 template <>
 struct prefix<uint32_t>
 { inline
                     static char const * value() {return "u";};
 };

 template <>
 struct prefix<int32_t>
 { inline
                     static char const * value() {return "i";};
 };

 template <>
 struct prefix<uint64_t>
 { inline
                     static char const * value() {return "u64";};
 };

 template <>
 struct prefix<int64_t>
 { inline
                     static char const * value() {return "i64";};
 };

 template <template <typename, precision> class matType, typename T, precision P>
 struct compute_to_string
 {};

 template <precision P>
 struct compute_to_string<tvec1, bool, P>
 { inline
                     static std::string call(tvec1<bool, P> const & x)
  {
   return detail::format("bvec1(%s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <precision P>
 struct compute_to_string<tvec2, bool, P>
 { inline
                     static std::string call(tvec2<bool, P> const & x)
  {
   return detail::format("bvec2(%s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <precision P>
 struct compute_to_string<tvec3, bool, P>
 { inline
                     static std::string call(tvec3<bool, P> const & x)
  {
   return detail::format("bvec3(%s, %s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse,
    x[2] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <precision P>
 struct compute_to_string<tvec4, bool, P>
 { inline
                     static std::string call(tvec4<bool, P> const & x)
  {
   return detail::format("bvec4(%s, %s, %s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse,
    x[2] ? detail::LabelTrue : detail::LabelFalse,
    x[3] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec1, T, P>
 { inline
                     static std::string call(tvec1<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec1(%s)",
    PrefixStr,
    LiteralStr));

   return detail::format(FormatStr.c_str(), x[0]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec2, T, P>
 { inline
                     static std::string call(tvec2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec2(%s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec3, T, P>
 { inline
                     static std::string call(tvec3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec3(%s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1], x[2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec4, T, P>
 { inline
                     static std::string call(tvec4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec4(%s, %s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1], x[2], x[3]);
  }
 };


 template <typename T, precision P>
 struct compute_to_string<tmat2x2, T, P>
 { inline
                     static std::string call(tmat2x2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x2((%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1],
    x[1][0], x[1][1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat2x3, T, P>
 { inline
                     static std::string call(tmat2x3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x3((%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2],
    x[1][0], x[1][1], x[1][2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat2x4, T, P>
 { inline
                     static std::string call(tmat2x4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x4((%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2], x[0][3],
    x[1][0], x[1][1], x[1][2], x[1][3]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat3x2, T, P>
 { inline
                     static std::string call(tmat3x2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x2((%s, %s), (%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1],
    x[1][0], x[1][1],
    x[2][0], x[2][1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat3x3, T, P>
 { inline
                     static std::string call(tmat3x3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2],
    x[1][0], x[1][1], x[1][2],
    x[2][0], x[2][1], x[2][2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat3x4, T, P>
 { inline
                     static std::string call(tmat3x4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2], x[0][3],
    x[1][0], x[1][1], x[1][2], x[1][3],
    x[2][0], x[2][1], x[2][2], x[2][3]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat4x2, T, P>
 { inline
                     static std::string call(tmat4x2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x2((%s, %s), (%s, %s), (%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1],
    x[1][0], x[1][1],
    x[2][0], x[2][1],
    x[3][0], x[3][1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat4x3, T, P>
 { inline
                     static std::string call(tmat4x3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2],
    x[1][0], x[1][1], x[1][2],
    x[2][0], x[2][1], x[2][2],
    x[3][0], x[3][1], x[3][2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat4x4, T, P>
 { inline
                     static std::string call(tmat4x4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2], x[0][3],
    x[1][0], x[1][1], x[1][2], x[1][3],
    x[2][0], x[2][1], x[2][2], x[2][3],
    x[3][0], x[3][1], x[3][2], x[3][3]);
  }
 };


 template <typename T, precision P>
 struct compute_to_string<tquat, T, P>
 { inline
                     static std::string call(tquat<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%squat(%s, %s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1], x[2], x[3]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tdualquat, T, P>
 { inline
                     static std::string call(tdualquat<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%sdualquat((%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x.real[0], x.real[1], x.real[2], x.real[3], x.dual[0], x.dual[1], x.dual[2], x.dual[3]);
  }
 };

}

template <template <typename, precision> class matType, typename T, precision P> inline
                   std::string to_string(matType<T, P> const & x)
{
 return detail::compute_to_string<matType, T, P>::call(x);
}

}
# 47 "/usr/local/include/glm/./gtx/string_cast.hpp" 2 3
# 102 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtx/transform2.hpp" 1 3
# 24 "/usr/local/include/glm/./gtx/transform2.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat3x3<T, P> shearX2D(
  tmat3x3<T, P> const & m,
  T y);



 template <typename T, precision P>
               tmat3x3<T, P> shearY2D(
  tmat3x3<T, P> const & m,
  T x);



 template <typename T, precision P>
               tmat4x4<T, P> shearX3D(
  const tmat4x4<T, P> & m,
  T y,
  T z);



 template <typename T, precision P>
               tmat4x4<T, P> shearY3D(
  const tmat4x4<T, P> & m,
  T x,
  T z);



 template <typename T, precision P>
               tmat4x4<T, P> shearZ3D(
  const tmat4x4<T, P> & m,
  T x,
  T y);
# 77 "/usr/local/include/glm/./gtx/transform2.hpp" 3
 template <typename T, precision P>
               tmat3x3<T, P> proj2D(
  const tmat3x3<T, P> & m,
  const tvec3<T, P>& normal);



 template <typename T, precision P>
               tmat4x4<T, P> proj3D(
  const tmat4x4<T, P> & m,
  const tvec3<T, P>& normal);



 template <typename valType, precision P>
               tmat4x4<valType, P> scaleBias(
  valType scale,
  valType bias);



 template <typename valType, precision P>
               tmat4x4<valType, P> scaleBias(
  tmat4x4<valType, P> const & m,
  valType scale,
  valType bias);


}


# 1 "/usr/local/include/glm/./gtx/transform2.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> shearX2D(tmat3x3<T, P> const& m, T s)
 {
  tmat3x3<T, P> r(1);
  r[1][0] = s;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> shearY2D(tmat3x3<T, P> const& m, T s)
 {
  tmat3x3<T, P> r(1);
  r[0][1] = s;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> shearX3D(tmat4x4<T, P> const& m, T s, T t)
 {
  tmat4x4<T, P> r(1);
  r[0][1] = s;
  r[0][2] = t;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> shearY3D(tmat4x4<T, P> const& m, T s, T t)
 {
  tmat4x4<T, P> r(1);
  r[1][0] = s;
  r[1][2] = t;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> shearZ3D(tmat4x4<T, P> const& m, T s, T t)
 {
  tmat4x4<T, P> r(1);
  r[2][0] = s;
  r[2][1] = t;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> reflect2D(tmat3x3<T, P> const& m, tvec3<T, P> const& normal)
 {
  tmat3x3<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - static_cast<T>(2) * normal.x * normal.x;
  r[0][1] = -static_cast<T>(2) * normal.x * normal.y;
  r[1][0] = -static_cast<T>(2) * normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - static_cast<T>(2) * normal.y * normal.y;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> reflect3D(tmat4x4<T, P> const& m, tvec3<T, P> const& normal)
 {
  tmat4x4<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - static_cast<T>(2) * normal.x * normal.x;
  r[0][1] = -static_cast<T>(2) * normal.x * normal.y;
  r[0][2] = -static_cast<T>(2) * normal.x * normal.z;

  r[1][0] = -static_cast<T>(2) * normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - static_cast<T>(2) * normal.y * normal.y;
  r[1][2] = -static_cast<T>(2) * normal.y * normal.z;

  r[2][0] = -static_cast<T>(2) * normal.x * normal.z;
  r[2][1] = -static_cast<T>(2) * normal.y * normal.z;
  r[2][2] = static_cast<T>(1) - static_cast<T>(2) * normal.z * normal.z;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> proj2D(
  const tmat3x3<T, P>& m,
  const tvec3<T, P>& normal)
 {
  tmat3x3<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - normal.x * normal.x;
  r[0][1] = - normal.x * normal.y;
  r[1][0] = - normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - normal.y * normal.y;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> proj3D(
  const tmat4x4<T, P>& m,
  const tvec3<T, P>& normal)
 {
  tmat4x4<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - normal.x * normal.x;
  r[0][1] = - normal.x * normal.y;
  r[0][2] = - normal.x * normal.z;
  r[1][0] = - normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - normal.y * normal.y;
  r[1][2] = - normal.y * normal.z;
  r[2][0] = - normal.x * normal.z;
  r[2][1] = - normal.y * normal.z;
  r[2][2] = static_cast<T>(1) - normal.z * normal.z;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scaleBias(T scale, T bias)
 {
  tmat4x4<T, P> result;
  result[3] = tvec4<T, P>(tvec3<T, P>(bias), static_cast<T>(1));
  result[0][0] = scale;
  result[1][1] = scale;
  result[2][2] = scale;
  return result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scaleBias(tmat4x4<T, P> const& m, T scale, T bias)
 {
  return m * scaleBias(scale, bias);
 }
}
# 107 "/usr/local/include/glm/./gtx/transform2.hpp" 2 3
# 105 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/vector_angle.hpp" 1 3
# 27 "/usr/local/include/glm/./gtx/vector_angle.hpp" 3
namespace glm
{






 template <typename vecType>
               typename vecType::value_type angle(
  vecType const & x,
  vecType const & y);




 template <typename T, precision P>
               T orientedAngle(
  tvec2<T, P> const & x,
  tvec2<T, P> const & y);




 template <typename T, precision P>
               T orientedAngle(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  tvec3<T, P> const & ref);


}


# 1 "/usr/local/include/glm/./gtx/vector_angle.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType angle
 (
  genType const & x,
  genType const & y
 )
 {
                                                                                                         ;
  return acos(clamp(dot(x, y), genType(-1), genType(1)));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T angle
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
                                                                                                   ;
  return acos(clamp(dot(x, y), T(-1), T(1)));
 }


 template <typename T, precision P> inline
                    T orientedAngle
 (
  tvec2<T, P> const & x,
  tvec2<T, P> const & y
 )
 {
                                                                                                           ;
  T const Angle(acos(clamp(dot(x, y), T(-1), T(1))));

  if(all(epsilonEqual(y, glm::rotate(x, Angle), T(0.0001))))
   return Angle;
  else
   return -Angle;
 }

 template <typename T, precision P> inline
                    T orientedAngle
 (
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  tvec3<T, P> const & ref
 )
 {
                                                                                                           ;

  T const Angle(acos(clamp(dot(x, y), T(-1), T(1))));
  return mix(Angle, -Angle, dot(ref, cross(x, y)) < T(0));
 }
}
# 60 "/usr/local/include/glm/./gtx/vector_angle.hpp" 2 3
# 106 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/wrap.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/wrap.hpp" 3
namespace glm
{





 template <typename genType>
               genType clamp(genType const& Texcoord);



 template <typename genType>
               genType repeat(genType const& Texcoord);



 template <typename genType>
               genType mirrorClamp(genType const& Texcoord);



 template <typename genType>
               genType mirrorRepeat(genType const& Texcoord);


}


# 1 "/usr/local/include/glm/./gtx/wrap.inl" 1 3



namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> clamp(vecType<T, P> const& Texcoord)
 {
  return glm::clamp(Texcoord, vecType<T, P>(0), vecType<T, P>(1));
 }

 template <typename genType> inline
                    genType clamp(genType const & Texcoord)
 {
  return clamp(tvec1<genType, defaultp>(Texcoord)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> repeat(vecType<T, P> const& Texcoord)
 {
  return glm::fract(Texcoord);
 }

 template <typename genType> inline
                    genType repeat(genType const & Texcoord)
 {
  return repeat(tvec1<genType, defaultp>(Texcoord)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mirrorClamp(vecType<T, P> const& Texcoord)
 {
  return glm::fract(glm::abs(Texcoord));
 }

 template <typename genType> inline
                    genType mirrorClamp(genType const & Texcoord)
 {
  return mirrorClamp(tvec1<genType, defaultp>(Texcoord)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mirrorRepeat(vecType<T, P> const& Texcoord)
 {
  vecType<T, P> const Abs = glm::abs(Texcoord);
  vecType<T, P> const Clamp = glm::mod(glm::floor(Abs), vecType<T, P>(2));
  vecType<T, P> const Floor = glm::floor(Abs);
  vecType<T, P> const Rest = Abs - Floor;
  vecType<T, P> const Mirror = Clamp + Rest;
  return mix(Rest, vecType<T, P>(1) - Rest, glm::greaterThanEqual(Mirror, vecType<T, P>(1)));
 }

 template <typename genType> inline
                    genType mirrorRepeat(genType const& Texcoord)
 {
  return mirrorRepeat(tvec1<genType, defaultp>(Texcoord)).x;
 }
}
# 51 "/usr/local/include/glm/./gtx/wrap.hpp" 2 3
# 108 "/usr/local/include/glm/ext.hpp" 2 3
# 16 "./common_utils_cpp.hpp" 2



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 1 3
# 118 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 1 3
# 17 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 2 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 3


namespace std {inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator ~() const throw()
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(bool __x) throw()
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(const __bit_reference& __x) throw()
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false> operator&() const throw()
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, bool& __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(bool& __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) throw()
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, true> operator&() const throw()
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))

    __bit_const_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference& __x);
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return _It(__first.__seg_, __first.__ctz_ + __n);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return _It(__first.__seg_, __first.__ctz_ + __n);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            __fill_n_true(__first, __n);
        else
            __fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return __copy_aligned(__first, __last, __result);
    return __copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return __copy_backward_aligned(__first, __last, __result);
    return __copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __swap_ranges_aligned(__first1, __last1, __first2);
    return __swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __equal_aligned(__first1, __last1, __first2);
    return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator() throw()



    {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) throw()
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) throw()
        : __seg_(__s), __ctz_(__ctz) {}


    friend typename _Cp::__self;



    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 2 3
# 132 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 133 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 2 3

namespace std {inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const throw();
    bool any() const throw();
    size_t __hash_code() const throw();
private:

    void __init(unsigned long long __v, false_type) throw();
    void __init(unsigned long long __v, true_type) throw();

    unsigned long to_ulong(false_type) const;
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    unsigned long long to_ullong(true_type) const;
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset() throw()



{

    std::__1::fill_n(__first_, _N_words, __storage_type(0));

}



template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) throw()
{
    __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
    for (size_t __i = 0; __i < sizeof(__t)/sizeof(__t[0]); ++__i, __v >>= __bits_per_word)
        __t[__i] = static_cast<__storage_type>(__v);
    std::__1::copy(__t, __t + sizeof(__t)/sizeof(__t[0]), __first_);
    std::__1::fill(__first_ + sizeof(__t)/sizeof(__t[0]), __first_ + sizeof(__first_)/sizeof(__first_[0]),
               __storage_type(0));
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, true_type) throw()
{
    __first_[0] = __v;
    std::__1::fill(__first_ + 1, __first_ + sizeof(__first_)/sizeof(__first_[0]), __storage_type(0));
}



template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset(unsigned long long __v) throw()
# 260 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 3
{

    __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());

}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() throw()
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)

        throw overflow_error("bitset to_ulong overflow error");



    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)

        throw overflow_error("bitset to_ullong overflow error");



    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<_N_words, _Size>::__hash_code() const throw()
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();

    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;

    bool all() const throw();
    bool any() const throw();

    size_t __hash_code() const throw();
};

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset() throw()
    : __first_(0)
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset(unsigned long long __v) throw()
    : __first_(static_cast<__storage_type>(__v))
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator&=(const __bitset& __v) throw()
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator|=(const __bitset& __v) throw()
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator^=(const __bitset& __v) throw()
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::flip() throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::all() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::any() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<1, _Size>::__hash_code() const throw()
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t) throw()
        {return reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t) const throw()
        {return const_reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t) throw()
        {return iterator(0, 0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t) const throw()
        {return const_iterator(0, 0);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator&=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator|=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator^=(const __bitset&) throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool all() const throw() {return true;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool any() const throw() {return false;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t __hash_code() const throw() {return 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset() throw()
{
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset(unsigned long long) throw()
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) bitset() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        bitset(unsigned long long __v) throw() : base(__v) {}
    template<class _CharT>
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    bitset& operator&=(const bitset& __rhs) throw();
    bitset& operator|=(const bitset& __rhs) throw();
    bitset& operator^=(const bitset& __rhs) throw();
    bitset& operator<<=(size_t __pos) throw();
    bitset& operator>>=(size_t __pos) throw();
    bitset& set() throw();
    bitset& set(size_t __pos, bool __val = true);
    bitset& reset() throw();
    bitset& reset(size_t __pos);
    bitset operator~() const throw();
    bitset& flip() throw();
    bitset& flip(size_t __pos);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    size_t count() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t size() const throw() {return _Size;}
    bool operator==(const bitset& __rhs) const throw();
    bool operator!=(const bitset& __rhs) const throw();
    bool test(size_t __pos) const;
    bool all() const throw();
    bool any() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool none() const throw() {return !any();}
    bitset operator<<(size_t __pos) const throw();
    bitset operator>>(size_t __pos) const throw();

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t __hash_code() const throw() {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)

            throw invalid_argument("bitset string ctor has invalid argument");



    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())

        throw out_of_range("bitset string pos out of range");



    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))

            throw invalid_argument("bitset string ctor has invalid argument");



    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) throw()
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) throw()
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) throw()
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::set() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)

        throw out_of_range("bitset set argument out of range");



    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::reset() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)

        throw out_of_range("bitset reset argument out of range");



    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator~() const throw()
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::flip() throw()
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)

        throw out_of_range("bitset flip argument out of range");



    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
bitset<_Size>::count() const throw()
{
    return static_cast<size_t>(std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator==(const bitset& __rhs) const throw()
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator!=(const bitset& __rhs) const throw()
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)

        throw out_of_range("bitset test argument out of range");



    return (*this)[__pos];
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::all() const throw()
{
    return base::all();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::any() const throw()
{
    return base::any();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const throw()
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const throw()
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const bitset<_Size>& __bs) const throw()
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 20 "./common_utils_cpp.hpp" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 1 3
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 1 3
# 216 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 1 3
# 176 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 1 3
# 15 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 1 3
# 281 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 1 3
# 73 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 74 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 2 3
# 77 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3


namespace std {inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp <= max - _Yp)>)> __t130;
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(min - _Yp <= _Xp)>)> __t148;
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(min + _Yp <= _Xp)>)> __t162;
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp <= max + _Yp)>)> __t180;
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp != nan && _Yp != nan && __a_x <= max / __a_y)>)> __t194;
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp != nan && _Yp != nan && _Yp != 0)>)> __t228;
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    typedef __static_assert_check<sizeof(__static_assert_test<(__static_abs<_Num>::value >= 0)>)> __t236;
    typedef __static_assert_check<sizeof(__static_assert_test<(_Den != 0)>)> __t237;
    typedef __static_assert_check<sizeof(__static_assert_test<(__static_abs<_Den>::value > 0)>)> __t238;
    static const intmax_t __na = __static_abs<_Num>::value;
    static const intmax_t __da = __static_abs<_Den>::value;
    static const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static const intmax_t num = __s * __na / __gcd;
    static const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den> const intmax_t ratio<_Num, _Den>::num;
template <intmax_t _Num, intmax_t _Den> const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};
# 294 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_multiply
    : public __ratio_multiply<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};
# 321 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_divide
    : public __ratio_divide<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
# 356 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_add
    : public __ratio_add<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
# 391 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_subtract
    : public __ratio_subtract<_R1, _R2>::type {};





template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public integral_constant<bool, _R1::num == _R2::num && _R1::den == _R2::den> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public integral_constant<bool, !ratio_equal<_R1, _R2>::value> {};



template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public integral_constant<bool, __ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public integral_constant<bool, !ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public integral_constant<bool, ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public integral_constant<bool, !ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};

} }
# 282 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 285 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3
# 288 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3


namespace std {inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep zero() {return _Rep(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep max() {return numeric_limits<_Rep>::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep min() {return numeric_limits<_Rep>::lowest();}
};



template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    typedef __static_assert_check<sizeof(__static_assert_test<(!__is_duration<_Rep>::value)>)> __t409;
    typedef __static_assert_check<sizeof(__static_assert_test<(__is_ratio<_Period>::value)>)> __t410;
    typedef __static_assert_check<sizeof(__static_assert_test<(_Period::num > 0)>)> __t411;

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef _Period period;
private:
    rep __rep_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))



        duration() {}


    template <class _Rep2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = 0)
                : __rep_(__r) {}


    template <class _Rep2, class _Period2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = 0)
                : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) rep count() const {return __rep_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator+() const {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator-() const {return duration(-__rep_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration zero() {return duration(duration_values<rep>::zero());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration min() {return duration(duration_values<rep>::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration max() {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;



template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}



template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
struct __duration_divide_result
{
};

template <class _Duration, class _Rep2,
    bool = is_convertible<_Rep2,
                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>
struct __duration_divide_imp
{
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>
{
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>
{
};

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}





template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    typedef __static_assert_check<sizeof(__static_assert_test<(__is_duration<_Duration>::value)>)> __t753;

public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point() : __d_(duration::zero()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit time_point(const duration& __d) : __d_(__d) {}


    template <class _Duration2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = 0)
            : __d_(t.time_since_epoch()) {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration time_since_epoch() const {return __d_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) static time_point min() {return time_point(duration::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static time_point max() {return time_point(duration::max());}
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __lhs + (-__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class __attribute__ ((__type_visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady = false;

    static time_point now() throw();
    static time_t to_time_t (const time_point& __t) throw();
    static time_point from_time_t(time_t __t) throw();
};

class __attribute__ ((__type_visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static const bool is_steady = true;

    static time_point now() throw();
};

typedef steady_clock high_resolution_clock;

}
# 1025 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
} }
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 1 3
# 229 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 3


namespace std {inline namespace __1 {



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};





struct __attribute__ ((__type_visibility__("default"))) errc { enum __lx
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) errc(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc::__lx>
    : true_type { };


class __attribute__ ((__type_visibility__("default"))) error_condition;
class __attribute__ ((__type_visibility__("default"))) error_code;



class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__type_visibility__("default"))) error_category
{
public:
    virtual ~error_category() throw();




    __attribute__ ((__visibility__("hidden"), __always_inline__))
                                  error_category() throw() {};

private:
    error_category(const error_category&);
    error_category& operator=(const error_category&);

public:
    virtual const char* name() const throw() = 0;
    virtual error_condition default_error_condition(int __ev) const throw();
    virtual bool equivalent(int __code, const error_condition& __condition) const throw();
    virtual bool equivalent(const error_code& __code, int __condition) const throw();
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const error_category& __rhs) const throw() {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const error_category& __rhs) const throw() {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator< (const error_category& __rhs) const throw() {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() throw();
__attribute__ ((__visibility__("default"))) const error_category& system_category() throw();

class __attribute__ ((__type_visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition() throw() : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition(int __val, const error_category& __cat) throw()
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = 0
                                                                     ) throw()
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) throw()
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) throw()
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const throw() {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const throw() {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(errc __e) throw()
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_condition& __x, const error_condition& __y) throw()
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}



class __attribute__ ((__type_visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code() throw() : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code(int __val, const error_category& __cat) throw()
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0
                                                                     ) throw()
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) throw()
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) throw()
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const throw() {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const throw() {return *__cat_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition default_error_condition() const throw()
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(errc __e) throw()
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_code& __x, const error_code& __y) throw()
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_code& __y) throw()
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_condition& __y) throw()
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_code& __y) throw()
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_condition& __y) throw()
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_code& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_condition& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_code& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_condition& __y) throw()
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const error_code& __ec) const throw()
    {
        return static_cast<size_t>(__ec.value());
    }
};



class __attribute__ ((__type_visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    ~system_error() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_code& code() const throw() {return __ec_;}

private:
    static string __init(const error_code&, string);
};

__attribute__ ((__visibility__("default"))) void __throw_system_error(int ev, const char* what_arg);

} }
# 17 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 1 "/usr/include/pthread.h" 1 3 4
# 57 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/pthread_impl.h" 1 3 4
# 58 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/sched.h" 1 3 4
# 30 "/usr/include/sched.h" 3 4
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/sys/_types/_pthread_cond_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 63 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_condattr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 64 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_key_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 65 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_mutex_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 66 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_mutexattr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 67 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_once_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 68 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_rwlock_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 69 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_rwlockattr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 70 "/usr/include/pthread.h" 2 3 4




# 1 "/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 49 "/usr/include/sys/_types/_mach_port_t.h" 3 4
typedef __darwin_mach_port_t mach_port_t;
# 75 "/usr/include/pthread.h" 2 3 4
# 102 "/usr/include/pthread.h" 3 4
extern "C" {
# 206 "/usr/include/pthread.h" 3 4
__attribute__((availability(macosx,introduced=10.4)))
int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getscope(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstack(const pthread_attr_t * , void ** ,
  size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstackaddr(const pthread_attr_t * , void ** );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_init(pthread_cond_t * ,
  const pthread_condattr_t * ) __asm("_" "pthread_cond_init") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_timedwait(pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * ) __asm("_" "pthread_cond_timedwait") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm("_" "pthread_cond_wait") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_create(pthread_t * , const pthread_attr_t * ,
  void *(*)(void *), void * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_detach(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_equal(pthread_t, pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
void pthread_exit(void *) __attribute__((noreturn));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_getconcurrency(void);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_getschedparam(pthread_t , int * ,
  struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
void* pthread_getspecific(pthread_key_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_join(pthread_t , void **) __asm("_" "pthread_join") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_key_create(pthread_key_t *, void (*)(void *));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_key_delete(pthread_key_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_once(pthread_once_t *, void (*)(void));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
pthread_t pthread_self(void);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setconcurrency(int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setspecific(pthread_key_t , const void *);

__attribute__((availability(macosx,introduced=10.4)))
void pthread_testcancel(void) __asm("_" "pthread_testcancel") ;




__attribute__((availability(macosx,introduced=10.4)))
int pthread_is_threaded_np(void);

__attribute__((availability(macosx,introduced=10.6)))
int pthread_threadid_np(pthread_t,__uint64_t*);


__attribute__((availability(macosx,introduced=10.6)))
int pthread_getname_np(pthread_t,char*,size_t);

__attribute__((availability(macosx,introduced=10.6)))
int pthread_setname_np(const char*);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_main_np(void);


__attribute__((availability(macosx,introduced=10.4)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
void* pthread_get_stackaddr_np(pthread_t);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec *);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_create_suspended_np(pthread_t *, const pthread_attr_t *,
  void *(*)(void *), void *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_kill(pthread_t, int);

__attribute__((availability(macosx,introduced=10.5)))
pthread_t pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask") ;

__attribute__((availability(macosx,introduced=10.4)))
void pthread_yield_np(void);


}
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) mutex
{
    pthread_mutex_t __m_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))



     mutex() throw() {__m_ = (pthread_mutex_t){0x32AAABA7, {0}};}

     ~mutex();

private:
    mutex(const mutex&);
    mutex& operator=(const mutex&);

public:
    void lock();
    bool try_lock() throw();
    void unlock() throw();

    typedef pthread_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__m_;}
};

struct __attribute__ ((__type_visibility__("default"))) defer_lock_t {};
struct __attribute__ ((__type_visibility__("default"))) try_to_lock_t {};
struct __attribute__ ((__type_visibility__("default"))) adopt_lock_t {};



extern const defer_lock_t defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t adopt_lock;
# 69 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type& __m_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit lock_guard(mutex_type& __m)
        : __m_(__m) {__m_.lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    lock_guard(mutex_type& __m, adopt_lock_t)
        : __m_(__m) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~lock_guard() {__m_.unlock();}

private:
    lock_guard(lock_guard const&);
    lock_guard& operator=(lock_guard const&);
};

template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock() throw() : __m_(std::__1::__get_nullptr_t()), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unique_lock(mutex_type& __m)
        : __m_(&__m), __owns_(true) {__m_->lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, defer_lock_t) throw()
        : __m_(&__m), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, try_to_lock_t)
        : __m_(&__m), __owns_(__m.try_lock()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, adopt_lock_t)
        : __m_(&__m), __owns_(true) {}
    template <class _Clock, class _Duration>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
            : __m_(&__m), __owns_(__m.try_lock_until(__t)) {}
    template <class _Rep, class _Period>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
            : __m_(&__m), __owns_(__m.try_lock_for(__d)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~unique_lock()
    {
        if (__owns_)
            __m_->unlock();
    }

private:
    unique_lock(unique_lock const&);
    unique_lock& operator=(unique_lock const&);

public:
# 157 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
    void lock();
    bool try_lock();

    template <class _Rep, class _Period>
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);

    void unlock();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(unique_lock& __u) throw()
    {
        std::__1::swap(__m_, __u.__m_);
        std::__1::swap(__owns_, __u.__owns_);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* release() throw()
    {
        mutex_type* __m = __m_;
        __m_ = std::__1::__get_nullptr_t();
        __owns_ = false;
        return __m;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool owns_lock() const throw() {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool () const throw() {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* mutex() const throw() {return __m_;}
};

template <class _Mutex>
void
unique_lock<_Mutex>::lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::lock: already locked");
    __m_->lock();
    __owns_ = true;
}

template <class _Mutex>
bool
unique_lock<_Mutex>::try_lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock: already locked");
    __owns_ = __m_->try_lock();
    return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool
unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_for(__d);
    return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool
unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_until(__t);
    return __owns_;
}

template <class _Mutex>
void
unique_lock<_Mutex>::unlock()
{
    if (!__owns_)
        __throw_system_error(1, "unique_lock::unlock: not locked");
    __m_->unlock();
    __owns_ = false;
}

template <class _Mutex>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) throw()
    {__x.swap(__y);}


struct __attribute__ ((__type_visibility__("default"))) cv_status { enum __lx
{
    no_timeout,
    timeout
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) cv_status(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit cv_status(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

class __attribute__ ((__type_visibility__("default"))) condition_variable
{
    pthread_cond_t __cv_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))



    condition_variable() {__cv_ = (pthread_cond_t){0x3CB0B1BB, {0}};}

    ~condition_variable();

private:
    condition_variable(const condition_variable&);
    condition_variable& operator=(const condition_variable&);

public:
    void notify_one() throw();
    void notify_all() throw();

    void wait(unique_lock<mutex>& __lk);
    template <class _Predicate>
        void wait(unique_lock<mutex>& __lk, _Predicate __pred);

    template <class _Clock, class _Duration>
        cv_status
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t);

    template <class _Clock, class _Duration, class _Predicate>
        bool
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred);

    template <class _Rep, class _Period>
        cv_status
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d);

    template <class _Rep, class _Period, class _Predicate>
        bool
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d,
                 _Predicate __pred);

    typedef pthread_cond_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__cv_;}

private:
    void __do_timed_wait(unique_lock<mutex>& __lk,
                 chrono::time_point<chrono::system_clock, chrono::nanoseconds>);
};

template <class _To, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    chrono::__is_duration<_To>::value,
    _To
>::type
__ceil(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    _To __r = duration_cast<_To>(__d);
    if (__r < __d)
        ++__r;
    return __r;
}

template <class _Predicate>
void
condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)
{
    while (!__pred())
        wait(__lk);
}

template <class _Clock, class _Duration>
cv_status
condition_variable::wait_until(unique_lock<mutex>& __lk,
                               const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    wait_for(__lk, __t - _Clock::now());
    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool
condition_variable::wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred)
{
    while (!__pred())
    {
        if (wait_until(__lk, __t) == cv_status::timeout)
            return __pred();
    }
    return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d)
{
    using namespace chrono;
    if (__d <= __d.zero())
        return cv_status::timeout;
    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;
    typedef time_point<system_clock, nanoseconds> __sys_tpi;
    __sys_tpf _Max = __sys_tpi::max();
    system_clock::time_point __s_now = system_clock::now();
    steady_clock::time_point __c_now = steady_clock::now();
    if (_Max - __d > __s_now)
        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
    else
        __do_timed_wait(__lk, __sys_tpi::max());
    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :
                                                 cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d,
                             _Predicate __pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}

} }
# 177 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 1 3
# 484 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3


namespace std {inline namespace __1 {




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};
# 516 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};
# 541 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};
# 566 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};
# 591 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};
# 616 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};
# 641 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};
# 666 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};
# 691 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};
# 718 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};
# 743 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};
# 768 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};
# 793 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};
# 818 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};
# 843 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};
# 868 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};
# 893 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};
# 935 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_03" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_03" 3


template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __mem_fn(type __f) : __f_(__f) {}



    typename __invoke_return<type>::type
       operator() ()
       {
           return __invoke(__f_);
       }

    template <class _A0>
       typename __invoke_return0<type, _A0>::type
          operator() (_A0& __a0)
          {
              return __invoke(__f_, __a0);
          }

    template <class _A0, class _A1>
       typename __invoke_return1<type, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1)
          {
              return __invoke(__f_, __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       typename __invoke_return2<type, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          {
              return __invoke(__f_, __a0, __a1, __a2);
          }
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm)
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)()>
mem_fn(_Rp (_Tp::* __pm)())
{
    return __mem_fn<_Rp (_Tp::*)()>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0)>
mem_fn(_Rp (_Tp::* __pm)(_A0))
{
    return __mem_fn<_Rp (_Tp::*)(_A0)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const>
mem_fn(_Rp (_Tp::* __pm)() const)
{
    return __mem_fn<_Rp (_Tp::*)() const>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const>
mem_fn(_Rp (_Tp::* __pm)(_A0) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() volatile>
mem_fn(_Rp (_Tp::* __pm)() volatile)
{
    return __mem_fn<_Rp (_Tp::*)() volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const volatile>
mem_fn(_Rp (_Tp::* __pm)() const volatile)
{
    return __mem_fn<_Rp (_Tp::*)() const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>(__pm);
}



class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{
};

template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function;

namespace __function
{

template<class _Fp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Fp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template<class _Fp> class __base;

template<class _Rp>
class __base<_Rp()>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()() = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0>
class __base<_Rp(_A0)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0, class _A1>
class __base<_Rp(_A0, _A1)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0, class _A1, class _A2>
class __base<_Rp(_A0, _A1, _A2)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1, _A2) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp>
class __func<_Fp, _Alloc, _Rp()>
    : public __base<_Rp()>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    explicit __func(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp()>* __clone() const;
    virtual void __clone(__base<_Rp()>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()();

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp>
__base<_Rp()>*
__func<_Fp, _Alloc, _Rp()>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::__clone(__base<_Rp()>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp>
_Rp
__func<_Fp, _Alloc, _Rp()>::operator()()
{
    return __invoke(__f_.first());
}



template<class _Fp, class _Alloc, class _Rp>
const void*
__func<_Fp, _Alloc, _Rp()>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp>
const std::type_info&
__func<_Fp, _Alloc, _Rp()>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0>
class __func<_Fp, _Alloc, _Rp(_A0)>
    : public __base<_Rp(_A0)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0>
__base<_Rp(_A0)>*
__func<_Fp, _Alloc, _Rp(_A0)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::__clone(__base<_Rp(_A0)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
_Rp
__func<_Fp, _Alloc, _Rp(_A0)>::operator()(_A0 __a0)
{
    return __invoke(__f_.first(), __a0);
}



template<class _Fp, class _Alloc, class _Rp, class _A0>
const void*
__func<_Fp, _Alloc, _Rp(_A0)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0)>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
class __func<_Fp, _Alloc, _Rp(_A0, _A1)>
    : public __base<_Rp(_A0, _A1)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
__base<_Rp(_A0, _A1)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone(__base<_Rp(_A0, _A1)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1)
{
    return __invoke(__f_.first(), __a0, __a1);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
const void*
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
class __func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>
    : public __base<_Rp(_A0, _A1, _A2)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1, _A2)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1, _A2)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1, _A2);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
__base<_Rp(_A0, _A1, _A2)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone(__base<_Rp(_A0, _A1, _A2)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2)
{
    return __invoke(__f_.first(), __a0, __a1, __a2);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
const void*
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::target_type() const
{
    return typeid(_Fp);
}



}

template<class _Rp>
class __attribute__ ((__type_visibility__("default"))) function<_Rp()>
{
    typedef __function::__base<_Rp()> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2>
        static bool __not_null(const function<_Rp()>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2>
      bool operator==(const function<_R2()>&) const;
    template<class _R2>
      bool operator!=(const function<_R2()>&) const;
public:

    _Rp operator()() const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp>
function<_Rp()>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template<class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template <class _Fp>
function<_Rp()>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
template <class _Fp, class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp()>&
>::type
function<_Rp()>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp>
void
function<_Rp()>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp>
_Rp
function<_Rp()>::operator()() const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)();
}



template<class _Rp>
const std::type_info&
function<_Rp()>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp>
template <typename _Tp>
_Tp*
function<_Rp()>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp>
template <typename _Tp>
const _Tp*
function<_Rp()>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0)>
    : public unary_function<_A0, _Rp>
{
    typedef __function::__base<_Rp(_A0)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0)) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)()) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() volatile) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const volatile) {return __p;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_Rp(_B0)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2, class _B0>
      bool operator==(const function<_R2(_B0)>&) const;
    template<class _R2, class _B0>
      bool operator!=(const function<_R2(_B0)>&) const;
public:

    _Rp operator()(_A0) const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0>
function<_Rp(_A0)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template<class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template <class _Fp>
function<_Rp(_A0)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
template <class _Fp, class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0)>&
>::type
function<_Rp(_A0)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0>
void
function<_Rp(_A0)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0>
_Rp
function<_Rp(_A0)>::operator()(_A0 __a0) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0);
}



template<class _Rp, class _A0>
const std::type_info&
function<_Rp(_A0)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0>
template <typename _Tp>
_Tp*
function<_Rp(_A0)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0>
template <typename _Tp>
const _Tp*
function<_Rp(_A0)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1)>
    : public binary_function<_A0, _A1, _Rp>
{
    typedef __function::__base<_Rp(_A0, _A1)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_Rp(_B0, _B1)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    operator bool() const {return __f_;}

private:

    template<class _R2, class _B0, class _B1>
      bool operator==(const function<_R2(_B0, _B1)>&) const;
    template<class _R2, class _B0, class _B1>
      bool operator!=(const function<_R2(_B0, _B1)>&) const;
public:

    _Rp operator()(_A0, _A1) const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template<class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
function<_Rp(_A0, _A1)>::function(_Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1)>&
>::type
function<_Rp(_A0, _A1)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1>
void
function<_Rp(_A0, _A1)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1>
_Rp
function<_Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0, __a1);
}



template<class _Rp, class _A0, class _A1>
const std::type_info&
function<_Rp(_A0, _A1)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0, class _A1>
template <typename _Tp>
_Tp*
function<_Rp(_A0, _A1)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0, class _A1>
template <typename _Tp>
const _Tp*
function<_Rp(_A0, _A1)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1, _A2)>
{
    typedef __function::__base<_Rp(_A0, _A1, _A2)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_Rp(_B0, _B1, _B2)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2, class _B0, class _B1, class _B2>
      bool operator==(const function<_R2(_B0, _B1, _B2)>&) const;
    template<class _R2, class _B0, class _B1, class _B2>
      bool operator!=(const function<_R2(_B0, _B1, _B2)>&) const;
public:

    _Rp operator()(_A0, _A1, _A2) const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template<class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc&,
                                      const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
function<_Rp(_A0, _A1, _A2)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1, _A2)>&
>::type
function<_Rp(_A0, _A1, _A2)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1, class _A2>
void
function<_Rp(_A0, _A1, _A2)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1, class _A2>
_Rp
function<_Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0, __a1, __a2);
}



template<class _Rp, class _A0, class _A1, class _A2>
const std::type_info&
function<_Rp(_A0, _A1, _A2)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0, class _A1, class _A2>
template <typename _Tp>
_Tp*
function<_Rp(_A0, _A1, _A2)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0, class _A1, class _A2>
template <typename _Tp>
const _Tp*
function<_Rp(_A0, _A1, _A2)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const function<_Fp>& __f, nullptr_t) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const function<_Fp>& __f) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const function<_Fp>& __f, nullptr_t) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const function<_Fp>& __f) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(function<_Fp>& __x, function<_Fp>& __y)
{return __x.swap(__y);}

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders
{

template <int _Np> struct __ph {};

extern __ph<1> _1;
extern __ph<2> _2;
extern __ph<3> _3;
extern __ph<4> _4;
extern __ph<5> _5;
extern __ph<6> _6;
extern __ph<7> _7;
extern __ph<8> _8;
extern __ph<9> _9;
extern __ph<10> _10;

}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};

template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}
# 1204 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 2 3
# 2200 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(bool __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(signed char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned char __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char16_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char32_t __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(wchar_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(float __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(double __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long double __v) const throw()
    {

        if (__v == 0)
            return 0;
# 2379 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__a = 0;
        __u.__b = 0;
        __u.__t = __v;
        return __u.__a ^ __u.__b;



    }
};
# 2416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
} }
# 178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 183 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3
# 186 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) recursive_mutex
{
    pthread_mutex_t __m_;

public:
     recursive_mutex();
     ~recursive_mutex();

private:
    recursive_mutex(const recursive_mutex&);
    recursive_mutex& operator=(const recursive_mutex&);

public:
    void lock();
    bool try_lock() throw();
    void unlock() throw();

    typedef pthread_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    native_handle_type native_handle() {return &__m_;}
};

class __attribute__ ((__type_visibility__("default"))) timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
     timed_mutex();
     ~timed_mutex();

private:
    timed_mutex(const timed_mutex&);
    timed_mutex& operator=(const timed_mutex&);

public:
    void lock();
    bool try_lock() throw();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() throw();
};

template <class _Clock, class _Duration>
bool
timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    unique_lock<mutex> __lk(__m_);
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __locked_)
        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
    if (!__locked_)
    {
        __locked_ = true;
        return true;
    }
    return false;
}

class __attribute__ ((__type_visibility__("default"))) recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    pthread_t __id_;
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

private:
    recursive_timed_mutex(const recursive_timed_mutex&);
    recursive_timed_mutex& operator=(const recursive_timed_mutex&);

public:
    void lock();
    bool try_lock() throw();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() throw();
};

template <class _Clock, class _Duration>
bool
recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    pthread_t __id = pthread_self();
    unique_lock<mutex> lk(__m_);
    if (pthread_equal(__id, __id_))
    {
        if (__count_ == numeric_limits<size_t>::max())
            return false;
        ++__count_;
        return true;
    }
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __count_ != 0)
        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
    if (__count_ == 0)
    {
        __count_ = 1;
        __id_ = __id;
        return true;
    }
    return false;
}

template <class _L0, class _L1>
int
try_lock(_L0& __l0, _L1& __l1)
{
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        if (__l1.try_lock())
        {
            __u0.release();
            return -1;
        }
        else
            return 1;
    }
    return 0;
}
# 345 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template <class _L0, class _L1>
void
lock(_L0& __l0, _L1& __l1)
{
    while (true)
    {
        {
            unique_lock<_L0> __u0(__l0);
            if (__l1.try_lock())
            {
                __u0.release();
                break;
            }
        }
        sched_yield();
        {
            unique_lock<_L1> __u1(__l1);
            if (__l0.try_lock())
            {
                __u1.release();
                break;
            }
        }
        sched_yield();
    }
}
# 428 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag;
# 438 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template<class _Callable>
__attribute__ ((__visibility__("hidden"), __always_inline__))
void call_once(once_flag&, _Callable);



struct __attribute__ ((__type_visibility__("default"))) once_flag
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))

        once_flag() throw() : __state_(0) {}

private:
    once_flag(const once_flag&);
    once_flag& operator=(const once_flag&);

    unsigned long __state_;






    template<class _Callable>
    friend
    void call_once(once_flag&, _Callable);

};
# 500 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template <class _Fp>
class __call_once_param
{
    _Fp __f_;
public:




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __call_once_param(const _Fp& __f) : __f_(__f) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()()
    {
        __f_();
    }
};



template <class _Fp>
void
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

__attribute__ ((__visibility__("default"))) void __call_once(volatile unsigned long&, void*, void(*)(void*));
# 550 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template<class _Callable>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
call_once(once_flag& __flag, _Callable __func)
{
    if (__flag.__state_ != ~0ul)
    {
        __call_once_param<_Callable> __p(__func);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Callable>);
    }
}



} }
# 19 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 2 3


# 1 "/usr/include/locale.h" 1 3 4
# 40 "/usr/include/locale.h" 3 4
# 1 "/usr/include/_locale.h" 1 3 4
# 43 "/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};



extern "C" {
struct lconv *localeconv(void);
}
# 41 "/usr/include/locale.h" 2 3 4
# 52 "/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 2 3





# 1 "/usr/include/xlocale.h" 1 3 4
# 33 "/usr/include/xlocale.h" 3 4
struct _xlocale;
typedef struct _xlocale * locale_t;



# 1 "/usr/include/_xlocale.h" 1 3 4
# 29 "/usr/include/_xlocale.h" 3 4
extern "C" {
int ___mb_cur_max(void);
int ___mb_cur_max_l(locale_t);
}
# 38 "/usr/include/xlocale.h" 2 3 4
# 65 "/usr/include/xlocale.h" 3 4
extern "C" {
extern const locale_t _c_locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}



# 1 "/usr/include/xlocale/_ctype.h" 1 3 4
# 34 "/usr/include/xlocale/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}

extern "C" {
int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}

inline int
__istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l)
{
 return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f)
  : __maskrune_l(_c, _f, _l));
}

inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c]
  : ___toupper_l(_c, _l);
}

inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__maplower[_c]
  : ___tolower_l(_c, _l);
}

inline int
__wcwidth_l(__darwin_ct_rune_t _c, locale_t _l)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune_l(_c, 0xe0000000L|0x00040000L, _l);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}



inline int
digittoint_l(int c, locale_t l)
{
 return (__maskrune_l(c, 0x0F, l));
}

inline int
isalnum_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L|0x00000400L, l));
}

inline int
isalpha_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L, l));
}

inline int
isblank_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00020000L, l));
}

inline int
iscntrl_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000200L, l));
}

inline int
isdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isgraph_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000800L, l));
}

inline int
ishexnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
isideogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00080000L, l));
}

inline int
islower_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00001000L, l));
}

inline int
isnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isphonogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00200000L, l));
}

inline int
isprint_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00040000L, l));
}

inline int
ispunct_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00002000L, l));
}

inline int
isrune_l(int c, locale_t l)
{
 return (__istype_l(c, 0xFFFFFFF0L, l));
}

inline int
isspace_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00004000L, l));
}

inline int
isspecial_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00100000L, l));
}

inline int
isupper_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00008000L, l));
}

inline int
isxdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
tolower_l(int c, locale_t l)
{
        return (__tolower_l(c, l));
}

inline int
toupper_l(int c, locale_t l)
{
        return (__toupper_l(c, l));
}
# 78 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/__wctype.h" 1 3 4
# 30 "/usr/include/xlocale/__wctype.h" 3 4
inline int
iswalnum_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L|0x00000400L, _l));
}

inline int
iswalpha_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L, _l));
}

inline int
iswcntrl_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000200L, _l));
}

inline int
iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l)
{
 return (__istype_l(_wc, _charclass, _l));
}

inline int
iswdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswgraph_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000800L, _l));
}

inline int
iswlower_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00001000L, _l));
}

inline int
iswprint_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00040000L, _l));
}

inline int
iswpunct_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00002000L, _l));
}

inline int
iswspace_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00004000L, _l));
}

inline int
iswupper_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00008000L, _l));
}

inline int
iswxdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline wint_t
towlower_l(wint_t _wc, locale_t _l)
{
        return (__tolower_l(_wc, _l));
}

inline wint_t
towupper_l(wint_t _wc, locale_t _l)
{
        return (__toupper_l(_wc, _l));
}
# 135 "/usr/include/xlocale/__wctype.h" 3 4
extern "C" {
wctype_t
 wctype_l(const char *, locale_t);
}
# 81 "/usr/include/xlocale.h" 2 3 4
# 95 "/usr/include/xlocale.h" 3 4
# 1 "/usr/include/xlocale/_stdio.h" 1 3 4
# 27 "/usr/include/xlocale/_stdio.h" 3 4
extern "C" {

int fprintf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int fscanf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int printf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 2, 3)));
int scanf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 2, 3)));
int sprintf_l(char * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int sscanf_l(const char * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int vfprintf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));
int vprintf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 2, 0)));
int vsprintf_l(char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


int snprintf_l(char * , size_t, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 4, 5)));
int vfscanf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));
int vscanf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 2, 0)));
int vsnprintf_l(char * , size_t, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 4, 0)));
int vsscanf_l(const char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));



int dprintf_l(int, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf_l(int, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((availability(macosx,introduced=10.7)));




int asprintf_l(char ** , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int vasprintf_l(char ** , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


}
# 96 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_stdlib.h" 1 3 4
# 27 "/usr/include/xlocale/_stdlib.h" 3 4
extern "C" {
double atof_l(const char *, locale_t);
int atoi_l(const char *, locale_t);
long atol_l(const char *, locale_t);

long long
  atoll_l(const char *, locale_t);

int mblen_l(const char *, size_t, locale_t);
size_t mbstowcs_l(wchar_t * , const char * , size_t,
     locale_t);
int mbtowc_l(wchar_t * , const char * , size_t,
     locale_t);
double strtod_l(const char *, char **, locale_t) __asm("_" "strtod_l") ;
float strtof_l(const char *, char **, locale_t) __asm("_" "strtof_l") ;
long strtol_l(const char *, char **, int, locale_t);
long double
  strtold_l(const char *, char **, locale_t);
long long
  strtoll_l(const char *, char **, int, locale_t);

long long
  strtoq_l(const char *, char **, int, locale_t);

unsigned long
  strtoul_l(const char *, char **, int, locale_t);
unsigned long long
  strtoull_l(const char *, char **, int, locale_t);

unsigned long long
  strtouq_l(const char *, char **, int, locale_t);

size_t wcstombs_l(char * , const wchar_t * , size_t,
     locale_t);
int wctomb_l(char *, wchar_t, locale_t);





}
# 99 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_string.h" 1 3 4
# 27 "/usr/include/xlocale/_string.h" 3 4
extern "C" {
int strcoll_l(const char *, const char *, locale_t);
size_t strxfrm_l(char *, const char *, size_t, locale_t);
int strcasecmp_l(const char *, const char *, locale_t);
char *strcasestr_l(const char *, const char *, locale_t);
int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
# 102 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_time.h" 1 3 4
# 27 "/usr/include/xlocale/_time.h" 3 4
extern "C" {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm("_" "strftime_l") __attribute__((__format__ (__strftime__, 3, 0)));
char *strptime_l(const char * , const char * ,
  struct tm * , locale_t)
  __asm("_" "strptime_l") __attribute__((__format__ (__strftime__, 2, 0)));
}
# 105 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_wchar.h" 1 3 4
# 28 "/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
wint_t btowc_l(int, locale_t);
wint_t fgetwc_l(FILE *, locale_t);
wchar_t *fgetws_l(wchar_t * , int, FILE * , locale_t);
wint_t fputwc_l(wchar_t, FILE *, locale_t);
int fputws_l(const wchar_t * , FILE * , locale_t);
int fwprintf_l(FILE * , locale_t, const wchar_t * , ...);
int fwscanf_l(FILE * , locale_t, const wchar_t * , ...);
wint_t getwc_l(FILE *, locale_t);
wint_t getwchar_l(locale_t);
size_t mbrlen_l(const char * , size_t, mbstate_t * ,
     locale_t);
size_t mbrtowc_l(wchar_t * , const char * , size_t,
     mbstate_t * , locale_t);
int mbsinit_l(const mbstate_t *, locale_t);
size_t mbsrtowcs_l(wchar_t * , const char ** , size_t,
     mbstate_t * , locale_t);
wint_t putwc_l(wchar_t, FILE *, locale_t);
wint_t putwchar_l(wchar_t, locale_t);
int swprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , ...);
int swscanf_l(const wchar_t * , locale_t,
  const wchar_t * , ...);
wint_t ungetwc_l(wint_t, FILE *, locale_t);
int vfwprintf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , __darwin_va_list);
int vwprintf_l(locale_t, const wchar_t * , __darwin_va_list);
size_t wcrtomb_l(char * , wchar_t, mbstate_t * ,
     locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
size_t wcsftime_l(wchar_t * , size_t, const wchar_t * ,
  const struct tm * , locale_t)
  __asm("_" "wcsftime_l") ;
size_t wcsrtombs_l(char * , const wchar_t ** , size_t,
     mbstate_t * , locale_t);
double wcstod_l(const wchar_t * , wchar_t ** , locale_t);
long wcstol_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long
 wcstoul_l(const wchar_t * , wchar_t ** , int,
     locale_t);
int wcswidth_l(const wchar_t *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t * , const wchar_t * , size_t,
     locale_t);
int wctob_l(wint_t, locale_t);
int wcwidth_l(wchar_t, locale_t);
int wprintf_l(locale_t, const wchar_t * , ...);
int wscanf_l(locale_t, const wchar_t * , ...);
}
# 87 "/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
int vfwscanf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswscanf_l(const wchar_t * , locale_t,
  const wchar_t * , __darwin_va_list);
int vwscanf_l(locale_t, const wchar_t * , __darwin_va_list);
float wcstof_l(const wchar_t * , wchar_t ** , locale_t);
long double
 wcstold_l(const wchar_t * , wchar_t ** , locale_t);

long long
 wcstoll_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long long
 wcstoull_l(const wchar_t * , wchar_t ** , int,
     locale_t);

}
# 114 "/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs_l(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * , locale_t);
int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs_l(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * , locale_t);
}







extern "C" {
wchar_t *fgetwln_l(FILE * , size_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
}
# 108 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_wctype.h" 1 3 4
# 30 "/usr/include/xlocale/_wctype.h" 3 4
inline int
iswblank_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00020000L, _l));
}

inline int
iswhexnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline int
iswideogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00080000L, _l));
}

inline int
iswnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswphonogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00200000L, _l));
}

inline int
iswrune_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}

inline int
iswspecial_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00100000L, _l));
}
# 86 "/usr/include/xlocale/_wctype.h" 3 4
extern "C" {
wint_t nextwctype_l(wint_t, wctype_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t
 wctrans_l(const char *, locale_t);
}
# 111 "/usr/include/xlocale.h" 2 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 2 3
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) locale;

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale&) throw();

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale&);

class __attribute__ ((__type_visibility__("default"))) locale
{
public:

    class __attribute__ ((__type_visibility__("default"))) facet;
    class __attribute__ ((__type_visibility__("default"))) id;

    typedef int category;
    static const category
        none = 0,
        collate = (1 << 0),
        ctype = (1 << 1),
        monetary = (1 << 3),
        numeric = (1 << 4),
        time = (1 << 5),
        messages = (1 << 2),
        all = collate | ctype | monetary | numeric | time | messages;


    locale() throw();
    locale(const locale&) throw();
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) throw();

    template <class _Facet> locale combine(const locale&) const;


    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;


    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) throw();
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__ ((__type_visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();



private:
    virtual void __on_zero_shared() throw();
};

class __attribute__ ((__type_visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&);
    id(const id&);
public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{

    if (!std::__1::has_facet<_Facet>(__other))
        throw runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale& __l) throw()
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__ ((__type_visibility__("default"))) collate<char>;
extern template class __attribute__ ((__type_visibility__("default"))) collate<wchar_t>;



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}



class __attribute__ ((__type_visibility__("default"))) ctype_base
{
public:
# 346 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
    typedef __uint32_t mask;





    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask cntrl = 0x00000200L;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask punct = 0x00002000L;
    static const mask xdigit = 0x00010000L;



    static const mask blank = 0x00020000L;
# 391 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ctype_base() {}
};

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;

template <>
class __attribute__ ((__type_visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;


    static const size_t table_size = (1 <<8 );



    __attribute__ ((__visibility__("hidden"), __always_inline__)) const mask* table() const throw() {return __tab_;}
    static const mask* classic_table() throw();
# 610 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class __attribute__ ((__type_visibility__("default"))) codecvt_base
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}

extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;

__attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

template <>
struct __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <>
struct __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

template <>
struct __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};

template <>
struct __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};



template <class charT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }
# 217 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 2 3
# 225 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 3


namespace std {inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__ ((__type_visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__type_visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    typedef iostate io_state;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    typedef openmode open_mode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};
    typedef seekdir seek_dir;

    typedef std::__1::streamoff streamoff;
    typedef std::__1::streampos streampos;

    class __attribute__ ((__type_visibility__("default"))) Init;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void unsetf(fmtflags __mask);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width(streamsize __wide);


    locale imbue(const locale& __loc);
    locale getloc() const;


    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&);
    ios_base& operator=(const ios_base&);

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ios_base() {
               }

    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static int __xindex_;

    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


struct __attribute__ ((__type_visibility__("default"))) io_errc { enum __lx
{
    stream = 1
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) io_errc(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit io_errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc::__lx> : public true_type { };


__attribute__ ((__visibility__("default")))
const error_category& iostream_category() throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(io_errc __e) throw()
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(io_errc __e) throw()
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    virtual ~failure() throw();
};

class __attribute__ ((__type_visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return !fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!() const {return fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const {return ios_base::good();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill(char_type __ch);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    locale imbue(const locale& __loc);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ios() {
                }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void move(basic_ios& __rhs);




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_ios& __rhs) throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
     mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = 0;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = 0;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) throw()
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, __rhs.__tie_);
    std::__1::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/streambuf" 1 3
# 117 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/streambuf" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();


    locale pubimbue(const locale& __loc);
    locale getloc() const;


    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out);
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out);
    int pubsync();



    streamsize in_avail();
    int_type snextc();
    int_type sbumpc();
    int_type sgetc();
    streamsize sgetn(char_type* __s, streamsize __n);


    int_type sputbackc(char_type __c);
    int_type sungetc();


    int_type sputc(char_type __c);
    streamsize sputn(const char_type* __s, streamsize __n);

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);


    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* eback() const {return __binp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* egptr() const {return __einp_;}
    void gbump(int __n);
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);


    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* epptr() const {return __eout_;}
    void pbump(int __n);
    void setp(char_type* __pbeg, char_type* __pend);



    virtual void imbue(const locale& __loc);


    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)
{
    imbue(__loc);
    locale __r = __loc_;
    __loc_ = __loc;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_streambuf<_CharT, _Traits>::getloc() const
{
    return __loc_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)
{
    return setbuf(__s, __n);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,
                                             ios_base::seekdir __way,
                                             ios_base::openmode __which)
{
    return seekoff(__off, __way, __which);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,
                                             ios_base::openmode __which)
{
    return seekpos(__sp, __which);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_streambuf<_CharT, _Traits>::pubsync()
{
    return sync();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::in_avail()
{
    if (__ninp_ < __einp_)
        return static_cast<streamsize>(__einp_ - __ninp_);
    return showmanyc();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::snextc()
{
    if (sbumpc() == traits_type::eof())
        return traits_type::eof();
    return sgetc();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sbumpc()
{
    if (__ninp_ == __einp_)
        return uflow();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sgetc()
{
    if (__ninp_ == __einp_)
        return underflow();
    return traits_type::to_int_type(*__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)
{
    return xsgetn(__s, __n);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)
{
    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
        return pbackfail(traits_type::to_int_type(__c));
    return traits_type::to_int_type(*--__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sungetc()
{
    if (__binp_ == __ninp_)
        return pbackfail();
    return traits_type::to_int_type(*--__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputc(char_type __c)
{
    if (__nout_ == __eout_)
        return overflow(traits_type::to_int_type(__c));
    *__nout_++ = __c;
    return traits_type::to_int_type(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)
{
    return xsputn(__s, __n);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(0),
      __ninp_(0),
      __einp_(0),
      __bout_(0),
      __nout_(0),
      __eout_(0)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__1::swap(__loc_, __sb.__loc_);
    std::__1::swap(__binp_, __sb.__binp_);
    std::__1::swap(__ninp_, __sb.__ninp_);
    std::__1::swap(__einp_, __sb.__einp_);
    std::__1::swap(__bout_, __sb.__bout_);
    std::__1::swap(__nout_, __sb.__nout_);
    std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::gbump(int __n)
{
    __ninp_ += __n;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,
                                                          char_type* __gend)
{
    __binp_ = __gbeg;
    __ninp_ = __gnext;
    __einp_ = __gend;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::pbump(int __n)
{
    __nout_ += __n;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)
{
    __bout_ = __nout_ = __pbeg;
    __eout_ = __pend;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    for (;__i < __n; ++__i, ++__s)
    {
        if (__ninp_ < __einp_)
            *__s = *__ninp_++;
        else if ((__c = uflow()) != __eof)
            *__s = traits_type::to_char_type(__c);
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    for (; __i < __n; ++__s, ++__i)
    {
        if (__nout_ < __eout_)
            *__nout_++ = *__s;
        else if (overflow(traits_type::to_int_type(*__s)) == __eof)
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}

extern template class __attribute__ ((__type_visibility__("default"))) basic_streambuf<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_streambuf<wchar_t>;

extern template class __attribute__ ((__type_visibility__("default"))) basic_ios<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_ios<wchar_t>;

} }
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 1 3
# 156 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 1 3
# 133 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 1 3
# 197 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
# 1 "/usr/include/nl_types.h" 1 3 4
# 45 "/usr/include/nl_types.h" 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
# 84 "/usr/include/sys/types.h" 3 4
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;

typedef unsigned long u_long;


typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef int32_t daddr_t;



typedef u_int32_t fixpt_t;





# 1 "/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 110 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 111 "/usr/include/sys/types.h" 2 3 4






# 1 "/usr/include/sys/_types/_key_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 118 "/usr/include/sys/types.h" 2 3 4






typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 137 "/usr/include/sys/types.h" 3 4
static inline __int32_t major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 170 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 171 "/usr/include/sys/types.h" 2 3 4
# 185 "/usr/include/sys/types.h" 3 4
typedef __int32_t fd_mask;
# 226 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 227 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 228 "/usr/include/sys/types.h" 2 3 4
# 46 "/usr/include/nl_types.h" 2 3 4
# 89 "/usr/include/nl_types.h" 3 4
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;


# 1 "/usr/include/_types/_nl_item.h" 1 3 4
# 31 "/usr/include/_types/_nl_item.h" 3 4
typedef __darwin_nl_item nl_item;
# 95 "/usr/include/nl_types.h" 2 3 4

extern "C" {
nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *)
 __attribute__((__format_arg__(4)));
int catclose(nl_catd);
}
# 198 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 2 3






# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 205 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 2 3
# 208 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3


namespace std {inline namespace __1 {
# 223 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
typedef std::__1::remove_pointer<locale_t>::type __locale_struct;
typedef std::__1::unique_ptr<__locale_struct, __typeof__(&freelocale)> __locale_unique_ptr;
# 426 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__ ((__visibility__("hidden")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == 0)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {

        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;






        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (__b == __e)
        __err |= ios_base::eofbit;

    for (__st = __status; __kb != __ke; ++__kb, ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__ ((__type_visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__ ((__visibility__("default")))
void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);
};

template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)
{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__ ((__type_visibility__("default"))) __num_get<char>;
extern template struct __attribute__ ((__type_visibility__("default"))) __num_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_get() {}

    template <class _Fp>
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
_Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        if (*__a == '-')
        {
            __err = ios_base::failbit;
            return 0;
        }
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long double __ld = strtold_l(__a, &__p2, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return static_cast<_Tp>(__ld);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,
                                            __ct, __err);
    __v = __i == __names;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __atoms[26];
    char_type __thousands_sep;
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __atoms[26];
    char_type __thousands_sep;
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_float<_Fp>(__a, __a_end, __err);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }

    __a[sizeof(__a)-1] = 0;

    if (sscanf_l(__a, 0, "%p", &__v) != 1)



        __err = ios_base::failbit;

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) num_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) num_get<wchar_t>;

struct __attribute__ ((__type_visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isxdigit_l(*__ns, 0))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isdigit_l(*__ns, 0))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__ ((__type_visibility__("default"))) __num_put<char>;
extern template struct __attribute__ ((__type_visibility__("default"))) __num_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}





template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == std::__1::__get_nullptr_t())
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}



template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
                          + ((numeric_limits<long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
                          + ((numeric_limits<long long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt,
                                   (int)__iob.precision(), __v);




    else

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);



    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)

            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);




        else

            __nc = asprintf_l(&__nb, 0, __fmt, __v);



        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt,
                                   (int)__iob.precision(), __v);




    else

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);



    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)

            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);




        else

            __nc = asprintf_l(&__nb, 0, __fmt, __v);



        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{

    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__ ((__type_visibility__("default"))) num_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) num_put<wchar_t>;

template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{

    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)
    {

        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__ ((__type_visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{

    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{

    const string_type* __month = this->__months();
    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) time_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_get<wchar_t>;

class __attribute__ ((__type_visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get_byname() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class __attribute__ ((__type_visibility__("default"))) time_get_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_get_byname<wchar_t>;

class __attribute__ ((__type_visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __time_put() : __loc_(0) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__1::copy(__nb, __ne, __s);
}

extern template class __attribute__ ((__type_visibility__("default"))) time_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put_byname() {}
};

extern template class __attribute__ ((__type_visibility__("default"))) time_put_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_put_byname<wchar_t>;



class __attribute__ ((__type_visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) money_base() {}
};



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<char, true>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<wchar_t, true>;



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> void moneypunct_byname<char, false>::init(const char*);
template<> void moneypunct_byname<char, true>::init(const char*);
template<> void moneypunct_byname<wchar_t, false>::init(const char*);
template<> void moneypunct_byname<wchar_t, true>::init(const char*);

extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<char, true>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<wchar_t, true>;



template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__ ((__type_visibility__("default"))) __money_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) __money_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__ ((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }

        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                {
                    if (__psn.size() > 0)
                    {
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(0, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == 0)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) money_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) money_get<wchar_t>;



template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {

            char_type* __t = __me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }

            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }

            reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() > 1)
        __me = std::__1::copy(__sn.begin()+1, __sn.end(), __me);

    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__ ((__type_visibility__("default"))) __money_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) __money_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
    unique_ptr<char, void(*)(void*)> __hn(0, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);

    if (__n > __bs-1)
    {

        __n = static_cast<size_t>(asprintf_l(&__bb, 0, "%.0Lf", __units));



        if (__bb == 0)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
        if (__hd == std::__1::__get_nullptr_t())
            __throw_bad_alloc();
        __db = __hd.get();
    }

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = static_cast<int>(__n) > __fd ?
                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +
                    __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__ ((__type_visibility__("default"))) money_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) money_put<wchar_t>;



class __attribute__ ((__type_visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) messages_base() {}
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{



    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;

}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{



    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(back_inserter(__w),
                                                        __n, __n + strlen(__n));
    return __w;

}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);

}

extern template class __attribute__ ((__type_visibility__("default"))) messages<char>;
extern template class __attribute__ ((__type_visibility__("default"))) messages<wchar_t>;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages_byname() {}
};

extern template class __attribute__ ((__type_visibility__("default"))) messages_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) messages_byname<wchar_t>;

template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:
                                 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
    wstring_convert(_Codecvt* __pcvt, state_type __state);
                                 wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());



    ~wstring_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t converted() const throw() {return __cvtcount_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}
# 3847 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);

                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        throw range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);

                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        throw range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:

    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);
public:
                                 wbuffer_convert(streambuf* __bytebuf = 0,
            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
    ~wbuffer_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;
            state_type __svs = __st_;
            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp((char_type*)__e, this->pptr());
                        this->pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    switch (__way)
    {
    case ios_base::beg:
        break;
    case ios_base::cur:
        break;
    case ios_base::end:
        break;
    default:
        return pos_type(off_type(-1));
    }
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = 0;
    if (__cv_ != 0 && __bufptr_ != 0)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = 0;
    }
    return __rt;
}

} }
# 134 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 2 3
# 139 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_ostream();
protected:
# 172 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
    void swap(basic_ostream& __rhs);
public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&));
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));
    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);


    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();


    pos_type tellp();
    basic_ostream& seekp(pos_type __pos);
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream() {}
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {

        try
        {

            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);

        }
        catch (...)
        {
        }

    }
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
{
    this->init(__sb);
}
# 292 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)
{
    basic_ios<char_type, traits_type>::swap(__rhs);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))
{
    return __pf(*this);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&
                                           (*__pf)(basic_ios<char_type,traits_type>&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);

                }
                catch (...)
                {
                    this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
 return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
 return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
 return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
 return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
 return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
 return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
 const char *__s = (const char *) __str;
 return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
 const char *__s = (const char *) __str;
 return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{

    try
    {

        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{

    try
    {

        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (__s)
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (__s)
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}
# 1063 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
 return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}

extern template class __attribute__ ((__type_visibility__("default"))) basic_ostream<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_ostream<wchar_t>;

} }
# 157 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 159 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 2 3
# 162 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_istream();
protected:
# 193 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
    void swap(basic_istream& __rhs);
public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&));
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&));
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&));
    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    basic_istream& operator>>(float& __f);
    basic_istream& operator>>(double& __f);
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streamsize gcount() const {return __gc_;}
    int_type get();
    basic_istream& get(char_type& __c);
    basic_istream& get(char_type* __s, streamsize __n);
    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb);
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    basic_istream& getline(char_type* __s, streamsize __n);
    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);


    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>::basic_istream(basic_streambuf<char_type, traits_type>* __sb)
    : __gc_(0)
{
    this->init(__sb);
}
# 320 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_istream<_CharT, _Traits>::swap(basic_istream& __rhs)
{
    std::__1::swap(__gc_, __rhs.__gc_);
    basic_ios<char_type, traits_type>::swap(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<short>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::min();
            }
            else if (__temp > numeric_limits<short>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::max();
            }
            else
                __n = static_cast<short>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<int>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::min();
            }
            else if (__temp > numeric_limits<int>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::max();
            }
            else
                __n = static_cast<int>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_istream& (*__pf)(basic_istream&))
{
    return __pf(*this);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_ios<char_type, traits_type>&
                                           (*__pf)(basic_ios<char_type, traits_type>&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(ios_base& (*__pf)(ios_base&))
{
    __pf(*this);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n-1)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __is.setstate(ios_base::eofbit | ios_base::failbit);
            else
                __c = _Traits::to_char_type(__i);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    __gc_ = 0;

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    ios_base::iostate __err = ios_base::goodbit;
                    while (true)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sgetc();
                        if (traits_type::eq_int_type(__i, _Traits::eof()))
                        {
                           __err |= ios_base::eofbit;
                           break;
                        }
                        if (traits_type::eq_int_type(
                                __sb->sputc(traits_type::to_char_type(__i)),
                                traits_type::eof()))
                            break;
                        ++__gc_;
                        this->rdbuf()->sbumpc();
                    }
                    if (__gc_ == 0)
                       __err |= ios_base::failbit;
                    this->setstate(__err);

                }
                catch (...)
                {
                    if (__gc_ == 0)
                        this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               this->setstate(ios_base::failbit | ios_base::eofbit);
            else
                __gc_ = 1;
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type& __c)
{
    int_type __ch = get();
    if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (__n > 0)
            {
                ios_base::iostate __err = ios_base::goodbit;
                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                *__s = char_type();
                if (__gc_ == 0)
                   __err |= ios_base::failbit;
                this->setstate(__err);
            }
            else
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n)
{
    return get(__s, __n, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;

            try
            {

                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }

            }
            catch (...)
            {
            }

            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb)
{
    return get(__sb, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __err |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }
            if (__n > 0)
                *__s = char_type();
            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n)
{
    return getline(__s, __n, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                this->setstate(ios_base::eofbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                this->setstate(ios_base::failbit | ios_base::eofbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    __gc_ = 0;
    streamsize __c = this->rdbuf()->in_avail();
    switch (__c)
    {
    case -1:
        this->setstate(ios_base::eofbit);
        break;
    case 0:
        break;
    default:
        read(__s, std::__1::min(__c, __n));
        break;
    }
    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    int __r = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                this->setstate(ios_base::badbit);
                return -1;
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    pos_type __r(-1);

    try
    {

        sentry __sen(*this, true);
        if (__sen)
            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __is.setstate(ios_base::eofbit);
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}
# 1458 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_iostream();
protected:
# 1485 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
    void swap(basic_iostream& __rhs);
public:
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_iostream<_CharT, _Traits>::basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
    : basic_istream<_CharT, _Traits>(__sb)
{
}
# 1516 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_iostream<_CharT, _Traits>::swap(basic_iostream& __rhs)
{
    basic_istream<char_type, traits_type>::swap(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            __str.clear();
            ios_base::iostate __err = ios_base::goodbit;
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __err |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}
# 1661 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            streamsize __c = 0;
            ios_base::iostate __err = ios_base::goodbit;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

extern template class __attribute__ ((__type_visibility__("default"))) basic_istream<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_istream<wchar_t>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_iostream<char>;

} }
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 2 3
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 3


namespace std {inline namespace __1 {

extern __attribute__ ((__visibility__("default"))) istream cin;
extern __attribute__ ((__visibility__("default"))) ostream cout;
extern __attribute__ ((__visibility__("default"))) ostream cerr;
extern __attribute__ ((__visibility__("default"))) ostream clog;
extern __attribute__ ((__visibility__("default"))) wistream wcin;
extern __attribute__ ((__visibility__("default"))) wostream wcout;
extern __attribute__ ((__visibility__("default"))) wostream wcerr;
extern __attribute__ ((__visibility__("default"))) wostream wclog;

} }
# 23 "./common_utils_cpp.hpp" 2

template <typename T>
inline T dref_as(void* ptr);





typedef std::pair<glm::vec3, glm::vec3> vec3_pair;
typedef std::pair<glm::vec4, glm::vec4> vec4_pair;

inline f64 dist2(glm::vec3 v, glm::vec3 w);
inline f64 dist_to_segment_squared(glm::vec3 v, glm::vec3 w, glm::vec3 p);
inline f64 dist_to_segment(glm::vec3 v, glm::vec3 w, glm::vec3 p);


bool line_segment_intersection(const vec3_pair* s0, const vec3_pair* s1, glm::vec3* out);

template<typename T>
static std::string to_binary_string(const T& x);

template <typename T, usize N>
struct Buffer {
    T memory[N];
    usize elements_used;

    operator T*(void)
    {
        return this->memory;
    }

    inline T& operator[](usize i)
    {
        return this->memory[i];
    }

    inline const T& operator[](usize i) const
    {
        return this->memory[i];
    }

    inline usize byte_length(void) const
    {
        return sizeof(T) * N;
    }

    inline usize element_length(void) const
    {
        return N;
    }

    inline void push_back(T val)
    {
        (__builtin_expect(!(this->elements_used < N), 0) ? __assert_rtn(__func__, "./common_utils_cpp.hpp", 76, "this->elements_used < N") : (void)0);
        memory[this->elements_used] = val;
        this->elements_used += 1;
    }

    inline void push_back(T* val)
    {
        (__builtin_expect(!(this->elements_used < N), 0) ? __assert_rtn(__func__, "./common_utils_cpp.hpp", 83, "this->elements_used < N") : (void)0);
        memory[this->elements_used] = *val;
        this->elements_used += 1;
    }

    inline void reset()
    {
        this->elements_used = 0;
    }

    typedef T* iterator;
    typedef const T* const_iterator;
    iterator begin(void) { return &this->memory[0]; }
    iterator end(void) { return &this->memory[N]; }
    iterator first_free(void) { return &this->memory[this->elements_used]; }
};

template <typename T>
struct DynamicBuffer {
    size_t cap;
    size_t count;
    T* array;

    operator T*()
    {
        return this->array;
    }

    T& operator[](size_t i)
    {
        return this->array[i];
    }

    const T& operator[](size_t i) const
    {
        return this->array[i];
    }

    inline size_t element_count() const
    {
        return this->count;
    }

    inline size_t element_size() const
    {
        return sizeof(T);
    }

    inline size_t size() const
    {
        return this->cap;
    }


    typedef T* iterator;
    typedef const T* const_iterator;
    iterator begin() { return &this->array[0]; }
    iterator end() { return &this->array[this->cap]; }
};

void vec2_print(glm::vec2* v);

void vec2_pair_print(glm::vec2* a, glm::vec2* b);

void vec3_print(glm::vec3* v);

void vec3_pair_print(glm::vec3* a, glm::vec3*b);

void vec4_print(glm::vec4* v);

void vec4_pair_print(glm::vec4* a, glm::vec4* b);

template<typename T>
void print_array(T* array, const usize N, const usize M = 1);




static inline f32 atan2pos_32(f64 y, f64 x);
static inline f64 atan2pos_64(f64 y, f64 x);

bool check_file_status(const char* file_path, struct stat* file_stat);

template <typename T>
inline void zero_mem(T* ptr);







template <typename T>
inline T dref_as(void* ptr)
{
    return *static_cast<T*>(ptr);
}

inline f64 dist2(glm::vec3 v, glm::vec3 w)
{
    f64 a = v.x - w.x;
    f64 b = v.y - w.y;
    return (a * a) + (b * b);
}

inline f64 dist_to_segment_squared(glm::vec3 v, glm::vec3 w, glm::vec3 p)
{
    const f64 l2 = dist2(v, w);
    if (l2 == 0.0) {
        return dist2(p, v);
    }

    const f64 t = glm::max(0.0, glm::min(1.0, dot(p - v, w - v) / l2));
    return dist2(p, glm::vec3(v.x + t * (w.x - v.x), v.y + t * (w.y - v.y), 0.0));
}

inline f64 dist_to_segment(glm::vec3 v, glm::vec3 w, glm::vec3 p)
{
    return glm::sqrt(dist_to_segment_squared(v, w, p));
}


bool line_segment_intersection(const vec3_pair* s0, const vec3_pair* s1, glm::vec3* out)
{
    f64 Ax = s0->first.x;
    f64 Ay = s0->first.y;
    f64 Bx = s0->second.x;
    f64 By = s0->second.y;

    f64 Cx = s1->first.x;
    f64 Cy = s1->first.y;
    f64 Dx = s1->second.x;
    f64 Dy = s1->second.y;

    f64 distAB, theCos, theSin, newX, ABpos;
# 230 "./common_utils_cpp.hpp"
    Bx -= Ax;
    By -= Ay;

    Cx -= Ax;
    Cy -=Ay;

    Dx -= Ax;
    Dy -=Ay;


    distAB = glm::sqrt(Bx*Bx + By*By);


    theCos = Bx / distAB;
    theSin = By / distAB;
    newX = Cx*theCos + Cy*theSin;
    Cy = Cy*theCos - Cx*theSin;
    Cx = newX;
    newX = Dx*theCos + Dy*theSin;
    Dy = Dy*theCos - Dx*theSin;
    Dx = newX;


    if ((Cy < 0.0 && Dy < 0.0) || (Cy >= 0.0 && Dy >= 0.0)) {
        return false;
    }


    ABpos = Dx + (Cx-Dx)*Dy / (Dy-Cy);


    if (ABpos < 0.0 || ABpos > distAB) {
        return false;
    }


    out->x =Ax+ABpos * theCos;
    out->y =Ay+ABpos * theSin;
    out->z = 0.0;


    return true;
}

template<typename T>
static std::string to_binary_string(const T& x)
{
    return std::bitset<sizeof(T) * 8>(x).to_string();
}

void vec2_print(glm::vec2* v)
{
    printf("[%f, %f]", v->x, v->y);
}

void vec3_pair_print(glm::vec2* a, glm::vec2* b)
{
    printf("[[%f, %f][%f, %f]]", a->x, a->y, b->x, b->y);
}

void vec3_print(glm::vec3* v)
{
    printf("[%f, %f, %f]", v->x, v->y, v->z);
}

void vec3_pair_print(glm::vec3* a, glm::vec3* b)
{
    printf("[[%f, %f, %f][%f, %f, %f]]", a->x, a->y, a->z, b->x, b->y, b->z);
}

void vec4_print(glm::vec4* v)
{
    printf("[%f, %f, %f, %f]", v->x, v->y, v->z, v->w);
}

void vec4_pair_print(glm::vec4* a, glm::vec4*b)
{
    printf("[[%f, %f, %f, %f][%f, %f, %f, %f]]", a->x, a->y, a->z, a->w, b->x, b->y, b->z, b->w);
}

template<typename T>
void print_array(T* const array, const usize N, const usize M)
{
    std::string s = "{\n";
    for (usize i = 0; i < N; ++i) {
        T* row = &array[i * M];
        s += "[";
        for (usize j = 0; j < M; ++j) {
            s += std::to_string(row[j]) + ", ";
        }
        s += "],\n";
    }
    s += "}";

    std::cout << s << std::endl;
}

static inline f32 atan2pos_32(f64 y, f64 x)
{
    f32 val = glm::atan2<f32, glm::highp>(-y, x);

    return (val < 0) ? val + 2 * glm::pi<f64>() : val;
}
static inline f64 atan2pos_64(f64 y, f64 x)
{
    f64 val = glm::atan2<f64, glm::highp>(-y, x);

    return (val < 0) ? val + 2 * glm::pi<f64>() : val;
}

bool check_file_status(const char* file_path, struct stat* file_stat)
{
    return stat(file_path, file_stat) == 0;
}

template <typename T>
inline void zero_mem(T* ptr)
{
    memset(ptr, 0, sizeof(T));
}
# 23 "run.cpp" 2

# 1 "./core_utils.h" 1
# 11 "./core_utils.h"
# 1 "./sdl.hpp" 1








# 1 "/usr/local/include/SDL2/SDL.h" 1 3
# 32 "/usr/local/include/SDL2/SDL.h" 3
# 1 "/usr/local/include/SDL2/SDL_main.h" 1 3
# 25 "/usr/local/include/SDL2/SDL_main.h" 3
# 1 "/usr/local/include/SDL2/SDL_stdinc.h" 1 3
# 31 "/usr/local/include/SDL2/SDL_stdinc.h" 3
# 1 "/usr/local/include/SDL2/SDL_config.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_config.h" 3
# 1 "/usr/local/include/SDL2/SDL_platform.h" 1 3
# 71 "/usr/local/include/SDL2/SDL_platform.h" 3
# 1 "/usr/include/AvailabilityMacros.h" 1 3 4
# 72 "/usr/local/include/SDL2/SDL_platform.h" 2 3
# 1 "/usr/include/TargetConditionals.h" 1 3 4
# 73 "/usr/local/include/SDL2/SDL_platform.h" 2 3
# 179 "/usr/local/include/SDL2/SDL_platform.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 180 "/usr/local/include/SDL2/SDL_platform.h" 2 3


extern "C" {





extern __attribute__ ((visibility("default"))) const char * SDL_GetPlatform (void);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 195 "/usr/local/include/SDL2/SDL_platform.h" 2 3
# 34 "/usr/local/include/SDL2/SDL_config.h" 2 3
# 32 "/usr/local/include/SDL2/SDL_stdinc.h" 2 3
# 41 "/usr/local/include/SDL2/SDL_stdinc.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 42 "/usr/local/include/SDL2/SDL_stdinc.h" 2 3
# 69 "/usr/local/include/SDL2/SDL_stdinc.h" 3
# 1 "/usr/include/inttypes.h" 1 3 4
# 227 "/usr/include/inttypes.h" 3 4
# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 228 "/usr/include/inttypes.h" 2 3 4



extern "C" {


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
imaxabs(intmax_t j);


typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;

__attribute__((availability(macosx,introduced=10.4)))
extern imaxdiv_t
imaxdiv(intmax_t __numer, intmax_t __denom);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
strtoimax(const char * __nptr,
   char ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
strtoumax(const char * __nptr,
   char ** __endptr,
   int __base);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
wcstoimax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
wcstoumax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);






}



# 1 "/usr/include/xlocale/_inttypes.h" 1 3 4
# 27 "/usr/include/xlocale/_inttypes.h" 3 4
extern "C" {
intmax_t strtoimax_l(const char * nptr, char ** endptr,
  int base, locale_t);
uintmax_t strtoumax_l(const char * nptr, char ** endptr,
  int base, locale_t);
intmax_t wcstoimax_l(const wchar_t * nptr,
  wchar_t ** endptr, int base, locale_t);
uintmax_t wcstoumax_l(const wchar_t * nptr,
  wchar_t ** endptr, int base, locale_t);





}
# 283 "/usr/include/inttypes.h" 2 3 4
# 70 "/usr/local/include/SDL2/SDL_stdinc.h" 2 3
# 139 "/usr/local/include/SDL2/SDL_stdinc.h" 3
typedef enum
{
    SDL_FALSE = 0,
    SDL_TRUE = 1
} SDL_bool;







typedef int8_t Sint8;





typedef uint8_t Uint8;





typedef int16_t Sint16;





typedef uint16_t Uint16;





typedef int32_t Sint32;





typedef uint32_t Uint32;






typedef int64_t Sint64;





typedef uint64_t Uint64;
# 294 "/usr/local/include/SDL2/SDL_stdinc.h" 3
typedef int SDL_compile_time_assert_uint8[(sizeof(Uint8) == 1) * 2 - 1];
typedef int SDL_compile_time_assert_sint8[(sizeof(Sint8) == 1) * 2 - 1];
typedef int SDL_compile_time_assert_uint16[(sizeof(Uint16) == 2) * 2 - 1];
typedef int SDL_compile_time_assert_sint16[(sizeof(Sint16) == 2) * 2 - 1];
typedef int SDL_compile_time_assert_uint32[(sizeof(Uint32) == 4) * 2 - 1];
typedef int SDL_compile_time_assert_sint32[(sizeof(Sint32) == 4) * 2 - 1];
typedef int SDL_compile_time_assert_uint64[(sizeof(Uint64) == 8) * 2 - 1];
typedef int SDL_compile_time_assert_sint64[(sizeof(Sint64) == 8) * 2 - 1];
# 315 "/usr/local/include/SDL2/SDL_stdinc.h" 3
typedef enum
{
    DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;

typedef int SDL_compile_time_assert_enum[(sizeof(SDL_DUMMY_ENUM) == sizeof(int)) * 2 - 1];





# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 326 "/usr/local/include/SDL2/SDL_stdinc.h" 2 3


extern "C" {
# 361 "/usr/local/include/SDL2/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) void * SDL_malloc(size_t size);
extern __attribute__ ((visibility("default"))) void * SDL_calloc(size_t nmemb, size_t size);
extern __attribute__ ((visibility("default"))) void * SDL_realloc(void *mem, size_t size);
extern __attribute__ ((visibility("default"))) void SDL_free(void *mem);

typedef void *( *SDL_malloc_func)(size_t size);
typedef void *( *SDL_calloc_func)(size_t nmemb, size_t size);
typedef void *( *SDL_realloc_func)(void *mem, size_t size);
typedef void ( *SDL_free_func)(void *mem);




extern __attribute__ ((visibility("default"))) void SDL_GetMemoryFunctions(SDL_malloc_func *malloc_func,
                                                    SDL_calloc_func *calloc_func,
                                                    SDL_realloc_func *realloc_func,
                                                    SDL_free_func *free_func);
# 387 "/usr/local/include/SDL2/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetMemoryFunctions(SDL_malloc_func malloc_func,
                                                   SDL_calloc_func calloc_func,
                                                   SDL_realloc_func realloc_func,
                                                   SDL_free_func free_func);




extern __attribute__ ((visibility("default"))) int SDL_GetNumAllocations(void);

extern __attribute__ ((visibility("default"))) char * SDL_getenv(const char *name);
extern __attribute__ ((visibility("default"))) int SDL_setenv(const char *name, const char *value, int overwrite);

extern __attribute__ ((visibility("default"))) void SDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *));

extern __attribute__ ((visibility("default"))) int SDL_abs(int x);






extern __attribute__ ((visibility("default"))) int SDL_isdigit(int x);
extern __attribute__ ((visibility("default"))) int SDL_isspace(int x);
extern __attribute__ ((visibility("default"))) int SDL_toupper(int x);
extern __attribute__ ((visibility("default"))) int SDL_tolower(int x);

extern __attribute__ ((visibility("default"))) void * SDL_memset( void *dst, int c, size_t len);





__attribute__((always_inline)) static __inline__ void SDL_memset4(void *dst, Uint32 val, size_t dwords)
{
# 432 "/usr/local/include/SDL2/SDL_stdinc.h" 3
    size_t _n = (dwords + 3) / 4;
    Uint32 *_p = static_cast<Uint32 *>(dst);
    Uint32 _val = (val);
    if (dwords == 0)
        return;
    switch (dwords % 4)
    {
        case 0: do { *_p++ = _val;
        case 3: *_p++ = _val;
        case 2: *_p++ = _val;
        case 1: *_p++ = _val;
        } while ( --_n );
    }

}


extern __attribute__ ((visibility("default"))) void * SDL_memcpy( void *dst, const void *src, size_t len);

extern __attribute__ ((visibility("default"))) void * SDL_memmove( void *dst, const void *src, size_t len);
extern __attribute__ ((visibility("default"))) int SDL_memcmp(const void *s1, const void *s2, size_t len);

extern __attribute__ ((visibility("default"))) size_t SDL_wcslen(const wchar_t *wstr);
extern __attribute__ ((visibility("default"))) size_t SDL_wcslcpy( wchar_t *dst, const wchar_t *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) size_t SDL_wcslcat( wchar_t *dst, const wchar_t *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) int SDL_wcscmp(const wchar_t *str1, const wchar_t *str2);

extern __attribute__ ((visibility("default"))) size_t SDL_strlen(const char *str);
extern __attribute__ ((visibility("default"))) size_t SDL_strlcpy( char *dst, const char *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) size_t SDL_utf8strlcpy( char *dst, const char *src, size_t dst_bytes);
extern __attribute__ ((visibility("default"))) size_t SDL_strlcat( char *dst, const char *src, size_t maxlen);
extern __attribute__ ((visibility("default"))) char * SDL_strdup(const char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strrev(char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strupr(char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strlwr(char *str);
extern __attribute__ ((visibility("default"))) char * SDL_strchr(const char *str, int c);
extern __attribute__ ((visibility("default"))) char * SDL_strrchr(const char *str, int c);
extern __attribute__ ((visibility("default"))) char * SDL_strstr(const char *haystack, const char *needle);
extern __attribute__ ((visibility("default"))) size_t SDL_utf8strlen(const char *str);

extern __attribute__ ((visibility("default"))) char * SDL_itoa(int value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_uitoa(unsigned int value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_ltoa(long value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_ultoa(unsigned long value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_lltoa(Sint64 value, char *str, int radix);
extern __attribute__ ((visibility("default"))) char * SDL_ulltoa(Uint64 value, char *str, int radix);

extern __attribute__ ((visibility("default"))) int SDL_atoi(const char *str);
extern __attribute__ ((visibility("default"))) double SDL_atof(const char *str);
extern __attribute__ ((visibility("default"))) long SDL_strtol(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) unsigned long SDL_strtoul(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) Sint64 SDL_strtoll(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) Uint64 SDL_strtoull(const char *str, char **endp, int base);
extern __attribute__ ((visibility("default"))) double SDL_strtod(const char *str, char **endp);

extern __attribute__ ((visibility("default"))) int SDL_strcmp(const char *str1, const char *str2);
extern __attribute__ ((visibility("default"))) int SDL_strncmp(const char *str1, const char *str2, size_t maxlen);
extern __attribute__ ((visibility("default"))) int SDL_strcasecmp(const char *str1, const char *str2);
extern __attribute__ ((visibility("default"))) int SDL_strncasecmp(const char *str1, const char *str2, size_t len);

extern __attribute__ ((visibility("default"))) int SDL_sscanf(const char *text, const char *fmt, ...) __attribute__ (( format( __scanf__, 2, 2 +1 )));
extern __attribute__ ((visibility("default"))) int SDL_vsscanf(const char *text, const char *fmt, va_list ap);
extern __attribute__ ((visibility("default"))) int SDL_snprintf( char *text, size_t maxlen, const char *fmt, ... ) __attribute__ (( format( __printf__, 3, 3 +1 )));
extern __attribute__ ((visibility("default"))) int SDL_vsnprintf( char *text, size_t maxlen, const char *fmt, va_list ap);







extern __attribute__ ((visibility("default"))) double SDL_acos(double x);
extern __attribute__ ((visibility("default"))) float SDL_acosf(float x);
extern __attribute__ ((visibility("default"))) double SDL_asin(double x);
extern __attribute__ ((visibility("default"))) float SDL_asinf(float x);
extern __attribute__ ((visibility("default"))) double SDL_atan(double x);
extern __attribute__ ((visibility("default"))) float SDL_atanf(float x);
extern __attribute__ ((visibility("default"))) double SDL_atan2(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_atan2f(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_ceil(double x);
extern __attribute__ ((visibility("default"))) float SDL_ceilf(float x);
extern __attribute__ ((visibility("default"))) double SDL_copysign(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_copysignf(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_cos(double x);
extern __attribute__ ((visibility("default"))) float SDL_cosf(float x);
extern __attribute__ ((visibility("default"))) double SDL_fabs(double x);
extern __attribute__ ((visibility("default"))) float SDL_fabsf(float x);
extern __attribute__ ((visibility("default"))) double SDL_floor(double x);
extern __attribute__ ((visibility("default"))) float SDL_floorf(float x);
extern __attribute__ ((visibility("default"))) double SDL_fmod(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_fmodf(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_log(double x);
extern __attribute__ ((visibility("default"))) float SDL_logf(float x);
extern __attribute__ ((visibility("default"))) double SDL_log10(double x);
extern __attribute__ ((visibility("default"))) float SDL_log10f(float x);
extern __attribute__ ((visibility("default"))) double SDL_pow(double x, double y);
extern __attribute__ ((visibility("default"))) float SDL_powf(float x, float y);
extern __attribute__ ((visibility("default"))) double SDL_scalbn(double x, int n);
extern __attribute__ ((visibility("default"))) float SDL_scalbnf(float x, int n);
extern __attribute__ ((visibility("default"))) double SDL_sin(double x);
extern __attribute__ ((visibility("default"))) float SDL_sinf(float x);
extern __attribute__ ((visibility("default"))) double SDL_sqrt(double x);
extern __attribute__ ((visibility("default"))) float SDL_sqrtf(float x);
extern __attribute__ ((visibility("default"))) double SDL_tan(double x);
extern __attribute__ ((visibility("default"))) float SDL_tanf(float x);
# 545 "/usr/local/include/SDL2/SDL_stdinc.h" 3
typedef struct _SDL_iconv_t *SDL_iconv_t;
extern __attribute__ ((visibility("default"))) SDL_iconv_t SDL_iconv_open(const char *tocode,
                                                   const char *fromcode);
extern __attribute__ ((visibility("default"))) int SDL_iconv_close(SDL_iconv_t cd);
extern __attribute__ ((visibility("default"))) size_t SDL_iconv(SDL_iconv_t cd, const char **inbuf,
                                         size_t * inbytesleft, char **outbuf,
                                         size_t * outbytesleft);




extern __attribute__ ((visibility("default"))) char * SDL_iconv_string(const char *tocode,
                                               const char *fromcode,
                                               const char *inbuf,
                                               size_t inbytesleft);
# 592 "/usr/local/include/SDL2/SDL_stdinc.h" 3
__attribute__((always_inline)) static __inline__ void *SDL_memcpy4( void *dst, const void *src, size_t dwords)
{
    return SDL_memcpy(dst, src, dwords * 4);
}



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 602 "/usr/local/include/SDL2/SDL_stdinc.h" 2 3
# 26 "/usr/local/include/SDL2/SDL_main.h" 2 3
# 117 "/usr/local/include/SDL2/SDL_main.h" 3
extern "C" int SDL_main(int argc, char *argv[]);



# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 121 "/usr/local/include/SDL2/SDL_main.h" 2 3

extern "C" {
# 132 "/usr/local/include/SDL2/SDL_main.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetMainReady(void);
# 162 "/usr/local/include/SDL2/SDL_main.h" 3
}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 165 "/usr/local/include/SDL2/SDL_main.h" 2 3
# 33 "/usr/local/include/SDL2/SDL.h" 2 3

# 1 "/usr/local/include/SDL2/SDL_assert.h" 1 3
# 27 "/usr/local/include/SDL2/SDL_assert.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 28 "/usr/local/include/SDL2/SDL_assert.h" 2 3


extern "C" {
# 102 "/usr/local/include/SDL2/SDL_assert.h" 3
typedef enum
{
    SDL_ASSERTION_RETRY,
    SDL_ASSERTION_BREAK,
    SDL_ASSERTION_ABORT,
    SDL_ASSERTION_IGNORE,
    SDL_ASSERTION_ALWAYS_IGNORE
} SDL_AssertState;

typedef struct SDL_AssertData
{
    int always_ignore;
    unsigned int trigger_count;
    const char *condition;
    const char *filename;
    int linenum;
    const char *function;
    const struct SDL_AssertData *next;
} SDL_AssertData;




extern __attribute__ ((visibility("default"))) SDL_AssertState SDL_ReportAssertion(SDL_AssertData *,
                                                             const char *,
                                                             const char *, int)





   __attribute__((analyzer_noreturn))


;
# 188 "/usr/local/include/SDL2/SDL_assert.h" 3
typedef SDL_AssertState ( *SDL_AssertionHandler)(
                                 const SDL_AssertData* data, void* userdata);
# 211 "/usr/local/include/SDL2/SDL_assert.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetAssertionHandler(
                                            SDL_AssertionHandler handler,
                                            void *userdata);
# 225 "/usr/local/include/SDL2/SDL_assert.h" 3
extern __attribute__ ((visibility("default"))) SDL_AssertionHandler SDL_GetDefaultAssertionHandler(void);
# 242 "/usr/local/include/SDL2/SDL_assert.h" 3
extern __attribute__ ((visibility("default"))) SDL_AssertionHandler SDL_GetAssertionHandler(void **puserdata);
# 266 "/usr/local/include/SDL2/SDL_assert.h" 3
extern __attribute__ ((visibility("default"))) const SDL_AssertData * SDL_GetAssertionReport(void);
# 275 "/usr/local/include/SDL2/SDL_assert.h" 3
extern __attribute__ ((visibility("default"))) void SDL_ResetAssertionReport(void);
# 285 "/usr/local/include/SDL2/SDL_assert.h" 3
}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 288 "/usr/local/include/SDL2/SDL_assert.h" 2 3
# 35 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_atomic.h" 1 3
# 65 "/usr/local/include/SDL2/SDL_atomic.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 66 "/usr/local/include/SDL2/SDL_atomic.h" 2 3



extern "C" {
# 89 "/usr/local/include/SDL2/SDL_atomic.h" 3
typedef int SDL_SpinLock;
# 98 "/usr/local/include/SDL2/SDL_atomic.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_AtomicTryLock(SDL_SpinLock *lock);






extern __attribute__ ((visibility("default"))) void SDL_AtomicLock(SDL_SpinLock *lock);






extern __attribute__ ((visibility("default"))) void SDL_AtomicUnlock(SDL_SpinLock *lock);
# 155 "/usr/local/include/SDL2/SDL_atomic.h" 3
extern __attribute__ ((visibility("default"))) void SDL_MemoryBarrierReleaseFunction(void);
extern __attribute__ ((visibility("default"))) void SDL_MemoryBarrierAcquireFunction(void);
# 198 "/usr/local/include/SDL2/SDL_atomic.h" 3
typedef struct { int value; } SDL_atomic_t;
# 207 "/usr/local/include/SDL2/SDL_atomic.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval);






extern __attribute__ ((visibility("default"))) int SDL_AtomicSet(SDL_atomic_t *a, int v);




extern __attribute__ ((visibility("default"))) int SDL_AtomicGet(SDL_atomic_t *a);
# 228 "/usr/local/include/SDL2/SDL_atomic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_AtomicAdd(SDL_atomic_t *a, int v);
# 254 "/usr/local/include/SDL2/SDL_atomic.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_AtomicCASPtr(void **a, void *oldval, void *newval);






extern __attribute__ ((visibility("default"))) void* SDL_AtomicSetPtr(void **a, void* v);




extern __attribute__ ((visibility("default"))) void* SDL_AtomicGetPtr(void **a);



}



# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 274 "/usr/local/include/SDL2/SDL_atomic.h" 2 3
# 36 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_audio.h" 1 3
# 32 "/usr/local/include/SDL2/SDL_audio.h" 3
# 1 "/usr/local/include/SDL2/SDL_error.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_error.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_error.h" 2 3


extern "C" {




extern __attribute__ ((visibility("default"))) int SDL_SetError( const char *fmt, ...) __attribute__ (( format( __printf__, 1, 1 +1 )));
extern __attribute__ ((visibility("default"))) const char * SDL_GetError(void);
extern __attribute__ ((visibility("default"))) void SDL_ClearError(void);
# 55 "/usr/local/include/SDL2/SDL_error.h" 3
typedef enum
{
    SDL_ENOMEM,
    SDL_EFREAD,
    SDL_EFWRITE,
    SDL_EFSEEK,
    SDL_UNSUPPORTED,
    SDL_LASTERROR
} SDL_errorcode;

extern __attribute__ ((visibility("default"))) int SDL_Error(SDL_errorcode code);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 73 "/usr/local/include/SDL2/SDL_error.h" 2 3
# 33 "/usr/local/include/SDL2/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_endian.h" 1 3
# 59 "/usr/local/include/SDL2/SDL_endian.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 60 "/usr/local/include/SDL2/SDL_endian.h" 2 3


extern "C" {
# 77 "/usr/local/include/SDL2/SDL_endian.h" 3
__attribute__((always_inline)) static __inline__ Uint16
SDL_Swap16(Uint16 x)
{
  __asm__("xchgb %b0,%h0": "=Q"(x):"0"(x));
    return x;
}
# 121 "/usr/local/include/SDL2/SDL_endian.h" 3
__attribute__((always_inline)) static __inline__ Uint32
SDL_Swap32(Uint32 x)
{
  __asm__("bswapl %0": "=r"(x):"0"(x));
    return x;
}
# 188 "/usr/local/include/SDL2/SDL_endian.h" 3
__attribute__((always_inline)) static __inline__ Uint64
SDL_Swap64(Uint64 x)
{
  __asm__("bswapq %0": "=r"(x):"0"(x));
    return x;
}
# 212 "/usr/local/include/SDL2/SDL_endian.h" 3
__attribute__((always_inline)) static __inline__ float
SDL_SwapFloat(float x)
{
    union
    {
        float f;
        Uint32 ui32;
    } swapper;
    swapper.f = x;
    swapper.ui32 = SDL_Swap32(swapper.ui32);
    return swapper.f;
}
# 254 "/usr/local/include/SDL2/SDL_endian.h" 3
}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 257 "/usr/local/include/SDL2/SDL_endian.h" 2 3
# 34 "/usr/local/include/SDL2/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_mutex.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_mutex.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 35 "/usr/local/include/SDL2/SDL_mutex.h" 2 3


extern "C" {
# 58 "/usr/local/include/SDL2/SDL_mutex.h" 3
struct SDL_mutex;
typedef struct SDL_mutex SDL_mutex;




extern __attribute__ ((visibility("default"))) SDL_mutex * SDL_CreateMutex(void);







extern __attribute__ ((visibility("default"))) int SDL_LockMutex(SDL_mutex * mutex);






extern __attribute__ ((visibility("default"))) int SDL_TryLockMutex(SDL_mutex * mutex);
# 90 "/usr/local/include/SDL2/SDL_mutex.h" 3
extern __attribute__ ((visibility("default"))) int SDL_UnlockMutex(SDL_mutex * mutex);




extern __attribute__ ((visibility("default"))) void SDL_DestroyMutex(SDL_mutex * mutex);
# 106 "/usr/local/include/SDL2/SDL_mutex.h" 3
struct SDL_semaphore;
typedef struct SDL_semaphore SDL_sem;




extern __attribute__ ((visibility("default"))) SDL_sem * SDL_CreateSemaphore(Uint32 initial_value);




extern __attribute__ ((visibility("default"))) void SDL_DestroySemaphore(SDL_sem * sem);






extern __attribute__ ((visibility("default"))) int SDL_SemWait(SDL_sem * sem);







extern __attribute__ ((visibility("default"))) int SDL_SemTryWait(SDL_sem * sem);
# 143 "/usr/local/include/SDL2/SDL_mutex.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms);






extern __attribute__ ((visibility("default"))) int SDL_SemPost(SDL_sem * sem);




extern __attribute__ ((visibility("default"))) Uint32 SDL_SemValue(SDL_sem * sem);
# 166 "/usr/local/include/SDL2/SDL_mutex.h" 3
struct SDL_cond;
typedef struct SDL_cond SDL_cond;
# 197 "/usr/local/include/SDL2/SDL_mutex.h" 3
extern __attribute__ ((visibility("default"))) SDL_cond * SDL_CreateCond(void);




extern __attribute__ ((visibility("default"))) void SDL_DestroyCond(SDL_cond * cond);






extern __attribute__ ((visibility("default"))) int SDL_CondSignal(SDL_cond * cond);






extern __attribute__ ((visibility("default"))) int SDL_CondBroadcast(SDL_cond * cond);
# 227 "/usr/local/include/SDL2/SDL_mutex.h" 3
extern __attribute__ ((visibility("default"))) int SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex);
# 237 "/usr/local/include/SDL2/SDL_mutex.h" 3
extern __attribute__ ((visibility("default"))) int SDL_CondWaitTimeout(SDL_cond * cond,
                                                SDL_mutex * mutex, Uint32 ms);






}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 248 "/usr/local/include/SDL2/SDL_mutex.h" 2 3
# 35 "/usr/local/include/SDL2/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_thread.h" 1 3
# 38 "/usr/local/include/SDL2/SDL_thread.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 39 "/usr/local/include/SDL2/SDL_thread.h" 2 3


extern "C" {



struct SDL_Thread;
typedef struct SDL_Thread SDL_Thread;


typedef unsigned long SDL_threadID;


typedef unsigned int SDL_TLSID;






typedef enum {
    SDL_THREAD_PRIORITY_LOW,
    SDL_THREAD_PRIORITY_NORMAL,
    SDL_THREAD_PRIORITY_HIGH
} SDL_ThreadPriority;





typedef int ( * SDL_ThreadFunction) (void *data);
# 162 "/usr/local/include/SDL2/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) SDL_Thread *
SDL_CreateThread(SDL_ThreadFunction fn, const char *name, void *data);
# 174 "/usr/local/include/SDL2/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetThreadName(SDL_Thread *thread);




extern __attribute__ ((visibility("default"))) SDL_threadID SDL_ThreadID(void);






extern __attribute__ ((visibility("default"))) SDL_threadID SDL_GetThreadID(SDL_Thread * thread);




extern __attribute__ ((visibility("default"))) int SDL_SetThreadPriority(SDL_ThreadPriority priority);
# 211 "/usr/local/include/SDL2/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) void SDL_WaitThread(SDL_Thread * thread, int *status);
# 239 "/usr/local/include/SDL2/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) void SDL_DetachThread(SDL_Thread * thread);
# 271 "/usr/local/include/SDL2/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) SDL_TLSID SDL_TLSCreate(void);
# 283 "/usr/local/include/SDL2/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) void * SDL_TLSGet(SDL_TLSID id);
# 297 "/usr/local/include/SDL2/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) int SDL_TLSSet(SDL_TLSID id, const void *value, void ( *destructor)(void*));




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 305 "/usr/local/include/SDL2/SDL_thread.h" 2 3
# 36 "/usr/local/include/SDL2/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_rwops.h" 1 3
# 35 "/usr/local/include/SDL2/SDL_rwops.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 36 "/usr/local/include/SDL2/SDL_rwops.h" 2 3


extern "C" {
# 52 "/usr/local/include/SDL2/SDL_rwops.h" 3
typedef struct SDL_RWops
{



    Sint64 ( * size) (struct SDL_RWops * context);







    Sint64 ( * seek) (struct SDL_RWops * context, Sint64 offset,
                             int whence);







    size_t ( * read) (struct SDL_RWops * context, void *ptr,
                             size_t size, size_t maxnum);







    size_t ( * write) (struct SDL_RWops * context, const void *ptr,
                              size_t size, size_t num);






    int ( * close) (struct SDL_RWops * context);

    Uint32 type;
    union
    {
# 124 "/usr/local/include/SDL2/SDL_rwops.h" 3
        struct
        {
            SDL_bool autoclose;
            FILE *fp;
        } stdio;

        struct
        {
            Uint8 *base;
            Uint8 *here;
            Uint8 *stop;
        } mem;
        struct
        {
            void *data1;
            void *data2;
        } unknown;
    } hidden;

} SDL_RWops;
# 153 "/usr/local/include/SDL2/SDL_rwops.h" 3
extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromFile(const char *file,
                                                  const char *mode);


extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromFP(FILE * fp,
                                                SDL_bool autoclose);





extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromMem(void *mem, int size);
extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromConstMem(const void *mem,
                                                      int size);




extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_AllocRW(void);
extern __attribute__ ((visibility("default"))) void SDL_FreeRW(SDL_RWops * area);
# 206 "/usr/local/include/SDL2/SDL_rwops.h" 3
extern __attribute__ ((visibility("default"))) void * SDL_LoadFile_RW(SDL_RWops * src, size_t *datasize,
                                                    int freesrc);
# 222 "/usr/local/include/SDL2/SDL_rwops.h" 3
extern __attribute__ ((visibility("default"))) Uint8 SDL_ReadU8(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint16 SDL_ReadLE16(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint16 SDL_ReadBE16(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint32 SDL_ReadLE32(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint32 SDL_ReadBE32(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint64 SDL_ReadLE64(SDL_RWops * src);
extern __attribute__ ((visibility("default"))) Uint64 SDL_ReadBE64(SDL_RWops * src);
# 237 "/usr/local/include/SDL2/SDL_rwops.h" 3
extern __attribute__ ((visibility("default"))) size_t SDL_WriteU8(SDL_RWops * dst, Uint8 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteLE16(SDL_RWops * dst, Uint16 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteBE16(SDL_RWops * dst, Uint16 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteLE32(SDL_RWops * dst, Uint32 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteBE32(SDL_RWops * dst, Uint32 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteLE64(SDL_RWops * dst, Uint64 value);
extern __attribute__ ((visibility("default"))) size_t SDL_WriteBE64(SDL_RWops * dst, Uint64 value);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 251 "/usr/local/include/SDL2/SDL_rwops.h" 2 3
# 37 "/usr/local/include/SDL2/SDL_audio.h" 2 3

# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 39 "/usr/local/include/SDL2/SDL_audio.h" 2 3


extern "C" {
# 64 "/usr/local/include/SDL2/SDL_audio.h" 3
typedef Uint16 SDL_AudioFormat;
# 162 "/usr/local/include/SDL2/SDL_audio.h" 3
typedef void ( * SDL_AudioCallback) (void *userdata, Uint8 * stream,
                                            int len);
# 177 "/usr/local/include/SDL2/SDL_audio.h" 3
typedef struct SDL_AudioSpec
{
    int freq;
    SDL_AudioFormat format;
    Uint8 channels;
    Uint8 silence;
    Uint16 samples;
    Uint16 padding;
    Uint32 size;
    SDL_AudioCallback callback;
    void *userdata;
} SDL_AudioSpec;


struct SDL_AudioCVT;
typedef void ( * SDL_AudioFilter) (struct SDL_AudioCVT * cvt,
                                          SDL_AudioFormat format);
# 225 "/usr/local/include/SDL2/SDL_audio.h" 3
typedef struct SDL_AudioCVT
{
    int needed;
    SDL_AudioFormat src_format;
    SDL_AudioFormat dst_format;
    double rate_incr;
    Uint8 *buf;
    int len;
    int len_cvt;
    int len_mult;
    double len_ratio;
    SDL_AudioFilter filters[9 + 1];
    int filter_index;
} __attribute__((packed)) SDL_AudioCVT;
# 250 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetNumAudioDrivers(void);
extern __attribute__ ((visibility("default"))) const char * SDL_GetAudioDriver(int index);
# 262 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_AudioInit(const char *driver_name);
extern __attribute__ ((visibility("default"))) void SDL_AudioQuit(void);






extern __attribute__ ((visibility("default"))) const char * SDL_GetCurrentAudioDriver(void);
# 317 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_OpenAudio(SDL_AudioSpec * desired,
                                          SDL_AudioSpec * obtained);
# 329 "/usr/local/include/SDL2/SDL_audio.h" 3
typedef Uint32 SDL_AudioDeviceID;
# 343 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetNumAudioDevices(int iscapture);
# 358 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetAudioDeviceName(int index,
                                                           int iscapture);
# 375 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) SDL_AudioDeviceID SDL_OpenAudioDevice(const char
                                                              *device,
                                                              int iscapture,
                                                              const
                                                              SDL_AudioSpec *
                                                              desired,
                                                              SDL_AudioSpec *
                                                              obtained,
                                                              int
                                                              allowed_changes);
# 394 "/usr/local/include/SDL2/SDL_audio.h" 3
typedef enum
{
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING,
    SDL_AUDIO_PAUSED
} SDL_AudioStatus;
extern __attribute__ ((visibility("default"))) SDL_AudioStatus SDL_GetAudioStatus(void);

extern __attribute__ ((visibility("default"))) SDL_AudioStatus
SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev);
# 416 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_PauseAudio(int pause_on);
extern __attribute__ ((visibility("default"))) void SDL_PauseAudioDevice(SDL_AudioDeviceID dev,
                                                  int pause_on);
# 440 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops * src,
                                                      int freesrc,
                                                      SDL_AudioSpec * spec,
                                                      Uint8 ** audio_buf,
                                                      Uint32 * audio_len);
# 456 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_FreeWAV(Uint8 * audio_buf);
# 467 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_BuildAudioCVT(SDL_AudioCVT * cvt,
                                              SDL_AudioFormat src_format,
                                              Uint8 src_channels,
                                              int src_rate,
                                              SDL_AudioFormat dst_format,
                                              Uint8 dst_channels,
                                              int dst_rate);
# 487 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_ConvertAudio(SDL_AudioCVT * cvt);
# 497 "/usr/local/include/SDL2/SDL_audio.h" 3
struct _SDL_AudioStream;
typedef struct _SDL_AudioStream SDL_AudioStream;
# 518 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) SDL_AudioStream * SDL_NewAudioStream(const SDL_AudioFormat src_format,
                                           const Uint8 src_channels,
                                           const int src_rate,
                                           const SDL_AudioFormat dst_format,
                                           const Uint8 dst_channels,
                                           const int dst_rate);
# 540 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamPut(SDL_AudioStream *stream, const void *buf, int len);
# 557 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamGet(SDL_AudioStream *stream, void *buf, int len);
# 572 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamAvailable(SDL_AudioStream *stream);
# 589 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_AudioStreamFlush(SDL_AudioStream *stream);
# 601 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_AudioStreamClear(SDL_AudioStream *stream);
# 613 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_FreeAudioStream(SDL_AudioStream *stream);
# 623 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_MixAudio(Uint8 * dst, const Uint8 * src,
                                          Uint32 len, int volume);






extern __attribute__ ((visibility("default"))) void SDL_MixAudioFormat(Uint8 * dst,
                                                const Uint8 * src,
                                                SDL_AudioFormat format,
                                                Uint32 len, int volume);
# 675 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_QueueAudio(SDL_AudioDeviceID dev, const void *data, Uint32 len);
# 721 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_DequeueAudio(SDL_AudioDeviceID dev, void *data, Uint32 len);
# 757 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetQueuedAudioSize(SDL_AudioDeviceID dev);
# 793 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_ClearQueuedAudio(SDL_AudioDeviceID dev);
# 805 "/usr/local/include/SDL2/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_LockAudio(void);
extern __attribute__ ((visibility("default"))) void SDL_LockAudioDevice(SDL_AudioDeviceID dev);
extern __attribute__ ((visibility("default"))) void SDL_UnlockAudio(void);
extern __attribute__ ((visibility("default"))) void SDL_UnlockAudioDevice(SDL_AudioDeviceID dev);





extern __attribute__ ((visibility("default"))) void SDL_CloseAudio(void);
extern __attribute__ ((visibility("default"))) void SDL_CloseAudioDevice(SDL_AudioDeviceID dev);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 822 "/usr/local/include/SDL2/SDL_audio.h" 2 3
# 37 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_clipboard.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_clipboard.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_clipboard.h" 2 3


extern "C" {
# 46 "/usr/local/include/SDL2/SDL_clipboard.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetClipboardText(const char *text);






extern __attribute__ ((visibility("default"))) char * SDL_GetClipboardText(void);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasClipboardText(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 68 "/usr/local/include/SDL2/SDL_clipboard.h" 2 3
# 38 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_cpuinfo.h" 1 3
# 64 "/usr/local/include/SDL2/SDL_cpuinfo.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/immintrin.h" 1 3 4
# 65 "/usr/local/include/SDL2/SDL_cpuinfo.h" 2 3
# 81 "/usr/local/include/SDL2/SDL_cpuinfo.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 82 "/usr/local/include/SDL2/SDL_cpuinfo.h" 2 3


extern "C" {
# 97 "/usr/local/include/SDL2/SDL_cpuinfo.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetCPUCount(void);







extern __attribute__ ((visibility("default"))) int SDL_GetCPUCacheLineSize(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasRDTSC(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasAltiVec(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasMMX(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_Has3DNow(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE2(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE3(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE41(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE42(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasAVX(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasAVX2(void);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasNEON(void);




extern __attribute__ ((visibility("default"))) int SDL_GetSystemRAM(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 178 "/usr/local/include/SDL2/SDL_cpuinfo.h" 2 3
# 39 "/usr/local/include/SDL2/SDL.h" 2 3


# 1 "/usr/local/include/SDL2/SDL_events.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_events.h" 3
# 1 "/usr/local/include/SDL2/SDL_video.h" 1 3
# 32 "/usr/local/include/SDL2/SDL_video.h" 3
# 1 "/usr/local/include/SDL2/SDL_pixels.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_pixels.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 35 "/usr/local/include/SDL2/SDL_pixels.h" 2 3


extern "C" {
# 51 "/usr/local/include/SDL2/SDL_pixels.h" 3
enum
{
    SDL_PIXELTYPE_UNKNOWN,
    SDL_PIXELTYPE_INDEX1,
    SDL_PIXELTYPE_INDEX4,
    SDL_PIXELTYPE_INDEX8,
    SDL_PIXELTYPE_PACKED8,
    SDL_PIXELTYPE_PACKED16,
    SDL_PIXELTYPE_PACKED32,
    SDL_PIXELTYPE_ARRAYU8,
    SDL_PIXELTYPE_ARRAYU16,
    SDL_PIXELTYPE_ARRAYU32,
    SDL_PIXELTYPE_ARRAYF16,
    SDL_PIXELTYPE_ARRAYF32
};


enum
{
    SDL_BITMAPORDER_NONE,
    SDL_BITMAPORDER_4321,
    SDL_BITMAPORDER_1234
};


enum
{
    SDL_PACKEDORDER_NONE,
    SDL_PACKEDORDER_XRGB,
    SDL_PACKEDORDER_RGBX,
    SDL_PACKEDORDER_ARGB,
    SDL_PACKEDORDER_RGBA,
    SDL_PACKEDORDER_XBGR,
    SDL_PACKEDORDER_BGRX,
    SDL_PACKEDORDER_ABGR,
    SDL_PACKEDORDER_BGRA
};




enum
{
    SDL_ARRAYORDER_NONE,
    SDL_ARRAYORDER_RGB,
    SDL_ARRAYORDER_RGBA,
    SDL_ARRAYORDER_ARGB,
    SDL_ARRAYORDER_BGR,
    SDL_ARRAYORDER_BGRA,
    SDL_ARRAYORDER_ABGR
};


enum
{
    SDL_PACKEDLAYOUT_NONE,
    SDL_PACKEDLAYOUT_332,
    SDL_PACKEDLAYOUT_4444,
    SDL_PACKEDLAYOUT_1555,
    SDL_PACKEDLAYOUT_5551,
    SDL_PACKEDLAYOUT_565,
    SDL_PACKEDLAYOUT_8888,
    SDL_PACKEDLAYOUT_2101010,
    SDL_PACKEDLAYOUT_1010102
};
# 171 "/usr/local/include/SDL2/SDL_pixels.h" 3
enum
{
    SDL_PIXELFORMAT_UNKNOWN,
    SDL_PIXELFORMAT_INDEX1LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX1MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX4LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX4MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX8 =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX8) << 24) | ((0) << 20) | ((0) << 16) | ((8) << 8) | ((1) << 0)),
    SDL_PIXELFORMAT_RGB332 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED8) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_332) << 16) | ((8) << 8) | ((1) << 0)),

    SDL_PIXELFORMAT_RGB444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((12) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGR555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ARGB4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGBA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ABGR4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGRA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ARGB1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGBA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ABGR1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGRA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGR565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_RGB) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),

    SDL_PIXELFORMAT_BGR24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_BGR) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),

    SDL_PIXELFORMAT_RGB888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_RGBX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGR888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGRX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ARGB8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_RGBA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ABGR8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGRA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ARGB2101010 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_2101010) << 16) | ((32) << 8) | ((4) << 0)),
# 271 "/usr/local/include/SDL2/SDL_pixels.h" 3
    SDL_PIXELFORMAT_RGBA32 = SDL_PIXELFORMAT_ABGR8888,
    SDL_PIXELFORMAT_ARGB32 = SDL_PIXELFORMAT_BGRA8888,
    SDL_PIXELFORMAT_BGRA32 = SDL_PIXELFORMAT_ARGB8888,
    SDL_PIXELFORMAT_ABGR32 = SDL_PIXELFORMAT_RGBA8888,


    SDL_PIXELFORMAT_YV12 =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_IYUV =
        ((static_cast<Uint32>(static_cast<Uint8>(('I'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 24)),
    SDL_PIXELFORMAT_YUY2 =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_UYVY =
        ((static_cast<Uint32>(static_cast<Uint8>(('U'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 24)),
    SDL_PIXELFORMAT_YVYU =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 24)),
    SDL_PIXELFORMAT_NV12 =
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_NV21 =
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 24)),
    SDL_PIXELFORMAT_EXTERNAL_OES =
        ((static_cast<Uint32>(static_cast<Uint8>(('O'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('E'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('S'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>((' '))) << 24))
};

typedef struct SDL_Color
{
    Uint8 r;
    Uint8 g;
    Uint8 b;
    Uint8 a;
} SDL_Color;


typedef struct SDL_Palette
{
    int ncolors;
    SDL_Color *colors;
    Uint32 version;
    int refcount;
} SDL_Palette;




typedef struct SDL_PixelFormat
{
    Uint32 format;
    SDL_Palette *palette;
    Uint8 BitsPerPixel;
    Uint8 BytesPerPixel;
    Uint8 padding[2];
    Uint32 Rmask;
    Uint32 Gmask;
    Uint32 Bmask;
    Uint32 Amask;
    Uint8 Rloss;
    Uint8 Gloss;
    Uint8 Bloss;
    Uint8 Aloss;
    Uint8 Rshift;
    Uint8 Gshift;
    Uint8 Bshift;
    Uint8 Ashift;
    int refcount;
    struct SDL_PixelFormat *next;
} SDL_PixelFormat;




extern __attribute__ ((visibility("default"))) const char* SDL_GetPixelFormatName(Uint32 format);
# 350 "/usr/local/include/SDL2/SDL_pixels.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_PixelFormatEnumToMasks(Uint32 format,
                                                            int *bpp,
                                                            Uint32 * Rmask,
                                                            Uint32 * Gmask,
                                                            Uint32 * Bmask,
                                                            Uint32 * Amask);
# 365 "/usr/local/include/SDL2/SDL_pixels.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_MasksToPixelFormatEnum(int bpp,
                                                          Uint32 Rmask,
                                                          Uint32 Gmask,
                                                          Uint32 Bmask,
                                                          Uint32 Amask);




extern __attribute__ ((visibility("default"))) SDL_PixelFormat * SDL_AllocFormat(Uint32 pixel_format);




extern __attribute__ ((visibility("default"))) void SDL_FreeFormat(SDL_PixelFormat *format);
# 391 "/usr/local/include/SDL2/SDL_pixels.h" 3
extern __attribute__ ((visibility("default"))) SDL_Palette * SDL_AllocPalette(int ncolors);




extern __attribute__ ((visibility("default"))) int SDL_SetPixelFormatPalette(SDL_PixelFormat * format,
                                                      SDL_Palette *palette);
# 409 "/usr/local/include/SDL2/SDL_pixels.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetPaletteColors(SDL_Palette * palette,
                                                 const SDL_Color * colors,
                                                 int firstcolor, int ncolors);






extern __attribute__ ((visibility("default"))) void SDL_FreePalette(SDL_Palette * palette);






extern __attribute__ ((visibility("default"))) Uint32 SDL_MapRGB(const SDL_PixelFormat * format,
                                          Uint8 r, Uint8 g, Uint8 b);






extern __attribute__ ((visibility("default"))) Uint32 SDL_MapRGBA(const SDL_PixelFormat * format,
                                           Uint8 r, Uint8 g, Uint8 b,
                                           Uint8 a);






extern __attribute__ ((visibility("default"))) void SDL_GetRGB(Uint32 pixel,
                                        const SDL_PixelFormat * format,
                                        Uint8 * r, Uint8 * g, Uint8 * b);






extern __attribute__ ((visibility("default"))) void SDL_GetRGBA(Uint32 pixel,
                                         const SDL_PixelFormat * format,
                                         Uint8 * r, Uint8 * g, Uint8 * b,
                                         Uint8 * a);




extern __attribute__ ((visibility("default"))) void SDL_CalculateGammaRamp(float gamma, Uint16 * ramp);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 467 "/usr/local/include/SDL2/SDL_pixels.h" 2 3
# 33 "/usr/local/include/SDL2/SDL_video.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_rect.h" 1 3
# 36 "/usr/local/include/SDL2/SDL_rect.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 37 "/usr/local/include/SDL2/SDL_rect.h" 2 3


extern "C" {
# 48 "/usr/local/include/SDL2/SDL_rect.h" 3
typedef struct SDL_Point
{
    int x;
    int y;
} SDL_Point;
# 64 "/usr/local/include/SDL2/SDL_rect.h" 3
typedef struct SDL_Rect
{
    int x, y;
    int w, h;
} SDL_Rect;




__attribute__((always_inline)) static __inline__ SDL_bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)
{
    return ( (p->x >= r->x) && (p->x < (r->x + r->w)) &&
             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? SDL_TRUE : SDL_FALSE;
}




__attribute__((always_inline)) static __inline__ SDL_bool SDL_RectEmpty(const SDL_Rect *r)
{
    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? SDL_TRUE : SDL_FALSE;
}




__attribute__((always_inline)) static __inline__ SDL_bool SDL_RectEquals(const SDL_Rect *a, const SDL_Rect *b)
{
    return (a && b && (a->x == b->x) && (a->y == b->y) &&
            (a->w == b->w) && (a->h == b->h)) ? SDL_TRUE : SDL_FALSE;
}






extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasIntersection(const SDL_Rect * A,
                                                     const SDL_Rect * B);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_IntersectRect(const SDL_Rect * A,
                                                   const SDL_Rect * B,
                                                   SDL_Rect * result);




extern __attribute__ ((visibility("default"))) void SDL_UnionRect(const SDL_Rect * A,
                                           const SDL_Rect * B,
                                           SDL_Rect * result);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_EnclosePoints(const SDL_Point * points,
                                                   int count,
                                                   const SDL_Rect * clip,
                                                   SDL_Rect * result);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_IntersectRectAndLine(const SDL_Rect *
                                                          rect, int *X1,
                                                          int *Y1, int *X2,
                                                          int *Y2);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 145 "/usr/local/include/SDL2/SDL_rect.h" 2 3
# 34 "/usr/local/include/SDL2/SDL_video.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_surface.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_surface.h" 3
# 1 "/usr/local/include/SDL2/SDL_blendmode.h" 1 3
# 31 "/usr/local/include/SDL2/SDL_blendmode.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 32 "/usr/local/include/SDL2/SDL_blendmode.h" 2 3


extern "C" {





typedef enum
{
    SDL_BLENDMODE_NONE = 0x00000000,

    SDL_BLENDMODE_BLEND = 0x00000001,


    SDL_BLENDMODE_ADD = 0x00000002,


    SDL_BLENDMODE_MOD = 0x00000004,


    SDL_BLENDMODE_INVALID = 0x7FFFFFFF



} SDL_BlendMode;




typedef enum
{
    SDL_BLENDOPERATION_ADD = 0x1,
    SDL_BLENDOPERATION_SUBTRACT = 0x2,
    SDL_BLENDOPERATION_REV_SUBTRACT = 0x3,
    SDL_BLENDOPERATION_MINIMUM = 0x4,
    SDL_BLENDOPERATION_MAXIMUM = 0x5

} SDL_BlendOperation;




typedef enum
{
    SDL_BLENDFACTOR_ZERO = 0x1,
    SDL_BLENDFACTOR_ONE = 0x2,
    SDL_BLENDFACTOR_SRC_COLOR = 0x3,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 0x4,
    SDL_BLENDFACTOR_SRC_ALPHA = 0x5,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 0x6,
    SDL_BLENDFACTOR_DST_COLOR = 0x7,
    SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 0x8,
    SDL_BLENDFACTOR_DST_ALPHA = 0x9,
    SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 0xA

} SDL_BlendFactor;
# 105 "/usr/local/include/SDL2/SDL_blendmode.h" 3
extern __attribute__ ((visibility("default"))) SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor,
                                                                 SDL_BlendFactor dstColorFactor,
                                                                 SDL_BlendOperation colorOperation,
                                                                 SDL_BlendFactor srcAlphaFactor,
                                                                 SDL_BlendFactor dstAlphaFactor,
                                                                 SDL_BlendOperation alphaOperation);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 117 "/usr/local/include/SDL2/SDL_blendmode.h" 2 3
# 35 "/usr/local/include/SDL2/SDL_surface.h" 2 3


# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 38 "/usr/local/include/SDL2/SDL_surface.h" 2 3


extern "C" {
# 69 "/usr/local/include/SDL2/SDL_surface.h" 3
typedef struct SDL_Surface
{
    Uint32 flags;
    SDL_PixelFormat *format;
    int w, h;
    int pitch;
    void *pixels;


    void *userdata;


    int locked;
    void *lock_data;


    SDL_Rect clip_rect;


    struct SDL_BlitMap *map;


    int refcount;
} SDL_Surface;




typedef int ( *SDL_blit) (struct SDL_Surface * src, SDL_Rect * srcrect,
                                 struct SDL_Surface * dst, SDL_Rect * dstrect);




typedef enum
{
    SDL_YUV_CONVERSION_JPEG,
    SDL_YUV_CONVERSION_BT601,
    SDL_YUV_CONVERSION_BT709,
    SDL_YUV_CONVERSION_AUTOMATIC
} SDL_YUV_CONVERSION_MODE;
# 129 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurface
    (Uint32 flags, int width, int height, int depth,
     Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);


extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurfaceWithFormat
    (Uint32 flags, int width, int height, int depth, Uint32 format);

extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurfaceFrom(void *pixels,
                                                              int width,
                                                              int height,
                                                              int depth,
                                                              int pitch,
                                                              Uint32 Rmask,
                                                              Uint32 Gmask,
                                                              Uint32 Bmask,
                                                              Uint32 Amask);
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurfaceWithFormatFrom
    (void *pixels, int width, int height, int depth, int pitch, Uint32 format);
extern __attribute__ ((visibility("default"))) void SDL_FreeSurface(SDL_Surface * surface);
# 157 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetSurfacePalette(SDL_Surface * surface,
                                                  SDL_Palette * palette);
# 179 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_LockSurface(SDL_Surface * surface);

extern __attribute__ ((visibility("default"))) void SDL_UnlockSurface(SDL_Surface * surface);
# 192 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_LoadBMP_RW(SDL_RWops * src,
                                                    int freesrc);
# 215 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SaveBMP_RW
    (SDL_Surface * surface, SDL_RWops * dst, int freedst);
# 234 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceRLE(SDL_Surface * surface,
                                              int flag);
# 248 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetColorKey(SDL_Surface * surface,
                                            int flag, Uint32 key);
# 261 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetColorKey(SDL_Surface * surface,
                                            Uint32 * key);
# 276 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 r, Uint8 g, Uint8 b);
# 292 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 * r, Uint8 * g,
                                                   Uint8 * b);
# 306 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 alpha);
# 319 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 * alpha);
# 332 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode blendMode);
# 345 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode *blendMode);
# 361 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_SetClipRect(SDL_Surface * surface,
                                                 const SDL_Rect * rect);







extern __attribute__ ((visibility("default"))) void SDL_GetClipRect(SDL_Surface * surface,
                                             SDL_Rect * rect);




extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_DuplicateSurface(SDL_Surface * surface);
# 388 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_ConvertSurface
    (SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags);
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_ConvertSurfaceFormat
    (SDL_Surface * src, Uint32 pixel_format, Uint32 flags);






extern __attribute__ ((visibility("default"))) int SDL_ConvertPixels(int width, int height,
                                              Uint32 src_format,
                                              const void * src, int src_pitch,
                                              Uint32 dst_format,
                                              void * dst, int dst_pitch);
# 414 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_FillRect
    (SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);
extern __attribute__ ((visibility("default"))) int SDL_FillRects
    (SDL_Surface * dst, const SDL_Rect * rects, int count, Uint32 color);
# 482 "/usr/local/include/SDL2/SDL_surface.h" 3
extern __attribute__ ((visibility("default"))) int SDL_UpperBlit
    (SDL_Surface * src, const SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);





extern __attribute__ ((visibility("default"))) int SDL_LowerBlit
    (SDL_Surface * src, SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);







extern __attribute__ ((visibility("default"))) int SDL_SoftStretch(SDL_Surface * src,
                                            const SDL_Rect * srcrect,
                                            SDL_Surface * dst,
                                            const SDL_Rect * dstrect);







extern __attribute__ ((visibility("default"))) int SDL_UpperBlitScaled
    (SDL_Surface * src, const SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);





extern __attribute__ ((visibility("default"))) int SDL_LowerBlitScaled
    (SDL_Surface * src, SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);




extern __attribute__ ((visibility("default"))) void SDL_SetYUVConversionMode(SDL_YUV_CONVERSION_MODE mode);




extern __attribute__ ((visibility("default"))) SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionMode(void);




extern __attribute__ ((visibility("default"))) SDL_YUV_CONVERSION_MODE SDL_GetYUVConversionModeForResolution(int width, int height);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 543 "/usr/local/include/SDL2/SDL_surface.h" 2 3
# 35 "/usr/local/include/SDL2/SDL_video.h" 2 3

# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 37 "/usr/local/include/SDL2/SDL_video.h" 2 3


extern "C" {
# 53 "/usr/local/include/SDL2/SDL_video.h" 3
typedef struct
{
    Uint32 format;
    int w;
    int h;
    int refresh_rate;
    void *driverdata;
} SDL_DisplayMode;
# 90 "/usr/local/include/SDL2/SDL_video.h" 3
typedef struct SDL_Window SDL_Window;






typedef enum
{

    SDL_WINDOW_FULLSCREEN = 0x00000001,
    SDL_WINDOW_OPENGL = 0x00000002,
    SDL_WINDOW_SHOWN = 0x00000004,
    SDL_WINDOW_HIDDEN = 0x00000008,
    SDL_WINDOW_BORDERLESS = 0x00000010,
    SDL_WINDOW_RESIZABLE = 0x00000020,
    SDL_WINDOW_MINIMIZED = 0x00000040,
    SDL_WINDOW_MAXIMIZED = 0x00000080,
    SDL_WINDOW_INPUT_GRABBED = 0x00000100,
    SDL_WINDOW_INPUT_FOCUS = 0x00000200,
    SDL_WINDOW_MOUSE_FOCUS = 0x00000400,
    SDL_WINDOW_FULLSCREEN_DESKTOP = ( SDL_WINDOW_FULLSCREEN | 0x00001000 ),
    SDL_WINDOW_FOREIGN = 0x00000800,
    SDL_WINDOW_ALLOW_HIGHDPI = 0x00002000,


    SDL_WINDOW_MOUSE_CAPTURE = 0x00004000,
    SDL_WINDOW_ALWAYS_ON_TOP = 0x00008000,
    SDL_WINDOW_SKIP_TASKBAR = 0x00010000,
    SDL_WINDOW_UTILITY = 0x00020000,
    SDL_WINDOW_TOOLTIP = 0x00040000,
    SDL_WINDOW_POPUP_MENU = 0x00080000,
    SDL_WINDOW_VULKAN = 0x10000000
} SDL_WindowFlags;
# 146 "/usr/local/include/SDL2/SDL_video.h" 3
typedef enum
{
    SDL_WINDOWEVENT_NONE,
    SDL_WINDOWEVENT_SHOWN,
    SDL_WINDOWEVENT_HIDDEN,
    SDL_WINDOWEVENT_EXPOSED,

    SDL_WINDOWEVENT_MOVED,

    SDL_WINDOWEVENT_RESIZED,
    SDL_WINDOWEVENT_SIZE_CHANGED,


    SDL_WINDOWEVENT_MINIMIZED,
    SDL_WINDOWEVENT_MAXIMIZED,
    SDL_WINDOWEVENT_RESTORED,

    SDL_WINDOWEVENT_ENTER,
    SDL_WINDOWEVENT_LEAVE,
    SDL_WINDOWEVENT_FOCUS_GAINED,
    SDL_WINDOWEVENT_FOCUS_LOST,
    SDL_WINDOWEVENT_CLOSE,
    SDL_WINDOWEVENT_TAKE_FOCUS,
    SDL_WINDOWEVENT_HIT_TEST
} SDL_WindowEventID;




typedef void *SDL_GLContext;




typedef enum
{
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES,
    SDL_GL_ACCELERATED_VISUAL,
    SDL_GL_RETAINED_BACKING,
    SDL_GL_CONTEXT_MAJOR_VERSION,
    SDL_GL_CONTEXT_MINOR_VERSION,
    SDL_GL_CONTEXT_EGL,
    SDL_GL_CONTEXT_FLAGS,
    SDL_GL_CONTEXT_PROFILE_MASK,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
    SDL_GL_CONTEXT_RESET_NOTIFICATION,
    SDL_GL_CONTEXT_NO_ERROR
} SDL_GLattr;

typedef enum
{
    SDL_GL_CONTEXT_PROFILE_CORE = 0x0001,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 0x0002,
    SDL_GL_CONTEXT_PROFILE_ES = 0x0004
} SDL_GLprofile;

typedef enum
{
    SDL_GL_CONTEXT_DEBUG_FLAG = 0x0001,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 0x0004,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 0x0008
} SDL_GLcontextFlag;

typedef enum
{
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0x0000,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x0001
} SDL_GLcontextReleaseFlag;

typedef enum
{
    SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000,
    SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 0x0001
} SDL_GLContextResetNotification;
# 245 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetNumVideoDrivers(void);
# 255 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetVideoDriver(int index);
# 271 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_VideoInit(const char *driver_name);
# 280 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_VideoQuit(void);
# 291 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetCurrentVideoDriver(void);






extern __attribute__ ((visibility("default"))) int SDL_GetNumVideoDisplays(void);
# 307 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetDisplayName(int displayIndex);
# 317 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect);
# 329 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayDPI(int displayIndex, float * ddpi, float * hdpi, float * vdpi);
# 348 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayUsableBounds(int displayIndex, SDL_Rect * rect);






extern __attribute__ ((visibility("default"))) int SDL_GetNumDisplayModes(int displayIndex);
# 368 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetDisplayMode(int displayIndex, int modeIndex,
                                               SDL_DisplayMode * mode);




extern __attribute__ ((visibility("default"))) int SDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode * mode);




extern __attribute__ ((visibility("default"))) int SDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode * mode);
# 403 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_DisplayMode * SDL_GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode * mode, SDL_DisplayMode * closest);







extern __attribute__ ((visibility("default"))) int SDL_GetWindowDisplayIndex(SDL_Window * window);
# 427 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowDisplayMode(SDL_Window * window,
                                                     const SDL_DisplayMode
                                                         * mode);
# 438 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetWindowDisplayMode(SDL_Window * window,
                                                     SDL_DisplayMode * mode);




extern __attribute__ ((visibility("default"))) Uint32 SDL_GetWindowPixelFormat(SDL_Window * window);
# 488 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_CreateWindow(const char *title,
                                                      int x, int y, int w,
                                                      int h, Uint32 flags);
# 501 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_CreateWindowFrom(const void *data);




extern __attribute__ ((visibility("default"))) Uint32 SDL_GetWindowID(SDL_Window * window);




extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetWindowFromID(Uint32 id);




extern __attribute__ ((visibility("default"))) Uint32 SDL_GetWindowFlags(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_SetWindowTitle(SDL_Window * window,
                                                const char *title);






extern __attribute__ ((visibility("default"))) const char * SDL_GetWindowTitle(SDL_Window * window);







extern __attribute__ ((visibility("default"))) void SDL_SetWindowIcon(SDL_Window * window,
                                               SDL_Surface * icon);
# 555 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void* SDL_SetWindowData(SDL_Window * window,
                                                const char *name,
                                                void *userdata);
# 569 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void * SDL_GetWindowData(SDL_Window * window,
                                                const char *name);
# 585 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetWindowPosition(SDL_Window * window,
                                                   int x, int y);
# 599 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_GetWindowPosition(SDL_Window * window,
                                                   int *x, int *y);
# 620 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetWindowSize(SDL_Window * window, int w,
                                               int h);
# 639 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_GetWindowSize(SDL_Window * window, int *w,
                                               int *h);
# 657 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetWindowBordersSize(SDL_Window * window,
                                                     int *top, int *left,
                                                     int *bottom, int *right);
# 674 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetWindowMinimumSize(SDL_Window * window,
                                                      int min_w, int min_h);
# 687 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_GetWindowMinimumSize(SDL_Window * window,
                                                      int *w, int *h);
# 703 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetWindowMaximumSize(SDL_Window * window,
                                                      int max_w, int max_h);
# 716 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_GetWindowMaximumSize(SDL_Window * window,
                                                      int *w, int *h);
# 733 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetWindowBordered(SDL_Window * window,
                                                   SDL_bool bordered);
# 750 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetWindowResizable(SDL_Window * window,
                                                    SDL_bool resizable);






extern __attribute__ ((visibility("default"))) void SDL_ShowWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_HideWindow(SDL_Window * window);




extern __attribute__ ((visibility("default"))) void SDL_RaiseWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_MaximizeWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_MinimizeWindow(SDL_Window * window);







extern __attribute__ ((visibility("default"))) void SDL_RestoreWindow(SDL_Window * window);
# 802 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowFullscreen(SDL_Window * window,
                                                    Uint32 flags);
# 818 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_GetWindowSurface(SDL_Window * window);
# 828 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_UpdateWindowSurface(SDL_Window * window);
# 838 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_UpdateWindowSurfaceRects(SDL_Window * window,
                                                         const SDL_Rect * rects,
                                                         int numrects);
# 853 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetWindowGrab(SDL_Window * window,
                                               SDL_bool grabbed);
# 863 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetWindowGrab(SDL_Window * window);
# 872 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetGrabbedWindow(void);
# 882 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowBrightness(SDL_Window * window, float brightness);
# 891 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) float SDL_GetWindowBrightness(SDL_Window * window);
# 904 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowOpacity(SDL_Window * window, float opacity);
# 919 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetWindowOpacity(SDL_Window * window, float * out_opacity);
# 929 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowModalFor(SDL_Window * modal_window, SDL_Window * parent_window);
# 943 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowInputFocus(SDL_Window * window);
# 963 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowGammaRamp(SDL_Window * window,
                                                   const Uint16 * red,
                                                   const Uint16 * green,
                                                   const Uint16 * blue);
# 983 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetWindowGammaRamp(SDL_Window * window,
                                                   Uint16 * red,
                                                   Uint16 * green,
                                                   Uint16 * blue);






typedef enum
{
    SDL_HITTEST_NORMAL,
    SDL_HITTEST_DRAGGABLE,
    SDL_HITTEST_RESIZE_TOPLEFT,
    SDL_HITTEST_RESIZE_TOP,
    SDL_HITTEST_RESIZE_TOPRIGHT,
    SDL_HITTEST_RESIZE_RIGHT,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT,
    SDL_HITTEST_RESIZE_BOTTOM,
    SDL_HITTEST_RESIZE_BOTTOMLEFT,
    SDL_HITTEST_RESIZE_LEFT
} SDL_HitTestResult;






typedef SDL_HitTestResult ( *SDL_HitTest)(SDL_Window *win,
                                                 const SDL_Point *area,
                                                 void *data);
# 1053 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowHitTest(SDL_Window * window,
                                                 SDL_HitTest callback,
                                                 void *callback_data);




extern __attribute__ ((visibility("default"))) void SDL_DestroyWindow(SDL_Window * window);
# 1069 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsScreenSaverEnabled(void);







extern __attribute__ ((visibility("default"))) void SDL_EnableScreenSaver(void);







extern __attribute__ ((visibility("default"))) void SDL_DisableScreenSaver(void);
# 1111 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GL_LoadLibrary(const char *path);




extern __attribute__ ((visibility("default"))) void * SDL_GL_GetProcAddress(const char *proc);






extern __attribute__ ((visibility("default"))) void SDL_GL_UnloadLibrary(void);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_GL_ExtensionSupported(const char
                                                           *extension);




extern __attribute__ ((visibility("default"))) void SDL_GL_ResetAttributes(void);






extern __attribute__ ((visibility("default"))) int SDL_GL_SetAttribute(SDL_GLattr attr, int value);







extern __attribute__ ((visibility("default"))) int SDL_GL_GetAttribute(SDL_GLattr attr, int *value);







extern __attribute__ ((visibility("default"))) SDL_GLContext SDL_GL_CreateContext(SDL_Window *
                                                           window);






extern __attribute__ ((visibility("default"))) int SDL_GL_MakeCurrent(SDL_Window * window,
                                               SDL_GLContext context);




extern __attribute__ ((visibility("default"))) SDL_Window* SDL_GL_GetCurrentWindow(void);




extern __attribute__ ((visibility("default"))) SDL_GLContext SDL_GL_GetCurrentContext(void);
# 1195 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_GL_GetDrawableSize(SDL_Window * window, int *w,
                                                    int *h);
# 1210 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GL_SetSwapInterval(int interval);
# 1223 "/usr/local/include/SDL2/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GL_GetSwapInterval(void);





extern __attribute__ ((visibility("default"))) void SDL_GL_SwapWindow(SDL_Window * window);






extern __attribute__ ((visibility("default"))) void SDL_GL_DeleteContext(SDL_GLContext context);






}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 1246 "/usr/local/include/SDL2/SDL_video.h" 2 3
# 34 "/usr/local/include/SDL2/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_keyboard.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_keyboard.h" 3
# 1 "/usr/local/include/SDL2/SDL_keycode.h" 1 3
# 32 "/usr/local/include/SDL2/SDL_keycode.h" 3
# 1 "/usr/local/include/SDL2/SDL_scancode.h" 1 3
# 43 "/usr/local/include/SDL2/SDL_scancode.h" 3
typedef enum
{
    SDL_SCANCODE_UNKNOWN = 0,
# 54 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,

    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,

    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,

    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    SDL_SCANCODE_BACKSLASH = 49,
# 116 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_NONUSHASH = 50,
# 128 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    SDL_SCANCODE_GRAVE = 53,
# 147 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,

    SDL_SCANCODE_CAPSLOCK = 57,

    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,

    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    SDL_SCANCODE_INSERT = 73,

    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,

    SDL_SCANCODE_NUMLOCKCLEAR = 83,

    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,

    SDL_SCANCODE_NONUSBACKSLASH = 100,
# 210 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_APPLICATION = 101,
    SDL_SCANCODE_POWER = 102,


    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,




    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,

    SDL_SCANCODE_INTERNATIONAL1 = 135,

    SDL_SCANCODE_INTERNATIONAL2 = 136,
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    SDL_SCANCODE_LANG1 = 144,
    SDL_SCANCODE_LANG2 = 145,
    SDL_SCANCODE_LANG3 = 146,
    SDL_SCANCODE_LANG4 = 147,
    SDL_SCANCODE_LANG5 = 148,
    SDL_SCANCODE_LANG6 = 149,
    SDL_SCANCODE_LANG7 = 150,
    SDL_SCANCODE_LANG8 = 151,
    SDL_SCANCODE_LANG9 = 152,

    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,

    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,

    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    SDL_SCANCODE_LALT = 226,
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    SDL_SCANCODE_RALT = 230,
    SDL_SCANCODE_RGUI = 231,

    SDL_SCANCODE_MODE = 257,
# 351 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,
# 378 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    SDL_SCANCODE_DISPLAYSWITCH = 277,

    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,

    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
# 400 "/usr/local/include/SDL2/SDL_scancode.h" 3
    SDL_SCANCODE_AUDIOREWIND = 285,
    SDL_SCANCODE_AUDIOFASTFORWARD = 286,





    SDL_NUM_SCANCODES = 512

} SDL_Scancode;
# 33 "/usr/local/include/SDL2/SDL_keycode.h" 2 3
# 45 "/usr/local/include/SDL2/SDL_keycode.h" 3
typedef Sint32 SDL_Keycode;




enum
{
    SDLK_UNKNOWN = 0,

    SDLK_RETURN = '\r',
    SDLK_ESCAPE = '\033',
    SDLK_BACKSPACE = '\b',
    SDLK_TAB = '\t',
    SDLK_SPACE = ' ',
    SDLK_EXCLAIM = '!',
    SDLK_QUOTEDBL = '"',
    SDLK_HASH = '#',
    SDLK_PERCENT = '%',
    SDLK_DOLLAR = '$',
    SDLK_AMPERSAND = '&',
    SDLK_QUOTE = '\'',
    SDLK_LEFTPAREN = '(',
    SDLK_RIGHTPAREN = ')',
    SDLK_ASTERISK = '*',
    SDLK_PLUS = '+',
    SDLK_COMMA = ',',
    SDLK_MINUS = '-',
    SDLK_PERIOD = '.',
    SDLK_SLASH = '/',
    SDLK_0 = '0',
    SDLK_1 = '1',
    SDLK_2 = '2',
    SDLK_3 = '3',
    SDLK_4 = '4',
    SDLK_5 = '5',
    SDLK_6 = '6',
    SDLK_7 = '7',
    SDLK_8 = '8',
    SDLK_9 = '9',
    SDLK_COLON = ':',
    SDLK_SEMICOLON = ';',
    SDLK_LESS = '<',
    SDLK_EQUALS = '=',
    SDLK_GREATER = '>',
    SDLK_QUESTION = '?',
    SDLK_AT = '@',



    SDLK_LEFTBRACKET = '[',
    SDLK_BACKSLASH = '\\',
    SDLK_RIGHTBRACKET = ']',
    SDLK_CARET = '^',
    SDLK_UNDERSCORE = '_',
    SDLK_BACKQUOTE = '`',
    SDLK_a = 'a',
    SDLK_b = 'b',
    SDLK_c = 'c',
    SDLK_d = 'd',
    SDLK_e = 'e',
    SDLK_f = 'f',
    SDLK_g = 'g',
    SDLK_h = 'h',
    SDLK_i = 'i',
    SDLK_j = 'j',
    SDLK_k = 'k',
    SDLK_l = 'l',
    SDLK_m = 'm',
    SDLK_n = 'n',
    SDLK_o = 'o',
    SDLK_p = 'p',
    SDLK_q = 'q',
    SDLK_r = 'r',
    SDLK_s = 's',
    SDLK_t = 't',
    SDLK_u = 'u',
    SDLK_v = 'v',
    SDLK_w = 'w',
    SDLK_x = 'x',
    SDLK_y = 'y',
    SDLK_z = 'z',

    SDLK_CAPSLOCK = (SDL_SCANCODE_CAPSLOCK | (1<<30)),

    SDLK_F1 = (SDL_SCANCODE_F1 | (1<<30)),
    SDLK_F2 = (SDL_SCANCODE_F2 | (1<<30)),
    SDLK_F3 = (SDL_SCANCODE_F3 | (1<<30)),
    SDLK_F4 = (SDL_SCANCODE_F4 | (1<<30)),
    SDLK_F5 = (SDL_SCANCODE_F5 | (1<<30)),
    SDLK_F6 = (SDL_SCANCODE_F6 | (1<<30)),
    SDLK_F7 = (SDL_SCANCODE_F7 | (1<<30)),
    SDLK_F8 = (SDL_SCANCODE_F8 | (1<<30)),
    SDLK_F9 = (SDL_SCANCODE_F9 | (1<<30)),
    SDLK_F10 = (SDL_SCANCODE_F10 | (1<<30)),
    SDLK_F11 = (SDL_SCANCODE_F11 | (1<<30)),
    SDLK_F12 = (SDL_SCANCODE_F12 | (1<<30)),

    SDLK_PRINTSCREEN = (SDL_SCANCODE_PRINTSCREEN | (1<<30)),
    SDLK_SCROLLLOCK = (SDL_SCANCODE_SCROLLLOCK | (1<<30)),
    SDLK_PAUSE = (SDL_SCANCODE_PAUSE | (1<<30)),
    SDLK_INSERT = (SDL_SCANCODE_INSERT | (1<<30)),
    SDLK_HOME = (SDL_SCANCODE_HOME | (1<<30)),
    SDLK_PAGEUP = (SDL_SCANCODE_PAGEUP | (1<<30)),
    SDLK_DELETE = '\177',
    SDLK_END = (SDL_SCANCODE_END | (1<<30)),
    SDLK_PAGEDOWN = (SDL_SCANCODE_PAGEDOWN | (1<<30)),
    SDLK_RIGHT = (SDL_SCANCODE_RIGHT | (1<<30)),
    SDLK_LEFT = (SDL_SCANCODE_LEFT | (1<<30)),
    SDLK_DOWN = (SDL_SCANCODE_DOWN | (1<<30)),
    SDLK_UP = (SDL_SCANCODE_UP | (1<<30)),

    SDLK_NUMLOCKCLEAR = (SDL_SCANCODE_NUMLOCKCLEAR | (1<<30)),
    SDLK_KP_DIVIDE = (SDL_SCANCODE_KP_DIVIDE | (1<<30)),
    SDLK_KP_MULTIPLY = (SDL_SCANCODE_KP_MULTIPLY | (1<<30)),
    SDLK_KP_MINUS = (SDL_SCANCODE_KP_MINUS | (1<<30)),
    SDLK_KP_PLUS = (SDL_SCANCODE_KP_PLUS | (1<<30)),
    SDLK_KP_ENTER = (SDL_SCANCODE_KP_ENTER | (1<<30)),
    SDLK_KP_1 = (SDL_SCANCODE_KP_1 | (1<<30)),
    SDLK_KP_2 = (SDL_SCANCODE_KP_2 | (1<<30)),
    SDLK_KP_3 = (SDL_SCANCODE_KP_3 | (1<<30)),
    SDLK_KP_4 = (SDL_SCANCODE_KP_4 | (1<<30)),
    SDLK_KP_5 = (SDL_SCANCODE_KP_5 | (1<<30)),
    SDLK_KP_6 = (SDL_SCANCODE_KP_6 | (1<<30)),
    SDLK_KP_7 = (SDL_SCANCODE_KP_7 | (1<<30)),
    SDLK_KP_8 = (SDL_SCANCODE_KP_8 | (1<<30)),
    SDLK_KP_9 = (SDL_SCANCODE_KP_9 | (1<<30)),
    SDLK_KP_0 = (SDL_SCANCODE_KP_0 | (1<<30)),
    SDLK_KP_PERIOD = (SDL_SCANCODE_KP_PERIOD | (1<<30)),

    SDLK_APPLICATION = (SDL_SCANCODE_APPLICATION | (1<<30)),
    SDLK_POWER = (SDL_SCANCODE_POWER | (1<<30)),
    SDLK_KP_EQUALS = (SDL_SCANCODE_KP_EQUALS | (1<<30)),
    SDLK_F13 = (SDL_SCANCODE_F13 | (1<<30)),
    SDLK_F14 = (SDL_SCANCODE_F14 | (1<<30)),
    SDLK_F15 = (SDL_SCANCODE_F15 | (1<<30)),
    SDLK_F16 = (SDL_SCANCODE_F16 | (1<<30)),
    SDLK_F17 = (SDL_SCANCODE_F17 | (1<<30)),
    SDLK_F18 = (SDL_SCANCODE_F18 | (1<<30)),
    SDLK_F19 = (SDL_SCANCODE_F19 | (1<<30)),
    SDLK_F20 = (SDL_SCANCODE_F20 | (1<<30)),
    SDLK_F21 = (SDL_SCANCODE_F21 | (1<<30)),
    SDLK_F22 = (SDL_SCANCODE_F22 | (1<<30)),
    SDLK_F23 = (SDL_SCANCODE_F23 | (1<<30)),
    SDLK_F24 = (SDL_SCANCODE_F24 | (1<<30)),
    SDLK_EXECUTE = (SDL_SCANCODE_EXECUTE | (1<<30)),
    SDLK_HELP = (SDL_SCANCODE_HELP | (1<<30)),
    SDLK_MENU = (SDL_SCANCODE_MENU | (1<<30)),
    SDLK_SELECT = (SDL_SCANCODE_SELECT | (1<<30)),
    SDLK_STOP = (SDL_SCANCODE_STOP | (1<<30)),
    SDLK_AGAIN = (SDL_SCANCODE_AGAIN | (1<<30)),
    SDLK_UNDO = (SDL_SCANCODE_UNDO | (1<<30)),
    SDLK_CUT = (SDL_SCANCODE_CUT | (1<<30)),
    SDLK_COPY = (SDL_SCANCODE_COPY | (1<<30)),
    SDLK_PASTE = (SDL_SCANCODE_PASTE | (1<<30)),
    SDLK_FIND = (SDL_SCANCODE_FIND | (1<<30)),
    SDLK_MUTE = (SDL_SCANCODE_MUTE | (1<<30)),
    SDLK_VOLUMEUP = (SDL_SCANCODE_VOLUMEUP | (1<<30)),
    SDLK_VOLUMEDOWN = (SDL_SCANCODE_VOLUMEDOWN | (1<<30)),
    SDLK_KP_COMMA = (SDL_SCANCODE_KP_COMMA | (1<<30)),
    SDLK_KP_EQUALSAS400 =
        (SDL_SCANCODE_KP_EQUALSAS400 | (1<<30)),

    SDLK_ALTERASE = (SDL_SCANCODE_ALTERASE | (1<<30)),
    SDLK_SYSREQ = (SDL_SCANCODE_SYSREQ | (1<<30)),
    SDLK_CANCEL = (SDL_SCANCODE_CANCEL | (1<<30)),
    SDLK_CLEAR = (SDL_SCANCODE_CLEAR | (1<<30)),
    SDLK_PRIOR = (SDL_SCANCODE_PRIOR | (1<<30)),
    SDLK_RETURN2 = (SDL_SCANCODE_RETURN2 | (1<<30)),
    SDLK_SEPARATOR = (SDL_SCANCODE_SEPARATOR | (1<<30)),
    SDLK_OUT = (SDL_SCANCODE_OUT | (1<<30)),
    SDLK_OPER = (SDL_SCANCODE_OPER | (1<<30)),
    SDLK_CLEARAGAIN = (SDL_SCANCODE_CLEARAGAIN | (1<<30)),
    SDLK_CRSEL = (SDL_SCANCODE_CRSEL | (1<<30)),
    SDLK_EXSEL = (SDL_SCANCODE_EXSEL | (1<<30)),

    SDLK_KP_00 = (SDL_SCANCODE_KP_00 | (1<<30)),
    SDLK_KP_000 = (SDL_SCANCODE_KP_000 | (1<<30)),
    SDLK_THOUSANDSSEPARATOR =
        (SDL_SCANCODE_THOUSANDSSEPARATOR | (1<<30)),
    SDLK_DECIMALSEPARATOR =
        (SDL_SCANCODE_DECIMALSEPARATOR | (1<<30)),
    SDLK_CURRENCYUNIT = (SDL_SCANCODE_CURRENCYUNIT | (1<<30)),
    SDLK_CURRENCYSUBUNIT =
        (SDL_SCANCODE_CURRENCYSUBUNIT | (1<<30)),
    SDLK_KP_LEFTPAREN = (SDL_SCANCODE_KP_LEFTPAREN | (1<<30)),
    SDLK_KP_RIGHTPAREN = (SDL_SCANCODE_KP_RIGHTPAREN | (1<<30)),
    SDLK_KP_LEFTBRACE = (SDL_SCANCODE_KP_LEFTBRACE | (1<<30)),
    SDLK_KP_RIGHTBRACE = (SDL_SCANCODE_KP_RIGHTBRACE | (1<<30)),
    SDLK_KP_TAB = (SDL_SCANCODE_KP_TAB | (1<<30)),
    SDLK_KP_BACKSPACE = (SDL_SCANCODE_KP_BACKSPACE | (1<<30)),
    SDLK_KP_A = (SDL_SCANCODE_KP_A | (1<<30)),
    SDLK_KP_B = (SDL_SCANCODE_KP_B | (1<<30)),
    SDLK_KP_C = (SDL_SCANCODE_KP_C | (1<<30)),
    SDLK_KP_D = (SDL_SCANCODE_KP_D | (1<<30)),
    SDLK_KP_E = (SDL_SCANCODE_KP_E | (1<<30)),
    SDLK_KP_F = (SDL_SCANCODE_KP_F | (1<<30)),
    SDLK_KP_XOR = (SDL_SCANCODE_KP_XOR | (1<<30)),
    SDLK_KP_POWER = (SDL_SCANCODE_KP_POWER | (1<<30)),
    SDLK_KP_PERCENT = (SDL_SCANCODE_KP_PERCENT | (1<<30)),
    SDLK_KP_LESS = (SDL_SCANCODE_KP_LESS | (1<<30)),
    SDLK_KP_GREATER = (SDL_SCANCODE_KP_GREATER | (1<<30)),
    SDLK_KP_AMPERSAND = (SDL_SCANCODE_KP_AMPERSAND | (1<<30)),
    SDLK_KP_DBLAMPERSAND =
        (SDL_SCANCODE_KP_DBLAMPERSAND | (1<<30)),
    SDLK_KP_VERTICALBAR =
        (SDL_SCANCODE_KP_VERTICALBAR | (1<<30)),
    SDLK_KP_DBLVERTICALBAR =
        (SDL_SCANCODE_KP_DBLVERTICALBAR | (1<<30)),
    SDLK_KP_COLON = (SDL_SCANCODE_KP_COLON | (1<<30)),
    SDLK_KP_HASH = (SDL_SCANCODE_KP_HASH | (1<<30)),
    SDLK_KP_SPACE = (SDL_SCANCODE_KP_SPACE | (1<<30)),
    SDLK_KP_AT = (SDL_SCANCODE_KP_AT | (1<<30)),
    SDLK_KP_EXCLAM = (SDL_SCANCODE_KP_EXCLAM | (1<<30)),
    SDLK_KP_MEMSTORE = (SDL_SCANCODE_KP_MEMSTORE | (1<<30)),
    SDLK_KP_MEMRECALL = (SDL_SCANCODE_KP_MEMRECALL | (1<<30)),
    SDLK_KP_MEMCLEAR = (SDL_SCANCODE_KP_MEMCLEAR | (1<<30)),
    SDLK_KP_MEMADD = (SDL_SCANCODE_KP_MEMADD | (1<<30)),
    SDLK_KP_MEMSUBTRACT =
        (SDL_SCANCODE_KP_MEMSUBTRACT | (1<<30)),
    SDLK_KP_MEMMULTIPLY =
        (SDL_SCANCODE_KP_MEMMULTIPLY | (1<<30)),
    SDLK_KP_MEMDIVIDE = (SDL_SCANCODE_KP_MEMDIVIDE | (1<<30)),
    SDLK_KP_PLUSMINUS = (SDL_SCANCODE_KP_PLUSMINUS | (1<<30)),
    SDLK_KP_CLEAR = (SDL_SCANCODE_KP_CLEAR | (1<<30)),
    SDLK_KP_CLEARENTRY = (SDL_SCANCODE_KP_CLEARENTRY | (1<<30)),
    SDLK_KP_BINARY = (SDL_SCANCODE_KP_BINARY | (1<<30)),
    SDLK_KP_OCTAL = (SDL_SCANCODE_KP_OCTAL | (1<<30)),
    SDLK_KP_DECIMAL = (SDL_SCANCODE_KP_DECIMAL | (1<<30)),
    SDLK_KP_HEXADECIMAL =
        (SDL_SCANCODE_KP_HEXADECIMAL | (1<<30)),

    SDLK_LCTRL = (SDL_SCANCODE_LCTRL | (1<<30)),
    SDLK_LSHIFT = (SDL_SCANCODE_LSHIFT | (1<<30)),
    SDLK_LALT = (SDL_SCANCODE_LALT | (1<<30)),
    SDLK_LGUI = (SDL_SCANCODE_LGUI | (1<<30)),
    SDLK_RCTRL = (SDL_SCANCODE_RCTRL | (1<<30)),
    SDLK_RSHIFT = (SDL_SCANCODE_RSHIFT | (1<<30)),
    SDLK_RALT = (SDL_SCANCODE_RALT | (1<<30)),
    SDLK_RGUI = (SDL_SCANCODE_RGUI | (1<<30)),

    SDLK_MODE = (SDL_SCANCODE_MODE | (1<<30)),

    SDLK_AUDIONEXT = (SDL_SCANCODE_AUDIONEXT | (1<<30)),
    SDLK_AUDIOPREV = (SDL_SCANCODE_AUDIOPREV | (1<<30)),
    SDLK_AUDIOSTOP = (SDL_SCANCODE_AUDIOSTOP | (1<<30)),
    SDLK_AUDIOPLAY = (SDL_SCANCODE_AUDIOPLAY | (1<<30)),
    SDLK_AUDIOMUTE = (SDL_SCANCODE_AUDIOMUTE | (1<<30)),
    SDLK_MEDIASELECT = (SDL_SCANCODE_MEDIASELECT | (1<<30)),
    SDLK_WWW = (SDL_SCANCODE_WWW | (1<<30)),
    SDLK_MAIL = (SDL_SCANCODE_MAIL | (1<<30)),
    SDLK_CALCULATOR = (SDL_SCANCODE_CALCULATOR | (1<<30)),
    SDLK_COMPUTER = (SDL_SCANCODE_COMPUTER | (1<<30)),
    SDLK_AC_SEARCH = (SDL_SCANCODE_AC_SEARCH | (1<<30)),
    SDLK_AC_HOME = (SDL_SCANCODE_AC_HOME | (1<<30)),
    SDLK_AC_BACK = (SDL_SCANCODE_AC_BACK | (1<<30)),
    SDLK_AC_FORWARD = (SDL_SCANCODE_AC_FORWARD | (1<<30)),
    SDLK_AC_STOP = (SDL_SCANCODE_AC_STOP | (1<<30)),
    SDLK_AC_REFRESH = (SDL_SCANCODE_AC_REFRESH | (1<<30)),
    SDLK_AC_BOOKMARKS = (SDL_SCANCODE_AC_BOOKMARKS | (1<<30)),

    SDLK_BRIGHTNESSDOWN =
        (SDL_SCANCODE_BRIGHTNESSDOWN | (1<<30)),
    SDLK_BRIGHTNESSUP = (SDL_SCANCODE_BRIGHTNESSUP | (1<<30)),
    SDLK_DISPLAYSWITCH = (SDL_SCANCODE_DISPLAYSWITCH | (1<<30)),
    SDLK_KBDILLUMTOGGLE =
        (SDL_SCANCODE_KBDILLUMTOGGLE | (1<<30)),
    SDLK_KBDILLUMDOWN = (SDL_SCANCODE_KBDILLUMDOWN | (1<<30)),
    SDLK_KBDILLUMUP = (SDL_SCANCODE_KBDILLUMUP | (1<<30)),
    SDLK_EJECT = (SDL_SCANCODE_EJECT | (1<<30)),
    SDLK_SLEEP = (SDL_SCANCODE_SLEEP | (1<<30)),
    SDLK_APP1 = (SDL_SCANCODE_APP1 | (1<<30)),
    SDLK_APP2 = (SDL_SCANCODE_APP2 | (1<<30)),

    SDLK_AUDIOREWIND = (SDL_SCANCODE_AUDIOREWIND | (1<<30)),
    SDLK_AUDIOFASTFORWARD = (SDL_SCANCODE_AUDIOFASTFORWARD | (1<<30))
};




typedef enum
{
    KMOD_NONE = 0x0000,
    KMOD_LSHIFT = 0x0001,
    KMOD_RSHIFT = 0x0002,
    KMOD_LCTRL = 0x0040,
    KMOD_RCTRL = 0x0080,
    KMOD_LALT = 0x0100,
    KMOD_RALT = 0x0200,
    KMOD_LGUI = 0x0400,
    KMOD_RGUI = 0x0800,
    KMOD_NUM = 0x1000,
    KMOD_CAPS = 0x2000,
    KMOD_MODE = 0x4000,
    KMOD_RESERVED = 0x8000
} SDL_Keymod;
# 34 "/usr/local/include/SDL2/SDL_keyboard.h" 2 3


# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 37 "/usr/local/include/SDL2/SDL_keyboard.h" 2 3


extern "C" {







typedef struct SDL_Keysym
{
    SDL_Scancode scancode;
    SDL_Keycode sym;
    Uint16 mod;
    Uint32 unused;
} SDL_Keysym;






extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetKeyboardFocus(void);
# 77 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) const Uint8 * SDL_GetKeyboardState(int *numkeys);




extern __attribute__ ((visibility("default"))) SDL_Keymod SDL_GetModState(void);






extern __attribute__ ((visibility("default"))) void SDL_SetModState(SDL_Keymod modstate);
# 99 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode);
# 109 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key);
# 120 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetScancodeName(SDL_Scancode scancode);
# 129 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) SDL_Scancode SDL_GetScancodeFromName(const char *name);
# 141 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetKeyName(SDL_Keycode key);
# 150 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) SDL_Keycode SDL_GetKeyFromName(const char *name);
# 160 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) void SDL_StartTextInput(void);







extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsTextInputActive(void);
# 177 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) void SDL_StopTextInput(void);







extern __attribute__ ((visibility("default"))) void SDL_SetTextInputRect(SDL_Rect *rect);
# 196 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasScreenKeyboardSupport(void);
# 207 "/usr/local/include/SDL2/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsScreenKeyboardShown(SDL_Window *window);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 214 "/usr/local/include/SDL2/SDL_keyboard.h" 2 3
# 35 "/usr/local/include/SDL2/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_mouse.h" 1 3
# 35 "/usr/local/include/SDL2/SDL_mouse.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 36 "/usr/local/include/SDL2/SDL_mouse.h" 2 3


extern "C" {


typedef struct SDL_Cursor SDL_Cursor;




typedef enum
{
    SDL_SYSTEM_CURSOR_ARROW,
    SDL_SYSTEM_CURSOR_IBEAM,
    SDL_SYSTEM_CURSOR_WAIT,
    SDL_SYSTEM_CURSOR_CROSSHAIR,
    SDL_SYSTEM_CURSOR_WAITARROW,
    SDL_SYSTEM_CURSOR_SIZENWSE,
    SDL_SYSTEM_CURSOR_SIZENESW,
    SDL_SYSTEM_CURSOR_SIZEWE,
    SDL_SYSTEM_CURSOR_SIZENS,
    SDL_SYSTEM_CURSOR_SIZEALL,
    SDL_SYSTEM_CURSOR_NO,
    SDL_SYSTEM_CURSOR_HAND,
    SDL_NUM_SYSTEM_CURSORS
} SDL_SystemCursor;




typedef enum
{
    SDL_MOUSEWHEEL_NORMAL,
    SDL_MOUSEWHEEL_FLIPPED
} SDL_MouseWheelDirection;






extern __attribute__ ((visibility("default"))) SDL_Window * SDL_GetMouseFocus(void);
# 87 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetMouseState(int *x, int *y);
# 112 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetGlobalMouseState(int *x, int *y);
# 121 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetRelativeMouseState(int *x, int *y);
# 132 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) void SDL_WarpMouseInWindow(SDL_Window * window,
                                                   int x, int y);
# 144 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) int SDL_WarpMouseGlobal(int x, int y);
# 162 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetRelativeMouseMode(SDL_bool enabled);
# 193 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) int SDL_CaptureMouse(SDL_bool enabled);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetRelativeMouseMode(void);
# 220 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_CreateCursor(const Uint8 * data,
                                                     const Uint8 * mask,
                                                     int w, int h, int hot_x,
                                                     int hot_y);






extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_CreateColorCursor(SDL_Surface *surface,
                                                          int hot_x,
                                                          int hot_y);






extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_CreateSystemCursor(SDL_SystemCursor id);




extern __attribute__ ((visibility("default"))) void SDL_SetCursor(SDL_Cursor * cursor);




extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_GetCursor(void);




extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_GetDefaultCursor(void);
# 263 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) void SDL_FreeCursor(SDL_Cursor * cursor);
# 273 "/usr/local/include/SDL2/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) int SDL_ShowCursor(int toggle);
# 296 "/usr/local/include/SDL2/SDL_mouse.h" 3
}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 299 "/usr/local/include/SDL2/SDL_mouse.h" 2 3
# 36 "/usr/local/include/SDL2/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_joystick.h" 1 3
# 45 "/usr/local/include/SDL2/SDL_joystick.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 46 "/usr/local/include/SDL2/SDL_joystick.h" 2 3


extern "C" {
# 66 "/usr/local/include/SDL2/SDL_joystick.h" 3
struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;


typedef struct {
    Uint8 data[16];
} SDL_JoystickGUID;
# 81 "/usr/local/include/SDL2/SDL_joystick.h" 3
typedef Sint32 SDL_JoystickID;

typedef enum
{
    SDL_JOYSTICK_TYPE_UNKNOWN,
    SDL_JOYSTICK_TYPE_GAMECONTROLLER,
    SDL_JOYSTICK_TYPE_WHEEL,
    SDL_JOYSTICK_TYPE_ARCADE_STICK,
    SDL_JOYSTICK_TYPE_FLIGHT_STICK,
    SDL_JOYSTICK_TYPE_DANCE_PAD,
    SDL_JOYSTICK_TYPE_GUITAR,
    SDL_JOYSTICK_TYPE_DRUM_KIT,
    SDL_JOYSTICK_TYPE_ARCADE_PAD,
    SDL_JOYSTICK_TYPE_THROTTLE
} SDL_JoystickType;

typedef enum
{
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY,
    SDL_JOYSTICK_POWER_LOW,
    SDL_JOYSTICK_POWER_MEDIUM,
    SDL_JOYSTICK_POWER_FULL,
    SDL_JOYSTICK_POWER_WIRED,
    SDL_JOYSTICK_POWER_MAX
} SDL_JoystickPowerLevel;
# 120 "/usr/local/include/SDL2/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) void SDL_LockJoysticks(void);
extern __attribute__ ((visibility("default"))) void SDL_UnlockJoysticks(void);




extern __attribute__ ((visibility("default"))) int SDL_NumJoysticks(void);






extern __attribute__ ((visibility("default"))) const char * SDL_JoystickNameForIndex(int device_index);





extern __attribute__ ((visibility("default"))) SDL_JoystickGUID SDL_JoystickGetDeviceGUID(int device_index);






extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetDeviceVendor(int device_index);






extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetDeviceProduct(int device_index);






extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetDeviceProductVersion(int device_index);





extern __attribute__ ((visibility("default"))) SDL_JoystickType SDL_JoystickGetDeviceType(int device_index);






extern __attribute__ ((visibility("default"))) SDL_JoystickID SDL_JoystickGetDeviceInstanceID(int device_index);
# 184 "/usr/local/include/SDL2/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) SDL_Joystick * SDL_JoystickOpen(int device_index);




extern __attribute__ ((visibility("default"))) SDL_Joystick * SDL_JoystickFromInstanceID(SDL_JoystickID joyid);





extern __attribute__ ((visibility("default"))) const char * SDL_JoystickName(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickGUID SDL_JoystickGetGUID(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetVendor(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetProduct(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) Uint16 SDL_JoystickGetProductVersion(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickType SDL_JoystickGetType(SDL_Joystick * joystick);





extern __attribute__ ((visibility("default"))) void SDL_JoystickGetGUIDString(SDL_JoystickGUID guid, char *pszGUID, int cbGUID);




extern __attribute__ ((visibility("default"))) SDL_JoystickGUID SDL_JoystickGetGUIDFromString(const char *pchGUID);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_JoystickGetAttached(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickID SDL_JoystickInstanceID(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumAxes(SDL_Joystick * joystick);







extern __attribute__ ((visibility("default"))) int SDL_JoystickNumBalls(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumHats(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumButtons(SDL_Joystick * joystick);







extern __attribute__ ((visibility("default"))) void SDL_JoystickUpdate(void);
# 286 "/usr/local/include/SDL2/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) int SDL_JoystickEventState(int state);
# 297 "/usr/local/include/SDL2/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) Sint16 SDL_JoystickGetAxis(SDL_Joystick * joystick,
                                                   int axis);
# 309 "/usr/local/include/SDL2/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_JoystickGetAxisInitialState(SDL_Joystick * joystick,
                                                   int axis, Sint16 *state);
# 343 "/usr/local/include/SDL2/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) Uint8 SDL_JoystickGetHat(SDL_Joystick * joystick,
                                                 int hat);
# 353 "/usr/local/include/SDL2/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) int SDL_JoystickGetBall(SDL_Joystick * joystick,
                                                int ball, int *dx, int *dy);






extern __attribute__ ((visibility("default"))) Uint8 SDL_JoystickGetButton(SDL_Joystick * joystick,
                                                    int button);




extern __attribute__ ((visibility("default"))) void SDL_JoystickClose(SDL_Joystick * joystick);




extern __attribute__ ((visibility("default"))) SDL_JoystickPowerLevel SDL_JoystickCurrentPowerLevel(SDL_Joystick * joystick);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 379 "/usr/local/include/SDL2/SDL_joystick.h" 2 3
# 37 "/usr/local/include/SDL2/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_gamecontroller.h" 1 3
# 36 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 37 "/usr/local/include/SDL2/SDL_gamecontroller.h" 2 3


extern "C" {
# 57 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
struct _SDL_GameController;
typedef struct _SDL_GameController SDL_GameController;


typedef enum
{
    SDL_CONTROLLER_BINDTYPE_NONE = 0,
    SDL_CONTROLLER_BINDTYPE_BUTTON,
    SDL_CONTROLLER_BINDTYPE_AXIS,
    SDL_CONTROLLER_BINDTYPE_HAT
} SDL_GameControllerBindType;




typedef struct SDL_GameControllerButtonBind
{
    SDL_GameControllerBindType bindType;
    union
    {
        int button;
        int axis;
        struct {
            int hat;
            int hat_mask;
        } hat;
    } value;

} SDL_GameControllerButtonBind;
# 122 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GameControllerAddMappingsFromRW(SDL_RWops * rw, int freerw);
# 136 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GameControllerAddMapping(const char* mappingString);






extern __attribute__ ((visibility("default"))) int SDL_GameControllerNumMappings(void);






extern __attribute__ ((visibility("default"))) char * SDL_GameControllerMappingForIndex(int mapping_index);






extern __attribute__ ((visibility("default"))) char * SDL_GameControllerMappingForGUID(SDL_JoystickGUID guid);






extern __attribute__ ((visibility("default"))) char * SDL_GameControllerMapping(SDL_GameController * gamecontroller);




extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsGameController(int joystick_index);






extern __attribute__ ((visibility("default"))) const char * SDL_GameControllerNameForIndex(int joystick_index);
# 187 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
extern __attribute__ ((visibility("default"))) SDL_GameController * SDL_GameControllerOpen(int joystick_index);




extern __attribute__ ((visibility("default"))) SDL_GameController * SDL_GameControllerFromInstanceID(SDL_JoystickID joyid);




extern __attribute__ ((visibility("default"))) const char * SDL_GameControllerName(SDL_GameController *gamecontroller);





extern __attribute__ ((visibility("default"))) Uint16 SDL_GameControllerGetVendor(SDL_GameController * gamecontroller);





extern __attribute__ ((visibility("default"))) Uint16 SDL_GameControllerGetProduct(SDL_GameController * gamecontroller);





extern __attribute__ ((visibility("default"))) Uint16 SDL_GameControllerGetProductVersion(SDL_GameController * gamecontroller);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_GameControllerGetAttached(SDL_GameController *gamecontroller);




extern __attribute__ ((visibility("default"))) SDL_Joystick * SDL_GameControllerGetJoystick(SDL_GameController *gamecontroller);
# 237 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GameControllerEventState(int state);







extern __attribute__ ((visibility("default"))) void SDL_GameControllerUpdate(void);
# 257 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
typedef enum
{
    SDL_CONTROLLER_AXIS_INVALID = -1,
    SDL_CONTROLLER_AXIS_LEFTX,
    SDL_CONTROLLER_AXIS_LEFTY,
    SDL_CONTROLLER_AXIS_RIGHTX,
    SDL_CONTROLLER_AXIS_RIGHTY,
    SDL_CONTROLLER_AXIS_TRIGGERLEFT,
    SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
    SDL_CONTROLLER_AXIS_MAX
} SDL_GameControllerAxis;




extern __attribute__ ((visibility("default"))) SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char *pchString);




extern __attribute__ ((visibility("default"))) const char* SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis);




extern __attribute__ ((visibility("default"))) SDL_GameControllerButtonBind
SDL_GameControllerGetBindForAxis(SDL_GameController *gamecontroller,
                                 SDL_GameControllerAxis axis);
# 294 "/usr/local/include/SDL2/SDL_gamecontroller.h" 3
extern __attribute__ ((visibility("default"))) Sint16
SDL_GameControllerGetAxis(SDL_GameController *gamecontroller,
                          SDL_GameControllerAxis axis);




typedef enum
{
    SDL_CONTROLLER_BUTTON_INVALID = -1,
    SDL_CONTROLLER_BUTTON_A,
    SDL_CONTROLLER_BUTTON_B,
    SDL_CONTROLLER_BUTTON_X,
    SDL_CONTROLLER_BUTTON_Y,
    SDL_CONTROLLER_BUTTON_BACK,
    SDL_CONTROLLER_BUTTON_GUIDE,
    SDL_CONTROLLER_BUTTON_START,
    SDL_CONTROLLER_BUTTON_LEFTSTICK,
    SDL_CONTROLLER_BUTTON_RIGHTSTICK,
    SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
    SDL_CONTROLLER_BUTTON_DPAD_UP,
    SDL_CONTROLLER_BUTTON_DPAD_DOWN,
    SDL_CONTROLLER_BUTTON_DPAD_LEFT,
    SDL_CONTROLLER_BUTTON_DPAD_RIGHT,
    SDL_CONTROLLER_BUTTON_MAX
} SDL_GameControllerButton;




extern __attribute__ ((visibility("default"))) SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchString);




extern __attribute__ ((visibility("default"))) const char* SDL_GameControllerGetStringForButton(SDL_GameControllerButton button);




extern __attribute__ ((visibility("default"))) SDL_GameControllerButtonBind
SDL_GameControllerGetBindForButton(SDL_GameController *gamecontroller,
                                   SDL_GameControllerButton button);







extern __attribute__ ((visibility("default"))) Uint8 SDL_GameControllerGetButton(SDL_GameController *gamecontroller,
                                                          SDL_GameControllerButton button);




extern __attribute__ ((visibility("default"))) void SDL_GameControllerClose(SDL_GameController *gamecontroller);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 359 "/usr/local/include/SDL2/SDL_gamecontroller.h" 2 3
# 38 "/usr/local/include/SDL2/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_quit.h" 1 3
# 39 "/usr/local/include/SDL2/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_gesture.h" 1 3
# 35 "/usr/local/include/SDL2/SDL_gesture.h" 3
# 1 "/usr/local/include/SDL2/SDL_touch.h" 1 3
# 35 "/usr/local/include/SDL2/SDL_touch.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 36 "/usr/local/include/SDL2/SDL_touch.h" 2 3


extern "C" {


typedef Sint64 SDL_TouchID;
typedef Sint64 SDL_FingerID;

typedef struct SDL_Finger
{
    SDL_FingerID id;
    float x;
    float y;
    float pressure;
} SDL_Finger;
# 61 "/usr/local/include/SDL2/SDL_touch.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetNumTouchDevices(void);




extern __attribute__ ((visibility("default"))) SDL_TouchID SDL_GetTouchDevice(int index);




extern __attribute__ ((visibility("default"))) int SDL_GetNumTouchFingers(SDL_TouchID touchID);




extern __attribute__ ((visibility("default"))) SDL_Finger * SDL_GetTouchFinger(SDL_TouchID touchID, int index);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 83 "/usr/local/include/SDL2/SDL_touch.h" 2 3
# 36 "/usr/local/include/SDL2/SDL_gesture.h" 2 3


# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 39 "/usr/local/include/SDL2/SDL_gesture.h" 2 3


extern "C" {


typedef Sint64 SDL_GestureID;
# 53 "/usr/local/include/SDL2/SDL_gesture.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RecordGesture(SDL_TouchID touchId);







extern __attribute__ ((visibility("default"))) int SDL_SaveAllDollarTemplates(SDL_RWops *dst);






extern __attribute__ ((visibility("default"))) int SDL_SaveDollarTemplate(SDL_GestureID gestureId,SDL_RWops *dst);







extern __attribute__ ((visibility("default"))) int SDL_LoadDollarTemplates(SDL_TouchID touchId, SDL_RWops *src);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 84 "/usr/local/include/SDL2/SDL_gesture.h" 2 3
# 40 "/usr/local/include/SDL2/SDL_events.h" 2 3


# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 43 "/usr/local/include/SDL2/SDL_events.h" 2 3


extern "C" {
# 55 "/usr/local/include/SDL2/SDL_events.h" 3
typedef enum
{
    SDL_FIRSTEVENT = 0,


    SDL_QUIT = 0x100,


    SDL_APP_TERMINATING,



    SDL_APP_LOWMEMORY,



    SDL_APP_WILLENTERBACKGROUND,



    SDL_APP_DIDENTERBACKGROUND,



    SDL_APP_WILLENTERFOREGROUND,



    SDL_APP_DIDENTERFOREGROUND,





    SDL_WINDOWEVENT = 0x200,
    SDL_SYSWMEVENT,


    SDL_KEYDOWN = 0x300,
    SDL_KEYUP,
    SDL_TEXTEDITING,
    SDL_TEXTINPUT,
    SDL_KEYMAPCHANGED,




    SDL_MOUSEMOTION = 0x400,
    SDL_MOUSEBUTTONDOWN,
    SDL_MOUSEBUTTONUP,
    SDL_MOUSEWHEEL,


    SDL_JOYAXISMOTION = 0x600,
    SDL_JOYBALLMOTION,
    SDL_JOYHATMOTION,
    SDL_JOYBUTTONDOWN,
    SDL_JOYBUTTONUP,
    SDL_JOYDEVICEADDED,
    SDL_JOYDEVICEREMOVED,


    SDL_CONTROLLERAXISMOTION = 0x650,
    SDL_CONTROLLERBUTTONDOWN,
    SDL_CONTROLLERBUTTONUP,
    SDL_CONTROLLERDEVICEADDED,
    SDL_CONTROLLERDEVICEREMOVED,
    SDL_CONTROLLERDEVICEREMAPPED,


    SDL_FINGERDOWN = 0x700,
    SDL_FINGERUP,
    SDL_FINGERMOTION,


    SDL_DOLLARGESTURE = 0x800,
    SDL_DOLLARRECORD,
    SDL_MULTIGESTURE,


    SDL_CLIPBOARDUPDATE = 0x900,


    SDL_DROPFILE = 0x1000,
    SDL_DROPTEXT,
    SDL_DROPBEGIN,
    SDL_DROPCOMPLETE,


    SDL_AUDIODEVICEADDED = 0x1100,
    SDL_AUDIODEVICEREMOVED,


    SDL_RENDER_TARGETS_RESET = 0x2000,
    SDL_RENDER_DEVICE_RESET,




    SDL_USEREVENT = 0x8000,




    SDL_LASTEVENT = 0xFFFF
} SDL_EventType;




typedef struct SDL_CommonEvent
{
    Uint32 type;
    Uint32 timestamp;
} SDL_CommonEvent;




typedef struct SDL_WindowEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint8 event;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint32 data1;
    Sint32 data2;
} SDL_WindowEvent;




typedef struct SDL_KeyboardEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint8 state;
    Uint8 repeat;
    Uint8 padding2;
    Uint8 padding3;
    SDL_Keysym keysym;
} SDL_KeyboardEvent;





typedef struct SDL_TextEditingEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    char text[(32)];
    Sint32 start;
    Sint32 length;
} SDL_TextEditingEvent;






typedef struct SDL_TextInputEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    char text[(32)];
} SDL_TextInputEvent;




typedef struct SDL_MouseMotionEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint32 which;
    Uint32 state;
    Sint32 x;
    Sint32 y;
    Sint32 xrel;
    Sint32 yrel;
} SDL_MouseMotionEvent;




typedef struct SDL_MouseButtonEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint32 which;
    Uint8 button;
    Uint8 state;
    Uint8 clicks;
    Uint8 padding1;
    Sint32 x;
    Sint32 y;
} SDL_MouseButtonEvent;




typedef struct SDL_MouseWheelEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Uint32 which;
    Sint32 x;
    Sint32 y;
    Uint32 direction;
} SDL_MouseWheelEvent;




typedef struct SDL_JoyAxisEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 axis;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;
    Uint16 padding4;
} SDL_JoyAxisEvent;




typedef struct SDL_JoyBallEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 ball;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 xrel;
    Sint16 yrel;
} SDL_JoyBallEvent;




typedef struct SDL_JoyHatEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 hat;
    Uint8 value;






    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyHatEvent;




typedef struct SDL_JoyButtonEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 button;
    Uint8 state;
    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyButtonEvent;




typedef struct SDL_JoyDeviceEvent
{
    Uint32 type;
    Uint32 timestamp;
    Sint32 which;
} SDL_JoyDeviceEvent;





typedef struct SDL_ControllerAxisEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 axis;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;
    Uint16 padding4;
} SDL_ControllerAxisEvent;





typedef struct SDL_ControllerButtonEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_JoystickID which;
    Uint8 button;
    Uint8 state;
    Uint8 padding1;
    Uint8 padding2;
} SDL_ControllerButtonEvent;





typedef struct SDL_ControllerDeviceEvent
{
    Uint32 type;
    Uint32 timestamp;
    Sint32 which;
} SDL_ControllerDeviceEvent;




typedef struct SDL_AudioDeviceEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 which;
    Uint8 iscapture;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_AudioDeviceEvent;





typedef struct SDL_TouchFingerEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_TouchID touchId;
    SDL_FingerID fingerId;
    float x;
    float y;
    float dx;
    float dy;
    float pressure;
} SDL_TouchFingerEvent;





typedef struct SDL_MultiGestureEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_TouchID touchId;
    float dTheta;
    float dDist;
    float x;
    float y;
    Uint16 numFingers;
    Uint16 padding;
} SDL_MultiGestureEvent;





typedef struct SDL_DollarGestureEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_TouchID touchId;
    SDL_GestureID gestureId;
    Uint32 numFingers;
    float error;
    float x;
    float y;
} SDL_DollarGestureEvent;







typedef struct SDL_DropEvent
{
    Uint32 type;
    Uint32 timestamp;
    char *file;
    Uint32 windowID;
} SDL_DropEvent;





typedef struct SDL_QuitEvent
{
    Uint32 type;
    Uint32 timestamp;
} SDL_QuitEvent;




typedef struct SDL_OSEvent
{
    Uint32 type;
    Uint32 timestamp;
} SDL_OSEvent;




typedef struct SDL_UserEvent
{
    Uint32 type;
    Uint32 timestamp;
    Uint32 windowID;
    Sint32 code;
    void *data1;
    void *data2;
} SDL_UserEvent;


struct SDL_SysWMmsg;
typedef struct SDL_SysWMmsg SDL_SysWMmsg;







typedef struct SDL_SysWMEvent
{
    Uint32 type;
    Uint32 timestamp;
    SDL_SysWMmsg *msg;
} SDL_SysWMEvent;




typedef union SDL_Event
{
    Uint32 type;
    SDL_CommonEvent common;
    SDL_WindowEvent window;
    SDL_KeyboardEvent key;
    SDL_TextEditingEvent edit;
    SDL_TextInputEvent text;
    SDL_MouseMotionEvent motion;
    SDL_MouseButtonEvent button;
    SDL_MouseWheelEvent wheel;
    SDL_JoyAxisEvent jaxis;
    SDL_JoyBallEvent jball;
    SDL_JoyHatEvent jhat;
    SDL_JoyButtonEvent jbutton;
    SDL_JoyDeviceEvent jdevice;
    SDL_ControllerAxisEvent caxis;
    SDL_ControllerButtonEvent cbutton;
    SDL_ControllerDeviceEvent cdevice;
    SDL_AudioDeviceEvent adevice;
    SDL_QuitEvent quit;
    SDL_UserEvent user;
    SDL_SysWMEvent syswm;
    SDL_TouchFingerEvent tfinger;
    SDL_MultiGestureEvent mgesture;
    SDL_DollarGestureEvent dgesture;
    SDL_DropEvent drop;
# 560 "/usr/local/include/SDL2/SDL_events.h" 3
    Uint8 padding[56];
} SDL_Event;
# 573 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) void SDL_PumpEvents(void);


typedef enum
{
    SDL_ADDEVENT,
    SDL_PEEKEVENT,
    SDL_GETEVENT
} SDL_eventaction;
# 601 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) int SDL_PeepEvents(SDL_Event * events, int numevents,
                                           SDL_eventaction action,
                                           Uint32 minType, Uint32 maxType);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasEvent(Uint32 type);
extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasEvents(Uint32 minType, Uint32 maxType);







extern __attribute__ ((visibility("default"))) void SDL_FlushEvent(Uint32 type);
extern __attribute__ ((visibility("default"))) void SDL_FlushEvents(Uint32 minType, Uint32 maxType);
# 629 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) int SDL_PollEvent(SDL_Event * event);
# 639 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) int SDL_WaitEvent(SDL_Event * event);
# 651 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) int SDL_WaitEventTimeout(SDL_Event * event,
                                                 int timeout);







extern __attribute__ ((visibility("default"))) int SDL_PushEvent(SDL_Event * event);

typedef int ( * SDL_EventFilter) (void *userdata, SDL_Event * event);
# 689 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetEventFilter(SDL_EventFilter filter,
                                                void *userdata);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetEventFilter(SDL_EventFilter * filter,
                                                    void **userdata);




extern __attribute__ ((visibility("default"))) void SDL_AddEventWatch(SDL_EventFilter filter,
                                               void *userdata);




extern __attribute__ ((visibility("default"))) void SDL_DelEventWatch(SDL_EventFilter filter,
                                               void *userdata);





extern __attribute__ ((visibility("default"))) void SDL_FilterEvents(SDL_EventFilter filter,
                                              void *userdata);
# 733 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) Uint8 SDL_EventState(Uint32 type, int state);
# 744 "/usr/local/include/SDL2/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_RegisterEvents(int numevents);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 751 "/usr/local/include/SDL2/SDL_events.h" 2 3
# 42 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_filesystem.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_filesystem.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_filesystem.h" 2 3



extern "C" {
# 63 "/usr/local/include/SDL2/SDL_filesystem.h" 3
extern __attribute__ ((visibility("default"))) char * SDL_GetBasePath(void);
# 126 "/usr/local/include/SDL2/SDL_filesystem.h" 3
extern __attribute__ ((visibility("default"))) char * SDL_GetPrefPath(const char *org, const char *app);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 133 "/usr/local/include/SDL2/SDL_filesystem.h" 2 3
# 43 "/usr/local/include/SDL2/SDL.h" 2 3

# 1 "/usr/local/include/SDL2/SDL_haptic.h" 1 3
# 114 "/usr/local/include/SDL2/SDL_haptic.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 115 "/usr/local/include/SDL2/SDL_haptic.h" 2 3


extern "C" {
# 129 "/usr/local/include/SDL2/SDL_haptic.h" 3
struct _SDL_Haptic;
typedef struct _SDL_Haptic SDL_Haptic;
# 439 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef struct SDL_HapticDirection
{
    Uint8 type;
    Sint32 dir[3];
} SDL_HapticDirection;
# 457 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef struct SDL_HapticConstant
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Sint16 level;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticConstant;
# 538 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef struct SDL_HapticPeriodic
{

    Uint16 type;


    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint16 period;
    Sint16 magnitude;
    Sint16 offset;
    Uint16 phase;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticPeriodic;
# 591 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef struct SDL_HapticCondition
{

    Uint16 type;

    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint16 right_sat[3];
    Uint16 left_sat[3];
    Sint16 right_coeff[3];
    Sint16 left_coeff[3];
    Uint16 deadband[3];
    Sint16 center[3];
} SDL_HapticCondition;
# 628 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef struct SDL_HapticRamp
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Sint16 start;
    Sint16 end;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticRamp;
# 665 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef struct SDL_HapticLeftRight
{

    Uint16 type;


    Uint32 length;


    Uint16 large_magnitude;
    Uint16 small_magnitude;
} SDL_HapticLeftRight;
# 693 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef struct SDL_HapticCustom
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint8 channels;
    Uint16 period;
    Uint16 samples;
    Uint16 *data;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticCustom;
# 789 "/usr/local/include/SDL2/SDL_haptic.h" 3
typedef union SDL_HapticEffect
{

    Uint16 type;
    SDL_HapticConstant constant;
    SDL_HapticPeriodic periodic;
    SDL_HapticCondition condition;
    SDL_HapticRamp ramp;
    SDL_HapticLeftRight leftright;
    SDL_HapticCustom custom;
} SDL_HapticEffect;
# 808 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_NumHaptics(void);
# 821 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_HapticName(int device_index);
# 845 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) SDL_Haptic * SDL_HapticOpen(int device_index);
# 856 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticOpened(int device_index);
# 867 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticIndex(SDL_Haptic * haptic);
# 876 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_MouseIsHaptic(void);
# 886 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) SDL_Haptic * SDL_HapticOpenFromMouse(void);
# 897 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_JoystickIsHaptic(SDL_Joystick * joystick);
# 916 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) SDL_Haptic * SDL_HapticOpenFromJoystick(SDL_Joystick *
                                                               joystick);






extern __attribute__ ((visibility("default"))) void SDL_HapticClose(SDL_Haptic * haptic);
# 940 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticNumEffects(SDL_Haptic * haptic);
# 956 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic);
# 974 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) unsigned int SDL_HapticQuery(SDL_Haptic * haptic);







extern __attribute__ ((visibility("default"))) int SDL_HapticNumAxes(SDL_Haptic * haptic);
# 994 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticEffectSupported(SDL_Haptic * haptic,
                                                      SDL_HapticEffect *
                                                      effect);
# 1009 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticNewEffect(SDL_Haptic * haptic,
                                                SDL_HapticEffect * effect);
# 1029 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticUpdateEffect(SDL_Haptic * haptic,
                                                   int effect,
                                                   SDL_HapticEffect * data);
# 1051 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticRunEffect(SDL_Haptic * haptic,
                                                int effect,
                                                Uint32 iterations);
# 1065 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticStopEffect(SDL_Haptic * haptic,
                                                 int effect);
# 1079 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) void SDL_HapticDestroyEffect(SDL_Haptic * haptic,
                                                     int effect);
# 1094 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticGetEffectStatus(SDL_Haptic * haptic,
                                                      int effect);
# 1113 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticSetGain(SDL_Haptic * haptic, int gain);
# 1129 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticSetAutocenter(SDL_Haptic * haptic,
                                                    int autocenter);
# 1146 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticPause(SDL_Haptic * haptic);
# 1158 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticUnpause(SDL_Haptic * haptic);







extern __attribute__ ((visibility("default"))) int SDL_HapticStopAll(SDL_Haptic * haptic);
# 1178 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticRumbleSupported(SDL_Haptic * haptic);
# 1191 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticRumbleInit(SDL_Haptic * haptic);
# 1205 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticRumblePlay(SDL_Haptic * haptic, float strength, Uint32 length );
# 1217 "/usr/local/include/SDL2/SDL_haptic.h" 3
extern __attribute__ ((visibility("default"))) int SDL_HapticRumbleStop(SDL_Haptic * haptic);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 1224 "/usr/local/include/SDL2/SDL_haptic.h" 2 3
# 45 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_hints.h" 1 3
# 44 "/usr/local/include/SDL2/SDL_hints.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 45 "/usr/local/include/SDL2/SDL_hints.h" 2 3


extern "C" {
# 936 "/usr/local/include/SDL2/SDL_hints.h" 3
typedef enum
{
    SDL_HINT_DEFAULT,
    SDL_HINT_NORMAL,
    SDL_HINT_OVERRIDE
} SDL_HintPriority;
# 953 "/usr/local/include/SDL2/SDL_hints.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_SetHintWithPriority(const char *name,
                                                         const char *value,
                                                         SDL_HintPriority priority);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_SetHint(const char *name,
                                             const char *value);






extern __attribute__ ((visibility("default"))) const char * SDL_GetHint(const char *name);






extern __attribute__ ((visibility("default"))) SDL_bool SDL_GetHintBoolean(const char *name, SDL_bool default_value);




typedef void ( *SDL_HintCallback)(void *userdata, const char *name, const char *oldValue, const char *newValue);
# 991 "/usr/local/include/SDL2/SDL_hints.h" 3
extern __attribute__ ((visibility("default"))) void SDL_AddHintCallback(const char *name,
                                                 SDL_HintCallback callback,
                                                 void *userdata);
# 1002 "/usr/local/include/SDL2/SDL_hints.h" 3
extern __attribute__ ((visibility("default"))) void SDL_DelHintCallback(const char *name,
                                                 SDL_HintCallback callback,
                                                 void *userdata);






extern __attribute__ ((visibility("default"))) void SDL_ClearHints(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 1019 "/usr/local/include/SDL2/SDL_hints.h" 2 3
# 46 "/usr/local/include/SDL2/SDL.h" 2 3

# 1 "/usr/local/include/SDL2/SDL_loadso.h" 1 3
# 47 "/usr/local/include/SDL2/SDL_loadso.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 48 "/usr/local/include/SDL2/SDL_loadso.h" 2 3


extern "C" {







extern __attribute__ ((visibility("default"))) void * SDL_LoadObject(const char *sofile);






extern __attribute__ ((visibility("default"))) void * SDL_LoadFunction(void *handle,
                                               const char *name);




extern __attribute__ ((visibility("default"))) void SDL_UnloadObject(void *handle);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 78 "/usr/local/include/SDL2/SDL_loadso.h" 2 3
# 48 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_log.h" 1 3
# 42 "/usr/local/include/SDL2/SDL_log.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 43 "/usr/local/include/SDL2/SDL_log.h" 2 3


extern "C" {
# 64 "/usr/local/include/SDL2/SDL_log.h" 3
enum
{
    SDL_LOG_CATEGORY_APPLICATION,
    SDL_LOG_CATEGORY_ERROR,
    SDL_LOG_CATEGORY_ASSERT,
    SDL_LOG_CATEGORY_SYSTEM,
    SDL_LOG_CATEGORY_AUDIO,
    SDL_LOG_CATEGORY_VIDEO,
    SDL_LOG_CATEGORY_RENDER,
    SDL_LOG_CATEGORY_INPUT,
    SDL_LOG_CATEGORY_TEST,


    SDL_LOG_CATEGORY_RESERVED1,
    SDL_LOG_CATEGORY_RESERVED2,
    SDL_LOG_CATEGORY_RESERVED3,
    SDL_LOG_CATEGORY_RESERVED4,
    SDL_LOG_CATEGORY_RESERVED5,
    SDL_LOG_CATEGORY_RESERVED6,
    SDL_LOG_CATEGORY_RESERVED7,
    SDL_LOG_CATEGORY_RESERVED8,
    SDL_LOG_CATEGORY_RESERVED9,
    SDL_LOG_CATEGORY_RESERVED10,
# 96 "/usr/local/include/SDL2/SDL_log.h" 3
    SDL_LOG_CATEGORY_CUSTOM
};




typedef enum
{
    SDL_LOG_PRIORITY_VERBOSE = 1,
    SDL_LOG_PRIORITY_DEBUG,
    SDL_LOG_PRIORITY_INFO,
    SDL_LOG_PRIORITY_WARN,
    SDL_LOG_PRIORITY_ERROR,
    SDL_LOG_PRIORITY_CRITICAL,
    SDL_NUM_LOG_PRIORITIES
} SDL_LogPriority;





extern __attribute__ ((visibility("default"))) void SDL_LogSetAllPriority(SDL_LogPriority priority);




extern __attribute__ ((visibility("default"))) void SDL_LogSetPriority(int category,
                                                SDL_LogPriority priority);




extern __attribute__ ((visibility("default"))) SDL_LogPriority SDL_LogGetPriority(int category);






extern __attribute__ ((visibility("default"))) void SDL_LogResetPriorities(void);




extern __attribute__ ((visibility("default"))) void SDL_Log( const char *fmt, ...) __attribute__ (( format( __printf__, 1, 1 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogVerbose(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogDebug(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogInfo(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogWarn(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogError(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogCritical(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogMessage(int category,
                                            SDL_LogPriority priority,
                                                                     const char *fmt, ...) __attribute__ (( format( __printf__, 3, 3 +1 )));




extern __attribute__ ((visibility("default"))) void SDL_LogMessageV(int category,
                                             SDL_LogPriority priority,
                                             const char *fmt, va_list ap);




typedef void ( *SDL_LogOutputFunction)(void *userdata, int category, SDL_LogPriority priority, const char *message);




extern __attribute__ ((visibility("default"))) void SDL_LogGetOutputFunction(SDL_LogOutputFunction *callback, void **userdata);





extern __attribute__ ((visibility("default"))) void SDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void *userdata);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 208 "/usr/local/include/SDL2/SDL_log.h" 2 3
# 49 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_messagebox.h" 1 3
# 28 "/usr/local/include/SDL2/SDL_messagebox.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 29 "/usr/local/include/SDL2/SDL_messagebox.h" 2 3


extern "C" {





typedef enum
{
    SDL_MESSAGEBOX_ERROR = 0x00000010,
    SDL_MESSAGEBOX_WARNING = 0x00000020,
    SDL_MESSAGEBOX_INFORMATION = 0x00000040
} SDL_MessageBoxFlags;




typedef enum
{
    SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 0x00000001,
    SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 0x00000002
} SDL_MessageBoxButtonFlags;




typedef struct
{
    Uint32 flags;
    int buttonid;
    const char * text;
} SDL_MessageBoxButtonData;




typedef struct
{
    Uint8 r, g, b;
} SDL_MessageBoxColor;

typedef enum
{
    SDL_MESSAGEBOX_COLOR_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_TEXT,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED,
    SDL_MESSAGEBOX_COLOR_MAX
} SDL_MessageBoxColorType;




typedef struct
{
    SDL_MessageBoxColor colors[SDL_MESSAGEBOX_COLOR_MAX];
} SDL_MessageBoxColorScheme;




typedef struct
{
    Uint32 flags;
    SDL_Window *window;
    const char *title;
    const char *message;

    int numbuttons;
    const SDL_MessageBoxButtonData *buttons;

    const SDL_MessageBoxColorScheme *colorScheme;
} SDL_MessageBoxData;
# 119 "/usr/local/include/SDL2/SDL_messagebox.h" 3
extern __attribute__ ((visibility("default"))) int SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
# 133 "/usr/local/include/SDL2/SDL_messagebox.h" 3
extern __attribute__ ((visibility("default"))) int SDL_ShowSimpleMessageBox(Uint32 flags, const char *title, const char *message, SDL_Window *window);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 141 "/usr/local/include/SDL2/SDL_messagebox.h" 2 3
# 50 "/usr/local/include/SDL2/SDL.h" 2 3

# 1 "/usr/local/include/SDL2/SDL_power.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_power.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_power.h" 2 3


extern "C" {





typedef enum
{
    SDL_POWERSTATE_UNKNOWN,
    SDL_POWERSTATE_ON_BATTERY,
    SDL_POWERSTATE_NO_BATTERY,
    SDL_POWERSTATE_CHARGING,
    SDL_POWERSTATE_CHARGED
} SDL_PowerState;
# 65 "/usr/local/include/SDL2/SDL_power.h" 3
extern __attribute__ ((visibility("default"))) SDL_PowerState SDL_GetPowerInfo(int *secs, int *pct);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 72 "/usr/local/include/SDL2/SDL_power.h" 2 3
# 52 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_render.h" 1 3
# 55 "/usr/local/include/SDL2/SDL_render.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 56 "/usr/local/include/SDL2/SDL_render.h" 2 3


extern "C" {





typedef enum
{
    SDL_RENDERER_SOFTWARE = 0x00000001,
    SDL_RENDERER_ACCELERATED = 0x00000002,

    SDL_RENDERER_PRESENTVSYNC = 0x00000004,

    SDL_RENDERER_TARGETTEXTURE = 0x00000008

} SDL_RendererFlags;




typedef struct SDL_RendererInfo
{
    const char *name;
    Uint32 flags;
    Uint32 num_texture_formats;
    Uint32 texture_formats[16];
    int max_texture_width;
    int max_texture_height;
} SDL_RendererInfo;




typedef enum
{
    SDL_TEXTUREACCESS_STATIC,
    SDL_TEXTUREACCESS_STREAMING,
    SDL_TEXTUREACCESS_TARGET
} SDL_TextureAccess;




typedef enum
{
    SDL_TEXTUREMODULATE_NONE = 0x00000000,
    SDL_TEXTUREMODULATE_COLOR = 0x00000001,
    SDL_TEXTUREMODULATE_ALPHA = 0x00000002
} SDL_TextureModulate;




typedef enum
{
    SDL_FLIP_NONE = 0x00000000,
    SDL_FLIP_HORIZONTAL = 0x00000001,
    SDL_FLIP_VERTICAL = 0x00000002
} SDL_RendererFlip;




struct SDL_Renderer;
typedef struct SDL_Renderer SDL_Renderer;




struct SDL_Texture;
typedef struct SDL_Texture SDL_Texture;
# 144 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetNumRenderDrivers(void);
# 158 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetRenderDriverInfo(int index,
                                                    SDL_RendererInfo * info);
# 172 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_CreateWindowAndRenderer(
                                int width, int height, Uint32 window_flags,
                                SDL_Window **window, SDL_Renderer **renderer);
# 191 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_Renderer * SDL_CreateRenderer(SDL_Window * window,
                                               int index, Uint32 flags);
# 204 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_Renderer * SDL_CreateSoftwareRenderer(SDL_Surface * surface);




extern __attribute__ ((visibility("default"))) SDL_Renderer * SDL_GetRenderer(SDL_Window * window);




extern __attribute__ ((visibility("default"))) int SDL_GetRendererInfo(SDL_Renderer * renderer,
                                                SDL_RendererInfo * info);




extern __attribute__ ((visibility("default"))) int SDL_GetRendererOutputSize(SDL_Renderer * renderer,
                                                      int *w, int *h);
# 242 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_Texture * SDL_CreateTexture(SDL_Renderer * renderer,
                                                        Uint32 format,
                                                        int access, int w,
                                                        int h);
# 260 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_Texture * SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface);
# 275 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_QueryTexture(SDL_Texture * texture,
                                             Uint32 * format, int *access,
                                             int *w, int *h);
# 292 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetTextureColorMod(SDL_Texture * texture,
                                                   Uint8 r, Uint8 g, Uint8 b);
# 308 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetTextureColorMod(SDL_Texture * texture,
                                                   Uint8 * r, Uint8 * g,
                                                   Uint8 * b);
# 323 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetTextureAlphaMod(SDL_Texture * texture,
                                                   Uint8 alpha);
# 336 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetTextureAlphaMod(SDL_Texture * texture,
                                                   Uint8 * alpha);
# 353 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetTextureBlendMode(SDL_Texture * texture,
                                                    SDL_BlendMode blendMode);
# 366 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetTextureBlendMode(SDL_Texture * texture,
                                                    SDL_BlendMode *blendMode);
# 385 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_UpdateTexture(SDL_Texture * texture,
                                              const SDL_Rect * rect,
                                              const void *pixels, int pitch);
# 408 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_UpdateYUVTexture(SDL_Texture * texture,
                                                 const SDL_Rect * rect,
                                                 const Uint8 *Yplane, int Ypitch,
                                                 const Uint8 *Uplane, int Upitch,
                                                 const Uint8 *Vplane, int Vpitch);
# 429 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_LockTexture(SDL_Texture * texture,
                                            const SDL_Rect * rect,
                                            void **pixels, int *pitch);






extern __attribute__ ((visibility("default"))) void SDL_UnlockTexture(SDL_Texture * texture);
# 447 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RenderTargetSupported(SDL_Renderer *renderer);
# 459 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetRenderTarget(SDL_Renderer *renderer,
                                                SDL_Texture *texture);
# 469 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_Texture * SDL_GetRenderTarget(SDL_Renderer *renderer);
# 494 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderSetLogicalSize(SDL_Renderer * renderer, int w, int h);
# 505 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) void SDL_RenderGetLogicalSize(SDL_Renderer * renderer, int *w, int *h);
# 519 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderSetIntegerScale(SDL_Renderer * renderer,
                                                      SDL_bool enable);
# 529 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RenderGetIntegerScale(SDL_Renderer * renderer);
# 546 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderSetViewport(SDL_Renderer * renderer,
                                                  const SDL_Rect * rect);






extern __attribute__ ((visibility("default"))) void SDL_RenderGetViewport(SDL_Renderer * renderer,
                                                   SDL_Rect * rect);
# 568 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderSetClipRect(SDL_Renderer * renderer,
                                                  const SDL_Rect * rect);
# 580 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) void SDL_RenderGetClipRect(SDL_Renderer * renderer,
                                                   SDL_Rect * rect);
# 590 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RenderIsClipEnabled(SDL_Renderer * renderer);
# 611 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderSetScale(SDL_Renderer * renderer,
                                               float scaleX, float scaleY);
# 623 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) void SDL_RenderGetScale(SDL_Renderer * renderer,
                                               float *scaleX, float *scaleY);
# 638 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetRenderDrawColor(SDL_Renderer * renderer,
                                           Uint8 r, Uint8 g, Uint8 b,
                                           Uint8 a);
# 654 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetRenderDrawColor(SDL_Renderer * renderer,
                                           Uint8 * r, Uint8 * g, Uint8 * b,
                                           Uint8 * a);
# 671 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetRenderDrawBlendMode(SDL_Renderer * renderer,
                                                       SDL_BlendMode blendMode);
# 684 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetRenderDrawBlendMode(SDL_Renderer * renderer,
                                                       SDL_BlendMode *blendMode);
# 695 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderClear(SDL_Renderer * renderer);
# 706 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawPoint(SDL_Renderer * renderer,
                                                int x, int y);
# 718 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawPoints(SDL_Renderer * renderer,
                                                 const SDL_Point * points,
                                                 int count);
# 733 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawLine(SDL_Renderer * renderer,
                                               int x1, int y1, int x2, int y2);
# 745 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawLines(SDL_Renderer * renderer,
                                                const SDL_Point * points,
                                                int count);
# 757 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawRect(SDL_Renderer * renderer,
                                               const SDL_Rect * rect);
# 769 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderDrawRects(SDL_Renderer * renderer,
                                                const SDL_Rect * rects,
                                                int count);
# 782 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderFillRect(SDL_Renderer * renderer,
                                               const SDL_Rect * rect);
# 794 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderFillRects(SDL_Renderer * renderer,
                                                const SDL_Rect * rects,
                                                int count);
# 810 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderCopy(SDL_Renderer * renderer,
                                           SDL_Texture * texture,
                                           const SDL_Rect * srcrect,
                                           const SDL_Rect * dstrect);
# 830 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderCopyEx(SDL_Renderer * renderer,
                                           SDL_Texture * texture,
                                           const SDL_Rect * srcrect,
                                           const SDL_Rect * dstrect,
                                           const double angle,
                                           const SDL_Point *center,
                                           const SDL_RendererFlip flip);
# 853 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_RenderReadPixels(SDL_Renderer * renderer,
                                                 const SDL_Rect * rect,
                                                 Uint32 format,
                                                 void *pixels, int pitch);




extern __attribute__ ((visibility("default"))) void SDL_RenderPresent(SDL_Renderer * renderer);







extern __attribute__ ((visibility("default"))) void SDL_DestroyTexture(SDL_Texture * texture);







extern __attribute__ ((visibility("default"))) void SDL_DestroyRenderer(SDL_Renderer * renderer);
# 890 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GL_BindTexture(SDL_Texture *texture, float *texw, float *texh);
# 899 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GL_UnbindTexture(SDL_Texture *texture);
# 910 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) void * SDL_RenderGetMetalLayer(SDL_Renderer * renderer);
# 921 "/usr/local/include/SDL2/SDL_render.h" 3
extern __attribute__ ((visibility("default"))) void * SDL_RenderGetMetalCommandEncoder(SDL_Renderer * renderer);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 928 "/usr/local/include/SDL2/SDL_render.h" 2 3
# 53 "/usr/local/include/SDL2/SDL.h" 2 3

# 1 "/usr/local/include/SDL2/SDL_shape.h" 1 3
# 31 "/usr/local/include/SDL2/SDL_shape.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 32 "/usr/local/include/SDL2/SDL_shape.h" 2 3


extern "C" {
# 66 "/usr/local/include/SDL2/SDL_shape.h" 3
extern __attribute__ ((visibility("default"))) SDL_Window * SDL_CreateShapedWindow(const char *title,unsigned int x,unsigned int y,unsigned int w,unsigned int h,Uint32 flags);
# 77 "/usr/local/include/SDL2/SDL_shape.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_IsShapedWindow(const SDL_Window *window);


typedef enum {

    ShapeModeDefault,

    ShapeModeBinarizeAlpha,

    ShapeModeReverseBinarizeAlpha,

    ShapeModeColorKey
} WindowShapeMode;




typedef union {

    Uint8 binarizationCutoff;
    SDL_Color colorKey;
} SDL_WindowShapeParams;


typedef struct SDL_WindowShapeMode {

    WindowShapeMode mode;

    SDL_WindowShapeParams parameters;
} SDL_WindowShapeMode;
# 121 "/usr/local/include/SDL2/SDL_shape.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetWindowShape(SDL_Window *window,SDL_Surface *shape,SDL_WindowShapeMode *shape_mode);
# 136 "/usr/local/include/SDL2/SDL_shape.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetShapedWindowMode(SDL_Window *window,SDL_WindowShapeMode *shape_mode);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 143 "/usr/local/include/SDL2/SDL_shape.h" 2 3
# 55 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_system.h" 1 3
# 36 "/usr/local/include/SDL2/SDL_system.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 37 "/usr/local/include/SDL2/SDL_system.h" 2 3


extern "C" {
# 241 "/usr/local/include/SDL2/SDL_system.h" 3
}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 244 "/usr/local/include/SDL2/SDL_system.h" 2 3
# 56 "/usr/local/include/SDL2/SDL.h" 2 3

# 1 "/usr/local/include/SDL2/SDL_timer.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_timer.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 35 "/usr/local/include/SDL2/SDL_timer.h" 2 3


extern "C" {







extern __attribute__ ((visibility("default"))) Uint32 SDL_GetTicks(void);
# 61 "/usr/local/include/SDL2/SDL_timer.h" 3
extern __attribute__ ((visibility("default"))) Uint64 SDL_GetPerformanceCounter(void);




extern __attribute__ ((visibility("default"))) Uint64 SDL_GetPerformanceFrequency(void);




extern __attribute__ ((visibility("default"))) void SDL_Delay(Uint32 ms);
# 81 "/usr/local/include/SDL2/SDL_timer.h" 3
typedef Uint32 ( * SDL_TimerCallback) (Uint32 interval, void *param);




typedef int SDL_TimerID;






extern __attribute__ ((visibility("default"))) SDL_TimerID SDL_AddTimer(Uint32 interval,
                                                 SDL_TimerCallback callback,
                                                 void *param);
# 104 "/usr/local/include/SDL2/SDL_timer.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_RemoveTimer(SDL_TimerID id);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 112 "/usr/local/include/SDL2/SDL_timer.h" 2 3
# 58 "/usr/local/include/SDL2/SDL.h" 2 3
# 1 "/usr/local/include/SDL2/SDL_version.h" 1 3
# 33 "/usr/local/include/SDL2/SDL_version.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 34 "/usr/local/include/SDL2/SDL_version.h" 2 3


extern "C" {
# 51 "/usr/local/include/SDL2/SDL_version.h" 3
typedef struct SDL_version
{
    Uint8 major;
    Uint8 minor;
    Uint8 patch;
} SDL_version;
# 133 "/usr/local/include/SDL2/SDL_version.h" 3
extern __attribute__ ((visibility("default"))) void SDL_GetVersion(SDL_version * ver);
# 142 "/usr/local/include/SDL2/SDL_version.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_GetRevision(void);
# 151 "/usr/local/include/SDL2/SDL_version.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetRevisionNumber(void);




}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 159 "/usr/local/include/SDL2/SDL_version.h" 2 3
# 59 "/usr/local/include/SDL2/SDL.h" 2 3


# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 62 "/usr/local/include/SDL2/SDL.h" 2 3


extern "C" {
# 93 "/usr/local/include/SDL2/SDL.h" 3
extern __attribute__ ((visibility("default"))) int SDL_Init(Uint32 flags);
# 104 "/usr/local/include/SDL2/SDL.h" 3
extern __attribute__ ((visibility("default"))) int SDL_InitSubSystem(Uint32 flags);




extern __attribute__ ((visibility("default"))) void SDL_QuitSubSystem(Uint32 flags);







extern __attribute__ ((visibility("default"))) Uint32 SDL_WasInit(Uint32 flags);





extern __attribute__ ((visibility("default"))) void SDL_Quit(void);



}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 130 "/usr/local/include/SDL2/SDL.h" 2 3
# 10 "./sdl.hpp" 2
# 1 "/usr/local/include/SDL2/SDL_image.h" 1 3
# 29 "/usr/local/include/SDL2/SDL_image.h" 3
# 1 "/usr/local/include/SDL2/begin_code.h" 1 3
# 30 "/usr/local/include/SDL2/SDL_image.h" 2 3



extern "C" {
# 68 "/usr/local/include/SDL2/SDL_image.h" 3
extern __attribute__ ((visibility("default"))) const SDL_version * IMG_Linked_Version(void);

typedef enum
{
    IMG_INIT_JPG = 0x00000001,
    IMG_INIT_PNG = 0x00000002,
    IMG_INIT_TIF = 0x00000004,
    IMG_INIT_WEBP = 0x00000008
} IMG_InitFlags;





extern __attribute__ ((visibility("default"))) int IMG_Init(int flags);


extern __attribute__ ((visibility("default"))) void IMG_Quit(void);
# 95 "/usr/local/include/SDL2/SDL_image.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadTyped_RW(SDL_RWops *src, int freesrc, const char *type);

extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_Load(const char *file);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_Load_RW(SDL_RWops *src, int freesrc);




extern __attribute__ ((visibility("default"))) SDL_Texture * IMG_LoadTexture(SDL_Renderer *renderer, const char *file);
extern __attribute__ ((visibility("default"))) SDL_Texture * IMG_LoadTexture_RW(SDL_Renderer *renderer, SDL_RWops *src, int freesrc);
extern __attribute__ ((visibility("default"))) SDL_Texture * IMG_LoadTextureTyped_RW(SDL_Renderer *renderer, SDL_RWops *src, int freesrc, const char *type);



extern __attribute__ ((visibility("default"))) int IMG_isICO(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isCUR(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isBMP(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isGIF(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isJPG(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isLBM(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isPCX(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isPNG(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isPNM(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isSVG(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isTIF(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isXCF(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isXPM(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isXV(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) int IMG_isWEBP(SDL_RWops *src);


extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadICO_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadCUR_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadBMP_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadGIF_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadJPG_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadLBM_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadPCX_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadPNG_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadPNM_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadSVG_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadTGA_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadTIF_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadXCF_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadXPM_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadXV_RW(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_LoadWEBP_RW(SDL_RWops *src);

extern __attribute__ ((visibility("default"))) SDL_Surface * IMG_ReadXPMFromArray(char **xpm);


extern __attribute__ ((visibility("default"))) int IMG_SavePNG(SDL_Surface *surface, const char *file);
extern __attribute__ ((visibility("default"))) int IMG_SavePNG_RW(SDL_Surface *surface, SDL_RWops *dst, int freedst);
extern __attribute__ ((visibility("default"))) int IMG_SaveJPG(SDL_Surface *surface, const char *file, int quality);
extern __attribute__ ((visibility("default"))) int IMG_SaveJPG_RW(SDL_Surface *surface, SDL_RWops *dst, int freedst, int quality);







}


# 1 "/usr/local/include/SDL2/close_code.h" 1 3
# 160 "/usr/local/include/SDL2/SDL_image.h" 2 3
# 11 "./sdl.hpp" 2
# 12 "./core_utils.h" 2
# 1 "./common_utils.h" 1
# 13 "./core_utils.h" 2
# 1 "./common_utils_cpp.hpp" 1
# 14 "./core_utils.h" 2



enum struct MOVEMENT_DIRECTION : unsigned char
{
    FORWARDS,
    BACKWARDS,
    LEFTWARDS,
    RIGHTWARDS,
    UPWARDS,
    DOWNWARDS
};



namespace input_sys {

enum struct CONTROL {
    UP,
    DOWN,
    LEFT,
    RIGHT,
    JUMP,
    EDIT_MODE,
    EDIT_VERBOSE,
    ZOOM_IN,
    ZOOM_OUT,
    RESET_POSITION,
    PHYSICS,
    LOAD_CONFIG,
    FREE_CAM,

    COUNT
};

enum struct MOUSE_BUTTON {
    LEFT,
    RIGHT,

    COUNT
};
# 68 "./core_utils.h"
struct Input {
    u8 keys_curr[(usize)CONTROL::COUNT]; u8 keys_prev[(usize)CONTROL::COUNT];
    u8 mouse_curr[(usize)MOUSE_BUTTON::COUNT]; u8 mouse_prev[(usize)MOUSE_BUTTON::COUNT];
    i32 mouse_x;
    i32 mouse_y;
};


typedef bool Toggle;





enum struct TOGGLE_BRANCH : u8 {
    PRESSED_ON = 3,
    PRESSED_OFF = 2,
    ON = 1,
    OFF = 0,


    COUNT = 4
};





static inline void init(struct Input* input);




static void keys_advance_history(struct Input* in);


static inline void key_set_up(struct Input* in, CONTROL key);

static inline void key_set_down(struct Input* in, CONTROL key);

static inline bool key_is_pressed(struct Input* in, CONTROL key);

static inline bool key_is_held(struct Input* in, CONTROL key);

static inline bool key_is_released(struct Input* in, CONTROL key);

static inline bool key_is_toggled(struct Input* in, CONTROL key);

static inline bool key_is_toggled_and_pressed(struct Input* in, CONTROL key);

static inline TOGGLE_BRANCH key_is_toggled_4_states(struct Input* in, CONTROL key, Toggle* t);



static void mouse_advance_history(struct Input* in);

static inline void mouse_set_up(struct Input* in, MOUSE_BUTTON mouse_button);

static inline void mouse_set_down(struct Input* in, MOUSE_BUTTON mouse_button);

static inline bool mouse_is_pressed(struct Input* in, MOUSE_BUTTON mouse_button);

static inline bool mouse_is_held(struct Input* in, MOUSE_BUTTON mouse_button);

static inline bool mouse_is_released(struct Input* in, MOUSE_BUTTON mouse_button);

static inline bool mouse_is_toggled(struct Input* in, MOUSE_BUTTON mouse_button);

static inline bool mouse_is_toggled_and_pressed(struct Input* in, MOUSE_BUTTON mouse_button, Toggle* t);


static inline TOGGLE_BRANCH mouse_is_toggled_4_states(struct Input* in, MOUSE_BUTTON mouse_button, Toggle* t);



static void keys_print(struct Input* in);


}

struct WindowState {
    bool focused;
    bool minimized;
    bool restored;
};


inline i32 snap_to_grid(i32 val_x, i32 len);


struct BoxComponent {
    glm::vec4 spatial;
    f64 width;
    f64 height;

    inline f32 position_x(void)
    {
        return this->spatial.x;
    }

    inline f32 position_y(void)
    {
        return this->spatial.y;
    }

    inline f32 position_z(void)
    {
        return this->spatial.z;
    }

    inline glm::vec3 position(void)
    {
        return glm::vec3(this->spatial);
    }

    inline f32 angle(void)
    {
        return this->spatial.w;
    }

    inline glm::vec2 calc_position_center(void)
    {
        return glm::vec2(this->spatial.x + (this->width / 2.0f), this->spatial.y + (this->height / 2));
    }

    inline void position_set(f64 x, f64 y)
    {
        this->spatial.x = x;
        this->spatial.y = y;
    }

    inline void position_set_center(f64 x, f64 y)
    {
        const f64 half_width = this->width / 2;
        const f64 half_height = this->height / 2;
        this->spatial.x = x - half_width;
        this->spatial.y = y - half_height;
    }

    inline void position_set_center(void)
    {
        const f64 half_width = this->width / 2;
        const f64 half_height = this->height / 2;
        this->spatial.x -= half_width;
        this->spatial.y -= half_height;
    }

    inline void orientation_set(f64 angle)
    {
        this->spatial.w = angle;
    }
};

void BoxComponent_init(f64 x, f64 y, f64 z, f64 angle, f64 width, f64 height);





struct Player {
    BoxComponent bound;
    f64 state_change_time;
    glm::vec2 velocity_ground;
    glm::vec2 velocity_air;
    f64 acceleration_ground;
    f64 acceleration_air;
    f64 initial_jump_velocity;
    f64 initial_jump_velocity_short;

    static constexpr f64 JUMP_VELOCITY_DEFAULT = -6.5;
    static constexpr f64 JUMP_VELOCITY_SHORT_DEFAULT = -4.0;
    bool on_ground;

    inline std::pair<glm::vec4, glm::vec4> floor_sensors(void)
    {
        return {

            glm::vec4(
                this->bound.spatial.x + (this->bound.width / 2) - 8.0,
                this->bound.spatial.y + (this->bound.height / 2),
                this->bound.spatial.z,
                0.0f
            ),
            glm::vec4(
                this->bound.spatial.x + (this->bound.width / 2) + 8.0,
                this->bound.spatial.y + (this->bound.height / 2),
                this->bound.spatial.z,
                0.0f
            )
        };
    }

    inline std::pair<
        std::pair<glm::vec3, glm::vec3>,
        std::pair<glm::vec3, glm::vec3>
    >
    floor_sensor_rays(void)
    {
        return {
            {
                glm::vec3(
                    (this->bound.spatial.x + (this->bound.width / 2)) - 9.0,
                    this->bound.spatial.y + (this->bound.height / 2),
                    this->bound.spatial.z
                ),
                glm::vec3(
                    (this->bound.spatial.x + (this->bound.width / 2)) - 9.0,
                    this->bound.spatial.y + this->bound.height + (this->bound.height * 0.4),
                    this->bound.spatial.z
                )
            },
            {
                glm::vec3(
                    (this->bound.spatial.x + (this->bound.width / 2)) + 9.0,
                    this->bound.spatial.y + (this->bound.height / 2),
                    this->bound.spatial.z
                ),
                glm::vec3(
                    (this->bound.spatial.x + (this->bound.width / 2)) + 9.0,
                    this->bound.spatial.y + this->bound.height + (this->bound.height * 0.4),
                    this->bound.spatial.z
                )
            }
        };
    }
# 325 "./core_utils.h"
};

void Player_init(Player* pl);

void Player_init(Player* pl, f64 x, f64 y, f64 z, bool position_at_center, f64 angle, f64 width, f64 height);

void Player_move_test(Player* you, MOVEMENT_DIRECTION direction, GLfloat delta_time);


# 1 "./config/config_state.cpp" 1
# 334 "./core_utils.h" 2
# 343 "./core_utils.h"
# 1 "./config/config_state.cpp" 1
# 66 "./config/config_state.cpp"
# 1 "./config/./config_movement.cpp" 1
# 11 "./config/./config_movement.cpp"
namespace wee { f64 WEEf64 = 0.0; }
namespace wee { i32 WEEi32 = 1; }
namespace ha { char HAchar = '2'; }


namespace physics { f64 GRAVITY_DEFAULT = 0.21875; }
namespace physics { f64 GRAVITY_TERRESTRIAL = 0.21875; }
namespace physics { f64 GRAVITY_OUTER_SPACE = 0.21875 / 2; }
namespace physics { f64 gravity = 0.21875; }
# 67 "./config/config_state.cpp" 2
# 83 "./config/config_state.cpp"
        ConfigVar config_state[] = {

# 1 "./config/./config_movement.cpp" 1
# 11 "./config/./config_movement.cpp"
{PROPERTY_TYPE::PROP_f64, "WEEf64", "wee", .f_f64 = 0.0, (void*)&wee::WEEf64},
{PROPERTY_TYPE::PROP_i32, "WEEi32", "wee", .f_i32 = 1, (void*)&wee::WEEi32},
{PROPERTY_TYPE::PROP_char, "HAchar", "ha", .f_char = '2', (void*)&ha::HAchar},


{PROPERTY_TYPE::PROP_f64, "GRAVITY_DEFAULT", "physics", .f_f64 = 0.21875, (void*)&physics::GRAVITY_DEFAULT},
{PROPERTY_TYPE::PROP_f64, "GRAVITY_TERRESTRIAL", "physics", .f_f64 = 0.21875, (void*)&physics::GRAVITY_TERRESTRIAL},
{PROPERTY_TYPE::PROP_f64, "GRAVITY_OUTER_SPACE", "physics", .f_f64 = 0.21875 / 2, (void*)&physics::GRAVITY_OUTER_SPACE},
{PROPERTY_TYPE::PROP_f64, "gravity", "physics", .f_f64 = 0.21875, (void*)&physics::gravity},
# 85 "./config/config_state.cpp" 2
 };
# 94 "./config/config_state.cpp"
        char* seek_arg_list_begin(char* buff, char* buff_end)
        {
            static char stack[16];
            char* stack_marker = &stack[1];
            char* stack_end = &stack[16];

            char* marker = buff;
            bool single_comment = false;
            bool multi_comment = false;
            while (marker != buff_end) {
                if (single_comment && *marker != '\0' && *marker != '\n') {
                    marker += 1;
                    continue;
                }

                bool do_print = true;

                switch (*marker) {
                case '\0':
                    single_comment = false;
                    marker += 1;
                    continue;
                    break;
                case '\n':
                    single_comment = false;
                    marker += 1;
                    continue;
                    break;
                case '/':
                    if (*(stack_marker - 1) == '/') {
                        single_comment = true;
                    } else {
                        *stack_marker = '/';
                        stack_marker += 1;
                    }
                    break;
                case '*':
                    break;
                case '+':
                    break;
                case '-':
                    break;
                case '(':
                    break;
                case ')':
                    break;
                case ',':
                    break;
                case ' ':
                case '\t':
                case '\r':
                    do_print = false;
                    break;
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '_':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case '#':
                    break;
                default:
                    if (!single_comment && !multi_comment) {

                    }
                    break;
                }

                if (do_print) {
                    std::cout << *marker;
                }

                marker += 1;
            }
            (__builtin_expect(!(buff != buff_end), 0) ? __assert_rtn(__func__, "./config/config_state.cpp", 225, "buff != buff_end") : (void)0);

            return std::__1::__get_nullptr_t();
        }

        char* parse_arg_list(char* buff)
        {
            return std::__1::__get_nullptr_t();
        }

        void ConfigState_load_runtime(void)
        {
            static char buff[512];

            char aliases[512];
            char* aliases_indices[512];

            FILE* fp = fopen("./config/config_movement.cpp", "r");
            (__builtin_expect(!(fp != std::__1::__get_nullptr_t()), 0) ? __assert_rtn(__func__, "./config/config_state.cpp", 243, "fp != nullptr") : (void)0);

            while (fgets(buff, sizeof(buff), fp) != std::__1::__get_nullptr_t()) {
                buff[511] = '\0';


                char* args_begin = seek_arg_list_begin(buff, &buff[strlen(buff)]);


                buff[511] = '\0';

            }

            (__builtin_expect(!(!ferror(fp)), 0) ? __assert_rtn(__func__, "./config/config_state.cpp", 256, "!ferror(fp)") : (void)0);


            file_io::flush_and_close_file(fp);
        }
# 344 "./core_utils.h" 2






namespace input_sys {

static void keys_advance_history(struct Input* in)
{
    u8* curr = in->keys_curr;
    u8* prev = in->keys_prev;
    for (u64 (i) = 0; (i) < ((u64)CONTROL::COUNT); ++(i)) {
        prev[i] = curr[i];
    }
}

static inline void key_set_up(struct Input* in, CONTROL key)
{
    in->keys_curr[((u8)key)] = 0x00;
}

static inline void key_set_down(struct Input* in, CONTROL key)
{
    in->keys_curr[((u8)key)] = 0x01;
}

static inline bool key_is_pressed(struct Input* in, CONTROL key)
{
    return in->keys_curr[((u8)key)] && !in->keys_prev[((u8)key)];
}

static inline bool key_is_held(struct Input* in, CONTROL key)
{
    return in->keys_curr[((u8)key)];
}

static inline bool key_is_released(struct Input* in, CONTROL key)
{
    return !in->keys_curr[((u8)key)] && in->keys_prev[((u8)key)];
}

static inline bool key_is_toggled(struct Input* in, CONTROL key, Toggle* t)
{
    if (key_is_pressed(in, key)) {
        *t = !*t;
    }
    return *t;
}

static inline bool key_is_toggled_and_pressed(struct Input* in, CONTROL key, Toggle* t)
{
    if (key_is_pressed(in, key)) {
        *t = !*t;
        return *t;
    }
    return false;
}
# 411 "./core_utils.h"
static inline TOGGLE_BRANCH key_is_toggled_4_states(struct Input* in, CONTROL key, Toggle* t)
{
    u8 state = 0;

    if (key_is_pressed(in, key)) {

        state = 2;

        *t = !*t;
    }

    state += (*t);

    return (TOGGLE_BRANCH)state;
}


static void mouse_advance_history(struct Input* in)
{
    u8* curr = in->mouse_curr;
    u8* prev = in->mouse_prev;
    for (u64 (i) = 0; (i) < ((u64)MOUSE_BUTTON::COUNT); ++(i)) {
        prev[i] = curr[i];
    }
}

static inline void mouse_set_up(struct Input* in, MOUSE_BUTTON mouse_button)
{
    in->mouse_curr[((u8)mouse_button)] = 0x00;
}

static inline void mouse_set_down(struct Input* in, MOUSE_BUTTON mouse_button)
{
    in->mouse_curr[((u8)mouse_button)] = 0x01;
}

static inline bool mouse_is_pressed(struct Input* in, MOUSE_BUTTON mouse_button)
{
    return in->mouse_curr[((u8)mouse_button)] && !in->mouse_prev[((u8)mouse_button)];
}

static inline bool mouse_is_held(struct Input* in, MOUSE_BUTTON mouse_button)
{
    return in->mouse_curr[((u8)mouse_button)];
}

static inline bool mouse_is_released(struct Input* in, MOUSE_BUTTON mouse_button)
{
    return !in->mouse_curr[((u8)mouse_button)] && in->mouse_prev[((u8)mouse_button)];
}

static inline bool mouse_is_toggled(struct Input* in, MOUSE_BUTTON mouse_button, Toggle* t)
{
    if (mouse_is_pressed(in, mouse_button)) {
        *t = !*t;
    }
    return *t;
}

static inline bool mouse_is_toggled_and_pressed(struct Input* in, MOUSE_BUTTON mouse_button, Toggle* t)
{
    if (mouse_is_pressed(in, mouse_button)) {
        *t = !*t;
        return *t;
    }
    return false;
}
# 488 "./core_utils.h"
static inline TOGGLE_BRANCH mouse_is_toggled_4_states(struct Input* in, MOUSE_BUTTON mouse_button, Toggle* t)
{
    u8 state = 0;

    if (mouse_is_pressed(in, mouse_button)) {

        state = 2;

        *t = !*t;
    }

    state += (*t);

    return (TOGGLE_BRANCH)state;
}

static void keys_print(struct Input* in)
{
    u8* k_curr = in->keys_curr;
    u8* k_prev = in->keys_prev;
    printf("{\n\tCURR: [ ");
    for (usize i = 0; i < (usize)CONTROL::COUNT; ++i) {
        printf("%u, ", k_curr[i]);
    }
    printf("]\n\tPREV: [ ");
    for (usize i = 0; i < (usize)CONTROL::COUNT; ++i) {
        printf("%u, ", k_prev[i]);
    }
    printf("]\n}\n");
}

static inline void init(struct Input* input)
{
    memset(input, 0x00, sizeof(struct Input));
}


}

inline i32 snap_to_grid(i32 val_x, i32 len)
{
    return glm::round((f64)val_x / (f64)len) * len;
}


void BoxComponent_init(BoxComponent* bc, f64 x, f64 y, f64 z, f64 angle, f64 width, f64 height)
{
    bc->spatial.x = x;
    bc->spatial.y = y;
    bc->spatial.z = z;
    bc->spatial.w = angle;
    bc->width = width;
    bc->height = height;
}

void Player_init(Player* pl )
{






    memset(pl, 0x00, sizeof(Player));
}

void Player_init(Player* pl, f64 x, f64 y, f64 z, bool position_at_center, f64 angle, f64 width, f64 height)
{
    BoxComponent_init(&pl->bound, x, y, z, angle, width, height);
    if (position_at_center) {
        pl->bound.position_set_center();
    }

    pl->on_ground = false;
    pl->state_change_time = 0.0;
    pl->velocity_ground = glm::vec2(0.0);
    pl->velocity_air = glm::vec2(0.0);
    pl->acceleration_air = 0.0;
    pl->acceleration_ground = 0.0;
    pl->initial_jump_velocity = Player::JUMP_VELOCITY_DEFAULT;
    pl->initial_jump_velocity_short = Player::JUMP_VELOCITY_SHORT_DEFAULT;
}

void Player_move_test(Player* you, MOVEMENT_DIRECTION direction, GLfloat delta_time)
{
    const GLfloat velocity = glm::min((0.01 * 360.0f) * delta_time, (32.0));
    glm::vec4* p = &you->bound.spatial;




    switch (direction) {
    case MOVEMENT_DIRECTION::FORWARDS:



        p->z -= velocity;
        break;
    case MOVEMENT_DIRECTION::BACKWARDS:



        p->z += velocity;
        break;
    case MOVEMENT_DIRECTION::LEFTWARDS:



        p->x -= velocity;
        break;
    case MOVEMENT_DIRECTION::RIGHTWARDS:



        p->x += velocity;
        break;
    case MOVEMENT_DIRECTION::UPWARDS:



        p->y -= velocity;
        break;
    case MOVEMENT_DIRECTION::DOWNWARDS:



        p->y += velocity;
        break;
    }







    p->z = glm::clamp(p->z, -1.0f, 1.0f);
}
# 25 "run.cpp" 2


# 1 "./entity.h" 1



# 1 "./common_utils.h" 1
# 5 "./entity.h" 2
# 1 "./common_utils_cpp.hpp" 1
# 6 "./entity.h" 2
# 17 "./entity.h"
    enum struct FIELD_TYPE {

        f_i64 , f_u64 , f_usize , f_f64 , f_i32 , f_u32 , f_f32 , f_i16 , f_u16 , f_i8 , f_u8 , f_bool , f_char , f_byteptr , f_vec2 , f_vec3 , f_vec4 ,


# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

f_Thing,
# 2 "././entities/entity_includes.hpp" 2
# 22 "./entity.h" 2
 COUNT_FIELD_TYPE
    };

    FIELD_TYPE x = FIELD_TYPE::f_u16;
# 47 "./entity.h"
# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

struct Thing {
    vec2 position;
    f32 speed;
    u32 health;
    u32 damage;
}; Thing Thing_array[ (((64 +0) > 0 && (64 +0) <= 0xFFFFFFFF) ? (64 + 0) : 1) ]; constexpr unsigned int Thing_array_count = (((64 +0) > 0 && (64 +0) <= 0xFFFFFFFF) ? (64 +0) : 1);
# 2 "././entities/entity_includes.hpp" 2
# 48 "./entity.h" 2
# 57 "./entity.h"
    struct FieldMetaData {
        const char* name;
        const i32 offset;
        FIELD_TYPE type;
        bool is_pointer;
        bool is_array;
    };
# 72 "./entity.h"
# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

FieldMetaData Thing_meta_data[] = {
    { "position", __builtin_offsetof(Thing, position), FIELD_TYPE::f_vec2, false, false},
    { "speed", __builtin_offsetof(Thing, speed), FIELD_TYPE::f_f32, false, false},
    { "health", __builtin_offsetof(Thing, health), FIELD_TYPE::f_u32, false, false},
    { "damage", __builtin_offsetof(Thing, damage), FIELD_TYPE::f_u32, false, false},
};
# 2 "././entities/entity_includes.hpp" 2
# 73 "./entity.h" 2
# 82 "./entity.h"
    struct ArrayMetaData {
        const char* name;
        void* array;
        const i32 element_size;
        void* meta_array;
    };
# 96 "./entity.h"
    ArrayMetaData meta_arrays[] = {

# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

{ "Thing_array", Thing_array, sizeof(Thing), Thing_meta_data




},
# 2 "././entities/entity_includes.hpp" 2
# 98 "./entity.h" 2
 };
# 28 "run.cpp" 2


# 1 "./collision.h" 1



# 1 "./common_utils.h" 1
# 5 "./collision.h" 2
# 1 "./common_utils_cpp.hpp" 1
# 6 "./collision.h" 2
# 1 "./core_utils.h" 1
# 7 "./collision.h" 2




struct Collider {
    glm::vec3 a;
    glm::vec3 b;

};

void Collider_print(Collider* c);


struct CollisionStatus {
    Collider* collider;

    glm::vec3 intersection;

    inline bool collided(void)
    {
        return this->collider != std::__1::__get_nullptr_t();
    }
};

void CollisionStatus_init(CollisionStatus* out);


extern Buffer<Collider, (2048)> collision_map;



glm::vec3 temp_test_collision(Player* you, Collider* c);






void CollisionStatus_init(CollisionStatus* out)
{
    out->collider = std::__1::__get_nullptr_t();
    out->intersection = glm::vec3((std::numeric_limits<f64>::infinity()));
}

Buffer<Collider, (2048)> collision_map;


void Collider_print(Collider* c)
{
    printf("[[%f, %f, %f][%f, %f, %f]]", c->a.x, c->a.y, c->a.z, c->b.x, c->b.y, c->b.z);
}
# 31 "run.cpp" 2
# 42 "run.cpp"
# 1 "./shader.hpp" 1
# 37 "./shader.hpp"
struct Shader {
    GLuint program;

    operator GLuint()
    {
        return this->program;
    }
};

bool Shader_init_program(Shader* shader, const GLchar* vertex_src, const GLchar* fragment_src);

bool Shader_load_from_file(Shader* shader, const std::string& vertex_path, const std::string& fragment_path,
                        const std::string& vert_addons="",
                        const std::string& frag_addons="");

bool Shader_load_from_src(Shader* shader, const std::string& vertex_src, const std::string& fragment_src,
                        const std::string& vert_addons="",
                        const std::string& frag_addons="");

std::string Shader_retrieve_src_from_file(const GLchar* path, bool* is_valid);




# 1 "./shader.cpp" 1
# 1 "./shader.hpp" 1
# 2 "./shader.cpp" 2

using namespace file_io;

bool Shader_load_from_file(Shader* shader, const std::string& vertex_path, const std::string& fragment_path,
                        const std::string& vert_addons,
                        const std::string& frag_addons)
{

    bool status = false;
    std::string vs = Shader_retrieve_src_from_file(vertex_path.c_str(), &status);
    if (!status) {
        return false;
    }
    std::string fs = Shader_retrieve_src_from_file(fragment_path.c_str(), &status);
    if (!status) {
        return false;
    }

    return Shader_load_from_src(
        shader,
        vs,
        fs,
        vert_addons,
        frag_addons
    );
}

bool Shader_load_from_src(Shader* shader, const std::string& vertex_src, const std::string& fragment_src,
                        const std::string& vert_addons,
                        const std::string& frag_addons)
{
    std::string vertex_combined;
    std::string fragment_combined;

    if (vert_addons.length() > 0) {
        vertex_combined = vertex_src;
        std::string::size_type main_idx = vertex_combined.find("void main(");
        if (main_idx == std::string::npos) {
            return false;
        }
        vertex_combined.insert(main_idx, vert_addons);
    }
    if (frag_addons.length() > 0) {
        fragment_combined = fragment_src;
        std::string::size_type main_idx = fragment_combined.find("void main(");
        if (main_idx == std::string::npos) {
            return false;
        }
        fragment_combined.insert(main_idx, frag_addons);
    }

    return Shader_init_program(
        shader,
        (vertex_combined.length() > 0) ? vertex_combined.c_str() : vertex_src.c_str(),
        (fragment_combined.length() > 0) ? fragment_combined.c_str() : fragment_src.c_str()
    );
}

bool Shader_init_program(Shader* shader, const GLchar* vertex_src, const GLchar* fragment_src)
{

    GLchar info_log[512];
    GLint success = 0;



    GLuint vertex_shader = __glewCreateShader(0x8B31);

    __glewShaderSource(vertex_shader, 1, &vertex_src, __null);

    __glewCompileShader(vertex_shader);


    __glewGetShaderiv(vertex_shader, 0x8B81, &success);
    if (success != 1) {
        __glewGetShaderInfoLog(vertex_shader, 512, __null, info_log);
        fprintf(__stderrp, "%s %s\n", "ERROR: VERTEX SHADER COMPILATION FAILED", info_log);
        return false;
    }




    GLuint fragment_shader = __glewCreateShader(0x8B30);

    __glewShaderSource(fragment_shader, 1, &fragment_src, __null);

    __glewCompileShader(fragment_shader);


    __glewGetShaderiv(fragment_shader, 0x8B81, &success);
    if (success != 1) {
        __glewGetShaderInfoLog(fragment_shader, 512, __null, info_log);
        fprintf(__stderrp, "%s %s\n", "ERROR: FRAGMENT SHADER COMPILATION FAILED", info_log);
        return false;
    }


    shader->program = __glewCreateProgram();

    __glewAttachShader(shader->program, vertex_shader);

    __glewAttachShader(shader->program, fragment_shader);

    __glewLinkProgram(shader->program);


    __glewGetProgramiv(shader->program, 0x8B82, &success);
    if (success != 1) {
        __glewGetProgramInfoLog(shader->program, 512, __null, info_log);
        fprintf(__stderrp, "%s %s\n", "ERROR: SHADER PROGRAM LINK FAILED", info_log);
        return false;
    }

    __glewDetachShader(shader->program, vertex_shader);
    __glewDetachShader(shader->program, fragment_shader);

    __glewDeleteShader(vertex_shader);
    __glewDeleteShader(fragment_shader);

    return true;
}

std::string Shader_retrieve_src_from_file(const GLchar* path, bool* is_valid)
{
    FILE* shader_fd = fopen(path, "r");
    if (shader_fd == __null) {
        return "";
    }

    std::string out = read_file(shader_fd);

    if (ferror(shader_fd) == 0 || (*__error()) != 0) {
        *is_valid = true;
        flush_and_close_file(shader_fd);
    } else {
        *is_valid = false;
    }

    return out;
}
# 61 "./shader.hpp" 2
# 43 "run.cpp" 2


# 1 "./texture.hpp" 1
# 13 "./texture.hpp"
GLboolean GL_texture_load(Texture* texture_id, const char* const path, const GLboolean alpha, const GLint param_edge_x, const GLint param_edge_y);

GLboolean GL_texture_gen_and_load_1(Texture* texture_id, const char* const path, const GLboolean alpha, const GLint param_edge_x, const GLint param_edge_y);




# 1 "./texture.cpp" 1
# 1 "./texture.hpp" 1
# 2 "./texture.cpp" 2

GLboolean GL_texture_load(Texture* texture_id, const char* const path, const GLboolean alpha, const GLint param_edge_x, const GLint param_edge_y)
{

    printf("loading %s\n", path);
    SDL_Surface* img = __null;
    if (!(img = IMG_Load(path))) {
        fprintf(__stderrp, "SDL_image could not be loaded %s, SDL_image Error: %s\n",
               path, SDL_GetError());
        return 0;
    }


    glBindTexture(0x0DE1, *texture_id);

    GLuint format = (alpha) ? 0x1908 : 0x1907;

    glTexImage2D(0x0DE1, 0, format, img->w, img->h, 0, format, 0x1401, (GLvoid*)img->pixels);


    glTexParameteri(0x0DE1, 0x2802, param_edge_x);
    glTexParameteri(0x0DE1, 0x2803, param_edge_y);

    glTexParameteri(0x0DE1, 0x2801, 0x2600);
    glTexParameteri(0x0DE1, 0x2800, 0x2600);
    glBindTexture(0x0DE1, 0);

    SDL_FreeSurface(img);

    return 1;
}

GLboolean GL_texture_gen_and_load_1(Texture* texture_id, const char* const path, const GLboolean alpha, const GLint param_edge_x, const GLint param_edge_y)
{
    glGenTextures(1, texture_id);
    return GL_texture_load(texture_id, path, alpha, param_edge_x, param_edge_y);
}
# 20 "./texture.hpp" 2
# 46 "run.cpp" 2


# 1 "./camera.hpp" 1
# 14 "./camera.hpp"
# 1 "./core_utils.h" 1
# 15 "./camera.hpp" 2






static const GLfloat ViewCamera_default_speed = 4.0f;

typedef struct ViewCamera {
    glm::vec3 position;
    GLfloat speed;
    glm::mat4 matrix;
    GLfloat min_x;
    GLfloat max_x;
    GLfloat min_y;
    GLfloat max_y;
    GLfloat min_z;
    GLfloat max_z;
} ViewCamera;

void ViewCamera_init(
    ViewCamera* view,
    glm::vec3 position_start,
    GLfloat speed,
    GLfloat min_z = -std::numeric_limits<double>::infinity(),
    GLfloat max_z = std::numeric_limits<double>::infinity(),
    GLfloat min_x = 0.0f,
    GLfloat max_x = std::numeric_limits<double>::infinity(),
    GLfloat min_y = 0.0f,
    GLfloat max_y = std::numeric_limits<double>::infinity()
);

void ViewCamera_process_directional_movement(ViewCamera* view, MOVEMENT_DIRECTION direction, GLfloat delta_time);
glm::mat4 ViewCamera_calc_view_matrix(ViewCamera* view);


enum class Camera_Movement : unsigned char
{
    FORWARDS,
    BACKWARDS,
    LEFTWARDS,
    RIGHTWARDS,
    UPWARDS,
    DOWNWARDS
};

namespace camera_defaults {
    const GLfloat YAW = -90.0f;
    const GLfloat PITCH = 0.0f;
    const GLfloat SPEED = 4.0f;
    const GLfloat SENSITIVITY = 0.25f;
    const GLfloat ZOOM = 45.0f;
}

struct Camera {

    glm::vec3 pos;
    glm::vec3 front;
    glm::vec3 up;
    glm::vec3 right;
    glm::vec3 world_up;

    GLfloat yaw;
    GLfloat pitch;

    GLfloat movement_speed;
    GLfloat mouse_sensitivity;
    GLfloat zoom;

    GLfloat minZ;
    GLfloat maxZ;


    Camera(
        glm::vec3 pos = glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f),
        GLfloat yaw = camera_defaults::YAW,
        GLfloat pitch = camera_defaults::PITCH
    );


    Camera(
        GLfloat pos_x, GLfloat pos_y, GLfloat pos_z,
        GLfloat up_x, GLfloat up_y, GLfloat up_z,
        GLfloat yaw = camera_defaults::YAW,
        GLfloat pitch = camera_defaults::PITCH
    );

    glm::mat4 get_view_matrix(void);

    void process_directional_movement(Camera_Movement direction, GLfloat delta_time);
    void process_mouse_movement(GLfloat x_offset, GLfloat y_offset, GLboolean constrain_pitch = 1);
    void process_mouse_scroll(GLfloat y_offset);
private:
    void update_camera_vectors(void);
};


struct FreeCamera {
 glm::vec3 position;
 glm::quat orientation;
    glm::mat4 matrix;
    GLfloat speed;

    glm::vec2 target;

    glm::vec2 offset;

    glm::vec2 target_diff;

    bool is_catching_up;


 FreeCamera (const FreeCamera &) = default;

 FreeCamera (const glm::vec3 &position) : position(position) { is_catching_up = false; }
 FreeCamera (const glm::vec3 &position, const glm::quat &orientation) : position(position), orientation(orientation) {}

 FreeCamera &operator=(const FreeCamera&) = default;

 glm::mat4 get_view_matrix(void) const { return glm::translate(glm::mat4_cast(orientation), -position); }

 void translate(const glm::vec3 &v) { position += v * orientation; }
 void translate(float x, float y, float z) { position += glm::vec3(x, y, z) * orientation; }

 void rotate(float angle, const glm::vec3& axis) { orientation *= glm::angleAxis(angle, axis * orientation); }
 void rotate(float angle, float x, float y, float z) { orientation *= glm::angleAxis(angle, glm::vec3(x, y, z) * orientation); }

 void yaw(float angle) { this->rotate(-angle, 0.0f, 1.0f, 0.0f); }
 void pitch(float angle) { this->rotate(-angle, 1.0f, 0.0f, 0.0f); }
 void roll(float angle) { this->rotate(-angle, 0.0f, 0.0f, 1.0f); }
};

void FreeCamera_init(FreeCamera* view, glm::vec3 start_position = glm::vec3(0.0));


void FreeCamera_process_directional_movement(FreeCamera* view, MOVEMENT_DIRECTION direction, GLfloat delta_time);

glm::mat4 FreeCamera_calc_view_matrix(FreeCamera* view);
glm::mat4 FreeCamera_calc_view_matrix_reverse(FreeCamera* view);

void FreeCamera_target_set(FreeCamera* view, glm::vec2 target);
void FreeCamera_target_x_set(FreeCamera* view, f64 target);
void FreeCamera_target_y_set(FreeCamera* view, f64 target);

void FreeCamera_target_follow(FreeCamera* view, f64 t_delta_s);
void FreeCamera_target_follow_x(FreeCamera* view, f64 t_delta_s);
void FreeCamera_target_follow_y(FreeCamera* view, f64 t_delta_s);





# 1 "./camera.cpp" 1
# 1 "./camera.hpp" 1
# 2 "./camera.cpp" 2


void ViewCamera_init(ViewCamera* view, glm::vec3 position_start, GLfloat speed, GLfloat min_z, GLfloat max_z, GLfloat min_x, GLfloat max_x, GLfloat min_y, GLfloat max_y)
{
    view->position = -position_start;
    view->speed = speed;
    view->matrix = glm::mat4(1.0f);

    view->min_x = min_x;
    view->max_x = max_x;
    view->min_y = min_y;
    view->max_y = max_y;
    view->min_z = min_z;
    view->max_z = max_z;
}

void ViewCamera_process_directional_movement(ViewCamera* view, MOVEMENT_DIRECTION direction, GLfloat delta_time)
{
    const GLfloat velocity = view->speed * delta_time;
    glm::vec3* p = &view->position;


    switch (direction) {
    case MOVEMENT_DIRECTION::FORWARDS:

        std::cout << "FORWARDS" << std::endl;

        p->z -= velocity;
        break;
    case MOVEMENT_DIRECTION::BACKWARDS:

        std::cout << "BACKWARDS" << std::endl;

        p->z += velocity;
        break;
    case MOVEMENT_DIRECTION::LEFTWARDS:

        std::cout << "LEFTWARDS" << std::endl;

        p->x -= velocity;
        break;
    case MOVEMENT_DIRECTION::RIGHTWARDS:

        std::cout << "RIGHTWARDS" << std::endl;

        p->x += velocity;
        break;
    case MOVEMENT_DIRECTION::UPWARDS:

        std::cout << "UPWARDS" << std::endl;

        p->y += velocity;
        break;
    case MOVEMENT_DIRECTION::DOWNWARDS:

        std::cout << "DOWNWARDS" << std::endl;

        p->y -= velocity;
        break;
    }



    p->x = glm::clamp(view->position.x, view->min_x, view->max_x);
    p->y = glm::clamp(view->position.y, view->min_y, view->max_y);
    p->z = glm::clamp(view->position.z, view->min_z, view->max_z);
}


static const glm::mat4 m_identity(1.0f);
glm::mat4 ViewCamera_calc_view_matrix(ViewCamera* view)
{
    return view->matrix = glm::translate(m_identity, -view->position);
}





Camera::Camera(glm::vec3 pos, glm::vec3 up, GLfloat yaw, GLfloat pitch)
: pos(pos),
    front(glm::vec3(0.0f, 0.0f, -1.0f)),
    up(up),
    world_up(up),
    yaw(yaw),
    pitch(pitch),
    movement_speed(camera_defaults::SPEED),
    mouse_sensitivity(camera_defaults::SENSITIVITY),
    zoom(camera_defaults::ZOOM)
{
    this->update_camera_vectors();
}


Camera::Camera(GLfloat pos_x, GLfloat pos_y, GLfloat pos_z,
                GLfloat up_x, GLfloat up_y, GLfloat up_z,
                GLfloat yaw, GLfloat pitch)
: pos(glm::vec3(pos_x, pos_y, pos_z)),
    front(glm::vec3(0.0f, 0.0f, -1.0f)),
    up(glm::vec3(up_x, up_y, up_z)),
    world_up(glm::vec3(up_x, up_y, up_z)),
    yaw(yaw),
    pitch(pitch),
    movement_speed(camera_defaults::SPEED),
    mouse_sensitivity(camera_defaults::SENSITIVITY),
    zoom(camera_defaults::ZOOM),
    minZ(-1.0f),
    maxZ(1.0f)
{
    this->update_camera_vectors();
}

glm::mat4 Camera::get_view_matrix(void)
{

    return glm::translate(glm::mat4(1.0f), this->pos);
}

void Camera::process_directional_movement(Camera_Movement direction, GLfloat delta_time)
{
    const GLfloat velocity = this->movement_speed * delta_time;

    switch (direction) {
    case Camera_Movement::FORWARDS:
        this->pos.z -= velocity;
        break;
    case Camera_Movement::BACKWARDS:
        this->pos.z += velocity;
        break;
    case Camera_Movement::LEFTWARDS:
        this->pos.x -= velocity;
        break;
    case Camera_Movement::RIGHTWARDS:
        this->pos.x += velocity;
        break;
    case Camera_Movement::UPWARDS:
        this->pos.y += velocity;
        break;
    case Camera_Movement::DOWNWARDS:
        this->pos.y -= velocity;
        break;
    }

    this->pos.z = glm::clamp(this->pos.z, this->minZ, this->maxZ);
}
void Camera::process_mouse_movement(GLfloat x_offset, GLfloat y_offset, GLboolean constrain_pitch)
{
    x_offset *= this->mouse_sensitivity;
    y_offset *= this->mouse_sensitivity;

    this->yaw = glm::mod(this->yaw + x_offset, 360.0f);
    this->pitch += y_offset;

    if (constrain_pitch == 1) {
        if (this->pitch > 89.0f) {
            this->pitch = 89.0f;
        } else if (this->pitch < -89.0f) {
            this->pitch = -89.0f;
        }
    }

    this->update_camera_vectors();
}
void Camera::process_mouse_scroll(GLfloat y_offset)
{
    if (this->zoom >= 1.0f && this->zoom <= 45.0f) {
        this->zoom -= y_offset;
    }
    if (this->zoom <= 1.0f) {
        this->zoom = 1.0f;
    } else if (this->zoom >= 45.0f) {
        this->zoom = 45.0f;
    }
}

void Camera::update_camera_vectors(void)
{

    glm::vec3 front(
        cos(glm::radians(this->yaw)) * cos(glm::radians(this->pitch)),
        sin(glm::radians(this->pitch)),
        sin(glm::radians(this->yaw)) * cos(glm::radians(this->pitch))
    );
    this->front = glm::normalize(front);

    this->right = glm::normalize(glm::cross(this->front, this->world_up));
    this->up = glm::normalize(glm::cross(this->right, this->front));
}




void FreeCamera_init(FreeCamera* view, glm::vec3 start_position)
{
    view->position = start_position;
    view->orientation = glm::quat();
    view->matrix = glm::mat4(1.0);
}


void FreeCamera_target_set(FreeCamera* view, glm::vec2 target)
{
    view->target_diff = (target - view->offset) - view->target;
    view->target = target - view->offset;
}

void FreeCamera_target_x_set(FreeCamera* view, f64 target)
{
    view->target_diff = glm::vec2((target - view->offset.x) - view->target.x, 0.0);
    view->target.x = target;
}

void FreeCamera_target_y_set(FreeCamera* view, f64 target)
{
    view->target_diff = glm::vec2(0.0, (target - view->offset.y) - view->target.y);
    view->target.y = target;
}


void FreeCamera_target_follow(FreeCamera* view, f64 t_delta_s)
{


    if (view->is_catching_up) {
        view->position.x += (view->target.x - view->position.x) * 8 * glm::min(1.0, t_delta_s);
        if (glm::abs(view->position.x - view->target.x) < 1) {
            view->is_catching_up = false;
        }
    } else {
        view->position.x = view->target.x;
    }
    view->position.y += (view->target.y - view->position.y) * 16 * glm::min(1.0, t_delta_s);
}

void FreeCamera_target_follow_x(FreeCamera* view, f64 t_delta_s)
{
    if (view->is_catching_up) {
        view->position.x += (view->target.x - view->position.x) * 8 * glm::min(1.0, t_delta_s);
        if (glm::abs(view->position.x - view->target.x) < 1) {
            view->is_catching_up = false;
        }
    } else {
        view->position.x = view->target.x;
    }
}

void FreeCamera_target_follow_y(FreeCamera* view, f64 t_delta_s)
{
    view->position.y += (view->target.y - view->position.y) * 16 * glm::min(1.0, t_delta_s);
}

void FreeCamera_process_directional_movement(FreeCamera* view, MOVEMENT_DIRECTION direction, GLfloat delta_time)
{
    const GLfloat velocity = glm::min((0.01 * 360.0f) * delta_time, (32.0));
    glm::vec3* p = &view->position;


    switch (direction) {
    case MOVEMENT_DIRECTION::FORWARDS:



        p->z -= velocity;
        break;
    case MOVEMENT_DIRECTION::BACKWARDS:



        p->z += velocity;
        break;
    case MOVEMENT_DIRECTION::LEFTWARDS:



        p->x -= velocity;
        break;
    case MOVEMENT_DIRECTION::RIGHTWARDS:



        p->x += velocity;
        break;
    case MOVEMENT_DIRECTION::UPWARDS:



        p->y -= velocity;
        break;
    case MOVEMENT_DIRECTION::DOWNWARDS:



        p->y += velocity;
        break;
    }







    p->z = glm::clamp(p->z, -1.0f, 1.0f);
}

glm::mat4 FreeCamera_calc_view_matrix(FreeCamera* view)
{
    return glm::translate(glm::mat4_cast(view->orientation), -view->position);
}

glm::mat4 FreeCamera_calc_view_matrix_reverse(FreeCamera* view)
{
    return glm::translate(glm::mat4_cast(view->orientation), view->position);
}
# 168 "./camera.hpp" 2
# 49 "run.cpp" 2

int ignore_mouse_movement(void* unused, SDL_Event* event)
{
    return (event->type == SDL_MOUSEMOTION) ? 0 : 1;
}


SDL_Window* window = __null;

typedef void* (*Fn_MemoryAllocator)(size_t bytes);



typedef struct TextureData {
    Texture* ids;
    size_t count;
} TextureData;

void TextureData_init(TextureData* t, const size_t id_count)
{
    t->ids = (Texture*)xmalloc(id_count * sizeof(t->ids));
    t->count = id_count;
    glGenTextures(t->count, t->ids);
}

void TextureData_init_inplace(TextureData* t, const size_t id_count, Texture* buffer)
{
    t->ids = buffer;
    t->count = id_count;
    glGenTextures(id_count, t->ids);
}

void TextureData_delete(TextureData* t)
{
    glDeleteTextures(t->count, t->ids);
    free(t);
}
void TextureData_delete_inplace(TextureData* t)
{
    glDeleteTextures(t->count, t->ids);
}

struct sceneData {
    glm::mat4 m_model;
    glm::mat4 m_view;
    glm::mat4 m_projection;
} scene;




typedef struct AttributeData {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLvoid* pointer;
    GLchar* name;
} AttributeData;

void AttributeData_init(
    AttributeData* a,
    GLuint index,
    GLint size,
    GLenum type,
    GLboolean normalized,
    GLsizei stride,
    GLvoid* pointer,
    GLchar* name
) {
    a->index = index;
    a->size = size;
    a->type = type;
    a->normalized = normalized;
    a->stride = stride;
    a->pointer = pointer;
    a->name = name;
}
# 163 "run.cpp"
struct VertexBufferData {
    VertexBuffer vbo;
    ElementBuffer ebo;
    size_t v_cap;
    size_t v_count;
    size_t i_cap;
    size_t i_count;
    GLfloat* vertices;
    GLuint* indices;
};

struct Open_GL_Data {
    VertexBuffer vbo;
    ElementBuffer ebo;
    DynamicBuffer<GLfloat> vertices;
    DynamicBuffer<GLuint> indices;
};

struct Entity {
    glm::vec3 position;
    GLfloat rotation;
};
# 197 "run.cpp"
void VertexBufferData_init(
    VertexBufferData* g,
    const size_t v_cap,
    const size_t i_cap,
    Fn_MemoryAllocator alloc_v,
    Fn_MemoryAllocator alloc_i
) {
    __glewGenBuffers(1, (GLBuffer*)&g->vbo);
    __glewGenBuffers(1, (GLBuffer*)&g->ebo);

    g->v_cap = v_cap;
    g->i_cap = i_cap;

    g->vertices = (GLfloat*)alloc_v(sizeof(GLfloat) * g->v_cap);
    g->indices = (GLuint*)alloc_i(sizeof(GLuint) * g->i_cap);

    g->v_count = v_cap;
    g->i_count = i_cap;
}

void VertexBufferData_init_inplace(
    VertexBufferData* g,
    const size_t v_cap,
    GLfloat* vertices,
    const size_t i_cap,
    GLuint* indices
) {
    __glewGenBuffers(1, (GLBuffer*)&g->vbo);
    __glewGenBuffers(1, (GLBuffer*)&g->ebo);

    g->v_cap = v_cap;
    g->i_cap = i_cap;

    g->vertices = vertices;
    g->indices = indices;

    g->v_count = v_cap;
    g->i_count = i_cap;
}

void VertexBufferData_delete(VertexBufferData* g)
{
    __glewDeleteBuffers(1, (GLBuffer*)&g->vbo);
    __glewDeleteBuffers(1, (GLBuffer*)&g->ebo);
    free(g->vertices);
    free(g->indices);
}
void VertexBufferData_delete_inplace(VertexBufferData* g)
{
    __glewDeleteBuffers(1, (GLBuffer*)&g->vbo);
    __glewDeleteBuffers(1, (GLBuffer*)&g->ebo);
}

void VertexBufferData_init_with_arenas(ArenaAllocator* v_arena, ArenaAllocator* i_arena, VertexBufferData* vbd, size_t v_count_elements, size_t i_count_elements)
{
    VertexBufferData_init_inplace(
        vbd,
        v_count_elements,
        (GLfloat*)ArenaAllocator_allocate(v_arena, v_count_elements * sizeof(GLfloat)),
        i_count_elements,
        (GLuint*)ArenaAllocator_allocate(i_arena, i_count_elements * sizeof(GLuint))
    );
}

void* GlobalArenaAlloc_vertex_attribute_data(size_t count)
{
    return xmalloc(count * sizeof(GLfloat));
}
void* GlobalArenaAlloc_index_data(size_t count)
{
    return xmalloc(count * sizeof(GLuint));
}


typedef struct VertexAttributeArray {
    VertexArray vao;
    size_t stride;

    operator GLuint() { return vao; }

} VertexAttributeArray;

typedef VertexAttributeArray VAttribArr;

void VertexAttributeArray_init(VertexAttributeArray* vao, size_t stride)
{
    __glewGenVertexArrays(1, &vao->vao);
    vao->stride = stride;
}
void VertexAttributeArray_delete(VertexAttributeArray* vao)
{
    __glewDeleteVertexArrays(1, &vao->vao);
}





void gl_set_and_enable_vertex_attrib_ptr(GLuint index, GLint size, GLenum type, GLboolean normalized, size_t offset, VertexAttributeArray* va)
{
    __glewVertexAttribPointer(index, size, type, normalized, va->stride * sizeof(GLfloat), (GLvoid*)(offset * sizeof(GLfloat)));
    __glewEnableVertexAttribArray(index);
}

void gl_bind_buffers_and_upload_data(VertexBufferData* vbd, GLenum usage, size_t v_cap, size_t i_cap, GLintptr v_begin_offset = 0, GLintptr i_begin_offset = 0)
{
    __glewBindBuffer(0x8892, vbd->vbo);
    __glewBufferData(0x8892, v_cap * sizeof(GLfloat), vbd->vertices + v_begin_offset, usage);

    __glewBindBuffer(0x8893, vbd->ebo);
    __glewBufferData(0x8893, i_cap * sizeof(GLuint), vbd->indices + i_begin_offset, usage);
}

void gl_bind_buffers_and_upload_data(VertexBufferData* vbd, GLenum usage, GLintptr v_begin_offset = 0, GLintptr i_begin_offset = 0)
{
    __glewBindBuffer(0x8892, vbd->vbo);
    __glewBufferData(0x8892, vbd->v_cap * sizeof(GLfloat), vbd->vertices + v_begin_offset, usage);

    __glewBindBuffer(0x8893, vbd->ebo);
    __glewBufferData(0x8893, vbd->i_cap * sizeof(GLuint), vbd->indices + i_begin_offset, usage);
}

void gl_bind_buffers_and_upload_sub_data(VertexBufferData* vbd)
{
    __glewBindBuffer(0x8892, vbd->vbo);
    __glewBufferSubData(0x8892, 0, vbd->v_count * sizeof(GLfloat), vbd->vertices);

    __glewBindBuffer(0x8892, vbd->ebo);
    __glewBufferSubData(0x8892, 0, vbd->i_count * sizeof(GLuint), vbd->indices);
}

void gl_bind_buffers_and_upload_sub_data(VertexBufferData* vbd, usize v_dest_offset, usize v_sub_count, GLintptr v_begin_offset, usize i_dest_offset, usize i_sub_count, GLintptr i_begin_offset)
{
    __glewBindBuffer(0x8892, vbd->vbo);
    __glewBufferSubData(0x8892, v_dest_offset * sizeof(GLfloat), v_sub_count * sizeof(GLfloat), vbd->vertices + v_begin_offset);

    __glewBindBuffer(0x8892, vbd->ebo);
    __glewBufferSubData(0x8892, i_dest_offset * sizeof(GLuint), i_sub_count * sizeof(GLuint), vbd->indices + i_begin_offset);
}

void gl_bind_buffers_and_upload_sub_data(VertexBufferData* vbd, usize v_dest_offset, usize v_sub_count, GLintptr v_begin_offset, usize i_dest_offset, usize i_sub_count, GLintptr i_begin_offset, GLfloat* vertices, GLuint* indices)
{
    __glewBindBuffer(0x8892, vbd->vbo);
    __glewBufferSubData(0x8892, v_dest_offset * sizeof(GLfloat), v_sub_count * sizeof(GLfloat), vertices + v_begin_offset);

    __glewBindBuffer(0x8892, vbd->ebo);
    __glewBufferSubData(0x8892, i_dest_offset * sizeof(GLuint), i_sub_count * sizeof(GLuint), indices + i_begin_offset);
}

struct GLData {
    VertexAttributeArray vao;
    VertexBufferData vbd;
};

void GLData_init(GLData* gl_data, size_t attribute_stride, const size_t v_cap, const size_t i_cap, Fn_MemoryAllocator alloc_v, Fn_MemoryAllocator alloc_i)
{
    VertexAttributeArray_init(&gl_data->vao, attribute_stride);
    VertexBufferData_init(&gl_data->vbd, v_cap, i_cap, alloc_v, alloc_i);
}

void GLData_init_inplace(GLData* gl_data, size_t attribute_stride, const size_t v_cap, GLfloat* vertices, const size_t i_cap, GLuint* indices)
{
    VertexAttributeArray_init(&gl_data->vao, attribute_stride);
    VertexBufferData_init_inplace(&gl_data->vbd, v_cap, vertices, i_cap, indices);
}

inline void GLData_advance(GLData* const gl_data, const size_t i)
{
    gl_data->vbd.v_count += (i * gl_data->vao.stride);
    gl_data->vbd.i_count += i;
}

void GLData_delete(GLData* gl_data)
{
    VertexAttributeArray_delete(&gl_data->vao);
    VertexBufferData_delete(&gl_data->vbd);
}

void GLData_delete_inplace(GLData* gl_data)
{
    VertexAttributeArray_delete(&gl_data->vao);
    VertexBufferData_delete_inplace(&gl_data->vbd);
}


struct Room {
    VertexBufferData geometry;
    Collider* collision_data;
    glm::mat4 matrix;
};

struct World {
    Room* rooms;
    glm::mat4 m_view;
    glm::mat4 m_projection;
};

struct GlobalData {
    SDL_GLContext context;
    TextureData textures;
};

GlobalData program_data;



# 1 "./gl_draw2d.h" 1



# 1 "./common_utils.h" 1
# 5 "./gl_draw2d.h" 2
# 1 "./common_utils_cpp.hpp" 1
# 6 "./gl_draw2d.h" 2






namespace Color {
    static const glm::vec4 RED = {1.0, 0.0, 0.0, 1.0};
    static const glm::vec4 GREEN = {0.0, 1.0, 0.0, 1.0};
    static const glm::vec4 BLUE = {0.0, 0.0, 1.0, 1.0};
    static const glm::vec4 MAGENTA = {1.0, 0.0, 1.0, 1.0};
    static const glm::vec4 BLACK = {0.0, 0.0, 0.0, 1.0};
    static const glm::vec4 WHITE = {1.0, 1.0, 1.0, 1.0};

}

template <usize GL_DRAW2D_SIZE = 2048>
struct GLDraw2D {

    static constexpr GLuint ATTRIBUTE_STRIDE = 7;

    GLfloat vertices_triangles[GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE];
    GLuint indices_triangles[GL_DRAW2D_SIZE * 2];

    GLfloat vertices_lines[GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE];
    GLuint indices_lines[GL_DRAW2D_SIZE * 2];

    VertexAttributeArray vao_triangles;
    VertexBufferData triangle_buffer;
    VertexAttributeArray vao_lines;
    VertexBufferData line_buffer;
    Shader shader;

    UniformLocation MAT_LOC;

    glm::mat4 projection_matrix;
    glm::mat4 transform_matrix;

    glm::vec4 color;

    bool update_projection_matrix;

    GLenum draw_type;


    GLuint index_triangles;
    GLuint index_lines;

    bool begun;

    void begin(void)
    {
        (__builtin_expect(!(begun == false), 0) ? __assert_rtn(__func__, "./gl_draw2d.h", 58, "begun == false") : (void)0);

        transform_matrix = glm::mat4(1.0f);

        __glewUseProgram(shader);

        if (update_projection_matrix) {
            update_projection_matrix = false;
            __glewUniformMatrix4fv(MAT_LOC, 1, 0, glm::value_ptr(projection_matrix));
        }

        begun = true;
    }

    void end(void)
    {
        (__builtin_expect(!(begun == true), 0) ? __assert_rtn(__func__, "./gl_draw2d.h", 74, "begun == true") : (void)0);

        __glewBindVertexArray(vao_triangles);
        gl_bind_buffers_and_upload_sub_data(&triangle_buffer);
        if (triangle_buffer.i_count > 0) {
            glDrawElements(0x0004, triangle_buffer.i_count, 0x1405, 0);
        }

        __glewBindVertexArray(vao_lines);
        gl_bind_buffers_and_upload_sub_data(&line_buffer);
        if (line_buffer.i_count > 0) {
            glDrawElements(0x0001, line_buffer.i_count, 0x1405, 0);
        }

        __glewBindBuffer(0x8892, 0);
        __glewBindVertexArray(0);
        __glewUseProgram(0);


        triangle_buffer.v_count = 0;
        triangle_buffer.i_count = 0;

        line_buffer.v_count = 0;
        line_buffer.i_count = 0;

        index_triangles = 0;
        index_lines = 0;

        begun = false;
    }

    void end_no_reset(void)
    {
        (__builtin_expect(!(begun == true), 0) ? __assert_rtn(__func__, "./gl_draw2d.h", 107, "begun == true") : (void)0);

        __glewBindVertexArray(vao_triangles);
        gl_bind_buffers_and_upload_sub_data(&triangle_buffer);
        if (triangle_buffer.i_count > 0) {
            glDrawElements(0x0004, triangle_buffer.i_count, 0x1405, 0);
        }

        __glewBindVertexArray(vao_lines);
        gl_bind_buffers_and_upload_sub_data(&line_buffer);
        if (line_buffer.i_count > 0) {
            glDrawElements(0x0001, line_buffer.i_count, 0x1405, 0);
        }

        __glewBindBuffer(0x8892, 0);
        __glewBindVertexArray(0);
        __glewUseProgram(0);

        begun = false;
    }

    static constexpr const char* const SHADER_VERTEX_PATH = "shaders/default_2d/default_2d.vrts";
    static constexpr const char* const SHADER_FRAGMENT_PATH = "shaders/default_2d/default_2d.frgs";

    bool init(glm::mat4 projection_matrix)
    {
        this->projection_matrix = projection_matrix;
        update_projection_matrix = false;
        begun = false;

        index_triangles = 0;
        index_lines = 0;

        draw_type = 0x0004;

        color = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);

        if (false == Shader_load_from_file(
            &shader,
            SHADER_VERTEX_PATH,
            SHADER_FRAGMENT_PATH
        )) {
            fprintf(__stderrp, "ERROR: immediate mode failed\n");
            return false;
        }

        __glewUseProgram(shader);
        MAT_LOC = __glewGetUniformLocation(shader, "u_matrix");
        __glewUniformMatrix4fv(MAT_LOC, 1, 0, glm::value_ptr(projection_matrix));
        __glewUseProgram(0);

        VertexAttributeArray_init(&vao_triangles, ATTRIBUTE_STRIDE);
        __glewBindVertexArray(vao_triangles);

            VertexBufferData_init_inplace(
                &triangle_buffer,
                GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE,
                vertices_triangles,
                GL_DRAW2D_SIZE,
                indices_triangles
            );
            triangle_buffer.v_count = 0;
            triangle_buffer.i_count = 0;

            gl_bind_buffers_and_upload_data(&triangle_buffer, 0x88E0);

            gl_set_and_enable_vertex_attrib_ptr(0, 3, 0x1406, 0, 0, &vao_triangles);

            gl_set_and_enable_vertex_attrib_ptr(1, 4, 0x1406, 0, 3, &vao_triangles);

            __glewBindBuffer(0x8892, 0);
        __glewBindVertexArray(0);

        VertexAttributeArray_init(&vao_lines, ATTRIBUTE_STRIDE);
        __glewBindVertexArray(vao_lines);
            VertexBufferData_init_inplace(
                &line_buffer,
                GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE,
                vertices_lines,
                GL_DRAW2D_SIZE,
                indices_lines
            );
            line_buffer.v_count = 0;
            line_buffer.i_count = 0;

            gl_bind_buffers_and_upload_data(&line_buffer, 0x88E0);

            gl_set_and_enable_vertex_attrib_ptr(0, 3, 0x1406, 0, 0, &vao_lines);

            gl_set_and_enable_vertex_attrib_ptr(1, 4, 0x1406, 0, 3, &vao_lines);

            __glewBindBuffer(0x8892, 0);
        __glewBindVertexArray(0);

        index_triangles = 0;
        index_lines = 0;

        return true;
    }

    void free(void)
    {
        VertexAttributeArray_delete(&vao_triangles);
        VertexAttributeArray_delete(&vao_lines);
        VertexBufferData_delete_inplace(&triangle_buffer);
        VertexBufferData_delete_inplace(&line_buffer);
        __glewDeleteProgram(shader);
    }

    void line(glm::vec3 a, glm::vec3 b)
    {
        const size_t v_count = line_buffer.v_count;
        const size_t i_count = line_buffer.i_count;

        if (v_count + (2 * ATTRIBUTE_STRIDE) > GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE || i_count + 2 > GL_DRAW2D_SIZE * 2) {
            fprintf(__stderrp, "%s\n", "ERROR: add_line_segment MAX LINES EXCEEDED");
            return;
        }

        a = glm::vec3(transform_matrix * glm::vec4(a, 1.0f));
        b = glm::vec3(transform_matrix * glm::vec4(b, 1.0f));

        const size_t v_idx = v_count;

        memcpy(&vertices_lines[v_idx], &a[0], sizeof(a[0]) * 3);
        memcpy(&vertices_lines[v_idx + 3], &color[0], sizeof(color[0]) * 4);


        memcpy(&vertices_lines[v_idx + ATTRIBUTE_STRIDE], &b[0], sizeof(b[0]) * 3);
        memcpy(&vertices_lines[v_idx + ATTRIBUTE_STRIDE + 3], &color[0], sizeof(color[0]) * 4);

        indices_lines[i_count] = index_lines;
        indices_lines[i_count + 1] = index_lines + 1;
        index_lines += 2;

        line_buffer.v_count += (2 * ATTRIBUTE_STRIDE);
        line_buffer.i_count += 2;
# 258 "./gl_draw2d.h"
    }

    void line(glm::vec2 a, glm::vec2 b)
    {
        const size_t v_count = line_buffer.v_count;
        const size_t i_count = line_buffer.i_count;

        if (v_count + (2 * ATTRIBUTE_STRIDE) > GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE || i_count + 2 > GL_DRAW2D_SIZE * 2) {
            fprintf(__stderrp, "%s\n", "ERROR: add_line_segment MAX LINES EXCEEDED");
            return;
        }

        a = glm::vec2(transform_matrix * glm::vec4(a, 0.0f, 1.0f));
        b = glm::vec2(transform_matrix * glm::vec4(b, 0.0f, 1.0f));

        const size_t v_idx = v_count;

        memcpy(&vertices_lines[v_idx], &a[0], sizeof(a[0]) * 2);
        vertices_lines[v_idx + 2] = 0.0f;
        memcpy(&vertices_lines[v_idx + 3], &color[0], sizeof(color[0]) * 4);


        memcpy(&vertices_lines[v_idx + ATTRIBUTE_STRIDE], &b[0], sizeof(b[0]) * 2);
        vertices_lines[v_idx + ATTRIBUTE_STRIDE + 2] = 0.0f;
        memcpy(&vertices_lines[v_idx + ATTRIBUTE_STRIDE + 3], &color[0], sizeof(color[0]) * 4);

        indices_lines[i_count] = index_lines;
        indices_lines[i_count + 1] = index_lines + 1;
        index_lines += 2;

        line_buffer.v_count += (2 * ATTRIBUTE_STRIDE);
        line_buffer.i_count += 2;
    }

    void polygon_convex_regular(GLfloat radius, glm::vec3 center, const size_t count_sides)
    {
        size_t count_tris = count_sides - 2;

        const size_t inc = ATTRIBUTE_STRIDE;

        size_t v_count = 0;
        size_t i_count = 0;
        size_t v_idx = 0;
        GLdouble angle_turn = -(2 * glm::pi<float64>()) / count_sides;

        switch (draw_type) {
        case 0x0004:
            v_count = triangle_buffer.v_count;
            i_count = triangle_buffer.i_count;
            v_idx = v_count;

            if (v_count + (ATTRIBUTE_STRIDE * count_sides) > GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE || i_count + (3 * count_tris) > GL_DRAW2D_SIZE * 2) {
                fprintf(__stderrp, "%s\n", "ERROR: polygon_convex_regular MAX TRIANGLES EXCEEDED");
                return;
            }

            for (size_t p = 0, idx_off = 0; p < count_tris; ++p, idx_off += 3) {
                indices_triangles[i_count + idx_off] = index_triangles + 0;
                indices_triangles[i_count + idx_off + 1] = index_triangles + p + 1;
                indices_triangles[i_count + idx_off + 2] = index_triangles + p + 2;
            }
            triangle_buffer.i_count += (3 * count_tris);


            for (size_t p = 0, off = 0; p < count_sides; ++p, off += inc) {
                glm::vec3 point = glm::vec3(transform_matrix *
                    glm::vec4(
                        (radius * glm::cos(p * angle_turn)) + center.x,
                        (radius * glm::sin(p * angle_turn)) + center.y,
                        center.z,
                        1.0f
                    )
                );

                vertices_triangles[v_idx + off] = point.x;
                vertices_triangles[v_idx + off + 1] = point.y;
                vertices_triangles[v_idx + off + 2] = point.z;

                memcpy(&vertices_triangles[v_idx + off + 3], &color[0], sizeof(color[0]) * 4);
            }

            triangle_buffer.v_count += (ATTRIBUTE_STRIDE * count_sides);

            index_triangles += count_sides;

            break;
        case 0x0001:
            v_count = line_buffer.v_count;
            i_count = line_buffer.i_count;
            v_idx = v_count;

            if (v_count + (ATTRIBUTE_STRIDE * count_sides) > GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE || i_count + (2 * count_sides) > GL_DRAW2D_SIZE * 2) {
                fprintf(__stderrp, "%s\n", "ERROR: polygon_convex_regular MAX LINES EXCEEDED");
                return;
            }

            for (size_t p = 0, off = 0; p < count_sides; ++p, off += 2) {
                indices_lines[i_count + off] = index_lines + p;
                indices_lines[i_count + off + 1] = index_lines + p + 1;
            }
            indices_lines[i_count + (count_sides * 2) - 1] = index_lines;

            line_buffer.i_count += (2 * count_sides);

            for (size_t p = 0, off = 0; p < count_sides; ++p, off += inc) {
                glm::vec3 point = glm::vec3(transform_matrix *
                    glm::vec4(
                        (radius * glm::cos(p * angle_turn)) + center.x,
                        (radius * glm::sin(p * angle_turn)) + center.y,
                        center.z,
                        1.0f
                    )
                );
                vertices_lines[v_idx + off] = point.x;
                vertices_lines[v_idx + off + 1] = point.y;
                vertices_lines[v_idx + off + 2] = point.z;

                memcpy(&vertices_lines[v_idx + off + 3], &color[0], sizeof(color[0]) * 4);
            }

            line_buffer.v_count += (ATTRIBUTE_STRIDE * count_sides);

            index_lines += count_sides;

            break;
        }
    }

    void circle(GLfloat radius, glm::vec3 center)
    {
        polygon_convex_regular(radius, center, 37);
    }

    void vertex(glm::vec3 v)
    {
        size_t v_count = 0;
        size_t i_count = 0;
        size_t v_idx = 0;

        switch (draw_type) {
        case 0x0004:
            v_count = triangle_buffer.v_count;
            i_count = triangle_buffer.i_count;
            v_idx = v_count;

            if (v_count + ATTRIBUTE_STRIDE > GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE || i_count + 1 > GL_DRAW2D_SIZE * 2) {
                fprintf(__stderrp, "%s\n", "ERROR: vertex MAX TRIANGLES EXCEEDED");
                return;
            }

            v = glm::vec3(transform_matrix * glm::vec4(v, 1.0f));


            memcpy(&vertices_triangles[v_idx], &v[0], sizeof(v[0]) * 3);
            memcpy(&vertices_triangles[v_idx + 3], &color[0], sizeof(color[0]) * 4);

            indices_triangles[i_count] = index_triangles;
            ++index_triangles;

            triangle_buffer.v_count += ATTRIBUTE_STRIDE;
            ++triangle_buffer.i_count;
# 434 "./gl_draw2d.h"
            break;
        case 0x0001:
            v_count = line_buffer.v_count;
            i_count = line_buffer.i_count;
            v_idx = v_count;

            if (v_count + ATTRIBUTE_STRIDE > GL_DRAW2D_SIZE * ATTRIBUTE_STRIDE || i_count + 1 > GL_DRAW2D_SIZE * 2) {
                fprintf(__stderrp, "%s\n", "ERROR: vertex MAX LINES EXCEEDED");
                return;
            }

            v = glm::vec3(transform_matrix * glm::vec4(v, 1.0f));


            memcpy(&vertices_lines[v_idx], &v[0], sizeof(v[0]) * 3);
            memcpy(&vertices_lines[v_idx + 3], &color[0], sizeof(color[0]) * 4);

            indices_lines[i_count] = index_lines;
            ++index_lines;

            line_buffer.v_count += ATTRIBUTE_STRIDE;
            ++line_buffer.i_count;

            break;
        }
    }
};
# 403 "run.cpp" 2

WindowState window_state;




SDL_GameController* controller_handle = std::__1::__get_nullptr_t();
char* controller_mapping = std::__1::__get_nullptr_t();

bool poll_input_events(input_sys::Input* input, SDL_Event* event)
{
    using namespace input_sys;

    keys_advance_history(input);


    mouse_advance_history(input);


    while (SDL_PollEvent(event)) {

        switch (event->type) {
        case SDL_QUIT:
            if (controller_handle != std::__1::__get_nullptr_t()) {
                SDL_GameControllerClose(controller_handle);
            }
            return false;
        case SDL_WINDOWEVENT:
            switch (event->window.event) {
# 456 "run.cpp"
            case SDL_WINDOWEVENT_MINIMIZED:
                window_state.minimized = true;

                break;



            case SDL_WINDOWEVENT_RESTORED:
                window_state.minimized = false;
                window_state.restored = true;

                break;







            case SDL_WINDOWEVENT_FOCUS_GAINED:
                window_state.focused = true;


                break;
            case SDL_WINDOWEVENT_FOCUS_LOST:
                window_state.focused = false;


                break;
# 496 "run.cpp"
            default:


                break;
            }
            break;
        case SDL_CONTROLLERDEVICEADDED:
            if (SDL_IsGameController(event->cdevice.which)) {
                controller_handle = SDL_GameControllerOpen(event->cdevice.which);
                fprintf(
                    __stdoutp,
                    "ADDING CONTROLLER (%s) TO PORT (%d)\n",
                    SDL_GameControllerName(controller_handle), event->cdevice.which
                );

                controller_mapping = SDL_GameControllerMapping(controller_handle);
                SDL_Log("CONTROLLER IS MAPPED AS \"%s\".", controller_mapping);
                SDL_free(controller_mapping);
            } else {
                fprintf(__stderrp, "CONTROLLER INCOMPATIBLE");
            }
            break;
        case SDL_CONTROLLERDEVICEREMOVED:
            if (controller_handle != std::__1::__get_nullptr_t()) {
                fprintf(
                    __stdoutp,
                    "REMOVING CONTROLLER (%s) FROM PORT (%d)\n",
                    SDL_GameControllerName(controller_handle), event->cdevice.which
                );
                SDL_GameControllerClose(controller_handle);
                input_sys::init(input);
            }
            break;
        case SDL_CONTROLLERBUTTONDOWN:
            switch (event->cbutton.button) {
            case SDL_CONTROLLER_BUTTON_A:
                std::cout << "DOWN_BUTTON_A" << std::endl;
                key_set_down(input, CONTROL::JUMP);
                break;
            case SDL_CONTROLLER_BUTTON_B:
                std::cout << "DOWN_BUTTON_B" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_X:
                std::cout << "DOWN_BUTTON_X" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_Y:
                std::cout << "DOWN_BUTTON_Y" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_BACK:
                std::cout << "DOWN_BUTTON_BACK" << std::endl;

                key_set_down(input, CONTROL::EDIT_MODE);

                break;
            case SDL_CONTROLLER_BUTTON_GUIDE:
                std::cout << "DOWN_BUTTON_GUIDE" << std::endl;
                key_set_down(input, CONTROL::RESET_POSITION);
                break;
            case SDL_CONTROLLER_BUTTON_START:
                std::cout << "DOWN_BUTTON_START" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_LEFTSTICK:
                std::cout << "DOWN_BUTTON_LEFTSTICK" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_RIGHTSTICK:
                std::cout << "DOWN_BUTTON_RIGHTSTICK" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_LEFTSHOULDER:
                std::cout << "DOWN_BUTTON_LEFTSHOULDER" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_RIGHTSHOULDER:
                std::cout << "DOWN_BUTTON_RIGHTSHOULDER" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_UP:
                std::cout << "DOWN_BUTTON_DPAD_UP" << std::endl;
                key_set_down(input, CONTROL::UP);
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_DOWN:
                std::cout << "DOWN_BUTTON_DPAD_DOWN" << std::endl;
                key_set_down(input, CONTROL::DOWN);
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_LEFT:
                std::cout << "DOWN_BUTTON_DPAD_LEFT" << std::endl;
                key_set_down(input, CONTROL::LEFT);
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_RIGHT:
                std::cout << "DOWN_BUTTON_DPAD_RIGHT" << std::endl;
                key_set_down(input, CONTROL::RIGHT);
                break;
            default:
                std::cout << "UNKNOWN" << std::endl;
                break;
            }
            break;
        case SDL_CONTROLLERBUTTONUP:
            switch (event->cbutton.button) {
            case SDL_CONTROLLER_BUTTON_A:
                std::cout << "UP_BUTTON_A" << std::endl;
                key_set_up(input, CONTROL::JUMP);
                break;
            case SDL_CONTROLLER_BUTTON_B:
                std::cout << "UP_BUTTON_B" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_X:
                std::cout << "UP_BUTTON_X" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_Y:
                std::cout << "UP_BUTTON_Y" << std::endl;
                break;

            case SDL_CONTROLLER_BUTTON_BACK:
                std::cout << "UP_BUTTON_BACK" << std::endl;

                key_set_up(input, CONTROL::EDIT_MODE);

                break;

            case SDL_CONTROLLER_BUTTON_GUIDE:
                std::cout << "UP_BUTTON_GUIDE" << std::endl;
                key_set_up(input, CONTROL::RESET_POSITION);
                break;
            case SDL_CONTROLLER_BUTTON_START:
                std::cout << "UP_BUTTON_START" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_LEFTSTICK:
                std::cout << "UP_BUTTON_LEFTSTICK" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_RIGHTSTICK:
                std::cout << "UP_BUTTON_RIGHTSTICK" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_LEFTSHOULDER:
                std::cout << "UP_BUTTON_LEFTSHOULDER" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_RIGHTSHOULDER:
                std::cout << "UP_BUTTON_RIGHTSHOULDER" << std::endl;
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_UP:
                std::cout << "UP_BUTTON_DPAD_UP" << std::endl;
                key_set_up(input, CONTROL::UP);
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_DOWN:
                std::cout << "UP_BUTTON_DPAD_DOWN" << std::endl;
                key_set_up(input, CONTROL::DOWN);
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_LEFT:
                std::cout << "UP_BUTTON_DPAD_LEFT" << std::endl;
                key_set_up(input, CONTROL::LEFT);
                break;
            case SDL_CONTROLLER_BUTTON_DPAD_RIGHT:
                std::cout << "UP_BUTTON_DPAD_RIGHT" << std::endl;
                key_set_up(input, CONTROL::RIGHT);
                break;
            default:
                std::cout << "UNKNOWN" << std::endl;
                break;
            }
            break;
        case SDL_CONTROLLERAXISMOTION:

            switch (event->caxis.axis) {
            case SDL_CONTROLLER_AXIS_MAX:
                std::cout << "AXIS_MAX " << event->caxis.value << std::endl;
                break;
            case SDL_CONTROLLER_AXIS_LEFTY:
                if (glm::abs(event->caxis.value) > (8000)) {
                    std::cout << "AXIS_LEFTY " << event->caxis.value << std::endl;
                }
                break;
            case SDL_CONTROLLER_AXIS_RIGHTY:
                if (glm::abs(event->caxis.value) > (8000)) {
                    std::cout << "AXIS_RIGHTY " << event->caxis.value << std::endl;
                }
                break;
            case SDL_CONTROLLER_AXIS_LEFTX:
                if (glm::abs(event->caxis.value) > (8000)) {
                    std::cout << "AXIS_LEFTX " << event->caxis.value << std::endl;
                }
                break;
            case SDL_CONTROLLER_AXIS_RIGHTX:
                if (glm::abs(event->caxis.value) > (8000)) {
                    std::cout << "AXIS_RIGHTX " << event->caxis.value << std::endl;
                }
                break;
            case SDL_CONTROLLER_AXIS_TRIGGERLEFT:
                std::cout << "AXIS_TRIGGERLEFT " << event->caxis.value << std::endl;
                break;
            case SDL_CONTROLLER_AXIS_TRIGGERRIGHT:
                std::cout << "AXIS_TRIGGERRIGHT " << event->caxis.value << std::endl;
                break;
            default:

                break;
            }
            break;
        case SDL_KEYDOWN:
            switch (event->key.keysym.scancode) {
            case SDL_SCANCODE_W:
                key_set_down(input, CONTROL::UP);
                break;
            case SDL_SCANCODE_S:
                key_set_down(input, CONTROL::DOWN);
                break;
            case SDL_SCANCODE_A:
                key_set_down(input, CONTROL::LEFT);
                break;
            case SDL_SCANCODE_D:
                key_set_down(input, CONTROL::RIGHT);
                break;
            case SDL_SCANCODE_J:
            case SDL_SCANCODE_K:
            case SDL_SCANCODE_L:
                key_set_down(input, CONTROL::JUMP);
                break;
            case SDL_SCANCODE_0:
                key_set_down(input, CONTROL::RESET_POSITION);
                break;
            case SDL_SCANCODE_C:
                key_set_down(input, CONTROL::FREE_CAM);
                break;

            case SDL_SCANCODE_E:
                key_set_down(input, CONTROL::EDIT_MODE);
                break;
            case SDL_SCANCODE_P:
                key_set_down(input, CONTROL::PHYSICS);
                break;
            case SDL_SCANCODE_V:
                key_set_down(input, CONTROL::EDIT_VERBOSE);
                break;
            case SDL_SCANCODE_GRAVE:
                key_set_down(input, CONTROL::LOAD_CONFIG);
                break;

            case SDL_SCANCODE_UP:
                key_set_down(input, CONTROL::ZOOM_IN);
                break;
            case SDL_SCANCODE_DOWN:
                key_set_down(input, CONTROL::ZOOM_OUT);
                break;
            default:
                break;
            }
            break;
        case SDL_KEYUP:
            switch (event->key.keysym.scancode) {
            case SDL_SCANCODE_W:
                key_set_up(input, CONTROL::UP);
                break;
            case SDL_SCANCODE_S:
                key_set_up(input, CONTROL::DOWN);
                break;
            case SDL_SCANCODE_A:
                key_set_up(input, CONTROL::LEFT);
                break;
            case SDL_SCANCODE_D:
                key_set_up(input, CONTROL::RIGHT);
                break;
            case SDL_SCANCODE_J:
            case SDL_SCANCODE_K:
            case SDL_SCANCODE_L:
                key_set_up(input, CONTROL::JUMP);
                break;
            case SDL_SCANCODE_0:
                key_set_up(input, CONTROL::RESET_POSITION);
                break;
            case SDL_SCANCODE_C:
                key_set_up(input, CONTROL::FREE_CAM);
                break;

            case SDL_SCANCODE_E:
                key_set_up(input, CONTROL::EDIT_MODE);
                break;
            case SDL_SCANCODE_P:
                key_set_up(input, CONTROL::PHYSICS);
                break;
            case SDL_SCANCODE_V:
                key_set_up(input, CONTROL::EDIT_VERBOSE);
                break;
            case SDL_SCANCODE_GRAVE:
                key_set_up(input, CONTROL::LOAD_CONFIG);
                break;

            case SDL_SCANCODE_UP:
                key_set_up(input, CONTROL::ZOOM_IN);
                break;
            case SDL_SCANCODE_DOWN:
                key_set_up(input, CONTROL::ZOOM_OUT);
                break;
            default:
                break;
            }
            break;
        case SDL_MOUSEBUTTONDOWN:
            switch (event->button.button) {
            case 1:
                mouse_set_down(input, MOUSE_BUTTON::LEFT);
                break;
            case 3:
                mouse_set_down(input, MOUSE_BUTTON::RIGHT);
                break;
            }
            break;
        case SDL_MOUSEBUTTONUP:
            switch (event->button.button) {
            case 1:
                mouse_set_up(input, MOUSE_BUTTON::LEFT);
                break;
            case 3:
                mouse_set_up(input, MOUSE_BUTTON::RIGHT);
                break;
            }
            break;
        default:
            break;
        }

    }


    SDL_GetMouseState(&input->mouse_x, &input->mouse_y);


    if (window_state.minimized) {
        SDL_Delay(1000);
    } else if (!window_state.focused) {
        SDL_Delay(64);
    }


    return true;
}

template <usize N>
void draw_player_collision(Player* you, GLDraw2D<N>* ctx)
{
    const glm::vec3 off(0.5, 0.5, 0.0);
    BoxComponent* bc = &you->bound;
    glm::vec3 top_left = bc->position() + off;
    glm::vec3 top_right = top_left + glm::vec3(bc->width, 0.0, 0.0);
    glm::vec3 bottom_right = top_left + glm::vec3(bc->width, bc->height, 0.0);
    glm::vec3 bottom_left = top_left + glm::vec3(0.0, bc->height, 0.0);

    ctx->draw_type = 0x0001;
    ctx->line(top_left, top_right);
    ctx->line(top_right, bottom_right);
    ctx->line(bottom_right, bottom_left);
    ctx->line(bottom_left, top_left);

    ctx->color = Color::RED;
    auto floor_sensor_rays = you->floor_sensor_rays();
    floor_sensor_rays.first.first += off;
    floor_sensor_rays.first.second += off;
    floor_sensor_rays.second.first += off;
    floor_sensor_rays.second.second += off;

    ctx->line(floor_sensor_rays.first.first, floor_sensor_rays.first.second);
    ctx->line(floor_sensor_rays.second.first, floor_sensor_rays.second.second);
}

template <usize N>
void BoxComponent_draw(BoxComponent* bc, GLDraw2D<N>* ctx)
{
    const glm::vec3 off(0.5, 0.5, 0.0);
    glm::vec3 top_left = bc->position() + off;
    glm::vec3 top_right = top_left + glm::vec3(bc->width, 0.0, 0.0);
    glm::vec3 bottom_right = top_left + glm::vec3(bc->width, bc->height, 0.0);
    glm::vec3 bottom_left = top_left + glm::vec3(0.0, bc->height, 0.0);

    ctx->draw_type = 0x0001;
    ctx->line(top_left, top_right);
    ctx->line(top_right, bottom_right);
    ctx->line(bottom_right, bottom_left);
    ctx->line(bottom_left, top_left);
}

bool temp_test_collision(Player* you, Collider* c, CollisionStatus* status)
{
    auto sensors = you->floor_sensor_rays();

    std::pair<glm::vec3, glm::vec3>* ray0 = &sensors.first;
    std::pair<glm::vec3, glm::vec3>* ray1 = &sensors.second;
    std::pair<glm::vec3, glm::vec3> collider = {
        c->a,
        c->b
    };
# 891 "run.cpp"
    glm::vec3 va((std::numeric_limits<f64>::infinity()));
    glm::vec3 vb((std::numeric_limits<f64>::infinity()));
    glm::vec3* choice = &va;
    bool possibly_collided = false;

    if (line_segment_intersection(ray0, &collider, &va)) {
        choice = &va;
        possibly_collided = true;
    }

    if (line_segment_intersection(ray1, &collider, &vb)) {
        choice = (va.y < vb.y) ? &va : &vb;
        possibly_collided = true;
    }

    if (!possibly_collided) {
        return false;
    }

    glm::vec3* out = &status->intersection;




    if (!you->on_ground && you->bound.spatial.y + you->bound.height >= choice->y) {
        f64 new_y = choice->y;






        if (new_y > out->y) {
            return false;
        }

        out->x = choice->x;
        out->y = choice->y;
        out->z = 0.0;
        status->collider = c;

        return true;
    } else if (you->on_ground) {
        f64 new_y = choice->y;





        if (new_y > out->y) {
            return false;
        }

        out->x = choice->x;
        out->y = choice->y;
        out->z = 0.0;
        status->collider = c;
# 956 "run.cpp"
        return true;
    }


    return false;

}

struct AirPhysicsConfig {
    std::string path;
    FILE* fd;
    struct stat stat;
    time_t t_prev_mod;
    f64 gravity;
    f64 player_initial_velocity;
    f64 player_initial_velocity_short;
};

bool load_config(AirPhysicsConfig* conf)
{

    check_file_status(conf->path.c_str(), &conf->stat);
    if (conf->stat.st_mtimespec.tv_sec != conf->t_prev_mod) {

        conf->t_prev_mod = conf->stat.st_mtimespec.tv_sec;

        char buff[512];

        std::string conf_string = file_io::read_file(conf->fd);

        if (conf_string.length() == 0 || conf_string.find("DEFAULT") == 0) {
            puts("USING DEFAULT PARAMETERS");
            conf->gravity = physics::GRAVITY_DEFAULT;
            conf->player_initial_velocity = Player::JUMP_VELOCITY_DEFAULT;
            conf->player_initial_velocity_short = Player::JUMP_VELOCITY_SHORT_DEFAULT;
            rewind(conf->fd);
            return true;
        }


        puts("MODIFYING PARAMETERS");
        printf("%s\n", conf_string.c_str());

        char seps[] = " ,:;\t\n";

        char* token = strtok((char*)conf_string.c_str(), seps);

        sscanf(token, "%lf", &conf->gravity);
        token = strtok(__null, seps);
        sscanf(token, "%lf", &conf->player_initial_velocity);
        token = strtok(__null, seps);
        sscanf(token, "%lf", &conf->player_initial_velocity_short);

        rewind(conf->fd);

        printf("%lf : %lf : %lf\n", conf->gravity, conf->player_initial_velocity, conf->player_initial_velocity_short);

        return true;
    }


    return false;
}



int main(int argc, char* argv[])
{
    using namespace input_sys;

    Thing_array[0].speed = 1.0f;


    char* ptr = (char*)&Thing_array[0];
    ptr += (4 * meta_arrays[0].element_size);
    ptr += Thing_meta_data[1].offset;
    *((f32*)ptr) = 2.0f;

    std::cout << Thing_array[4].speed << std::endl;

    std::cout << (sizeof(config_state) / sizeof((config_state)[0])) << std::endl;

    for (usize k = 0; k < 2; ++k) {
        for (usize i = 0; i < (sizeof(config_state) / sizeof((config_state)[0])); ++i) {
            using pt = PROPERTY_TYPE;
            switch (config_state[i].type) {
            case pt::PROP_f64:
                std::cout << *((f64*)config_state[i].ptr) << std::endl;
                *((f64*)config_state[i].ptr) *= 2.0;
            }
        }
    }

    for (usize i = 0; i < (sizeof(config_state) / sizeof((config_state)[0])); ++i) {
        using pt = PROPERTY_TYPE;
        switch (config_state[i].type) {
        case pt::PROP_f64:
            *((f64*)config_state[i].ptr) = config_state[i].f_f64;
        }
    }

    CommandLineArgs cmd;
    if (!parse_command_line_args(&cmd, argc, argv)) {
        return 1;
    }


    if (SDL_Init(0x00000020u | 0x00000001u | 0x00002000u | 0x00001000u) < 0) {
        fprintf(__stderrp, "%s\n", "SDL could not initialize");
        return 1;
    }
# 1086 "run.cpp"
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);


    SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);


    if (__null == (window = SDL_CreateWindow(
        (""),
        (0x1FFF0000u|(0)),
        (0x1FFF0000u|(0)),
        (1280.0f), (720.0f),
        SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN | SDL_WINDOW_ALLOW_HIGHDPI)))
    {
        fprintf(__stderrp, "Window could not be created\n");
        return 1;
    }

    window_state.focused = true;
    window_state.minimized = false;



    int imgFlags = IMG_INIT_PNG | IMG_INIT_JPG;
    if(!(IMG_Init(imgFlags) & imgFlags)) {
      fprintf(__stderrp, "SDL_image could not initialize, SDL_image Error: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        return 1;
    }

    program_data.context = SDL_GL_CreateContext(window);

    glewExperimental = 1;
    glewInit();


    ConfigState_load_runtime();

    bool status = false;
    std::string glsl_perlin_noise = Shader_retrieve_src_from_file("shaders/perlin_noise.glsl", &status);
    if (!status) {
        fprintf(__stderrp, "ERROR: failed to load shader addon source");
        return false;
    }


    Shader shader_2d;
    if (false == Shader_load_from_file(
        &shader_2d,
        "shaders/parallax/parallax_v2_vrt.glsl",
        "shaders/parallax/parallax_v2_frg.glsl",
        glsl_perlin_noise,
        glsl_perlin_noise
    )) {
        fprintf(__stderrp, "ERROR: shader_2d\n");
        return 1;
    }


    Shader shader_grid;
    if (false == Shader_load_from_file(
        &shader_grid,
        "shaders/default_2d/grid_vrt.glsl",
        "shaders/default_2d/grid_frg.glsl"
    )) {
        fprintf(__stderrp, "ERROR: shader_grid\n");
        return 1;
    }


    const GLfloat ASPECT = (GLfloat)(1280.0f) / (GLfloat)(720.0f);

    size_t STRIDE = 5;


    size_t POINTS_PER_QUAD = 4;
    size_t POINTS_PER_TRI = 3;
    size_t TRIS_PER_QUAD = 2;

    GLfloat wf = 1.0f;
    GLfloat hf = 1.0f * (512.0 / 360.0);
    const GLfloat OFF = 0.0f * wf * ASPECT;

    const GLfloat y_off_left = (16.0f / 45.0f);
    const GLfloat x_off_right = (512.0f / 640.0f);

    glm::vec2 tex_res(2048.0f, 1024.0f);

    glm::vec3 world_bguv_factor = glm::vec3(glm::vec2(1.0f) / tex_res, 1.0f);

    GLuint layers_per_row = (GLuint)(tex_res.x / (1280.0f));



    GLfloat x_ratio = (1280.0f) / tex_res.x;
    GLfloat y_ratio = (720.0f) / tex_res.y;

    GLfloat X_OFF = (tex_res.x - (1280.0f)) / 2.0f;
    GLfloat Y_OFF = (tex_res.y - (720.0f)) / 2.0f;

    GLfloat T[] = {
       0.0f - X_OFF, 0.0f - Y_OFF, 0.0f, 0.0f, 0.0f,
       0.0f - X_OFF, tex_res.y - Y_OFF, 0.0f, 0.0f, 1.0f,
       tex_res.x - X_OFF, tex_res.y - Y_OFF, 0.0f, 1.0f, 1.0f,
       tex_res.x - X_OFF, 0.0f - Y_OFF, 0.0f, 1.0f, 0.0f,
    };

    GLuint TI[] = {
        0, 1, 2,
        2, 3, 0,
    };
# 1209 "run.cpp"
    VertexAttributeArray vao_2d2;
    VertexBufferData tri_data;

    VertexAttributeArray_init(&vao_2d2, STRIDE);

    __glewBindVertexArray(vao_2d2.vao);

        VertexBufferData_init_inplace(
            &tri_data,
            (sizeof(T) / sizeof((T)[0])),
            T,
            (sizeof(TI) / sizeof((TI)[0])),
            TI
        );


        gl_bind_buffers_and_upload_data(&tri_data, 0x88E4);

        gl_set_and_enable_vertex_attrib_ptr(0, 3, 0x1406, 0, 0, &vao_2d2);

        gl_set_and_enable_vertex_attrib_ptr(1, 2, 0x1406, 0, 3, &vao_2d2);

        __glewBindBuffer(0x8892, 0);

    __glewBindVertexArray(0);
# 1252 "run.cpp"
    glViewport(0, 0, (1280.0f), (720.0f));

    glEnable(0x809D);
# 1267 "run.cpp"
    {
        SDL_version compiled;
        SDL_version linked;

        { (&compiled)->major = 2; (&compiled)->minor = 0; (&compiled)->patch = 8; };
        SDL_GetVersion(&linked);

        printf(
            "COMPILED AGAINST SDL VERSION %d.%d.%d.\n",
            compiled.major, compiled.minor, compiled.patch
        );
        printf(
            "LINKED AGAINST SDL VERSION %d.%d.%d.\n",
            linked.major, linked.minor, linked.patch
        );
    }


    printf("USING GL VERSION: %s\n", glGetString(0x1F02));

    glm::mat4 mat_ident(1.0f);
    glm::mat4 mat_projection = glm::ortho(
        0.0f,
        1.0f * (1280.0f),
        1.0f * (720.0f),
        0.0f,
        0.0f,
        1.0f * 10.0f
    );




    glm::vec3 start_pos(0.0f, 0.0f, 1.0f);

    FreeCamera main_cam(start_pos);
    main_cam.orientation = glm::quat();
    main_cam.speed = (0.01 * 360.0f);
    main_cam.offset = glm::vec2((1280.0f) / 2.0, (720.0f) / 2.0);
    main_cam.target = glm::vec2(0);
# 1320 "run.cpp"
    const f64 POS_ACC = 1.08;
    const f64 NEG_ACC = 1.0 / POS_ACC;
# 1330 "run.cpp"
    double up_acc = 1.0;
    double down_acc = 1.0;
    double left_acc = 1.0;
    double right_acc = 1.0;
    double forwards_acc = 1.0;
    double backwards_acc = 1.0;

    double max_acc = 1000.0;
# 1352 "run.cpp"
    Texture bgs[5];
    for (u64 (i) = 0; (i) < ((u64)5); ++(i)) {
        if (0 == GL_texture_gen_and_load_1(
                &bgs[i], ("./textures/separate_test_2/" + std::to_string(i) + ".png").c_str(),
                1, 0x2901, 0x812F
        )) {
            return 1;
        }
    }

    do { GLenum err = 0; while ((err = glGetError()) != 0) { fprintf(__stderrp, "ERROR: 0x%x\n", err); } } while (0);


    __glewUseProgram(shader_2d);



    UniformLocation MAT_LOC = __glewGetUniformLocation(shader_2d, "u_matrix");

    UniformLocation CAM_LOC = __glewGetUniformLocation(shader_2d, "u_position_cam");


    const GLuint UVAL_COUNT_LAYERS = 5;





    __glewActiveTexture(0x84C0);
    glBindTexture(0x0DE1, bgs[0]);
    __glewUniform1i(__glewGetUniformLocation(shader_2d, "tex0"), 0);

    __glewActiveTexture(0x84C1);
    glBindTexture(0x0DE1, bgs[1]);
    __glewUniform1i(__glewGetUniformLocation(shader_2d, "tex1"), 1);

    __glewActiveTexture(0x84C2);
    glBindTexture(0x0DE1, bgs[2]);
    __glewUniform1i(__glewGetUniformLocation(shader_2d, "tex2"), 2);

    __glewActiveTexture(0x84C3);
    glBindTexture(0x0DE1, bgs[3]);
    __glewUniform1i(__glewGetUniformLocation(shader_2d, "tex3"), 3);

    __glewActiveTexture(0x84C4);
    glBindTexture(0x0DE1, bgs[4]);
    __glewUniform1i(__glewGetUniformLocation(shader_2d, "tex4"), 4);


    do { GLenum err = 0; while ((err = glGetError()) != 0) { fprintf(__stderrp, "ERROR: 0x%x\n", err); } } while (0);



    GLDraw2D<> gl_draw2d;
    if (!gl_draw2d.init(mat_projection)) {
        return 1;
    }


    Toggle free_cam_toggle = false;


    __glewUseProgram(shader_grid);

    UniformLocation COLOR_LOC_GRID = __glewGetUniformLocation(shader_grid, "u_color");
    __glewUniform4fv(COLOR_LOC_GRID, 1, glm::value_ptr(glm::vec4(0.25f, 0.25f, 0.25f, 0.5f)));

    UniformLocation SQUARE_PIXEL_LOC_GRID = __glewGetUniformLocation(shader_grid, "u_grid_square_pix");

    GLfloat grid_square_pixel_size = 16.0f;
    __glewUniform1f(SQUARE_PIXEL_LOC_GRID, tex_res.x / grid_square_pixel_size);

    UniformLocation MAT_LOC_GRID = __glewGetUniformLocation(shader_grid, "u_matrix");

    UniformLocation CAM_LOC_GRID = __glewGetUniformLocation(shader_grid, "u_position_cam");


    GLDraw2D<> existing;
    GLDraw2D<256> in_prog;
    Toggle drawing = false;
    Toggle deletion = false;

    if (!existing.init(mat_projection)) {
        fprintf(__stderrp, "FAILED TO INITIALIZE EDITOR DATA \"existing\"\n");
        return 1;
    }
    if (!in_prog.init(mat_projection)) {
        fprintf(__stderrp, "FAILED TO INITIALIZE EDITOR DATA \"in_prog\"\n");
        return 1;
    }



    size_t display_mode_count = 0;
    SDL_DisplayMode mode;

    if (SDL_GetDisplayMode(0, 0, &mode) != 0) {
        SDL_Log("SDL_GetDisplayMode failed: %s", SDL_GetError());
        return 1;
    }

    printf("REFRESH_RATE: %d\n", mode.refresh_rate);


    SDL_GL_SetSwapInterval(1);
    const f64 INTERVAL = (1000.0) / mode.refresh_rate;
    const f64 REFRESH_RATE = mode.refresh_rate;

    f64 frequency = SDL_GetPerformanceFrequency();

    u64 t_now = SDL_GetPerformanceCounter();
    u64 t_prev = 0.0;
    u64 t_start = t_now;
    u64 t_delta = 0;

    f64 t_now_s = (f64)t_now / frequency;
    f64 t_prev_s = 0.0;
    f64 t_since_start_s = 0.0;
    f64 t_delta_s = 0.0;
# 1479 "run.cpp"
    input_sys::Input input = {};
    input_sys::init(&input);


    if (SDL_GameControllerAddMappingsFromRW(SDL_RWFromFile("./mapping/gamecontrollerdb.txt", "rb"), 1) < 0) {
        fprintf(__stderrp, "FAILED TO LOAD CONTROLLER MAPPINGS FROM %s\n", "./mapping/gamecontrollerdb.txt");
    }
# 1501 "run.cpp"
    bool is_running = true;
    SDL_Event event;


    Toggle grid_toggle = false;
    Toggle physics_toggle = false;
    Toggle verbose_view_toggle = false;
    glm::vec3 in_progress_line[2];
    in_progress_line[0] = glm::vec3(0.0f);
    in_progress_line[1] = glm::vec3(0.0f);



    collision_map.first_free()->a = glm::vec3(0.0, 5 * 128, 0.0);
    collision_map.first_free()->b = glm::vec3((1280.0f), 5 * 128, 0.0);
    collision_map.elements_used += 1;

    collision_map.first_free()->a = glm::vec3(512.0, 3 * 128, 0.0);
    collision_map.first_free()->b = glm::vec3(768.0, 3 * 128, 0.0);
    collision_map.elements_used += 1;

    existing.update_projection_matrix = true;
    existing.projection_matrix = mat_projection;
    existing.begin();
    existing.draw_type = 0x0001;
    existing.color = Color::BLACK;
    existing.transform_matrix = glm::mat4(1.0);

    for (u64 (i) = 0; (i) < ((u64)collision_map.elements_used); ++(i)) {
        existing.line(collision_map[i].a, collision_map[i].b);
    }
    existing.end_no_reset();



    Player you;
    Player_init(&you, (1280.0f) / 2.0, (720.0f) / 2.0, 0.0, true, 0, 20, 40);
    you.state_change_time = t_now;
# 1561 "run.cpp"
    AirPhysicsConfig air_physics_conf;

    air_physics_conf.path = "./config/air.txt";
    air_physics_conf.fd = fopen(air_physics_conf.path.c_str(), "r");
    if (air_physics_conf.fd == std::__1::__get_nullptr_t()) {
        fprintf(__stderrp, "ERROR: CANNOT OPEN AIR CONFIG FILE");
    }
    air_physics_conf.gravity = physics::gravity;
    air_physics_conf.player_initial_velocity = Player::JUMP_VELOCITY_DEFAULT;
    air_physics_conf.player_initial_velocity_short = Player::JUMP_VELOCITY_SHORT_DEFAULT;
    air_physics_conf.t_prev_mod = -1;

    if (cmd.hot_config) {
        if (load_config(&air_physics_conf)) {
            physics::gravity = air_physics_conf.gravity;
            you.initial_jump_velocity = air_physics_conf.player_initial_velocity;
            you.initial_jump_velocity_short = air_physics_conf.player_initial_velocity_short;
        }
    }





    while (is_running) {
        t_prev = t_now;
        t_prev_s = t_now_s;

        t_now = SDL_GetPerformanceCounter();
        t_now_s = (f64)t_now / frequency;

        t_delta = (t_now - t_prev);
        t_delta_s = (f64)t_delta / frequency;

        f64 t_since_start_s = ((f64)(t_now - t_start)) / frequency;


        if (!poll_input_events(&input, &event)) {
            is_running = false;
            continue;
        } else if (window_state.minimized) {
            continue;
        } else if (window_state.restored) {
            window_state.restored = false;
            SDL_GL_SwapWindow(window);
            continue;
        }


        bool free_cam_is_on = key_is_toggled(&input, CONTROL::FREE_CAM, &free_cam_toggle);
        bool camera_locked = key_is_held(&input, CONTROL::UP);

        if (free_cam_is_on) {
            main_cam.is_catching_up = true;
        } else if (camera_locked) {
            main_cam.is_catching_up = true;
        }


        {

            main_cam.orientation = glm::quat();

            if (free_cam_is_on) {
                if (key_is_held(&input, CONTROL::UP)) {
                    FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::UPWARDS, t_delta_s * up_acc);
                    up_acc *= POS_ACC;
                    up_acc = glm::min(max_acc, up_acc);
                } else {
                    if (up_acc > 1.0) {
                        FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::UPWARDS, t_delta_s * up_acc);
                    }
                    up_acc = glm::max(1.0, up_acc * NEG_ACC);
                }
                if (key_is_held(&input, CONTROL::DOWN)) {
                    FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::DOWNWARDS, t_delta_s * down_acc);
                    down_acc *= POS_ACC;
                    down_acc = glm::min(max_acc, down_acc);
                } else {
                    if (down_acc > 1.0) {
                        FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::DOWNWARDS, t_delta_s * down_acc);
                    }
                    down_acc = glm::max(1.0, down_acc * NEG_ACC);
                }
            }

            if (key_is_held(&input, CONTROL::LEFT)) {
                if (free_cam_is_on) {
                    FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::LEFTWARDS, t_delta_s * left_acc);
                } else {

                    Player_move_test(&you, MOVEMENT_DIRECTION::LEFTWARDS, t_delta_s * left_acc);
                }

                left_acc *= POS_ACC;
                left_acc = glm::min(max_acc, left_acc);

            } else {
                if (left_acc > 1.0) {
                    if (free_cam_is_on) {
                        FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::LEFTWARDS, t_delta_s * left_acc);
                    } else {

                        Player_move_test(&you, MOVEMENT_DIRECTION::LEFTWARDS, t_delta_s * left_acc);
                    }
                }
                left_acc = glm::max(1.0, left_acc * NEG_ACC);
                left_acc = glm::min(max_acc, left_acc);
            }

            if (key_is_held(&input, CONTROL::RIGHT)) {
                if (free_cam_is_on) {
                    FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::RIGHTWARDS, t_delta_s * right_acc);
                } else {

                    Player_move_test(&you, MOVEMENT_DIRECTION::RIGHTWARDS, t_delta_s * right_acc);
                }

                right_acc *= POS_ACC;
                right_acc = glm::min(max_acc, right_acc);

            } else {
                if (right_acc > 1.0) {
                    if (free_cam_is_on) {
                        FreeCamera_process_directional_movement(&main_cam, MOVEMENT_DIRECTION::RIGHTWARDS, t_delta_s * right_acc);
                    } else {

                        Player_move_test(&you, MOVEMENT_DIRECTION::RIGHTWARDS, t_delta_s * right_acc);
                    }
                }
                right_acc = glm::max(1.0, right_acc * NEG_ACC);
            }
# 1714 "run.cpp"
            if (key_is_pressed(&input, CONTROL::RESET_POSITION)) {
# 1726 "run.cpp"
                main_cam.position = start_pos;
                main_cam.orientation = glm::quat();
                main_cam.is_catching_up = false;

                up_acc = 1.0;
                down_acc = 1.0;
                left_acc = 1.0;
                right_acc = 1.0;
                backwards_acc = 1.0;
                forwards_acc = 1.0;

                Player_init(&you, (1280.0f) / 2.0, (720.0f) / 2.0, 0.0, true, 0, 20, 40);
                you.state_change_time = t_now;
                you.on_ground = false;
            }

            if (!free_cam_is_on &&
                !(camera_locked)) {

                FreeCamera_target_set(&main_cam, you.bound.calc_position_center());
                FreeCamera_target_follow(&main_cam, t_delta_s);


            }
        }
# 1759 "run.cpp"
        glClearColor(97.0 / 255.0, 201.0 / 255.0, 255.0 / 255.0, 0.0f);
        glClear(0x00004000 | 0x00000100);

        __glewUseProgram(shader_2d);



        __glewUniformMatrix4fv(MAT_LOC, 1, 0, glm::value_ptr(
            mat_projection



                        )
        );



        glm::vec3 pos = main_cam.position;
# 1787 "run.cpp"
        __glewUniform3fv(CAM_LOC, 1, glm::value_ptr(pos * world_bguv_factor));
        glEnable(0x0B71);







        __glewBindVertexArray(vao_2d2.vao);
        glDrawElements(0x0004, tri_data.i_count, 0x1405, 0);




        glEnable(0x0B71);
        glDepthRange(0, 1);
        glClear(0x00000100);


        glm::mat4 cam = FreeCamera_calc_view_matrix(&main_cam);
# 1883 "run.cpp"
        if (key_is_toggled(&input, CONTROL::EDIT_MODE, &grid_toggle)) {
            glEnable(0x0BE2);
            glBlendFunc(0x0302, 0x0303);

            glClear(0x00000100);


            __glewUseProgram(shader_grid);



            if (key_is_pressed(&input, CONTROL::ZOOM_IN)) {
                grid_square_pixel_size *= 2;
                grid_square_pixel_size = glm::clamp(grid_square_pixel_size, 4.0f, 64.0f);

                __glewUniform1f(SQUARE_PIXEL_LOC_GRID, tex_res.x / grid_square_pixel_size);
            } else if (key_is_pressed(&input, CONTROL::ZOOM_OUT)) {
                grid_square_pixel_size /= 2;
                grid_square_pixel_size = glm::clamp(grid_square_pixel_size, 4.0f, 64.0f);

                __glewUniform1f(SQUARE_PIXEL_LOC_GRID, tex_res.x / grid_square_pixel_size);
            }


            __glewUniformMatrix4fv(MAT_LOC_GRID, 1, 0, glm::value_ptr(
                    mat_projection
                )
            );

            __glewUniform3fv(CAM_LOC_GRID, 1, glm::value_ptr(pos));


            __glewBindVertexArray(vao_2d2.vao);
            glDrawElements(0x0004, tri_data.i_count, 0x1405, 0);


            glm::mat4 rev_view = FreeCamera_calc_view_matrix_reverse(&main_cam);

            glm::vec4 mouse = glm::vec4((int)input.mouse_x, (int)input.mouse_y, 0.0f, 1.0f);

            mouse = rev_view * mouse;
# 1935 "run.cpp"
            glClear(0x00000100);

            i32 grid_len = tex_res.x / grid_square_pixel_size;



            if (mouse_is_toggled(&input, MOUSE_BUTTON::RIGHT, &deletion)) {
                drawing = false;
                if (mouse_is_pressed(&input, MOUSE_BUTTON::LEFT)) {
                    in_prog.begin();

                    {
                        in_prog.draw_type = 0x0004;
                        in_prog.transform_matrix = cam;
                        in_prog.color = Color::RED;
                        in_prog.circle(
                            10.0f,
                            glm::vec3(
                                mouse.x,
                                mouse.y,
                                1.0f
                            )
                        );
                    }

                    in_prog.end();
                } else {
                    in_prog.begin();

                    {
                        in_prog.draw_type = 0x0004;
                        in_prog.transform_matrix = cam;
                        in_prog.color = Color::RED;
                        in_prog.circle(
                            5.0f,
                            glm::vec3(
                                mouse.x,
                                mouse.y,
                                1.0f
                            )
                        );
                    }

                    in_prog.end();
                }


                existing.update_projection_matrix = true;
                existing.projection_matrix = mat_projection * cam;
                existing.begin();
                existing.draw_type = 0x0001;

                existing.end_no_reset();

            } else {
                switch (mouse_is_toggled_4_states(&input, MOUSE_BUTTON::LEFT, &drawing)) {
                case TOGGLE_BRANCH::PRESSED_ON:

                    in_progress_line[0].x = snap_to_grid(mouse.x, grid_len);
                    in_progress_line[0].y = snap_to_grid(mouse.y, grid_len);
                    in_progress_line[0].z = mouse.z;

                    collision_map.first_free()->a = in_progress_line[0];
                    collision_map.first_free()->a.z = 0;
                case TOGGLE_BRANCH::ON:

                    in_progress_line[1].x = snap_to_grid(mouse.x, grid_len);
                    in_progress_line[1].y = snap_to_grid(mouse.y, grid_len);
                    in_progress_line[1].z = mouse.z;

                    collision_map.first_free()->b = in_progress_line[1];
                    collision_map.first_free()->b.z = 0;

                    in_prog.begin();
                    in_prog.draw_type = 0x0001;
                    in_prog.transform_matrix = cam;
                    in_prog.color = Color::BLACK;
                    in_prog.line(in_progress_line[0], in_progress_line[1]);

                    {
                        in_prog.draw_type = 0x0004;
                        in_prog.transform_matrix = cam;
                        in_prog.color = Color::BLUE;
                        in_prog.circle(
                            5.0f,
                            glm::vec3(
                                snap_to_grid(mouse.x, grid_len),
                                snap_to_grid(mouse.y, grid_len),
                                1.0f
                            )
                        );
                    }

                    in_prog.end();

                    existing.update_projection_matrix = true;
                    existing.projection_matrix = mat_projection * cam;
                    existing.begin();
                    existing.draw_type = 0x0001;

                    existing.end_no_reset();

                    break;
                case TOGGLE_BRANCH::PRESSED_OFF:



                    collision_map.elements_used += 1;

                    in_prog.begin();
                    {
                        in_prog.draw_type = 0x0004;
                        in_prog.transform_matrix = cam;
                        in_prog.color = Color::GREEN;
                        in_prog.circle(
                            10.0f,
                            glm::vec3(
                                snap_to_grid(mouse.x, grid_len),
                                snap_to_grid(mouse.y, grid_len),
                                1.0f
                            )
                        );
                    }
                    in_prog.end();

                    existing.update_projection_matrix = true;
                    existing.projection_matrix = mat_projection * cam;
                    existing.begin();
                    existing.draw_type = 0x0001;




                    existing.line(in_progress_line[0], in_progress_line[1]);
# 2090 "run.cpp"
                    existing.end_no_reset();
                    break;
                case TOGGLE_BRANCH::OFF:
                    in_prog.begin();
                    {
                        in_prog.draw_type = 0x0004;
                        in_prog.transform_matrix = cam;
                        in_prog.color = Color::BLUE;
                        in_prog.circle(
                            5.0f,
                            glm::vec3(
                                snap_to_grid(mouse.x, grid_len),
                                snap_to_grid(mouse.y, grid_len),
                                1.0f
                            )
                        );
                    }
                    in_prog.end();

                    existing.update_projection_matrix = true;
                    existing.projection_matrix = mat_projection * cam;
                    existing.begin();
                    existing.draw_type = 0x0001;

                    existing.end_no_reset();
                    break;
                default:
                    break;
                }
            }

            gl_draw2d.begin();

            glClear(0x00000100);

            gl_draw2d.draw_type = 0x0001;

            gl_draw2d.color = Color::BLUE;

            gl_draw2d.transform_matrix = cam;




            f64 WEE = ((f64)(t_now - you.state_change_time)) / frequency;
# 2143 "run.cpp"
            gl_draw2d.end();

            gl_draw2d.begin();

            glClear(0x00000100);

            gl_draw2d.color = Color::GREEN;
            gl_draw2d.transform_matrix = cam;


            if (cmd.hot_config && air_physics_conf.fd != std::__1::__get_nullptr_t() && key_is_pressed(&input, CONTROL::LOAD_CONFIG)) {
                if (load_config(&air_physics_conf)) {
                    physics::gravity = air_physics_conf.gravity;
                    you.initial_jump_velocity= air_physics_conf.player_initial_velocity;
                    you.initial_jump_velocity_short = air_physics_conf.player_initial_velocity_short;
                }

            }



            if (!you.on_ground) {



                if (!key_is_held(&input, CONTROL::JUMP)) {
                    if (you.velocity_air.y < you.initial_jump_velocity_short) {
                        you.velocity_air.y = you.initial_jump_velocity_short;
                    }
                }

                you.velocity_air += (physics::gravity * ((1 / (t_delta_s * REFRESH_RATE))));
                you.bound.spatial.y += you.velocity_air.y;
            }


            bool collided = false;

            CollisionStatus status;
            CollisionStatus_init(&status);
            for (auto it = collision_map.begin(); it != collision_map.first_free(); ++it)
            {


                if (temp_test_collision(&you, it, &status)) {

                    gl_draw2d.line(glm::vec3(0.0), status.intersection);
                    you.on_ground = true;
                    you.state_change_time = t_now;
                    collided = true;


                } else {

                }
            }

            if (!collided) {
                you.on_ground = false;
            } else {

                if (you.on_ground) {
                    if (key_is_pressed(&input, CONTROL::JUMP)) {
                        you.velocity_air.y = you.initial_jump_velocity;
                        you.on_ground = false;
                    }
                }

                you.bound.spatial.y = status.intersection.y - (1 * you.bound.height);

                Collider* col = status.collider;
                glm::vec3* a = &col->a;
                glm::vec3* b = &col->b;
                you.bound.spatial.w = glm::mod(atan2pos_64(b->y - a->y, b->x - a->x), glm::pi<f64>());


                if (key_is_toggled(&input, CONTROL::EDIT_VERBOSE, &verbose_view_toggle)) {
                    f64 dy = col->b.y - col->a.y;
                    f64 dx = col->b.x - col->a.x;

                    glm::vec3 na(-dy, dx, 0.0);
                    glm::vec3 nb(dy, -dx, 0.0);




                    gl_draw2d.color = Color::GREEN;
                    gl_draw2d.line(status.collider->a, status.collider->b);
                    gl_draw2d.color = Color::BLUE;
                    gl_draw2d.line(na + col->a, nb + col->a);






                }

            }

            gl_draw2d.color = Color::BLUE;
            draw_player_collision(&you, &gl_draw2d);

            gl_draw2d.end();

            glDisable(0x0BE2);
# 2260 "run.cpp"
        }



        SDL_GL_SwapWindow(window);
# 2276 "run.cpp"
    }

    if (air_physics_conf.fd != std::__1::__get_nullptr_t()) {
        fclose(air_physics_conf.fd);
    }

    VertexAttributeArray_delete(&vao_2d2);
    VertexBufferData_delete_inplace(&tri_data);

    gl_draw2d.free();


    in_prog.free();
    existing.free();
    __glewDeleteProgram(shader_grid);

    __glewDeleteProgram(shader_2d);

    SDL_GL_DeleteContext(program_data.context);
    SDL_DestroyWindow(window);
    IMG_Quit();
    SDL_Quit();

    return 0;
}
