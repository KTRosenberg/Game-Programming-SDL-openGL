# 1 "common_utils_cpp.h"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 169 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "common_utils_cpp.h" 2







# 1 "/usr/include/sys/stat.h" 1 3 4
# 27 "/usr/include/sys/stat.h" 3 4



# 67 "/usr/include/sys/stat.h" 3 4







# 1 "/usr/include/sys/_types.h" 1 3 4
# 27 "/usr/include/sys/_types.h" 3 4






# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 27 "/usr/include/sys/cdefs.h" 3 4



# 65 "/usr/include/sys/cdefs.h" 3 4



























# 111 "/usr/include/sys/cdefs.h" 3 4
















































    #if 1
        
    #else
        
    #endif







    #if 1
        
    #else
        
    #endif


























# 215 "/usr/include/sys/cdefs.h" 3 4



# 232 "/usr/include/sys/cdefs.h" 3 4



























































# 325 "/usr/include/sys/cdefs.h" 3 4









# 350 "/usr/include/sys/cdefs.h" 3 4










# 382 "/usr/include/sys/cdefs.h" 3 4


# 404 "/usr/include/sys/cdefs.h" 3 4


# 414 "/usr/include/sys/cdefs.h" 3 4
















# 438 "/usr/include/sys/cdefs.h" 3 4


# 448 "/usr/include/sys/cdefs.h" 3 4





































# 1 "/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 26 "/usr/include/sys/_symbol_aliasing.h" 3 4





























































































































































# 485 "/usr/include/sys/cdefs.h" 2 3 4











# 513 "/usr/include/sys/cdefs.h" 3 4
















# 540 "/usr/include/sys/cdefs.h" 3 4











# 1 "/usr/include/sys/_posix_availability.h" 1 3 4
# 26 "/usr/include/sys/_posix_availability.h" 3 4

















































# 551 "/usr/include/sys/cdefs.h" 2 3 4















































































































# 33 "/usr/include/sys/_types.h" 2 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
# 27 "/usr/include/machine/_types.h" 3 4






# 1 "/usr/include/i386/_types.h" 1 3 4
# 27 "/usr/include/i386/_types.h" 3 4










typedef __signed char		__int8_t;



typedef unsigned char		__uint8_t;
typedef	short			__int16_t;
typedef	unsigned short		__uint16_t;
typedef int			__int32_t;
typedef unsigned int		__uint32_t;
typedef long long		__int64_t;
typedef unsigned long long	__uint64_t;

typedef long			__darwin_intptr_t;
typedef unsigned int		__darwin_natural_t;


# 68 "/usr/include/i386/_types.h" 3 4


typedef int			__darwin_ct_rune_t;	





typedef union {
	char		__mbstate8[128];
	long long	_mbstateL;			
} __mbstate_t;

typedef __mbstate_t		__darwin_mbstate_t;	


typedef long int	__darwin_ptrdiff_t;	







typedef long unsigned int		__darwin_size_t;	





typedef __builtin_va_list	__darwin_va_list;	





typedef int		__darwin_wchar_t;	




typedef __darwin_wchar_t	__darwin_rune_t;	


typedef int		__darwin_wint_t;	




typedef unsigned long		__darwin_clock_t;	
typedef __uint32_t		__darwin_socklen_t;	
typedef long			__darwin_ssize_t;	
typedef long			__darwin_time_t;	


# 33 "/usr/include/machine/_types.h" 2 3 4





# 34 "/usr/include/sys/_types.h" 2 3 4



# 57 "/usr/include/sys/_types.h" 3 4

struct __darwin_pthread_handler_rec
{
	void           (*__routine)(void *);	
	void           *__arg;			
	struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec  *__cleanup_stack; char __opaque[1168]; };








# 93 "/usr/include/sys/_types.h" 3 4

typedef	__int64_t	__darwin_blkcnt_t;	
typedef	__int32_t	__darwin_blksize_t;	
typedef __int32_t	__darwin_dev_t;		
typedef unsigned int	__darwin_fsblkcnt_t;	
typedef unsigned int	__darwin_fsfilcnt_t;	
typedef __uint32_t	__darwin_gid_t;		
typedef __uint32_t	__darwin_id_t;		
typedef __uint64_t	__darwin_ino64_t;	

typedef __darwin_ino64_t __darwin_ino_t;	



typedef __darwin_natural_t __darwin_mach_port_name_t; 
typedef __darwin_mach_port_name_t __darwin_mach_port_t; 
typedef __uint16_t	__darwin_mode_t;	
typedef __int64_t	__darwin_off_t;		
typedef __int32_t	__darwin_pid_t;		
typedef struct _opaque_pthread_attr_t
			__darwin_pthread_attr_t; 
typedef struct _opaque_pthread_cond_t
			__darwin_pthread_cond_t; 
typedef struct _opaque_pthread_condattr_t
			__darwin_pthread_condattr_t; 
typedef unsigned long	__darwin_pthread_key_t;	
typedef struct _opaque_pthread_mutex_t
			__darwin_pthread_mutex_t; 
typedef struct _opaque_pthread_mutexattr_t
			__darwin_pthread_mutexattr_t; 
typedef struct _opaque_pthread_once_t
			__darwin_pthread_once_t; 
typedef struct _opaque_pthread_rwlock_t
			__darwin_pthread_rwlock_t; 
typedef struct _opaque_pthread_rwlockattr_t
			__darwin_pthread_rwlockattr_t; 
typedef struct _opaque_pthread_t
			*__darwin_pthread_t;	
typedef __uint32_t	__darwin_sigset_t;	
typedef __int32_t	__darwin_suseconds_t;	
typedef __uint32_t	__darwin_uid_t;		
typedef __uint32_t	__darwin_useconds_t;	
typedef	unsigned char	__darwin_uuid_t[16];
typedef	char	__darwin_uuid_string_t[37];


# 74 "/usr/include/sys/stat.h" 2 3 4

# 1 "/usr/include/Availability.h" 1 3 4
# 22 "/usr/include/Availability.h" 3 4

 


 
# 117 "/usr/include/Availability.h" 3 4



# 129 "/usr/include/Availability.h" 3 4



# 146 "/usr/include/Availability.h" 3 4



# 1 "/usr/include/AvailabilityInternal.h" 1 3 4
# 22 "/usr/include/AvailabilityInternal.h" 3 4














    #ifdef __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__
        
        
    #endif




    #if 1
        
    #else
        
    #endif










    
    
        #define __IPHONE_OS_VERSION_MAX_ALLOWED     70000
    
    
    
        #undef __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__
        
    #endif

    
        #if 1
            
            
            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_0    __attribute__((availability(ios,introduced=2.0,deprecated=2.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1    __attribute__((availability(ios,introduced=2.0,deprecated=2.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2    __attribute__((availability(ios,introduced=2.0,deprecated=2.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=2.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0    __attribute__((availability(ios,introduced=2.0,deprecated=3.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=2.0,deprecated=3.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=2.0,deprecated=3.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=3.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=2.0,deprecated=4.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=2.0,deprecated=4.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=2.0,deprecated=4.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=2.0,deprecated=4.3)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=4.3,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=2.0,deprecated=5.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=5.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=2.0,deprecated=5.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=5.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=2.0,deprecated=6.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=6.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=2.0,deprecated=6.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=6.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=2.0,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.0,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=2.0)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_2_1                    __attribute__((availability(ios,introduced=2.1)))
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #define __AVAILABILITY_INTERNAL__IPHONE_2_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=2.1)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2    __attribute__((availability(ios,introduced=2.2,deprecated=2.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_2_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=2.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0    __attribute__((availability(ios,introduced=2.2,deprecated=3.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=2.2,deprecated=3.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=2.2,deprecated=3.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=3.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=2.2,deprecated=4.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=2.2,deprecated=4.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=2.2,deprecated=4.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=2.2,deprecated=4.3)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=4.3,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=2.2,deprecated=5.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=5.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=2.2,deprecated=5.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=5.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=2.2,deprecated=6.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=6.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=2.2,deprecated=6.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=6.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=2.2,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=2.2,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_2_2_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=2.2)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_3_0                    __attribute__((availability(ios,introduced=3.0)))
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #define __AVAILABILITY_INTERNAL__IPHONE_3_0_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=3.0)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1    __attribute__((availability(ios,introduced=3.1,deprecated=3.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=3.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2    __attribute__((availability(ios,introduced=3.1,deprecated=3.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_3_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=3.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=3.1,deprecated=4.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=3.1,deprecated=4.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=3.1,deprecated=4.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=3.1,deprecated=4.3)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=4.3,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=3.1,deprecated=5.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=5.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=3.1,deprecated=5.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=5.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=3.1,deprecated=6.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=6.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=3.1,deprecated=6.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=6.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=3.1,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=3.1,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_3_1_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=3.1)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_3_2                    __attribute__((availability(ios,introduced=3.2)))
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #define __AVAILABILITY_INTERNAL__IPHONE_3_2_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=3.2)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0    __attribute__((availability(ios,introduced=4.0,deprecated=4.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1    __attribute__((availability(ios,introduced=4.0,deprecated=4.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=4.0,deprecated=4.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=4.0,deprecated=4.3)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=4.3,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=4.0,deprecated=5.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=5.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=4.0,deprecated=5.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=5.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=4.0,deprecated=6.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=6.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=4.0,deprecated=6.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=6.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=4.0,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.0,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=4.0)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_4_1                    __attribute__((availability(ios,introduced=4.1)))
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #define __AVAILABILITY_INTERNAL__IPHONE_4_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=4.1)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2    __attribute__((availability(ios,introduced=4.2,deprecated=4.2)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_2_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=4.2,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3    __attribute__((availability(ios,introduced=4.2,deprecated=4.3)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_4_3_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=4.3,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=4.2,deprecated=5.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=5.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=4.2,deprecated=5.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=5.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=4.2,deprecated=6.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=6.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=4.2,deprecated=6.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=6.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=4.2,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=4.2,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_4_2_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=4.2)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_4_3                    __attribute__((availability(ios,introduced=4.3)))
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #define __AVAILABILITY_INTERNAL__IPHONE_4_3_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=4.3)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0    __attribute__((availability(ios,introduced=5.0,deprecated=5.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=5.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1    __attribute__((availability(ios,introduced=5.0,deprecated=5.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_5_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=5.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=5.0,deprecated=6.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=6.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=5.0,deprecated=6.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=6.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=5.0,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=5.0,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_5_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=5.0)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_5_1                    __attribute__((availability(ios,introduced=5.1)))
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #define __AVAILABILITY_INTERNAL__IPHONE_5_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=5.1)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0    __attribute__((availability(ios,introduced=6.0,deprecated=6.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=6.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1    __attribute__((availability(ios,introduced=6.0,deprecated=6.1)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_6_1_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=6.1,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=6.0,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=6.0,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_6_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=6.0)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_6_1                    __attribute__((availability(ios,introduced=6.1)))
            
            #if 1
                    
            #else
                    
            #endif
            
            #if 1
                    
            #else
                    
            #endif
            
            #define __AVAILABILITY_INTERNAL__IPHONE_6_1_DEP__IPHONE_NA_MSG(_msg)     __attribute__((availability(ios,introduced=6.1)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0    __attribute__((availability(ios,introduced=7.0,deprecated=7.0)))
            
                    #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_7_0_MSG(_msg)    __attribute__((availability(ios,introduced=7.0,deprecated=7.0,message=_msg)))
            


            #define __AVAILABILITY_INTERNAL__IPHONE_7_0_DEP__IPHONE_NA               __attribute__((availability(ios,introduced=7.0)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_NA                               __attribute__((availability(ios,unavailable)))
            
            #define __AVAILABILITY_INTERNAL__IPHONE_NA_DEP__IPHONE_NA_MSG(_msg)      __attribute__((availability(ios,unavailable)))
        
    #endif

    
# 3612 "/usr/include/AvailabilityInternal.h" 3 4


# 4013 "/usr/include/AvailabilityInternal.h" 3 4
        #if __MAC_OS_X_VERSION_MAX_ALLOWED < 1060
            
        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < 1060
            
        #else
            
        #endif
        
            #define __AVAILABILITY_INTERNAL__MAC_10_5        __attribute__((unavailable))
        




        #if __MAC_OS_X_VERSION_MAX_ALLOWED < 1040
            
        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < 1040
            
        #else
            
        #endif
        
            #define __AVAILABILITY_INTERNAL__MAC_10_3        __attribute__((unavailable))
        




        #if __MAC_OS_X_VERSION_MAX_ALLOWED < 1020
            
        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < 1020
            
        #else
            
        #endif
        
            #define __AVAILABILITY_INTERNAL__MAC_10_1        __attribute__((unavailable))
        




        #if __MAC_OS_X_VERSION_MAX_ALLOWED < 1000
            
        #elif __MAC_OS_X_VERSION_MIN_REQUIRED < 1000
            
        #else
            
        #endif
        
        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1010
            
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_1_MSG(_msg)    __attribute__((deprecated))
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_1_MSG(_msg)    __attribute__((deprecated))
        





        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1020
            
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_2_MSG(_msg)    __attribute__((deprecated))
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_2_MSG(_msg)    __attribute__((deprecated))
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_2_MSG(_msg)    __attribute__((deprecated))
        







        #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1030
            
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_3_MSG(_msg)    __attribute__((deprecated))
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_3_MSG(_msg)    __attribute__((deprecated))
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_3_MSG(_msg)    __attribute__((deprecated))
            
            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_3_MSG(_msg)    __attribute__((deprecated))
        
            #define __attribute__((deprecated))              
            
            #define __attribute__((deprecated))              __AVAILABILITY_INTERNAL__MAC_10_1
            
            #define __attribute__((deprecated))              
            
            #define __attribute__((deprecated))              __AVAILABILITY_INTERNAL__MAC_10_3
            
        #endif
        
# 4120 "/usr/include/AvailabilityInternal.h" 3 4
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_4              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_4              __AVAILABILITY_INTERNAL__MAC_10_1
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_4              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_4              __AVAILABILITY_INTERNAL__MAC_10_3
            
            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_4              
            
        #endif
        
# 4145 "/usr/include/AvailabilityInternal.h" 3 4
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_5              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_1
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_5              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_3
            
            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_5              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_5              __AVAILABILITY_INTERNAL__MAC_10_5
            
        #endif
        
# 4174 "/usr/include/AvailabilityInternal.h" 3 4
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_6              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_1
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_6              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_3
            
            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_6              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_6              __AVAILABILITY_INTERNAL__MAC_10_5
            
            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_6              
            
        #endif
        
# 4207 "/usr/include/AvailabilityInternal.h" 3 4
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_7              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_1
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_7              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_3
            
            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_7              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_5
            
            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_7              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_7              __AVAILABILITY_INTERNAL__MAC_10_7
            
        #endif
        
# 4244 "/usr/include/AvailabilityInternal.h" 3 4
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_8              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_1
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_8              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_3
            
            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_8              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_5
            
            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_8              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_7
            
            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_8              __AVAILABILITY_INTERNAL__MAC_10_8
            
        #endif
        
# 4285 "/usr/include/AvailabilityInternal.h" 3 4
            #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_10_9              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_1
            
            #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_9              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_3
            
            #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_9              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_5
            
            #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_9              
            
            #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_7
            
            #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_8
            
            #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_9              __AVAILABILITY_INTERNAL__MAC_10_9
            
        #endif
        
        #define __AVAILABILITY_INTERNAL__MAC_10_0_DEP__MAC_NA_MSG(_msg)   
        
        #define __AVAILABILITY_INTERNAL__MAC_10_1_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_1
        
        #define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_NA_MSG(_msg)   
        
        #define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_3
        
        #define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_NA_MSG(_msg)   
        
        #define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_5
        
        #define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_NA_MSG(_msg)   
        
        #define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_7
        
        #define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_8
        
        #define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_NA_MSG(_msg)   __AVAILABILITY_INTERNAL__MAC_10_9
        
        #define __AVAILABILITY_INTERNAL__MAC_NA_DEP__MAC_NA_MSG(_msg)     __attribute__((unavailable))
    



# 149 "/usr/include/Availability.h" 2 3 4



    #define __OSX_AVAILABLE_STARTING(_osx, _ios) __AVAILABILITY_INTERNAL##_ios
    

    #define __OSX_AVAILABLE_BUT_DEPRECATED_MSG(_osxIntro, _osxDep, _iosIntro, _iosDep, _msg)                                                      __AVAILABILITY_INTERNAL##_iosIntro##_DEP##_iosDep##_MSG(_msg)


# 170 "/usr/include/Availability.h" 3 4



# 76 "/usr/include/sys/stat.h" 2 3 4



# 1 "/usr/include/sys/_types/_timespec.h" 1 3 4
# 27 "/usr/include/sys/_types/_timespec.h" 3 4



struct timespec
{
	__darwin_time_t	tv_sec;
	long            tv_nsec;
};

# 79 "/usr/include/sys/stat.h" 2 3 4







# 1 "/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_blkcnt_t.h" 3 4



typedef __darwin_blkcnt_t        blkcnt_t; 

# 86 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_blksize_t.h" 3 4



typedef __darwin_blksize_t        blksize_t; 

# 87 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_dev_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_dev_t.h" 3 4



typedef __darwin_dev_t        dev_t;	 

# 88 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_ino_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_ino_t.h" 3 4



typedef	__darwin_ino_t		ino_t;		

# 89 "/usr/include/sys/stat.h" 2 3 4



# 1 "/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_ino64_t.h" 3 4



typedef __darwin_ino64_t        ino64_t; 	

# 92 "/usr/include/sys/stat.h" 2 3 4



# 1 "/usr/include/sys/_types/_mode_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_mode_t.h" 3 4



typedef	__darwin_mode_t		mode_t;

# 95 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_nlink_t.h" 3 4



typedef __uint16_t        nlink_t;  	

# 96 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_uid_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_uid_t.h" 3 4



typedef __darwin_uid_t        uid_t; 

# 97 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_gid_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_gid_t.h" 3 4



typedef __darwin_gid_t	gid_t; 

# 98 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_off_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_off_t.h" 3 4



typedef __darwin_off_t		off_t;

# 99 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_time_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_time_t.h" 3 4



typedef __darwin_time_t		time_t; 

# 100 "/usr/include/sys/stat.h" 2 3 4










struct ostat {
	__uint16_t	st_dev;		
	ino_t		st_ino;		
	mode_t		st_mode;	
	nlink_t		st_nlink;	
	__uint16_t	st_uid;		
	__uint16_t	st_gid;		
	__uint16_t	st_rdev;	
	__int32_t	st_size;	
	struct	timespec st_atimespec;	
	struct	timespec st_mtimespec;	
	struct	timespec st_ctimespec;	
	__int32_t	st_blksize;	
	__int32_t	st_blocks;	
	__uint32_t	st_flags;	
	__uint32_t	st_gen;		
};








# 147 "/usr/include/sys/stat.h" 3 4


# 157 "/usr/include/sys/stat.h" 3 4


# 175 "/usr/include/sys/stat.h" 3 4







struct stat { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };


# 216 "/usr/include/sys/stat.h" 3 4





struct stat64 { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };




















# 1 "/usr/include/sys/_types/_s_ifmt.h" 1 3 4
# 27 "/usr/include/sys/_types/_s_ifmt.h" 3 4









# 46 "/usr/include/sys/_types/_s_ifmt.h" 3 4























# 242 "/usr/include/sys/stat.h" 2 3 4








# 259 "/usr/include/sys/stat.h" 3 4


# 274 "/usr/include/sys/stat.h" 3 4






# 292 "/usr/include/sys/stat.h" 3 4






							

							


















	




					












	
	







int	chmod(__const char *, mode_t) __asm("_" "x") ;
int	fchmod(int, mode_t) __asm("_" "x") ;
int	fstat(int, struct stat *) __asm("_" "x" "$INODE64");
int	lstat(__const char *, struct stat *) __asm("_" "x" "$INODE64");
int	mkdir(__const char *, mode_t);
int	mkfifo(__const char *, mode_t);
int	stat(__const char *, struct stat *) __asm("_" "x" "$INODE64");
int	mknod(__const char *, mode_t, dev_t);
mode_t	umask(mode_t);




# 1 "/usr/include/sys/_types/_filesec_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_filesec_t.h" 3 4



struct _filesec;
typedef struct _filesec	*filesec_t;

# 359 "/usr/include/sys/stat.h" 2 3 4

int	chflags(__const char *, __uint32_t);
int	chmodx_np(__const char *, filesec_t);
int	fchflags(int, __uint32_t);
int	fchmodx_np(int, filesec_t);
int	fstatx_np(int, struct stat *, filesec_t) __asm("_" "x" "$INODE64");
int	lchflags(__const char *, __uint32_t) __OSX_AVAILABLE_STARTING(1050, 20000);
int	lchmod(__const char *, mode_t) __OSX_AVAILABLE_STARTING(1050, 20000);
int	lstatx_np(__const char *, struct stat *, filesec_t) __asm("_" "x" "$INODE64");
int	mkdirx_np(__const char *, filesec_t);
int	mkfifox_np(__const char *, filesec_t);
int	statx_np(__const char *, struct stat *, filesec_t) __asm("_" "x" "$INODE64");
int	umaskx_np(filesec_t) __AVAILABILITY_INTERNAL##__IPHONE_NA##_DEP##__IPHONE_NA;



int	fstatx64_np(int, struct stat64 *, filesec_t) __AVAILABILITY_INTERNAL##__IPHONE_NA##_DEP##__IPHONE_NA;
int	lstatx64_np(__const char *, struct stat64 *, filesec_t) __AVAILABILITY_INTERNAL##__IPHONE_NA##_DEP##__IPHONE_NA;
int	statx64_np(__const char *, struct stat64 *, filesec_t) __AVAILABILITY_INTERNAL##__IPHONE_NA##_DEP##__IPHONE_NA;
int	fstat64(int, struct stat64 *) __AVAILABILITY_INTERNAL##__IPHONE_NA##_DEP##__IPHONE_NA;
int	lstat64(__const char *, struct stat64 *) __AVAILABILITY_INTERNAL##__IPHONE_NA##_DEP##__IPHONE_NA;
int	stat64(__const char *, struct stat64 *) __AVAILABILITY_INTERNAL##__IPHONE_NA##_DEP##__IPHONE_NA;





# 8 "common_utils_cpp.h" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 22 "/usr/include/fcntl.h" 3 4


# 1 "/usr/include/sys/fcntl.h" 1 3 4
# 27 "/usr/include/sys/fcntl.h" 3 4



# 67 "/usr/include/sys/fcntl.h" 3 4

















# 1 "/usr/include/sys/_types/_size_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_size_t.h" 3 4



typedef __darwin_size_t        size_t; 

# 84 "/usr/include/sys/fcntl.h" 2 3 4


# 1 "/usr/include/sys/_types/_pid_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_pid_t.h" 3 4



typedef __darwin_pid_t        pid_t; 

# 87 "/usr/include/sys/fcntl.h" 2 3 4






























# 1 "/usr/include/sys/_types/_o_sync.h" 1 3 4
# 27 "/usr/include/sys/_types/_o_sync.h" 3 4


# 117 "/usr/include/sys/fcntl.h" 2 3 4


# 131 "/usr/include/sys/fcntl.h" 3 4











# 1 "/usr/include/sys/_types/_o_dsync.h" 1 3 4
# 27 "/usr/include/sys/_types/_o_dsync.h" 3 4


# 142 "/usr/include/sys/fcntl.h" 2 3 4






















# 172 "/usr/include/sys/fcntl.h" 3 4

















# 208 "/usr/include/sys/fcntl.h" 3 4



















                                        






















                                        







// FS-specific fcntl()'s numbers begin at 0x00010000 and go up





















# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
# 27 "/usr/include/sys/_types/_seek_set.h" 3 4




# 280 "/usr/include/sys/fcntl.h" 2 3 4
















						







struct flock {
	off_t	l_start;	
	off_t	l_len;		
	pid_t	l_pid;		
	short	l_type;		
	short	l_whence;	
};








struct flocktimeout {
	struct flock    fl;             
	struct timespec timeout;        
};









struct radvisory {
       off_t   ra_offset;
       int     ra_count;
};








typedef struct fsignatures {
	off_t		fs_file_start;
	void		*fs_blob_start;
	size_t		fs_blob_size;
} fsignatures_t;









typedef struct fstore {
	unsigned int fst_flags;	
	int 	fst_posmode;	
	off_t	fst_offset;	
	off_t	fst_length;	
	off_t   fst_bytesalloc;	
} fstore_t;



typedef struct fbootstraptransfer {
  off_t fbt_offset;             
  size_t fbt_length;          
  void *fbt_buffer;             
} fbootstraptransfer_t;



# 395 "/usr/include/sys/fcntl.h" 3 4


# 396 "/usr/include/sys/fcntl.h" 3 4
#pragma pack(4)

struct log2phys {
	unsigned int	l2p_flags;	 
	off_t		l2p_contigbytes; 
					 
					 
	off_t		l2p_devoffset;   
					 
					 
};


# 408 "/usr/include/sys/fcntl.h" 3 4
#pragma pack()












typedef enum {
	FILESEC_OWNER = 1,
	FILESEC_GROUP = 2,
	FILESEC_UUID = 3,
	FILESEC_MODE = 4,
	FILESEC_ACL = 5,
	FILESEC_GRPUUID = 6,


	FILESEC_ACL_RAW = 100,
	FILESEC_ACL_ALLOCSIZE = 101
} filesec_property_t;






int	open(__const char *, int, ...) __asm("_" "x") ;
int	creat(__const char *, mode_t) __asm("_" "x") ;
int	fcntl(int, int, ...) __asm("_" "x") ;


int	openx_np(__const char *, int, filesec_t);

int open_dprotected_np ( __const char *, int, int, int, ...);
int	flock(int, int);
filesec_t filesec_init(void);
filesec_t filesec_dup(filesec_t);
void	filesec_free(filesec_t);
int	filesec_get_property(filesec_t, filesec_property_t, void *);
int	filesec_query_property(filesec_t, filesec_property_t, int *);
int	filesec_set_property(filesec_t, filesec_property_t, __const void *);
int	filesec_unset_property(filesec_t, filesec_property_t) __OSX_AVAILABLE_STARTING(1060, 30200);



           


# 24 "/usr/include/fcntl.h" 2 3 4
# 9 "common_utils_cpp.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 22 "/usr/include/unistd.h" 3 4


# 60 "/usr/include/unistd.h" 3 4












# 1 "/usr/include/_types.h" 1 3 4
# 22 "/usr/include/_types.h" 3 4








# 38 "/usr/include/_types.h" 3 4

typedef	int		__darwin_nl_item;
typedef	int		__darwin_wctrans_t;

typedef	__uint32_t	__darwin_wctype_t;


























# 72 "/usr/include/unistd.h" 2 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 27 "/usr/include/sys/unistd.h" 3 4



# 62 "/usr/include/sys/unistd.h" 3 4





















				

# 1 "/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 27 "/usr/include/sys/_types/_posix_vdisable.h" 3 4


# 85 "/usr/include/sys/unistd.h" 2 3 4
















# 113 "/usr/include/sys/unistd.h" 3 4



















struct accessx_descriptor {
	unsigned int ad_name_offset;
	int ad_flags;
	int ad_pad[2];
};






# 151 "/usr/include/sys/unistd.h" 3 4










# 172 "/usr/include/sys/unistd.h" 3 4





# 73 "/usr/include/unistd.h" 2 3 4


# 1 "/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_intptr_t.h" 3 4



typedef __darwin_intptr_t	intptr_t;

# 76 "/usr/include/unistd.h" 2 3 4






# 1 "/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_ssize_t.h" 3 4



typedef __darwin_ssize_t        ssize_t; 

# 82 "/usr/include/unistd.h" 2 3 4

# 1 "/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_useconds_t.h" 3 4



typedef __darwin_useconds_t	useconds_t;

# 84 "/usr/include/unistd.h" 2 3 4
# 1 "/usr/include/sys/_types/_null.h" 1 3 4
# 27 "/usr/include/sys/_types/_null.h" 3 4


# 85 "/usr/include/unistd.h" 2 3 4














# 148 "/usr/include/unistd.h" 3 4


# 165 "/usr/include/unistd.h" 3 4




































# 210 "/usr/include/unistd.h" 3 4



# 239 "/usr/include/unistd.h" 3 4


# 267 "/usr/include/unistd.h" 3 4







# 326 "/usr/include/unistd.h" 3 4


# 342 "/usr/include/unistd.h" 3 4





























# 385 "/usr/include/unistd.h" 3 4




# 405 "/usr/include/unistd.h" 3 4



















void	 _exit(int) __attribute__((noreturn));
int	 access(__const char *, int);
unsigned int
	 alarm(unsigned int);
int	 chdir(__const char *);
int	 chown(__const char *, uid_t, gid_t);

int	 close(int) __asm("_" "x") ;

int	 dup(int);
int	 dup2(int, int);
int	 execl(__const char *, __const char *, ...);
int	 execle(__const char *, __const char *, ...);
int	 execlp(__const char *, __const char *, ...);
int	 execv(__const char *, char * __const *);
int	 execve(__const char *, char * __const *, char * __const *);
int	 execvp(__const char *, char * __const *);
pid_t	 fork(void);
long	 fpathconf(int, int);
char	*getcwd(char *, size_t);
gid_t	 getegid(void);
uid_t	 geteuid(void);
gid_t	 getgid(void);



int	 getgroups(int, gid_t []);

char	*getlogin(void);
pid_t	 getpgrp(void);
pid_t	 getpid(void);
pid_t	 getppid(void);
uid_t	 getuid(void);
int	 isatty(int);
int	 link(__const char *, __const char *);
off_t	 lseek(int, off_t, int);
long	 pathconf(__const char *, int);

int	 pause(void) __asm("_" "x") ;

int	 pipe(int [2]);

ssize_t	 read(int, void *, size_t) __asm("_" "x") ;

int	 rmdir(__const char *);
int	 setgid(gid_t);
int	 setpgid(pid_t, pid_t);
pid_t	 setsid(void);
int	 setuid(uid_t);

unsigned int
	 sleep(unsigned int) __asm("_" "x") ;

long	 sysconf(int);
pid_t	 tcgetpgrp(int);
int	 tcsetpgrp(int, pid_t);
char	*ttyname(int);


int	 ttyname_r(int, char *, size_t) __asm("_" "x") ;




int	 unlink(__const char *);

ssize_t	 write(int, __const void *, size_t) __asm("_" "x") ;









             
size_t	 confstr(int, char *, size_t) __asm("_" "x") ;

int	 getopt(int, char * __const [], __const char *) __asm("_" "x") ;

extern char *optarg;			
extern int optind, opterr, optopt;












                               





 





__attribute__((deprecated))

void	*brk(__const void *);
int	 chroot(__const char *) ___POSIX_C_DEPRECATED_STARTING_##199506L;


char	*crypt(__const char *, __const char *);



char    *ctermid(char *);


void	 encrypt(char *, int) __asm("_" "x") ;



int	 fchdir(int);
long	 gethostid(void);
pid_t	 getpgid(pid_t);
pid_t	 getsid(pid_t);



int	 getdtablesize(void) ___POSIX_C_DEPRECATED_STARTING_##199506L;
int	 getpagesize(void) __attribute__((__const)) ___POSIX_C_DEPRECATED_STARTING_##199506L;
char	*getpass(__const char *) ___POSIX_C_DEPRECATED_STARTING_##199506L;




char	*getwd(char *) ___POSIX_C_DEPRECATED_STARTING_##200112L; 


int	 lchown(__const char *, uid_t, gid_t) __asm("_" "x") ;

int	 lockf(int, int, off_t) __asm("_" "x") ;

int	 nice(int) __asm("_" "x") ;

ssize_t	 pread(int, void *, size_t, off_t) __asm("_" "x") ;

ssize_t	 pwrite(int, __const void *, size_t, off_t) __asm("_" "x") ;






__attribute__((deprecated))

void	*sbrk(int);



pid_t	 setpgrp(void) __asm("_" "x") ;




int	 setregid(gid_t, gid_t) __asm("_" "x") ;

int	 setreuid(uid_t, uid_t) __asm("_" "x") ;

void     swab(__const void * restrict, void * restrict, ssize_t);
void	 sync(void);
int	 truncate(__const char *, off_t);
useconds_t	 ualarm(useconds_t, useconds_t);
int	 usleep(useconds_t) __asm("_" "x") ;
pid_t	 vfork(void);


int	 fsync(int) __asm("_" "x") ;

int	 ftruncate(int, off_t);
int	 getlogin_r(char *, size_t);











             
int	 fchown(int, uid_t, gid_t);
int	 gethostname(char *, size_t);
ssize_t  readlink(__const char * restrict, char * restrict, size_t);
int	 setegid(gid_t);
int	 seteuid(uid_t);
int	 symlink(__const char *, __const char *);









# 1 "/usr/include/sys/select.h" 1 3 4
# 27 "/usr/include/sys/select.h" 3 4


# 61 "/usr/include/sys/select.h" 3 4






# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 27 "/usr/include/sys/appleapiopts.h" 3 4





































# 67 "/usr/include/sys/select.h" 2 3 4









# 1 "/usr/include/sys/_types/_fd_def.h" 1 3 4
# 27 "/usr/include/sys/_types/_fd_def.h" 3 4



















typedef	struct fd_set {
	__int32_t	fds_bits[((((1024) % ( (sizeof(__int32_t) * 8))) == 0) ? ((1024) / ( (sizeof(__int32_t) * 8))) : (((1024) / ( (sizeof(__int32_t) * 8))) + 1))];
} fd_set;



static __inline int
__darwin_fd_isset(int _n, __const struct fd_set *_p)
{
	return (_p->fds_bits[(unsigned long)_n/(sizeof(__int32_t) * 8)] & ((__int32_t)(1<<((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}
















# 76 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/sys/_types/_timeval.h" 1 3 4
# 27 "/usr/include/sys/_types/_timeval.h" 3 4



struct timeval
{
	__darwin_time_t	        tv_sec;	        
	__darwin_suseconds_t    tv_usec;        
};

# 78 "/usr/include/sys/select.h" 2 3 4








# 1 "/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_suseconds_t.h" 3 4



typedef __darwin_suseconds_t	suseconds_t;

# 86 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_sigset_t.h" 3 4



typedef __darwin_sigset_t		sigset_t;

# 87 "/usr/include/sys/select.h" 2 3 4














# 1 "/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 27 "/usr/include/sys/_types/_fd_setsize.h" 3 4


# 101 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_set.h" 1 3 4
# 27 "/usr/include/sys/_types/_fd_set.h" 3 4


# 102 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 27 "/usr/include/sys/_types/_fd_clr.h" 3 4


# 103 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 27 "/usr/include/sys/_types/_fd_isset.h" 3 4


# 104 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 27 "/usr/include/sys/_types/_fd_zero.h" 3 4


# 105 "/usr/include/sys/select.h" 2 3 4



# 1 "/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 27 "/usr/include/sys/_types/_fd_copy.h" 3 4


# 108 "/usr/include/sys/select.h" 2 3 4






int	 pselect(int, fd_set * restrict, fd_set * restrict,
		fd_set * restrict, __const struct timespec * restrict,
		__const sigset_t * restrict)




		__asm("_" "x" "$1050")




		;



# 1 "/usr/include/sys/_select.h" 1 3 4
# 27 "/usr/include/sys/_select.h" 3 4












int	 select(int, fd_set * restrict, fd_set * restrict,
		fd_set * restrict, struct timeval * restrict)




		__asm("_" "x" "$1050")




		;


# 130 "/usr/include/sys/select.h" 2 3 4





# 634 "/usr/include/unistd.h" 2 3 4




# 1 "/usr/include/sys/_types/_uuid_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_uuid_t.h" 3 4



typedef __darwin_uuid_t	uuid_t;

# 638 "/usr/include/unistd.h" 2 3 4


void	 _Exit(int) __attribute__((noreturn));
int	 accessx_np(__const struct accessx_descriptor *, size_t, int *, uid_t);
int	 acct(__const char *);
int	 add_profil(char *, size_t, unsigned long, unsigned int);
void	 endusershell(void);
int	 execvP(__const char *, __const char *, char * __const *);
char	*fflagstostr(unsigned long);
int	 getdomainname(char *, int);
int	 getgrouplist(__const char *, int, int *, int *);





# 1 "/usr/include/gethostuuid.h" 1 3 4
# 27 "/usr/include/gethostuuid.h" 3 4










int gethostuuid(uuid_t, __const struct timespec *) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_NA, __MAC_NA, 20000, 50000, "gethostuuid() is no longer supported");





# 654 "/usr/include/unistd.h" 2 3 4




mode_t	 getmode(__const void *, mode_t);
int	 getpeereid(int, uid_t *, gid_t *);
int	 getsgroups_np(int *, uuid_t);
char	*getusershell(void);
int	 getwgroups_np(int *, uuid_t);
int	 initgroups(__const char *, int);
int	 iruserok(unsigned long, int, __const char *, __const char *);
int	 iruserok_sa(__const void *, int, int, __const char *, __const char *);
int	 issetugid(void);
char	*mkdtemp(char *);
int	 mknod(__const char *, mode_t, dev_t);
int	 mkpath_np(__const char *path, mode_t omode) __OSX_AVAILABLE_STARTING(1080, 50000); 
int	 mkstemp(char *);
int	 mkstemps(char *, int);
char	*mktemp(char *);
int	 nfssvc(int, void *);
int	 profil(char *, size_t, unsigned long, unsigned int);
int	 pthread_setugid_np(uid_t, gid_t);
int	 pthread_getugid_np( uid_t *, gid_t *);
int	 rcmd(char **, int, __const char *, __const char *, __const char *, int *);
int	 rcmd_af(char **, int, __const char *, __const char *, __const char *, int *,
		int);
int	 reboot(int);
int	 revoke(__const char *);
int	 rresvport(int *);
int	 rresvport_af(int *, int);
int	 ruserok(__const char *, int, __const char *, __const char *);
int	 setdomainname(__const char *, int);
int	 setgroups(int, __const gid_t *);
void	 sethostid(long);
int	 sethostname(__const char *, int);

void	 setkey(__const char *) __asm("_" "x") ;



int	 setlogin(__const char *);
void	*setmode(__const char *) __DARWIN_ALIAS_STARTING_MAC_##1060( __asm("_" "x"));
int	 setrgid(gid_t);
int	 setruid(uid_t);
int	 setsgroups_np(int, __const uuid_t);
void	 setusershell(void);
int	 setwgroups_np(int, __const uuid_t);
int	 strtofflags(char **, unsigned long *, unsigned long *);
int	 swapon(__const char *);
int	 syscall(int, ...);
int	 ttyslot(void);
int	 undelete(__const char *);
int	 unwhiteout(__const char *);
void	*valloc(size_t);			

extern char *suboptarg;			
int	 getsubopt(char **, char * __const *, char **);



int    fgetattrlist(int,void*,void*,size_t,unsigned int) __OSX_AVAILABLE_STARTING(1060, 30000);
int    fsetattrlist(int,void*,void*,size_t,unsigned int) __OSX_AVAILABLE_STARTING(1060, 30000);
int    getattrlist(__const char*,void*,void*,size_t,unsigned int) __asm("_" "x") ;
int    setattrlist(__const char*,void*,void*,size_t,unsigned int) __asm("_" "x") ;
int exchangedata(__const char*,__const char*,unsigned int);
int    getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);


# 730 "/usr/include/unistd.h" 3 4

struct fssearchblock;
struct searchstate;

int	 searchfs(__const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int	 fsctl(__const char *,unsigned long,void*,unsigned int);
int	 ffsctl(int,unsigned long,void*,unsigned int) __OSX_AVAILABLE_STARTING(1060, 30000);




int	fsync_volume_np(int, int) __OSX_AVAILABLE_STARTING(1080, 60000);
int	sync_volume_np(__const char *, int) __OSX_AVAILABLE_STARTING(1080, 60000);

extern int optreset;





# 10 "common_utils_cpp.h" 2


# 1 "/usr/local/include/glm/glm.hpp" 1 3
/// @ref core
/// @file glm/glm.hpp
///
/// @defgroup core GLM Core
///
/// @brief The core of GLM, which implements exactly and only the GLSL specification to the degree possible.
///
/// The GLM core consists of @ref core_types "C++ types that mirror GLSL types" and
/// C++ functions that mirror the GLSL functions. It also includes 
/// @ref core_precision "a set of precision-based types" that can be used in the appropriate
/// functions. The C++ types are all based on a basic set of @ref core_template "template types".
///
/// The best documentation for GLM Core is the current GLSL specification,
/// <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.clean.pdf">version 4.2
/// (pdf file)</a>.
///
/// GLM core functionnalities require <glm/glm.hpp> to be included to be used.
///
/// @defgroup core_types Types
///
/// @brief The standard types defined by the specification.
///
/// These types are all typedefs of more generalized, template types. To see the definition
/// of these template types, go to @ref core_template.
///
/// @ingroup core
///
/// @defgroup core_precision Precision types
///
/// @brief Non-GLSL types that are used to define precision-based types.
///
/// The GLSL language allows the user to define the precision of a particular variable.
/// In OpenGL's GLSL, these precision qualifiers have no effect; they are there for compatibility
/// with OpenGL ES's precision qualifiers, where they @em do have an effect.
///
/// C++ has no language equivalent to precision qualifiers. So GLM provides the next-best thing:
/// a number of typedefs of the @ref core_template that use a particular precision.
///
/// None of these types make any guarantees about the actual precision used.
///
/// @ingroup core
///
/// @defgroup core_template Template types
///
/// @brief The generic template types used as the basis for the core types. 
///
/// These types are all templates used to define the actual @ref core_types.
/// These templetes are implementation details of GLM types and should not be used explicitly.
///
/// @ingroup core


# 1 "/usr/local/include/glm/detail/_fixes.hpp" 1 3
/// @ref core
/// @file glm/detail/_fixes.hpp



//! Workaround for compatibility with other libraries


       

//! Workaround for compatibility with other libraries


       

//! Workaround for Android


       

//! Workaround for Android


       

//! Workaround for Chrone Native Client


       


# 52 "/usr/local/include/glm/glm.hpp" 2 3










# 1 "/usr/local/include/glm/fwd.hpp" 1 3
/// @ref core
/// @file glm/fwd.hpp




# 1 "/usr/local/include/glm/detail/type_int.hpp" 1 3
/// @ref core
/// @file glm/detail/type_int.hpp




# 1 "/usr/local/include/glm/detail/setup.hpp" 1 3
/// @ref core
/// @file glm/detail/setup.hpp





       

///////////////////////////////////////////////////////////////////////////////////
// Messages



       







      







# 1 "/usr/local/include/glm/detail/../simd/platform.h" 1 3
/// @ref simd
/// @file glm/simd/platform.h



///////////////////////////////////////////////////////////////////////////////////
// Platform





//#define GLM_PLATFORM_IOS			0x00080000













                         


# 43 "/usr/local/include/glm/detail/../simd/platform.h" 3
         

// Report platform detection

# 71 "/usr/local/include/glm/detail/../simd/platform.h" 3
                     

///////////////////////////////////////////////////////////////////////////////////
// Compiler



// Intel








// Visual C++ defines







// GCC defines




















// CUDA











// Clang













// Build model



// Force generic C++ compiler

# 179 "/usr/local/include/glm/detail/../simd/platform.h" 3
                         





                                                     







         

# 226 "/usr/local/include/glm/detail/../simd/platform.h" 3
        

// Visual C++

# 294 "/usr/local/include/glm/detail/../simd/platform.h" 3
       



                     

///////////////////////////////////////////////////////////////////////////////////
// Instruction sets

// User defines: GLM_FORCE_PURE GLM_FORCE_SSE2 GLM_FORCE_SSE3 GLM_FORCE_AVX GLM_FORCE_AVX2 GLM_FORCE_AVX2































# 358 "/usr/local/include/glm/detail/../simd/platform.h" 3
                                                                                                                                               
//	This is Skylake set of instruction set

# 370 "/usr/local/include/glm/detail/../simd/platform.h" 3
                          


# 388 "/usr/local/include/glm/detail/../simd/platform.h" 3
        

# 411 "/usr/local/include/glm/detail/../simd/platform.h" 3
       

// With MinGW-W64, including intrinsic headers before intrin.h will produce some errors. The problem is
// that windows.h (and maybe other headers) will silently include intrin.h, which of course causes problems.
// To fix, we just explicitly include intrin.h here.


       


# 431 "/usr/local/include/glm/detail/../simd/platform.h" 3
                                    

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 1 3 4
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 3 4

 








# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 1 3 4
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 3 4

 








# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 1 3 4
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4










# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 1 3 4
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4

 


 





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mmintrin.h" 1 3 4
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mmintrin.h" 3 4









typedef long long __m64 __attribute__((__vector_size__(8)));

typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_empty(void)
{
    __builtin_ia32_emms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi8(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu8(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu16(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mullo_pi16(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi(__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);       
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq(__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi(__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}




# 499 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mmintrin.h" 3 4






# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));

// This header should only be included in a hosted environment as it depends on
// a standard library to provide allocation routines.


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mm_malloc.h" 1 3 4
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mm_malloc.h" 3 4






# 1 "/usr/include/stdlib.h" 1 3 4
# 22 "/usr/include/stdlib.h" 3 4


# 56 "/usr/include/stdlib.h" 3 4










# 1 "/usr/include/sys/wait.h" 1 3 4
# 27 "/usr/include/sys/wait.h" 3 4



# 62 "/usr/include/sys/wait.h" 3 4

 















typedef enum {
	P_ALL,
	P_PID,
	P_PGID
} idtype_t;







# 1 "/usr/include/sys/_types/_id_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_id_t.h" 3 4



typedef __darwin_id_t	id_t;		

# 91 "/usr/include/sys/wait.h" 2 3 4


# 108 "/usr/include/sys/wait.h" 3 4


# 1 "/usr/include/sys/signal.h" 1 3 4
# 27 "/usr/include/sys/signal.h" 3 4



# 67 "/usr/include/sys/signal.h" 3 4















# 1 "/usr/include/machine/signal.h" 1 3 4
# 27 "/usr/include/machine/signal.h" 3 4






# 1 "/usr/include/i386/signal.h" 1 3 4
# 27 "/usr/include/i386/signal.h" 3 4












typedef int sig_atomic_t; 






# 33 "/usr/include/machine/signal.h" 2 3 4





# 82 "/usr/include/sys/signal.h" 2 3 4


# 123 "/usr/include/sys/signal.h" 3 4








# 141 "/usr/include/sys/signal.h" 3 4





# 1 "/usr/include/machine/_mcontext.h" 1 3 4
# 27 "/usr/include/machine/_mcontext.h" 3 4



# 1 "/usr/include/i386/_mcontext.h" 1 3 4
# 27 "/usr/include/i386/_mcontext.h" 3 4







# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
# 27 "/usr/include/mach/i386/_structs.h" 3 4
















struct __darwin_i386_thread_state
{
    unsigned int	__eax;
    unsigned int	__ebx;
    unsigned int	__ecx;
    unsigned int	__edx;
    unsigned int	__edi;
    unsigned int	__esi;
    unsigned int	__ebp;
    unsigned int	__esp;
    unsigned int	__ss;
    unsigned int	__eflags;
    unsigned int	__eip;
    unsigned int	__cs;
    unsigned int	__ds;
    unsigned int	__es;
    unsigned int	__fs;
    unsigned int	__gs;
};

# 84 "/usr/include/mach/i386/_structs.h" 3 4





struct __darwin_fp_control
{
    unsigned short		__invalid	:1,
    				__denorm	:1,
				__zdiv		:1,
				__ovrfl		:1,
				__undfl		:1,
				__precis	:1,
						:2,
				__pc		:2,





				__rc		:2,






						:1,
						:3;
};
typedef struct __darwin_fp_control	__darwin_fp_control_t;

# 140 "/usr/include/mach/i386/_structs.h" 3 4







struct __darwin_fp_status
{
    unsigned short		__invalid	:1,
    				__denorm	:1,
				__zdiv		:1,
				__ovrfl		:1,
				__undfl		:1,
				__precis	:1,
				__stkflt	:1,
				__errsumm	:1,
				__c0		:1,
				__c1		:1,
				__c2		:1,
				__tos		:3,
				__c3		:1,
				__busy		:1;
};
typedef struct __darwin_fp_status	__darwin_fp_status_t;

# 186 "/usr/include/mach/i386/_structs.h" 3 4
				




struct __darwin_mmst_reg
{
	char	__mmst_reg[10];
	char	__mmst_rsrv[6];
};














struct __darwin_xmm_reg
{
	char		__xmm_reg[16];
};


















struct __darwin_i386_float_state
{
	int 			__fpu_reserved[2];
	struct __darwin_fp_control	__fpu_fcw;		
	struct __darwin_fp_status	__fpu_fsw;		
	__uint8_t		__fpu_ftw;		
	__uint8_t		__fpu_rsrv1;		 
	__uint16_t		__fpu_fop;		
	__uint32_t		__fpu_ip;		
	__uint16_t		__fpu_cs;		
	__uint16_t		__fpu_rsrv2;		
	__uint32_t		__fpu_dp;		
	__uint16_t		__fpu_ds;		
	__uint16_t		__fpu_rsrv3;		
	__uint32_t		__fpu_mxcsr;		
	__uint32_t		__fpu_mxcsrmask;	
	struct __darwin_mmst_reg	__fpu_stmm0;		
	struct __darwin_mmst_reg	__fpu_stmm1;		
	struct __darwin_mmst_reg	__fpu_stmm2;		
	struct __darwin_mmst_reg	__fpu_stmm3;		
	struct __darwin_mmst_reg	__fpu_stmm4;		
	struct __darwin_mmst_reg	__fpu_stmm5;		
	struct __darwin_mmst_reg	__fpu_stmm6;		
	struct __darwin_mmst_reg	__fpu_stmm7;		
	struct __darwin_xmm_reg		__fpu_xmm0;		
	struct __darwin_xmm_reg		__fpu_xmm1;		
	struct __darwin_xmm_reg		__fpu_xmm2;		
	struct __darwin_xmm_reg		__fpu_xmm3;		
	struct __darwin_xmm_reg		__fpu_xmm4;		
	struct __darwin_xmm_reg		__fpu_xmm5;		
	struct __darwin_xmm_reg		__fpu_xmm6;		
	struct __darwin_xmm_reg		__fpu_xmm7;		
	char			__fpu_rsrv4[14*16];	
	int 			__fpu_reserved1;
};


struct __darwin_i386_avx_state
{
	int 			__fpu_reserved[2];
	struct __darwin_fp_control	__fpu_fcw;		
	struct __darwin_fp_status	__fpu_fsw;		
	__uint8_t		__fpu_ftw;		
	__uint8_t		__fpu_rsrv1;		 
	__uint16_t		__fpu_fop;		
	__uint32_t		__fpu_ip;		
	__uint16_t		__fpu_cs;		
	__uint16_t		__fpu_rsrv2;		
	__uint32_t		__fpu_dp;		
	__uint16_t		__fpu_ds;		
	__uint16_t		__fpu_rsrv3;		
	__uint32_t		__fpu_mxcsr;		
	__uint32_t		__fpu_mxcsrmask;	
	struct __darwin_mmst_reg	__fpu_stmm0;		
	struct __darwin_mmst_reg	__fpu_stmm1;		
	struct __darwin_mmst_reg	__fpu_stmm2;		
	struct __darwin_mmst_reg	__fpu_stmm3;		
	struct __darwin_mmst_reg	__fpu_stmm4;		
	struct __darwin_mmst_reg	__fpu_stmm5;		
	struct __darwin_mmst_reg	__fpu_stmm6;		
	struct __darwin_mmst_reg	__fpu_stmm7;		
	struct __darwin_xmm_reg		__fpu_xmm0;		
	struct __darwin_xmm_reg		__fpu_xmm1;		
	struct __darwin_xmm_reg		__fpu_xmm2;		
	struct __darwin_xmm_reg		__fpu_xmm3;		
	struct __darwin_xmm_reg		__fpu_xmm4;		
	struct __darwin_xmm_reg		__fpu_xmm5;		
	struct __darwin_xmm_reg		__fpu_xmm6;		
	struct __darwin_xmm_reg		__fpu_xmm7;		
	char			__fpu_rsrv4[14*16];	
	int 			__fpu_reserved1;
	char			__avx_reserved1[64];
	struct __darwin_xmm_reg		__fpu_ymmh0;		
	struct __darwin_xmm_reg		__fpu_ymmh1;		
	struct __darwin_xmm_reg		__fpu_ymmh2;		
	struct __darwin_xmm_reg		__fpu_ymmh3;		
	struct __darwin_xmm_reg		__fpu_ymmh4;		
	struct __darwin_xmm_reg		__fpu_ymmh5;		
	struct __darwin_xmm_reg		__fpu_ymmh6;		
	struct __darwin_xmm_reg		__fpu_ymmh7;		
};


# 399 "/usr/include/mach/i386/_structs.h" 3 4



struct __darwin_i386_exception_state
{
	__uint16_t	__trapno;
	__uint16_t	__cpu;
	__uint32_t	__err;
	__uint32_t	__faultvaddr;
};

# 419 "/usr/include/mach/i386/_structs.h" 3 4



struct __darwin_x86_debug_state32
{
	unsigned int	__dr0;
	unsigned int	__dr1;
	unsigned int	__dr2;
	unsigned int	__dr3;
	unsigned int	__dr4;
	unsigned int	__dr5;
	unsigned int	__dr6;
	unsigned int	__dr7;
};

# 447 "/usr/include/mach/i386/_structs.h" 3 4







struct __darwin_x86_thread_state64
{
	__uint64_t	__rax;
	__uint64_t	__rbx;
	__uint64_t	__rcx;
	__uint64_t	__rdx;
	__uint64_t	__rdi;
	__uint64_t	__rsi;
	__uint64_t	__rbp;
	__uint64_t	__rsp;
	__uint64_t	__r8;
	__uint64_t	__r9;
	__uint64_t	__r10;
	__uint64_t	__r11;
	__uint64_t	__r12;
	__uint64_t	__r13;
	__uint64_t	__r14;
	__uint64_t	__r15;
	__uint64_t	__rip;
	__uint64_t	__rflags;
	__uint64_t	__cs;
	__uint64_t	__fs;
	__uint64_t	__gs;
};

# 505 "/usr/include/mach/i386/_structs.h" 3 4




struct __darwin_x86_float_state64
{
	int 			__fpu_reserved[2];
	struct __darwin_fp_control	__fpu_fcw;		
	struct __darwin_fp_status	__fpu_fsw;		
	__uint8_t		__fpu_ftw;		
	__uint8_t		__fpu_rsrv1;		 
	__uint16_t		__fpu_fop;		

	
	__uint32_t		__fpu_ip;		
	__uint16_t		__fpu_cs;		

	__uint16_t		__fpu_rsrv2;		

	
	__uint32_t		__fpu_dp;		
	__uint16_t		__fpu_ds;		

	__uint16_t		__fpu_rsrv3;		
	__uint32_t		__fpu_mxcsr;		
	__uint32_t		__fpu_mxcsrmask;	
	struct __darwin_mmst_reg	__fpu_stmm0;		
	struct __darwin_mmst_reg	__fpu_stmm1;		
	struct __darwin_mmst_reg	__fpu_stmm2;		
	struct __darwin_mmst_reg	__fpu_stmm3;		
	struct __darwin_mmst_reg	__fpu_stmm4;		
	struct __darwin_mmst_reg	__fpu_stmm5;		
	struct __darwin_mmst_reg	__fpu_stmm6;		
	struct __darwin_mmst_reg	__fpu_stmm7;		
	struct __darwin_xmm_reg		__fpu_xmm0;		
	struct __darwin_xmm_reg		__fpu_xmm1;		
	struct __darwin_xmm_reg		__fpu_xmm2;		
	struct __darwin_xmm_reg		__fpu_xmm3;		
	struct __darwin_xmm_reg		__fpu_xmm4;		
	struct __darwin_xmm_reg		__fpu_xmm5;		
	struct __darwin_xmm_reg		__fpu_xmm6;		
	struct __darwin_xmm_reg		__fpu_xmm7;		
	struct __darwin_xmm_reg		__fpu_xmm8;		
	struct __darwin_xmm_reg		__fpu_xmm9;		
	struct __darwin_xmm_reg		__fpu_xmm10;		
	struct __darwin_xmm_reg		__fpu_xmm11;		
	struct __darwin_xmm_reg		__fpu_xmm12;		
	struct __darwin_xmm_reg		__fpu_xmm13;		
	struct __darwin_xmm_reg		__fpu_xmm14;		
	struct __darwin_xmm_reg		__fpu_xmm15;		
	char			__fpu_rsrv4[6*16];	
	int 			__fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
	int 			__fpu_reserved[2];
	struct __darwin_fp_control	__fpu_fcw;		
	struct __darwin_fp_status	__fpu_fsw;		
	__uint8_t		__fpu_ftw;		
	__uint8_t		__fpu_rsrv1;		 
	__uint16_t		__fpu_fop;		

	
	__uint32_t		__fpu_ip;		
	__uint16_t		__fpu_cs;		

	__uint16_t		__fpu_rsrv2;		

	
	__uint32_t		__fpu_dp;		
	__uint16_t		__fpu_ds;		

	__uint16_t		__fpu_rsrv3;		
	__uint32_t		__fpu_mxcsr;		
	__uint32_t		__fpu_mxcsrmask;	
	struct __darwin_mmst_reg	__fpu_stmm0;		
	struct __darwin_mmst_reg	__fpu_stmm1;		
	struct __darwin_mmst_reg	__fpu_stmm2;		
	struct __darwin_mmst_reg	__fpu_stmm3;		
	struct __darwin_mmst_reg	__fpu_stmm4;		
	struct __darwin_mmst_reg	__fpu_stmm5;		
	struct __darwin_mmst_reg	__fpu_stmm6;		
	struct __darwin_mmst_reg	__fpu_stmm7;		
	struct __darwin_xmm_reg		__fpu_xmm0;		
	struct __darwin_xmm_reg		__fpu_xmm1;		
	struct __darwin_xmm_reg		__fpu_xmm2;		
	struct __darwin_xmm_reg		__fpu_xmm3;		
	struct __darwin_xmm_reg		__fpu_xmm4;		
	struct __darwin_xmm_reg		__fpu_xmm5;		
	struct __darwin_xmm_reg		__fpu_xmm6;		
	struct __darwin_xmm_reg		__fpu_xmm7;		
	struct __darwin_xmm_reg		__fpu_xmm8;		
	struct __darwin_xmm_reg		__fpu_xmm9;		
	struct __darwin_xmm_reg		__fpu_xmm10;		
	struct __darwin_xmm_reg		__fpu_xmm11;		
	struct __darwin_xmm_reg		__fpu_xmm12;		
	struct __darwin_xmm_reg		__fpu_xmm13;		
	struct __darwin_xmm_reg		__fpu_xmm14;		
	struct __darwin_xmm_reg		__fpu_xmm15;		
	char			__fpu_rsrv4[6*16];	
	int 			__fpu_reserved1;
	char			__avx_reserved1[64];
	struct __darwin_xmm_reg		__fpu_ymmh0;		
	struct __darwin_xmm_reg		__fpu_ymmh1;		
	struct __darwin_xmm_reg		__fpu_ymmh2;		
	struct __darwin_xmm_reg		__fpu_ymmh3;		
	struct __darwin_xmm_reg		__fpu_ymmh4;		
	struct __darwin_xmm_reg		__fpu_ymmh5;		
	struct __darwin_xmm_reg		__fpu_ymmh6;		
	struct __darwin_xmm_reg		__fpu_ymmh7;		
	struct __darwin_xmm_reg		__fpu_ymmh8;		
	struct __darwin_xmm_reg		__fpu_ymmh9;		
	struct __darwin_xmm_reg		__fpu_ymmh10;		
	struct __darwin_xmm_reg		__fpu_ymmh11;		
	struct __darwin_xmm_reg		__fpu_ymmh12;		
	struct __darwin_xmm_reg		__fpu_ymmh13;		
	struct __darwin_xmm_reg		__fpu_ymmh14;		
	struct __darwin_xmm_reg		__fpu_ymmh15;		
};


# 748 "/usr/include/mach/i386/_structs.h" 3 4



struct __darwin_x86_exception_state64
{
    __uint16_t	__trapno;
    __uint16_t	__cpu;
    __uint32_t	__err;
    __uint64_t	__faultvaddr;
};

# 768 "/usr/include/mach/i386/_structs.h" 3 4



struct __darwin_x86_debug_state64
{
	__uint64_t	__dr0;
	__uint64_t	__dr1;
	__uint64_t	__dr2;
	__uint64_t	__dr3;
	__uint64_t	__dr4;
	__uint64_t	__dr5;
	__uint64_t	__dr6;
	__uint64_t	__dr7;
};

# 796 "/usr/include/mach/i386/_structs.h" 3 4


# 34 "/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
	struct __darwin_i386_exception_state	__es;
	struct __darwin_i386_thread_state	__ss;
	struct __darwin_i386_float_state	__fs;
};


struct __darwin_mcontext_avx32
{
	struct __darwin_i386_exception_state	__es;
	struct __darwin_i386_thread_state	__ss;
	struct __darwin_i386_avx_state		__fs;
};


# 72 "/usr/include/i386/_mcontext.h" 3 4




struct __darwin_mcontext64
{
	struct __darwin_x86_exception_state64	__es;
	struct __darwin_x86_thread_state64	__ss;
	struct __darwin_x86_float_state64	__fs;
};


struct __darwin_mcontext_avx64
{
	struct __darwin_x86_exception_state64	__es;
	struct __darwin_x86_thread_state64	__ss;
	struct __darwin_x86_avx_state64		__fs;
};


# 110 "/usr/include/i386/_mcontext.h" 3 4





typedef struct __darwin_mcontext64	*mcontext_t;















# 30 "/usr/include/machine/_mcontext.h" 2 3 4
# 146 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 27 "/usr/include/sys/_types/_sigaltstack.h" 3 4









struct __darwin_sigaltstack
{
	void            *ss_sp;	        
	__darwin_size_t ss_size;        
	int             ss_flags;       
};
typedef struct __darwin_sigaltstack	stack_t; 


# 147 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_ucontext.h" 1 3 4
# 27 "/usr/include/sys/_types/_ucontext.h" 3 4







struct __darwin_ucontext
{
	int                     uc_onstack;
	__darwin_sigset_t       uc_sigmask;     
	struct __darwin_sigaltstack     uc_stack;       
	struct __darwin_ucontext        *uc_link;       
	__darwin_size_t	        uc_mcsize;      
	struct __darwin_mcontext64        *uc_mcontext;   



};


typedef struct __darwin_ucontext	ucontext_t;     	


# 148 "/usr/include/sys/signal.h" 2 3 4



# 1 "/usr/include/sys/_types/_pthread_attr_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_pthread_attr_t.h" 3 4



typedef __darwin_pthread_attr_t		pthread_attr_t;

# 151 "/usr/include/sys/signal.h" 2 3 4




union sigval {
	
	int	sival_int;
	void	*sival_ptr;
};





struct sigevent {
	int				sigev_notify;				
	int				sigev_signo;				
	union sigval	sigev_value;				
	void			(*sigev_notify_function)(union sigval);	  
	pthread_attr_t	*sigev_notify_attributes;	
};


typedef struct __siginfo {
	int	si_signo;		
	int	si_errno;		
	int	si_code;		
	pid_t	si_pid;			
	uid_t	si_uid;			
	int	si_status;		
	void	*si_addr;		
	union sigval si_value;		
	long	si_band;		
	unsigned long	__pad[7];	
} siginfo_t;



# 197 "/usr/include/sys/signal.h" 3 4






# 213 "/usr/include/sys/signal.h" 3 4



# 226 "/usr/include/sys/signal.h" 3 4






















# 256 "/usr/include/sys/signal.h" 3 4










union __sigaction_u {
	void    (*__sa_handler)(int);
	void    (*__sa_sigaction)(int, struct __siginfo *,
		       void *);
};


struct	__sigaction {
	union __sigaction_u __sigaction_u;  
	void    (*sa_tramp)(void *, int, int, siginfo_t *, void *);
	sigset_t sa_mask;		
	int	sa_flags;		
};




struct	sigaction {
	union __sigaction_u __sigaction_u;  
	sigset_t sa_mask;		
	int	sa_flags;		
};








# 304 "/usr/include/sys/signal.h" 3 4
























typedef	void (*sig_t)(int);	
















struct	sigvec {
	void	(*sv_handler)(int);	
	int	sv_mask;		
	int	sv_flags;		
};














struct	sigstack {
	char	*ss_sp;			
	int	ss_onstack;		
};



















void	(*signal(int, void (*)(int)))(int);


# 110 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 27 "/usr/include/sys/resource.h" 3 4



# 62 "/usr/include/sys/resource.h" 3 4











# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 1 3 4
# 23 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 3 4











// C99 7.18.3 Limits of other integer types
//
//  Footnote 219, 220: C++ implementations should define these macros only when
//  __STDC_LIMIT_MACROS is defined before <stdint.h> is included.
//
//  Footnote 222: C++ implementations should define these macros only when
//  __STDC_CONSTANT_MACROS is defined before <stdint.h> is included.
//
// C++11 [cstdint.syn]p2:
//
//  The macros defined by <cstdint> are provided unconditionally. In particular,
//  the symbols __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS (mentioned in
//  footnotes 219, 220, and 222 in the C standard) play no role in C++.
//
// C11 removed the problematic footnotes.
//
// Work around this inconsistency by always defining those macros in C++ mode,
// so that a C library implementation which follows the C99 standard can be
// used in C++.

# 63 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 3 4


# 1 "/usr/include/stdint.h" 1 3 4


















# 1 "/usr/include/sys/_types/_int8_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_int8_t.h" 3 4



typedef	__signed char		int8_t;

# 19 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int16_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_int16_t.h" 3 4



typedef	short			int16_t;

# 20 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int32_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_int32_t.h" 3 4



typedef	int			int32_t;

# 21 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int64_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_int64_t.h" 3 4



typedef	long long		int64_t;

# 22 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/_types/_uint8_t.h" 1 3 4
# 27 "/usr/include/_types/_uint8_t.h" 3 4




typedef unsigned char uint8_t;

# 24 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint16_t.h" 1 3 4
# 27 "/usr/include/_types/_uint16_t.h" 3 4




typedef unsigned short uint16_t;

# 25 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint32_t.h" 1 3 4
# 27 "/usr/include/_types/_uint32_t.h" 3 4




typedef unsigned int uint32_t;

# 26 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint64_t.h" 1 3 4
# 27 "/usr/include/_types/_uint64_t.h" 3 4




typedef unsigned long long uint64_t;

# 27 "/usr/include/stdint.h" 2 3 4


typedef int8_t           int_least8_t;
typedef int16_t         int_least16_t;
typedef int32_t         int_least32_t;
typedef int64_t         int_least64_t;
typedef uint8_t         uint_least8_t;
typedef uint16_t       uint_least16_t;
typedef uint32_t       uint_least32_t;
typedef uint64_t       uint_least64_t;



typedef int8_t            int_fast8_t;
typedef int16_t          int_fast16_t;
typedef int32_t          int_fast32_t;
typedef int64_t          int_fast64_t;
typedef uint8_t          uint_fast8_t;
typedef uint16_t        uint_fast16_t;
typedef uint32_t        uint_fast32_t;
typedef uint64_t        uint_fast64_t;







# 1 "/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_uintptr_t.h" 3 4



typedef unsigned long		uintptr_t;

# 55 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/_types/_intmax_t.h" 1 3 4
# 27 "/usr/include/_types/_intmax_t.h" 3 4





typedef long int intmax_t;

# 59 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uintmax_t.h" 1 3 4
# 27 "/usr/include/_types/_uintmax_t.h" 3 4





typedef long unsigned int uintmax_t;

# 60 "/usr/include/stdint.h" 2 3 4















   








































































































































# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 2 3 4











# 73 "/usr/include/sys/resource.h" 2 3 4
















typedef __uint64_t	rlim_t;





























































struct	rusage {
	struct timeval ru_utime;	
	struct timeval ru_stime;	



	




	long	ru_maxrss;		

	long	ru_ixrss;		
	long	ru_idrss;		
	long	ru_isrss;		
	long	ru_minflt;		
	long	ru_majflt;		
	long	ru_nswap;		
	long	ru_inblock;		
	long	ru_oublock;		
	long	ru_msgsnd;		
	long	ru_msgrcv;		
	long	ru_nsignals;		
	long	ru_nvcsw;		
	long	ru_nivcsw;		


};










typedef void *rusage_info_t;

struct rusage_info_v0 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;	
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;	
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;	
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
};























# 285 "/usr/include/sys/resource.h" 3 4





struct rlimit {
	rlim_t	rlim_cur;		
	rlim_t	rlim_max;		
};























struct proc_rlimit_control_wakeupmon {
	uint32_t wm_flags;
	int32_t wm_rate;
};


























int	getpriority(int, id_t);

int	getiopolicy_np(int, int) __OSX_AVAILABLE_STARTING(1050, 20000);

int	getrlimit(int, struct rlimit *) __asm("_" "x") ;
int	getrusage(int, struct rusage *);
int	setpriority(int, id_t, int);

int	setiopolicy_np(int, int, int) __OSX_AVAILABLE_STARTING(1050, 20000);

int	setrlimit(int, __const struct rlimit *) __asm("_" "x") ;



# 111 "/usr/include/sys/wait.h" 2 3 4












































































# 1 "/usr/include/machine/endian.h" 1 3 4
# 27 "/usr/include/machine/endian.h" 3 4









# 1 "/usr/include/i386/endian.h" 1 3 4
# 27 "/usr/include/i386/endian.h" 3 4





# 64 "/usr/include/i386/endian.h" 3 4




































# 1 "/usr/include/sys/_endian.h" 1 3 4
# 27 "/usr/include/sys/_endian.h" 3 4



# 56 "/usr/include/sys/_endian.h" 3 4


# 88 "/usr/include/sys/_endian.h" 3 4












# 123 "/usr/include/sys/_endian.h" 3 4


# 1 "/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 27 "/usr/include/libkern/_OSByteOrder.h" 3 4



























# 62 "/usr/include/libkern/_OSByteOrder.h" 3 4





# 1 "/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 27 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4






# 41 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4



static __inline
__uint16_t
_OSSwapInt16(
    __uint16_t        _data
)
{
    return ((__uint16_t)((_data << 8) | (_data >> 8)));
}

static __inline
__uint32_t
_OSSwapInt32(
    __uint32_t        _data
)
{

    return __builtin_bswap32(_data);




}


static __inline
__uint64_t
_OSSwapInt64(
    __uint64_t        _data
)
{
    return __builtin_bswap64(_data);
}


# 103 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4


# 67 "/usr/include/libkern/_OSByteOrder.h" 2 3 4














# 129 "/usr/include/libkern/_OSByteOrder.h" 3 4


# 125 "/usr/include/sys/_endian.h" 2 3 4








# 100 "/usr/include/i386/endian.h" 2 3 4


# 36 "/usr/include/machine/endian.h" 2 3 4





# 187 "/usr/include/sys/wait.h" 2 3 4







union wait {
	int	w_status;		
	


	struct {

		unsigned int	w_Termsig:7,	
				w_Coredump:1,	
				w_Retcode:8,	
				w_Filler:16;	







	} w_T;
	




	struct {

		unsigned int	w_Stopval:8,	
				w_Stopsig:8,	
				w_Filler:16;	






	} w_S;
};

















pid_t	wait(int *) __asm("_" "x") ;
pid_t	waitpid(pid_t, int *, int) __asm("_" "x") ;

int	waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "x") ;


pid_t	wait3(int *, int, struct rusage *);
pid_t	wait4(pid_t, int *, int, struct rusage *);

           

# 66 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/alloca.h" 1 3 4
# 22 "/usr/include/alloca.h" 3 4










void	*alloca(size_t);		











# 68 "/usr/include/stdlib.h" 2 3 4









# 1 "/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_ct_rune_t.h" 3 4




typedef __darwin_ct_rune_t ct_rune_t;

# 77 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_rune_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_rune_t.h" 3 4



typedef __darwin_rune_t rune_t; 

# 78 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 27 "/usr/include/sys/_types/_wchar_t.h" 3 4






typedef __darwin_wchar_t wchar_t;

# 81 "/usr/include/stdlib.h" 2 3 4

typedef struct {
	int quot;		
	int rem;		
} div_t;

typedef struct {
	long quot;		
	long rem;		
} ldiv_t;


typedef struct {
	long long quot;
	long long rem;
} lldiv_t;




















extern int __mb_cur_max;










void	 abort(void) __attribute__((noreturn));
int	 abs(int) __attribute__((__const));
int	 atexit(void (*)(void));
double	 atof(__const char *);
int	 atoi(__const char *);
long	 atol(__const char *);

long long
	 atoll(__const char *);

void	*bsearch(__const void *, __const void *, size_t,
	    size_t, int (*)(__const void *, __const void *));
void	*calloc(size_t, size_t);
div_t	 div(int, int) __attribute__((__const));
void	 exit(int) __attribute__((noreturn));
void	 free(void *);
char	*getenv(__const char *);
long	 labs(long) __attribute__((__const));
ldiv_t	 ldiv(long, long) __attribute__((__const));

long long
	 llabs(long long);
lldiv_t	 lldiv(long long, long long);

void	*malloc(size_t);
int	 mblen(__const char *, size_t);
size_t	 mbstowcs(wchar_t * restrict , __const char * restrict, size_t);
int	 mbtowc(wchar_t * restrict, __const char * restrict, size_t);
int 	 posix_memalign(void **, size_t, size_t) __OSX_AVAILABLE_STARTING(1060, 30000);
void	 qsort(void *, size_t, size_t,
	    int (*)(__const void *, __const void *));
int	 rand(void);
void	*realloc(void *, size_t);
void	 srand(unsigned);
double	 strtod(__const char *, char **) __asm("_" "x") ;
float	 strtof(__const char *, char **) __asm("_" "x") ;
long	 strtol(__const char *, char **, int);
long double
	 strtold(__const char *, char **);

long long 
	 strtoll(__const char *, char **, int);

unsigned long
	 strtoul(__const char *, char **, int);

unsigned long long
	 strtoull(__const char *, char **, int);

int	 system(__const char *) __asm("_" "x") ;
size_t	 wcstombs(char * restrict, __const wchar_t * restrict, size_t);
int	 wctomb(char *, wchar_t);


void	_Exit(int) __attribute__((noreturn));
long	 a64l(__const char *);
double	 drand48(void);
char	*ecvt(double, int, int *restrict, int *restrict); 
double	 erand48(unsigned short[3]); 
char	*fcvt(double, int, int *restrict, int *restrict); 
char	*gcvt(double, int, char *); 
int	 getsubopt(char **, char * __const *, char **);
int	 grantpt(int);

char	*initstate(unsigned, char *, size_t); 



long	 jrand48(unsigned short[3]);
char	*l64a(long);
void	 lcong48(unsigned short[7]);
long	 lrand48(void);
char	*mktemp(char *);
int	 mkstemp(char *);
long	 mrand48(void); 
long	 nrand48(unsigned short[3]);
int	 posix_openpt(int);
char	*ptsname(int);
int	 putenv(char *) __asm("_" "x") ;
long	 random(void);
int	 rand_r(unsigned *);

char	*realpath(__const char * restrict, char * restrict) __asm("_" "x" "$DARWIN_EXTSN");



unsigned short
	*seed48(unsigned short[3]);
int	 setenv(__const char *, __const char *, int) __asm("_" "x") ;

void	 setkey(__const char *) __asm("_" "x") ;



char	*setstate(__const char *);
void	 srand48(long);

void	 srandom(unsigned);



int	 unlockpt(int);

int	 unsetenv(__const char *) __asm("_" "x") ;







# 1 "/usr/include/machine/types.h" 1 3 4
# 27 "/usr/include/machine/types.h" 3 4









# 1 "/usr/include/i386/types.h" 1 3 4
# 27 "/usr/include/i386/types.h" 3 4





# 64 "/usr/include/i386/types.h" 3 4

















typedef	unsigned char		u_int8_t;
typedef	unsigned short		u_int16_t;
typedef	unsigned int		u_int32_t;
typedef	unsigned long long	u_int64_t;


typedef int64_t			register_t;









typedef u_int64_t		user_addr_t;	
typedef u_int64_t		user_size_t;	
typedef int64_t			user_ssize_t;
typedef int64_t			user_long_t;
typedef u_int64_t		user_ulong_t;
typedef int64_t			user_time_t;
typedef int64_t			user_off_t;







typedef u_int64_t		syscall_arg_t;


# 1 "/usr/include/sys/_types/___offsetof.h" 1 3 4
# 27 "/usr/include/sys/_types/___offsetof.h" 3 4


# 114 "/usr/include/i386/types.h" 2 3 4


# 36 "/usr/include/machine/types.h" 2 3 4





# 239 "/usr/include/stdlib.h" 2 3 4




u_int32_t	arc4random(void);
void	 arc4random_addrandom(unsigned char * , int );
void	 arc4random_buf(void * , size_t ) __OSX_AVAILABLE_STARTING(1070, 40300);
void	 arc4random_stir(void);
u_int32_t
	 arc4random_uniform(u_int32_t ) __OSX_AVAILABLE_STARTING(1070, 40300);

int	 atexit_b(void (^)(void)) __OSX_AVAILABLE_STARTING(1060, 30200);
void	*bsearch_b(__const void *, __const void *, size_t,
	    size_t, int (^)(__const void *, __const void *)) __OSX_AVAILABLE_STARTING(1060, 30200);


	 
char	*cgetcap(char *, __const char *, int);
int	 cgetclose(void);
int	 cgetent(char **, char **, __const char *);
int	 cgetfirst(char **, char **);
int	 cgetmatch(__const char *, __const char *);
int	 cgetnext(char **, char **);
int	 cgetnum(char *, __const char *, long *);
int	 cgetset(__const char *);
int	 cgetstr(char *, __const char *, char **);
int	 cgetustr(char *, __const char *, char **);

int	 daemon(int, int) __asm("_" "x" "$1050") __AVAILABILITY_INTERNAL## 20000##_DEP## 20000;
char	*devname(dev_t, mode_t);
char	*devname_r(dev_t, mode_t, char *buf, int len);
char	*getbsize(int *, long *);
int	 getloadavg(double [], int);
__const char
	*getprogname(void);

int	 heapsort(void *, size_t, size_t,
	    int (*)(__const void *, __const void *));

int	 heapsort_b(void *, size_t, size_t,
	    int (^)(__const void *, __const void *)) __OSX_AVAILABLE_STARTING(1060, 30200);

int	 mergesort(void *, size_t, size_t,
	    int (*)(__const void *, __const void *));

int	 mergesort_b(void *, size_t, size_t,
	    int (^)(__const void *, __const void *)) __OSX_AVAILABLE_STARTING(1060, 30200);

void	 psort(void *, size_t, size_t,
	    int (*)(__const void *, __const void *)) __OSX_AVAILABLE_STARTING(1060, 30200);

void	 psort_b(void *, size_t, size_t,
	    int (^)(__const void *, __const void *)) __OSX_AVAILABLE_STARTING(1060, 30200);

void	 psort_r(void *, size_t, size_t, void *,
	    int (*)(void *, __const void *, __const void *))  __OSX_AVAILABLE_STARTING(1060, 30200);

void	 qsort_b(void *, size_t, size_t,
	    int (^)(__const void *, __const void *)) __OSX_AVAILABLE_STARTING(1060, 30200);

void	 qsort_r(void *, size_t, size_t, void *,
	    int (*)(void *, __const void *, __const void *));
int	 radixsort(__const unsigned char **, int, __const unsigned char *,
	    unsigned);
void	 setprogname(__const char *);
int	 sradixsort(__const unsigned char **, int, __const unsigned char *,
	    unsigned);
void	 sranddev(void);
void	 srandomdev(void);
void	*reallocf(void *, size_t);

long long
	 strtoq(__const char *, char **, int);
unsigned long long
	 strtouq(__const char *, char **, int);

extern char *suboptarg;		
void	*valloc(size_t);






           






# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mm_malloc.h" 2 3 4





extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size);










static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t __size, size_t __align)
{
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{
  free(__p);
}



# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return __a + __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return __a - __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return __a * __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return __a / __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_sqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rcpss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ps(__m128 __a)
{
  return __builtin_ia32_rcpps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rsqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 1),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 2),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 5),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 6),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 3);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}



static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64(__a);
}



static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si32(__m128 __a)
{
  return __a[0];
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si64(__m128 __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}

static __inline__ float __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pi(__m128 __a, __const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pi(__m128 __a, __const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ss(__const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load_ss_struct*)__p)->__u;
  return (__m128){ __u, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load1_ps(__const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct*)__p)->__u;
  return (__m128){ __u, __u, __u, __u };
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ps(__const float *__p)
{
  return *(__m128*)__p;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadu_ps(__const float *__p)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadr_ps(__const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ss(float __w)
{
  return (__m128){ __w, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set1_ps(float __w)
{
  return (__m128){ __w, __w, __w, __w };
}

// Microsoft specific.
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __w, __x, __y, __z };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __z, __y, __x, __w };
}

static __inline__ __m128 __attribute__((__always_inline__))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __attribute__((__always_inline__))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storehps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storelps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_ps(float *__p, __m128 __a)
{
  __builtin_ia32_storeups(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 0, 0, 0, 0);
  _mm_storeu_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps1(float *__p, __m128 __a)
{
    return _mm_store1_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128 *)__p = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}











static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_ia32_movntps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_pi16(__m64 __a, int __n)
{
  __v4hi __b = (__v4hi)__a;
  return (unsigned short)__b[__n & 3];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_insert_pi16(__m64 __a, int __d, int __n)
{
   __v4hi __b = (__v4hi)__a;
   __b[__n & 3] = __d;
   return (__m64)__b;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}





static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_setcsr(unsigned int __i)
{
  __builtin_ia32_ldmxcsr(__i);
}









static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 2, 6, 3, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 4, 1, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_move_ss(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 6, 7, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;
  
  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;
  
  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;
  
  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;
  
  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);
  
  return _mm_packs_pi32(__b, __c);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;
  
  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();
  
  return _mm_packs_pi16(__b, __c);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps(__a);
}








































# 976 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4



# 993 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 1 3 4
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4



# 997 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4





# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 2 3 4

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return __a + __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return __a - __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return __a * __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return __a / __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd(__b);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 1);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 2);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 5);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 6);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pd(__m128 __a)
{
  return __builtin_ia32_cvtps2pd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_pd(__m128i __a)
{
  return __builtin_ia32_cvtdq2pd((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si32(__m128d __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_pd(double __const *__dp)
{
  return *(__m128d*)__dp;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load1_pd(double __const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load1_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __u };
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadr_pd(double __const *__dp)
{
  __m128d __u = *(__m128d*)__dp;
  return __builtin_shufflevector(__u, __u, 1, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadu_pd(double __const *__dp)
{
  struct __loadu_pd {
    __m128d __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_pd*)__dp)->__v;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_sd(double __const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load_sd_struct*)__dp)->__u;
  return (__m128d){ __u, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pd(__m128d __a, double __const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadh_pd_struct*)__dp)->__u;
  return (__m128d){ __a[0], __u };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pd(__m128d __a, double __const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadl_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_sd(double __w)
{
  return (__m128d){ __w, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set1_pd(double __w)
{
  return (__m128d){ __w, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_pd(double __w, double __x)
{
  return (__m128d){ __x, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setr_pd(double __w, double __x)
{
  return (__m128d){ __w, __x };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_move_sd(__m128d __a, __m128d __b)
{
  return (__m128d){ __b[0], __a[1] };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_pd(double *__dp, __m128d __a)
{
  struct __mm_store1_pd_struct {
    double __u[2];
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store1_pd_struct*)__dp)->__u[0] = __a[0];
  ((struct __mm_store1_pd_struct*)__dp)->__u[1] = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  __builtin_ia32_storeupd(__dp, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector(__a, __a, 1, 0);
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a + (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a + (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a + (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a * (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a - (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a - (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a - (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return __a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return ~__a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return __a | __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return __a ^ __b;
}







static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}








static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{
  

  typedef __signed char __v16qs __attribute__((__vector_size__(16)));
  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}


static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si64(__m128d __a)
{
  return __a[0];
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_ps(__m128i __a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si128(int __a)
{
  return (__m128i)(__v4si){ __a, 0, 0, 0 };
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si128(long long __a)
{
  return (__m128i){ __a, 0 };
}


static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_load_si128(__m128i __const *__p)
{
  return *__p;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadu_si128(__m128i __const *__p)
{
  struct __loadu_si128 {
    __m128i __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_si128*)__p)->__v;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadl_epi64(__m128i __const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64x(long long q1, long long q0)
{
  return (__m128i){ q0, q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64(__m64 q1, __m64 q0)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi32(int i3, int i2, int i1, int i0)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi16(short w7, short w6, short w5, short w4, short w3, short w2, short w1, short w0)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi8(char b15, char b14, char b13, char b12, char b11, char b10, char b9, char b8, char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64x(long long __q)
{
  return (__m128i){ __q, __q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64(__m64 __q)
{
  return (__m128i){ (long long)__q, (long long)__q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi32(int __i)
{
  return (__m128i)(__v4si){ __i, __i, __i, __i };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi16(short __w)
{
  return (__m128i)(__v8hi){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi8(char __b)
{
  return (__m128i)(__v16qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi64(__m64 q0, __m64 q1)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi32(int i0, int i1, int i2, int i3)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi16(short w0, short w1, short w2, short w3, short w4, short w5, short w6, short w7)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi8(char b0, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8, char b9, char b10, char b11, char b12, char b13, char b14, char b15)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_si128(__m128i *__p, __m128i __b)
{
  __builtin_ia32_storedqu((char *)__p, (__v16qi)__b);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_epi64(__m128i *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_ia32_movntpd(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_ia32_movntdq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_clflush(void __const *__p)
{
  __builtin_ia32_clflush(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_lfence(void)
{
  __builtin_ia32_lfence();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mfence(void)
{
  __builtin_ia32_mfence();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_epi16(__m128i __a, int __imm)
{
  __v8hi __b = (__v8hi)__a;
  return (unsigned short)__b[__imm & 7];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_insert_epi16(__m128i __a, int __b, int __imm)
{
  __v8hi __c = (__v8hi)__a;
  __c[__imm & 7] = __b;
  return (__m128i)__c;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}



















# 1313 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_movpi64_epi64(__m64 __a)
{
  return (__m128i){ (long long)__a, 0 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector(__a, (__m128i){ 0 }, 0, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd(__a);
}








static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_pause(void)
{
  __asm__ __volatile ("pause");
}






# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 2 3 4

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_lddqu_si128(__m128i __const *__p)
{
  return (__m128i)__builtin_ia32_lddqu((char __const *)__p);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_addsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_addsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_haddps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_hsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehdup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 1, 1, 3, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_moveldup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0, 2, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_addsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_addsubpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_haddpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_hsubpd(__a, __b);
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_movedup_pd(__m128d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0);
}









static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_monitor(void __const *__p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitor((void *)__p, __extensions, __hints);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mwait(unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_mwait(__extensions, __hints);
}




# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 2 3 4

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi8(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi8(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsb128((__v16qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi16(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi16(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsw128((__v8hi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi32(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi32(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsd128((__v4si)__a);
}











static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadds_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadds_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)__a, (__v2si)__b);
}




# 432 "/usr/local/include/glm/detail/../simd/platform.h" 2 3





                 


	typedef __m128		glm_vec4;
	typedef __m128i		glm_ivec4;
	typedef __m128i		glm_uvec4;




       




       

# 30 "/usr/local/include/glm/detail/setup.hpp" 2 3


///////////////////////////////////////////////////////////////////////////////////
// Version










                     

// Report compiler detection

# 62 "/usr/local/include/glm/detail/setup.hpp" 3
                     

///////////////////////////////////////////////////////////////////////////////////
// Build model







         



                  








                     


# 117 "/usr/local/include/glm/detail/setup.hpp" 3
                     

///////////////////////////////////////////////////////////////////////////////////
// C++ Version

// User defines: GLM_FORCE_CXX98, GLM_FORCE_CXX03, GLM_FORCE_CXX11, GLM_FORCE_CXX14






















# 168 "/usr/local/include/glm/detail/setup.hpp" 3
      


# 180 "/usr/local/include/glm/detail/setup.hpp" 3
        



# 262 "/usr/local/include/glm/detail/setup.hpp" 3
        



# 289 "/usr/local/include/glm/detail/setup.hpp" 3
                     

///////////////////////////////////////////////////////////////////////////////////
// Has of C++ features

// http://clang.llvm.org/cxx_status.html
// http://gcc.gnu.org/projects/cxx0x.html
// http://msdn.microsoft.com/en-us/library/vstudio/hh567368(v=vs.120).aspx

// Android has multiple STLs but C++11 STL detection doesn't always work #284 #564


                                        


       







       

// N1720









       

// N1988


      




                                                                             


// N2235











       

// N2672









       

// N2544 Unrestricted unions http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf









       

// N2346


                                        









       

// N2118









       

// N2437 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf










       

// N2258 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf










       

// N2930 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html










       

// N2341 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2341.pdf










       




       

//


      


                                                                                


//


//


      


                                                                                  




      


                                                                                                               


// OpenMP

# 527 "/usr/local/include/glm/detail/setup.hpp" 3
       

///////////////////////////////////////////////////////////////////////////////////
// Static assert







      




///////////////////////////////////////////////////////////////////////////////////
// Qualifiers




      






      




# 574 "/usr/local/include/glm/detail/setup.hpp" 3
      







///////////////////////////////////////////////////////////////////////////////////
// Swizzle operators

// User defines: GLM_FORCE_SWIZZLE



       







      











                     

///////////////////////////////////////////////////////////////////////////////////
// Allows using not basic types as genType

// #define GLM_FORCE_UNRESTRICTED_GENTYPE



      








                     

///////////////////////////////////////////////////////////////////////////////////
// Clip control



       






      










                     

///////////////////////////////////////////////////////////////////////////////////
// Coordinate system, define GLM_FORCE_LEFT_HANDED before including GLM
// to use left handed coordinate system by default.



       






      










                     

///////////////////////////////////////////////////////////////////////////////////
// Qualifiers


# 695 "/usr/local/include/glm/detail/setup.hpp" 3
                                                                                  









        




        

# 727 "/usr/local/include/glm/detail/setup.hpp" 3
                     








      











      






      





      





      



///////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////
// Length type

// User defines: GLM_FORCE_SIZE_T_LENGTH GLM_FORCE_SIZE_FUNC

namespace glm
{
	using std::size_t;


       
		typedef int length_t;

}//namespace glm








                     

///////////////////////////////////////////////////////////////////////////////////
// countof



       


# 818 "/usr/local/include/glm/detail/setup.hpp" 3
      



///////////////////////////////////////////////////////////////////////////////////
// Uninitialize constructors

namespace glm
{
	enum ctor{uninitialize};
}//namespace glm

# 6 "/usr/local/include/glm/detail/type_int.hpp" 2 3



       



       

namespace glm{
namespace detail
{

# 28 "/usr/local/include/glm/detail/type_int.hpp" 3
       

# 42 "/usr/local/include/glm/detail/type_int.hpp" 3
                                            

# 43 "/usr/local/include/glm/detail/type_int.hpp" 3
#pragma clang diagnostic ignored "-Wc++11-long-long"
# 43 "/usr/local/include/glm/detail/type_int.hpp" 3

			typedef __signed long	long		sint64;
			typedef unsigned long long		uint64;
	



                       
		
		typedef __signed char					int8;
		typedef __signed short				int16;
		typedef __signed int					int32;
		typedef sint64						int64;
	
		typedef unsigned char				uint8;
		typedef unsigned short				uint16;
		typedef unsigned int				uint32;
		typedef uint64						uint64;

	
	typedef __signed int						lowp_int_t;
	typedef __signed int						mediump_int_t;
	typedef __signed int						highp_int_t;
	
	typedef unsigned int					lowp_uint_t;
	typedef unsigned int					mediump_uint_t;
	typedef unsigned int					highp_uint_t;





                            
		template <typename genType>
		struct make_signed
		{};

		template <>
		struct make_signed<char>
		{
			typedef char type;
		};

		template <>
		struct make_signed<short>
		{
			typedef short type;
		};

		template <>
		struct make_signed<int>
		{
			typedef int type;
		};

		template <>
		struct make_signed<long>
		{
			typedef long type;
		};
	
		template <>
		struct make_signed<unsigned char>
		{
			typedef char type;
		};

		template <>
		struct make_signed<unsigned short>
		{
			typedef short type;
		};

		template <>
		struct make_signed<unsigned int>
		{
			typedef int type;
		};

		template <>
		struct make_signed<unsigned long>
		{
			typedef long type;
		};

		template <typename genType>
		struct make_unsigned
		{};

		template <>
		struct make_unsigned<char>
		{
			typedef unsigned char type;
		};

		template <>
		struct make_unsigned<short>
		{
			typedef unsigned short type;
		};

		template <>
		struct make_unsigned<int>
		{
			typedef unsigned int type;
		};

		template <>
		struct make_unsigned<long>
		{
			typedef unsigned long type;
		};

		template <>
		struct make_unsigned<unsigned char>
		{
			typedef unsigned char type;
		};

		template <>
		struct make_unsigned<unsigned short>
		{
			typedef unsigned short type;
		};

		template <>
		struct make_unsigned<unsigned int>
		{
			typedef unsigned int type;
		};

		template <>
		struct make_unsigned<unsigned long>
		{
			typedef unsigned long type;
		};

		template <>
		struct make_signed<long long>
		{
			typedef long long type;
		};
	
		template <>
		struct make_signed<unsigned long long>
		{
			typedef long long type;
		};
	
		template <>
		struct make_unsigned<long long>
		{
			typedef unsigned long long type;
		};
	
		template <>
		struct make_unsigned<unsigned long long>
		{
			typedef unsigned long long type;
		};

}//namespace detail

	typedef detail::int8					int8;
	typedef detail::int16					int16;
	typedef detail::int32					int32;
	typedef detail::int64					int64;
	
	typedef detail::uint8					uint8;
	typedef detail::uint16					uint16;
	typedef detail::uint32					uint32;
	typedef detail::uint64					uint64;

	/// @addtogroup core_precision
	/// @{

	/// Low precision __signed integer. 
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef detail::lowp_int_t				lowp_int;

	/// Medium precision __signed integer. 
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef detail::mediump_int_t			mediump_int;

	/// High precision __signed integer.
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef detail::highp_int_t				highp_int;

	/// Low precision unsigned integer. 
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef detail::lowp_uint_t				lowp_uint;

	/// Medium precision unsigned integer. 
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef detail::mediump_uint_t			mediump_uint;

	/// High precision unsigned integer. 
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef detail::highp_uint_t			highp_uint;


	typedef mediump_int					int_t;








       


	typedef mediump_uint				uint_t;








       

	/// Unsigned integer type.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.3 Integers</a>
	typedef unsigned int				uint;

	/// @}

////////////////////
// check type sizes

# 304 "/usr/local/include/glm/detail/type_int.hpp" 3
                               

}//namespace glm

# 6 "/usr/local/include/glm/fwd.hpp" 2 3


# 1 "/usr/local/include/glm/detail/type_float.hpp" 1 3
/// @ref core
/// @file glm/detail/type_float.hpp





namespace glm{
namespace detail
{
	typedef float				float32;
	typedef double				float64;
}//namespace detail
	
	typedef float				lowp_float_t;
	typedef float				mediump_float_t;
	typedef double				highp_float_t;

	/// @addtogroup core_precision
	/// @{

	/// Low precision floating-point numbers. 
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.4 Floats</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef lowp_float_t		lowp_float;

	/// Medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.4 Floats</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef mediump_float_t		mediump_float;

	/// High precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	/// 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.4 Floats</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef highp_float_t		highp_float;


	typedef mediump_float		float_t;








       

	typedef float				float32;
	typedef double				float64;

////////////////////
// check type sizes



                               

	/// @}

}//namespace glm

# 7 "/usr/local/include/glm/fwd.hpp" 2 3


# 1 "/usr/local/include/glm/detail/type_vec.hpp" 1 3
/// @ref core
/// @file glm/detail/type_vec.hpp




# 1 "/usr/local/include/glm/detail/precision.hpp" 1 3
/// @ref core
/// @file glm/detail/precision.hpp





namespace glm
{
	enum precision
	{
		packed_highp,
		packed_mediump,
		packed_lowp,






         

		highp = packed_highp,
		mediump = packed_mediump,
		lowp = packed_lowp,
		packed = packed_highp,



        
			defaultp = highp

	};
	
namespace detail
{
	template <glm::precision P>
	struct is_aligned
	{
		static __const bool value = false;
	};


# 61 "/usr/local/include/glm/detail/precision.hpp" 3
        
}//namespace detail
}//namespace glm

# 6 "/usr/local/include/glm/detail/type_vec.hpp" 2 3



namespace glm{
namespace detail
{
	template <typename T, std::size_t size, bool aligned>
	struct storage
	{
		typedef struct type {
			uint8 data[size];
		} type;
	};

	





     

	template <typename T> struct storage<T, 1, true> { struct __attribute__((aligned(1))) type { uint8 data[1]; }; };
	template <typename T> struct storage<T, 2, true> { struct __attribute__((aligned(2))) type { uint8 data[2]; }; };
	template <typename T> struct storage<T, 4, true> { struct __attribute__((aligned(4))) type { uint8 data[4]; }; };
	template <typename T> struct storage<T, 8, true> { struct __attribute__((aligned(8))) type { uint8 data[8]; }; };
	template <typename T> struct storage<T, 16, true> { struct __attribute__((aligned(16))) type { uint8 data[16]; }; };
	template <typename T> struct storage<T, 32, true> { struct __attribute__((aligned(32))) type { uint8 data[32]; }; };
	template <typename T> struct storage<T, 64, true> { struct __attribute__((aligned(64))) type { uint8 data[64]; }; };
		

		template <>
		struct storage<float, 16, true>
		{
			typedef glm_vec4 type;
		};

		template <>
		struct storage<int, 16, true>
		{
			typedef glm_ivec4 type;
		};

		template <>
		struct storage<unsigned int, 16, true>
		{
			typedef glm_uvec4 type;
		};

# 78 "/usr/local/include/glm/detail/type_vec.hpp" 3









        


# 101 "/usr/local/include/glm/detail/type_vec.hpp" 3
        
}//namespace detail

	template <typename T, precision P> struct tvec1;
	template <typename T, precision P> struct tvec2;
	template <typename T, precision P> struct tvec3;
	template <typename T, precision P> struct tvec4;

	typedef tvec1<float, highp>		highp_vec1_t;
	typedef tvec1<float, mediump>	mediump_vec1_t;
	typedef tvec1<float, lowp>		lowp_vec1_t;
	typedef tvec1<double, highp>	highp_dvec1_t;
	typedef tvec1<double, mediump>	mediump_dvec1_t;
	typedef tvec1<double, lowp>		lowp_dvec1_t;
	typedef tvec1<int, highp>		highp_ivec1_t;
	typedef tvec1<int, mediump>		mediump_ivec1_t;
	typedef tvec1<int, lowp>		lowp_ivec1_t;
	typedef tvec1<uint, highp>		highp_uvec1_t;
	typedef tvec1<uint, mediump>	mediump_uvec1_t;
	typedef tvec1<uint, lowp>		lowp_uvec1_t;
	typedef tvec1<bool, highp>		highp_bvec1_t;
	typedef tvec1<bool, mediump>	mediump_bvec1_t;
	typedef tvec1<bool, lowp>		lowp_bvec1_t;

	/// @addtogroup core_precision
	/// @{

	/// 2 components vector of high single-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<float, highp>		highp_vec2;

	/// 2 components vector of medium single-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<float, mediump>	mediump_vec2;

	/// 2 components vector of low single-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<float, lowp>		lowp_vec2;

	/// 2 components vector of high double-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<double, highp>	highp_dvec2;

	/// 2 components vector of medium double-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<double, mediump>	mediump_dvec2;

	/// 2 components vector of low double-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<double, lowp>		lowp_dvec2;

	/// 2 components vector of high precision __signed integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<int, highp>		highp_ivec2;

	/// 2 components vector of medium precision __signed integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<int, mediump>		mediump_ivec2;

	/// 2 components vector of low precision __signed integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<int, lowp>		lowp_ivec2;

	/// 2 components vector of high precision unsigned integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<uint, highp>		highp_uvec2;

	/// 2 components vector of medium precision unsigned integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<uint, mediump>	mediump_uvec2;

	/// 2 components vector of low precision unsigned integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<uint, lowp>		lowp_uvec2;

	/// 2 components vector of high precision bool numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<bool, highp>		highp_bvec2;

	/// 2 components vector of medium precision bool numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<bool, mediump>	mediump_bvec2;

	/// 2 components vector of low precision bool numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec2<bool, lowp>		lowp_bvec2;

	/// @}

	/// @addtogroup core_precision
	/// @{

	/// 3 components vector of high single-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<float, highp>		highp_vec3;

	/// 3 components vector of medium single-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<float, mediump>	mediump_vec3;

	/// 3 components vector of low single-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<float, lowp>		lowp_vec3;

	/// 3 components vector of high double-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<double, highp>	highp_dvec3;

	/// 3 components vector of medium double-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<double, mediump>	mediump_dvec3;

	/// 3 components vector of low double-precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<double, lowp>		lowp_dvec3;

	/// 3 components vector of high precision __signed integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<int, highp>		highp_ivec3;

	/// 3 components vector of medium precision __signed integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<int, mediump>		mediump_ivec3;

	/// 3 components vector of low precision __signed integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<int, lowp>		lowp_ivec3;

	/// 3 components vector of high precision unsigned integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<uint, highp>		highp_uvec3;

	/// 3 components vector of medium precision unsigned integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<uint, mediump>	mediump_uvec3;

	/// 3 components vector of low precision unsigned integer numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<uint, lowp>		lowp_uvec3;

	/// 3 components vector of high precision bool numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<bool, highp>		highp_bvec3;

	/// 3 components vector of medium precision bool numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<bool, mediump>	mediump_bvec3;

	/// 3 components vector of low precision bool numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec3<bool, lowp>		lowp_bvec3;

	/// @}

	/// @addtogroup core_precision
	/// @{

	/// 4 components vector of high single-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<float, highp>		highp_vec4;

	/// 4 components vector of medium single-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<float, mediump>	mediump_vec4;

	/// 4 components vector of low single-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<float, lowp>		lowp_vec4;

	/// 4 components vector of high double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<double, highp>	highp_dvec4;

	/// 4 components vector of medium double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<double, mediump>	mediump_dvec4;

	/// 4 components vector of low double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<double, lowp>		lowp_dvec4;

	/// 4 components vector of high precision __signed integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<int, highp>		highp_ivec4;

	/// 4 components vector of medium precision __signed integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<int, mediump>		mediump_ivec4;

	/// 4 components vector of low precision __signed integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<int, lowp>		lowp_ivec4;

	/// 4 components vector of high precision unsigned integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<uint, highp>		highp_uvec4;

	/// 4 components vector of medium precision unsigned integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<uint, mediump>	mediump_uvec4;

	/// 4 components vector of low precision unsigned integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<uint, lowp>		lowp_uvec4;

	/// 4 components vector of high precision bool numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<bool, highp>		highp_bvec4;

	/// 4 components vector of medium precision bool numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<bool, mediump>	mediump_bvec4;

	/// 4 components vector of low precision bool numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tvec4<bool, lowp>		lowp_bvec4;

	/// @}

	/// @addtogroup core_types
	/// @{

	// -- Default float definition --









                                           
	/// 2 components vector of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_vec2			vec2;

	//! 3 components vector of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_vec3			vec3;

	//! 4 components vector of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_vec4			vec4;


	// -- Default double definition --









                                            
	/// 2 components vector of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_dvec2			dvec2;

	//! 3 components vector of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_dvec3			dvec3;

	//! 4 components vector of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_dvec4			dvec4;


	// -- Signed integer definition --









                                         
	/// 2 components vector of __signed integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_ivec2			ivec2;

	/// 3 components vector of __signed integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_ivec3			ivec3;

	/// 4 components vector of __signed integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_ivec4			ivec4;


	// -- Unsigned integer definition --









                                          
	/// 2 components vector of unsigned integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_uvec2			uvec2;

	/// 3 components vector of unsigned integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_uvec3			uvec3;

	/// 4 components vector of unsigned integer numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_uvec4			uvec4;


	// -- Boolean definition --









                                          
	/// 2 components vector of boolean.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_bvec2			bvec2;

	/// 3 components vector of boolean.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_bvec3			bvec3;

	/// 4 components vector of boolean.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>
	typedef highp_bvec4			bvec4;


	/// @}
}//namespace glm

# 8 "/usr/local/include/glm/fwd.hpp" 2 3


# 1 "/usr/local/include/glm/detail/type_mat.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat.hpp





namespace glm{
namespace detail
{
	template <typename T, precision P, template <class, precision> class colType, template <class, precision> class rowType>
	struct outerProduct_trait{};
}//namespace detail

	template <typename T, precision P> struct tvec2;
	template <typename T, precision P> struct tvec3;
	template <typename T, precision P> struct tvec4;
	template <typename T, precision P> struct tmat2x2;
	template <typename T, precision P> struct tmat2x3;
	template <typename T, precision P> struct tmat2x4;
	template <typename T, precision P> struct tmat3x2;
	template <typename T, precision P> struct tmat3x3;
	template <typename T, precision P> struct tmat3x4;
	template <typename T, precision P> struct tmat4x2;
	template <typename T, precision P> struct tmat4x3;
	template <typename T, precision P> struct tmat4x4;

	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> inverse(matType<T, P> __const & m);

	/// @addtogroup core_precision
	/// @{
	
	/// 2 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, lowp>		lowp_mat2;
	
	/// 2 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, mediump>		mediump_mat2;
	
	/// 2 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, highp>		highp_mat2;
	
	/// 2 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, lowp>		lowp_mat2x2;
	
	/// 2 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, mediump>		mediump_mat2x2;
	
	/// 2 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, highp>		highp_mat2x2;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 2 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<float, lowp>		lowp_mat2x3;
	
	/// 2 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<float, mediump>		mediump_mat2x3;
	
	/// 2 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<float, highp>		highp_mat2x3;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 2 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<float, lowp>		lowp_mat2x4;
	
	/// 2 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<float, mediump>		mediump_mat2x4;
	
	/// 2 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<float, highp>		highp_mat2x4;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 3 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<float, lowp>		lowp_mat3x2;
	
	/// 3 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<float, mediump>		mediump_mat3x2;
	
	/// 3 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<float, highp>		highp_mat3x2;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 3 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, lowp>		lowp_mat3;
	
	/// 3 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, mediump>		mediump_mat3;
	
	/// 3 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, highp>		highp_mat3;
	
	/// 3 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, lowp>		lowp_mat3x3;
	
	/// 3 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, mediump>		mediump_mat3x3;
	
	/// 3 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, highp>		highp_mat3x3;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 3 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<float, lowp>		lowp_mat3x4;
	
	/// 3 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<float, mediump>		mediump_mat3x4;
	
	/// 3 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<float, highp>		highp_mat3x4;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 4 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<float, lowp>		lowp_mat4x2;
	
	/// 4 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<float, mediump>		mediump_mat4x2;
	
	/// 4 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<float, highp>		highp_mat4x2;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 4 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<float, lowp>		lowp_mat4x3;
	
	/// 4 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<float, mediump>		mediump_mat4x3;
	
	/// 4 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<float, highp>		highp_mat4x3;
	
	/// @}
	
	
	/// @addtogroup core_precision
	/// @{
	
	/// 4 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, lowp>		lowp_mat4;
	
	/// 4 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, mediump>		mediump_mat4;
	
	/// 4 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, highp>		highp_mat4;
	
	/// 4 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, lowp>		lowp_mat4x4;
	
	/// 4 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, mediump>		mediump_mat4x4;
	
	/// 4 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, highp>		highp_mat4x4;
	
	/// @}
	
	/// @addtogroup core_types
	/// @{
	
	//////////////////////////
	// Float definition
	

# 355 "/usr/local/include/glm/detail/type_mat.hpp" 3
       
	//! 2 columns of 2 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat2x2			mat2x2;
	
	//! 2 columns of 3 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat2x3			mat2x3;
	
	//! 2 columns of 4 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat2x4			mat2x4;
	
	//! 3 columns of 2 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat3x2			mat3x2;
	
	//! 3 columns of 3 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat3x3			mat3x3;
	
	//! 3 columns of 4 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat3x4			mat3x4;
	
	//! 4 columns of 2 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat4x2			mat4x2;
	
	//! 4 columns of 3 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat4x3			mat4x3;
	
	//! 4 columns of 4 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_mat4x4			mat4x4;
	

	
	//! 2 columns of 2 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef mat2x2					mat2;
	
	//! 3 columns of 3 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef mat3x3					mat3;
	
	//! 4 columns of 4 components matrix of floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef mat4x4					mat4;
		
	//////////////////////////
	// Double definition
	
	/// @addtogroup core_precision
	/// @{
	
	/// 2 columns of 2 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<double, lowp>		lowp_dmat2;
	
	/// 2 columns of 2 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<double, mediump>	mediump_dmat2;
	
	/// 2 columns of 2 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<double, highp>		highp_dmat2;
	
	/// 2 columns of 2 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<double, lowp>		lowp_dmat2x2;
	
	/// 2 columns of 2 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<double, mediump>	mediump_dmat2x2;
	
	/// 2 columns of 2 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<double, highp>		highp_dmat2x2;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 2 columns of 3 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<double, lowp>		lowp_dmat2x3;
	
	/// 2 columns of 3 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<double, mediump>	mediump_dmat2x3;
	
	/// 2 columns of 3 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<double, highp>		highp_dmat2x3;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 2 columns of 4 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<double, lowp>		lowp_dmat2x4;
	
	/// 2 columns of 4 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<double, mediump>	mediump_dmat2x4;
	
	/// 2 columns of 4 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<double, highp>		highp_dmat2x4;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 3 columns of 2 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<double, lowp>		lowp_dmat3x2;
	
	/// 3 columns of 2 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<double, mediump>	mediump_dmat3x2;
	
	/// 3 columns of 2 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<double, highp>		highp_dmat3x2;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 3 columns of 3 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, lowp>		lowp_dmat3;
	
	/// 3 columns of 3 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<double, mediump>	mediump_dmat3;
	
	/// 3 columns of 3 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<double, highp>		highp_dmat3;
	
	/// 3 columns of 3 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<double, lowp>		lowp_dmat3x3;
	
	/// 3 columns of 3 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<double, mediump>	mediump_dmat3x3;
	
	/// 3 columns of 3 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<double, highp>		highp_dmat3x3;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 3 columns of 4 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<double, lowp>		lowp_dmat3x4;
	
	/// 3 columns of 4 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<double, mediump>	mediump_dmat3x4;
	
	/// 3 columns of 4 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<double, highp>		highp_dmat3x4;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 4 columns of 2 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<double, lowp>		lowp_dmat4x2;
	
	/// 4 columns of 2 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<double, mediump>	mediump_dmat4x2;
	
	/// 4 columns of 2 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<double, highp>		highp_dmat4x2;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 4 columns of 3 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<double, lowp>		lowp_dmat4x3;
	
	/// 4 columns of 3 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<double, mediump>	mediump_dmat4x3;
	
	/// 4 columns of 3 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<double, highp>		highp_dmat4x3;
	
	/// @}
	
	/// @addtogroup core_precision
	/// @{
	
	/// 4 columns of 4 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<double, lowp>		lowp_dmat4;
	
	/// 4 columns of 4 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<double, mediump>	mediump_dmat4;
	
	/// 4 columns of 4 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<double, highp>		highp_dmat4;
	
	/// 4 columns of 4 components matrix of low precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<double, lowp>		lowp_dmat4x4;
	
	/// 4 columns of 4 components matrix of medium precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<double, mediump>	mediump_dmat4x4;
	
	/// 4 columns of 4 components matrix of high precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<double, highp>		highp_dmat4x4;
	
	/// @}
	

# 702 "/usr/local/include/glm/detail/type_mat.hpp" 3
                                            
	
	//! 2 * 2 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat2x2		dmat2;
	
	//! 3 * 3 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat3x3		dmat3;
	
	//! 4 * 4 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat4x4		dmat4;
	
	//! 2 * 2 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat2x2		dmat2x2;
	
	//! 2 * 3 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat2x3		dmat2x3;
	
	//! 2 * 4 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat2x4		dmat2x4;
	
	//! 3 * 2 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat3x2		dmat3x2;
	
	/// 3 * 3 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat3x3		dmat3x3;
	
	/// 3 * 4 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat3x4		dmat3x4;
	
	/// 4 * 2 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat4x2		dmat4x2;
	
	/// 4 * 3 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat4x3		dmat4x3;
	
	/// 4 * 4 matrix of double-precision floating-point numbers.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	typedef highp_dmat4x4		dmat4x4;


	
	/// @}
}//namespace glm

# 9 "/usr/local/include/glm/fwd.hpp" 2 3


//////////////////////
// GLM_GTC_quaternion
namespace glm
{
	template <typename T, precision P> struct tquat;

	/// Quaternion of low single-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef tquat<float, lowp>		lowp_quat;

	/// Quaternion of medium single-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef tquat<float, mediump>	mediump_quat;

	/// Quaternion of high single-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef tquat<float, highp>		highp_quat;







                                                                                                                          
	/// Quaternion of default single-precision floating-point numbers.
	typedef highp_quat			quat;


	/// Quaternion of low single-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef lowp_quat			lowp_fquat;

	/// Quaternion of medium single-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef mediump_quat		mediump_fquat;

	/// Quaternion of high single-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef highp_quat			highp_fquat;

	/// Quaternion of default single-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef quat				fquat;


	/// Quaternion of low double-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef tquat<double, lowp>		lowp_dquat;
	
	/// Quaternion of medium double-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef tquat<double, mediump>	mediump_dquat;
	
	/// Quaternion of high double-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef tquat<double, highp>	highp_dquat;
	






                                                                                                                             
	/// Quaternion of default double-precision floating-point numbers.
	///
	/// @see gtc_quaternion
	typedef highp_dquat			dquat;


}//namespace glm

//////////////////////
// GLM_GTC_precision
namespace glm
{
	/// Low precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 lowp_int8;
	
	/// Low precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 lowp_int16;

	/// Low precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 lowp_int32;

	/// Low precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 lowp_int64;

	/// Low precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 lowp_int8_t;
	
	/// Low precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 lowp_int16_t;

	/// Low precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 lowp_int32_t;

	/// Low precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 lowp_int64_t;

	/// Low precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 lowp_i8;
	
	/// Low precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 lowp_i16;

	/// Low precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 lowp_i32;

	/// Low precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 lowp_i64;

	/// Medium precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 mediump_int8;
	
	/// Medium precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 mediump_int16;

	/// Medium precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 mediump_int32;

	/// Medium precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 mediump_int64;

	/// Medium precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 mediump_int8_t;
	
	/// Medium precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 mediump_int16_t;

	/// Medium precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 mediump_int32_t;

	/// Medium precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 mediump_int64_t;

	/// Medium precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 mediump_i8;
	
	/// Medium precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 mediump_i16;

	/// Medium precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 mediump_i32;

	/// Medium precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 mediump_i64;

	/// High precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 highp_int8;
	
	/// High precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 highp_int16;

	/// High precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 highp_int32;

	/// High precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 highp_int64;

	/// High precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 highp_int8_t;
	
	/// High precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 highp_int16_t;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 highp_int32_t;

	/// High precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 highp_int64_t;

	/// High precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 highp_i8;
	
	/// High precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 highp_i16;

	/// High precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 highp_i32;

	/// High precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 highp_i64;
	

	/// 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 int8;
	
	/// 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 int16;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 int32;

	/// 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 int64;







      
	/// 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 int8_t;
	
	/// 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 int16_t;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 int32_t;

	/// 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 int64_t;


	/// 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 i8;
	
	/// 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 i16;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 i32;

	/// 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 i64;
	
	
	
	/// Low precision 8 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i8, lowp> lowp_i8vec1;
	
	/// Low precision 8 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i8, lowp> lowp_i8vec2;
	
	/// Low precision 8 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i8, lowp> lowp_i8vec3;
	
	/// Low precision 8 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i8, lowp> lowp_i8vec4;
	

	/// Medium precision 8 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i8, mediump> mediump_i8vec1;
	
	/// Medium precision 8 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i8, mediump> mediump_i8vec2;
	
	/// Medium precision 8 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i8, mediump> mediump_i8vec3;
	
	/// Medium precision 8 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i8, mediump> mediump_i8vec4;
	
	
	/// High precision 8 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i8, highp> highp_i8vec1;
	
	/// High precision 8 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i8, highp> highp_i8vec2;
	
	/// High precision 8 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i8, highp> highp_i8vec3;
	
	/// High precision 8 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i8, highp> highp_i8vec4;
	

# 361 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 8 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef highp_i8vec1			i8vec1;
	
	/// Default precision 8 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_i8vec2			i8vec2;
	
	/// Default precision 8 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_i8vec3			i8vec3;
	
	/// Default precision 8 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_i8vec4			i8vec4;

	
	
	/// Low precision 16 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i16, lowp>		lowp_i16vec1;
	
	/// Low precision 16 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i16, lowp>		lowp_i16vec2;
	
	/// Low precision 16 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i16, lowp>		lowp_i16vec3;
	
	/// Low precision 16 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i16, lowp>		lowp_i16vec4;
	
	
	/// Medium precision 16 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i16, mediump>		mediump_i16vec1;
	
	/// Medium precision 16 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i16, mediump>		mediump_i16vec2;
	
	/// Medium precision 16 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i16, mediump>		mediump_i16vec3;
	
	/// Medium precision 16 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i16, mediump>		mediump_i16vec4;
	
	
	/// High precision 16 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i16, highp>		highp_i16vec1;
	
	/// High precision 16 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i16, highp>		highp_i16vec2;
	
	/// High precision 16 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i16, highp>		highp_i16vec3;
	
	/// High precision 16 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i16, highp>		highp_i16vec4;
	
	

# 441 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 16 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef highp_i16vec1			i16vec1;
	
	/// Default precision 16 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_i16vec2			i16vec2;
	
	/// Default precision 16 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_i16vec3			i16vec3;
	
	/// Default precision 16 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_i16vec4			i16vec4;



	/// Low precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i32, lowp>		lowp_i32vec1;
	
	/// Low precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i32, lowp>		lowp_i32vec2;
	
	/// Low precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i32, lowp>		lowp_i32vec3;
	
	/// Low precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i32, lowp>		lowp_i32vec4;
	
	
	/// Medium precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i32, mediump>		mediump_i32vec1;
	
	/// Medium precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i32, mediump>		mediump_i32vec2;
	
	/// Medium precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i32, mediump>		mediump_i32vec3;
	
	/// Medium precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i32, mediump>		mediump_i32vec4;
	
	
	/// High precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i32, highp>		highp_i32vec1;
	
	/// High precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i32, highp>		highp_i32vec2;
	
	/// High precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i32, highp>		highp_i32vec3;
	
	/// High precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i32, highp>		highp_i32vec4;
	

# 520 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef highp_i32vec1			i32vec1;
	
	/// Default precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_i32vec2			i32vec2;
	
	/// Default precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_i32vec3			i32vec3;
	
	/// Default precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_i32vec4			i32vec4;



	/// Low precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i32, lowp>		lowp_i32vec1;
	
	/// Low precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i32, lowp>		lowp_i32vec2;
	
	/// Low precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i32, lowp>		lowp_i32vec3;
	
	/// Low precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i32, lowp>		lowp_i32vec4;
	
	
	/// Medium precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i32, mediump>		mediump_i32vec1;
	
	/// Medium precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i32, mediump>		mediump_i32vec2;
	
	/// Medium precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i32, mediump>		mediump_i32vec3;
	
	/// Medium precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i32, mediump>		mediump_i32vec4;
	
	
	/// High precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i32, highp>		highp_i32vec1;
	
	/// High precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i32, highp>		highp_i32vec2;
	
	/// High precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i32, highp>		highp_i32vec3;
	
	/// High precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i32, highp>		highp_i32vec4;
	

# 599 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef highp_i32vec1			i32vec1;

	/// Default precision 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_i32vec2			i32vec2;
	
	/// Default precision 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_i32vec3			i32vec3;
	
	/// Default precision 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_i32vec4			i32vec4;



	
	/// Low precision 64 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i64, lowp>		lowp_i64vec1;
	
	/// Low precision 64 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i64, lowp>		lowp_i64vec2;
	
	/// Low precision 64 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i64, lowp>		lowp_i64vec3;
	
	/// Low precision 64 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i64, lowp>		lowp_i64vec4;
	
	
	/// Medium precision 64 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i64, mediump>		mediump_i64vec1;
	
	/// Medium precision 64 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i64, mediump>		mediump_i64vec2;
	
	/// Medium precision 64 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i64, mediump>		mediump_i64vec3;
	
	/// Medium precision 64 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i64, mediump>		mediump_i64vec4;
	
	
	/// High precision 64 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i64, highp>		highp_i64vec1;
	
	/// High precision 64 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i64, highp>		highp_i64vec2;
	
	/// High precision 64 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i64, highp>		highp_i64vec3;
	
	/// High precision 64 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i64, highp>		highp_i64vec4;
	

# 679 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 64 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef highp_i64vec1			i64vec1;

	/// Default precision 64 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_i64vec2			i64vec2;
	
	/// Default precision 64 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_i64vec3			i64vec3;
	
	/// Default precision 64 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_i64vec4			i64vec4;

	
	
	/////////////////////////////
	// Unsigned int vector types
	
	/// Low precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 lowp_uint8;
	
	/// Low precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 lowp_uint16;
	
	/// Low precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 lowp_uint32;
	
	/// Low precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 lowp_uint64;
	
	
	/// Low precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 lowp_uint8_t;
	
	/// Low precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 lowp_uint16_t;
	
	/// Low precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 lowp_uint32_t;
	
	/// Low precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 lowp_uint64_t;
	
	
	/// Low precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 lowp_u8;
	
	/// Low precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 lowp_u16;
	
	/// Low precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 lowp_u32;
	
	/// Low precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 lowp_u64;
	
	
	
	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 mediump_uint8;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 mediump_uint16;
	
	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 mediump_uint32;
	
	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 mediump_uint64;
	
	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 mediump_uint8_t;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 mediump_uint16_t;
	
	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 mediump_uint32_t;
	
	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 mediump_uint64_t;
	
	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 mediump_u8;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 mediump_u16;
	
	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 mediump_u32;
	
	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 mediump_u64;
		
	
	
	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 highp_uint8;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 highp_uint16;
	
	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 highp_uint32;
	
	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 highp_uint64;
	
	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 highp_uint8_t;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 highp_uint16_t;
	
	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 highp_uint32_t;
	
	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 highp_uint64_t;
	
	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 highp_u8;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 highp_u16;
	
	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 highp_u32;
	
	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 highp_u64;
	
	
	
	/// 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 uint8;
	
	/// 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 uint16;
	
	/// 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 uint32;
	
	/// 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 uint64;
	





      
	/// 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 uint8_t;
	
	/// 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 uint16_t;
	
	/// 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 uint32_t;
	
	/// 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 uint64_t;


	/// 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 u8;

	/// 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 u16;

	/// 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 u32;

	/// 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 u64;



	/// Low precision 8 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u8, lowp> lowp_u8vec1;
	
	/// Low precision 8 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u8, lowp> lowp_u8vec2;
	
	/// Low precision 8 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u8, lowp> lowp_u8vec3;
	
	/// Low precision 8 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u8, lowp> lowp_u8vec4;
	

	/// Medium precision 8 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u8, mediump> mediump_u8vec1;

	/// Medium precision 8 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u8, mediump> mediump_u8vec2;

	/// Medium precision 8 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u8, mediump> mediump_u8vec3;

	/// Medium precision 8 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u8, mediump> mediump_u8vec4;


	/// High precision 8 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u8, highp> highp_u8vec1;

	/// High precision 8 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u8, highp> highp_u8vec2;

	/// High precision 8 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u8, highp> highp_u8vec3;

	/// High precision 8 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u8, highp> highp_u8vec4;


# 970 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 8 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef highp_u8vec1			u8vec1;

	/// Default precision 8 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_u8vec2			u8vec2;

	/// Default precision 8 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_u8vec3			u8vec3;

	/// Default precision 8 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_u8vec4			u8vec4;



	/// Low precision 16 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u16, lowp>		lowp_u16vec1;

	/// Low precision 16 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u16, lowp>		lowp_u16vec2;

	/// Low precision 16 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u16, lowp>		lowp_u16vec3;

	/// Low precision 16 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u16, lowp>		lowp_u16vec4;


	/// Medium precision 16 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u16, mediump>		mediump_u16vec1;

	/// Medium precision 16 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u16, mediump>		mediump_u16vec2;

	/// Medium precision 16 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u16, mediump>		mediump_u16vec3;

	/// Medium precision 16 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u16, mediump>		mediump_u16vec4;


	/// High precision 16 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u16, highp>		highp_u16vec1;

	/// High precision 16 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u16, highp>		highp_u16vec2;

	/// High precision 16 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u16, highp>		highp_u16vec3;

	/// High precision 16 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u16, highp>		highp_u16vec4;



# 1050 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 16 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef highp_u16vec1			u16vec1;

	/// Default precision 16 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_u16vec2			u16vec2;

	/// Default precision 16 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_u16vec3			u16vec3;

	/// Default precision 16 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_u16vec4			u16vec4;



	/// Low precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u32, lowp>		lowp_u32vec1;

	/// Low precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u32, lowp>		lowp_u32vec2;

	/// Low precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u32, lowp>		lowp_u32vec3;

	/// Low precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u32, lowp>		lowp_u32vec4;


	/// Medium precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u32, mediump>		mediump_u32vec1;

	/// Medium precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u32, mediump>		mediump_u32vec2;

	/// Medium precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u32, mediump>		mediump_u32vec3;

	/// Medium precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u32, mediump>		mediump_u32vec4;


	/// High precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u32, highp>		highp_u32vec1;

	/// High precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u32, highp>		highp_u32vec2;

	/// High precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u32, highp>		highp_u32vec3;

	/// High precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u32, highp>		highp_u32vec4;


# 1129 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef highp_u32vec1			u32vec1;

	/// Default precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_u32vec2			u32vec2;

	/// Default precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_u32vec3			u32vec3;

	/// Default precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_u32vec4			u32vec4;



	/// Low precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u32, lowp>		lowp_u32vec1;

	/// Low precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u32, lowp>		lowp_u32vec2;

	/// Low precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u32, lowp>		lowp_u32vec3;

	/// Low precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u32, lowp>		lowp_u32vec4;


	/// Medium precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u32, mediump>		mediump_u32vec1;

	/// Medium precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u32, mediump>		mediump_u32vec2;

	/// Medium precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u32, mediump>		mediump_u32vec3;

	/// Medium precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u32, mediump>		mediump_u32vec4;


	/// High precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u32, highp>		highp_u32vec1;

	/// High precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u32, highp>		highp_u32vec2;

	/// High precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u32, highp>		highp_u32vec3;

	/// High precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u32, highp>		highp_u32vec4;


# 1208 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef highp_u32vec1			u32vec1;

	/// Default precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_u32vec2			u32vec2;
	
	/// Default precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_u32vec3			u32vec3;
	
	/// Default precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_u32vec4			u32vec4;



	
	/// Low precision 64 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u64, lowp>		lowp_u64vec1;

	/// Low precision 64 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u64, lowp>		lowp_u64vec2;

	/// Low precision 64 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u64, lowp>		lowp_u64vec3;

	/// Low precision 64 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u64, lowp>		lowp_u64vec4;


	/// Medium precision 64 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u64, mediump>		mediump_u64vec1;

	/// Medium precision 64 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u64, mediump>		mediump_u64vec2;

	/// Medium precision 64 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u64, mediump>		mediump_u64vec3;

	/// Medium precision 64 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u64, mediump>		mediump_u64vec4;


	/// High precision 64 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u64, highp>		highp_u64vec1;

	/// High precision 64 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u64, highp>		highp_u64vec2;

	/// High precision 64 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u64, highp>		highp_u64vec3;

	/// High precision 64 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u64, highp>		highp_u64vec4;


# 1288 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default precision 64 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef highp_u64vec1			u64vec1;

	/// Default precision 64 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef highp_u64vec2			u64vec2;
	
	/// Default precision 64 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef highp_u64vec3			u64vec3;
	
	/// Default precision 64 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef highp_u64vec4			u64vec4;

	
	
	//////////////////////
	// Float vector types

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 lowp_float32;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 lowp_float64;

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 lowp_float32_t;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 lowp_float64_t;

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float32 lowp_f32;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float64 lowp_f64;

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 lowp_float32;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 lowp_float64;

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 lowp_float32_t;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 lowp_float64_t;

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float32 lowp_f32;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float64 lowp_f64;


	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 lowp_float32;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 lowp_float64;

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 lowp_float32_t;
	
	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 lowp_float64_t;

	/// Low 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float32 lowp_f32;

	/// Low 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float64 lowp_f64;


	/// Medium 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 mediump_float32;

	/// Medium 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 mediump_float64;

	/// Medium 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 mediump_float32_t;

	/// Medium 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 mediump_float64_t;

	/// Medium 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float32 mediump_f32;

	/// Medium 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float64 mediump_f64;


	/// High 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 highp_float32;

	/// High 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 highp_float64;

	/// High 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 highp_float32_t;

	/// High 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 highp_float64_t;

	/// High 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float32 highp_f32;

	/// High 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float64 highp_f64;



# 1485 "/usr/local/include/glm/fwd.hpp" 3
                                            

	/// Default 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef highp_float32 float32;

	/// Default 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef highp_float64 float64;

	/// Default 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef highp_float32_t float32_t;

	/// Default 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef highp_float64_t float64_t;

	/// Default 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef highp_float32_t f32;

	/// Default 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef highp_float64_t f64;



	/// Low single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<float, lowp> lowp_vec1;

	/// Low single-precision floating-point vector of 2 components.
	/// @see core_precision
	typedef tvec2<float, lowp> lowp_vec2;

	/// Low single-precision floating-point vector of 3 components.
	/// @see core_precision
	typedef tvec3<float, lowp> lowp_vec3;

	/// Low single-precision floating-point vector of 4 components.
	/// @see core_precision
	typedef tvec4<float, lowp> lowp_vec4;

	/// Low single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<float, lowp> lowp_fvec1;

	/// Low single-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<float, lowp> lowp_fvec2;

	/// Low single-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<float, lowp> lowp_fvec3;

	/// Low single-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<float, lowp> lowp_fvec4;


	/// Medium single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<float, mediump> mediump_vec1;

	/// Medium Single-precision floating-point vector of 2 components.
	/// @see core_precision
	typedef tvec2<float, mediump> mediump_vec2;

	/// Medium Single-precision floating-point vector of 3 components.
	/// @see core_precision
	typedef tvec3<float, mediump> mediump_vec3;

	/// Medium Single-precision floating-point vector of 4 components.
	/// @see core_precision
	typedef tvec4<float, mediump> mediump_vec4;

	/// Medium single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<float, mediump> mediump_fvec1;

	/// Medium Single-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<float, mediump> mediump_fvec2;

	/// Medium Single-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<float, mediump> mediump_fvec3;

	/// Medium Single-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<float, mediump> mediump_fvec4;


	/// High single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<float, highp> highp_vec1;

	/// High Single-precision floating-point vector of 2 components.
	/// @see core_precision
	typedef tvec2<float, highp> highp_vec2;

	/// High Single-precision floating-point vector of 3 components.
	/// @see core_precision
	typedef tvec3<float, highp> highp_vec3;

	/// High Single-precision floating-point vector of 4 components.
	/// @see core_precision
	typedef tvec4<float, highp> highp_vec4;

	/// High single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<float, highp> highp_fvec1;

	/// High Single-precision floating-point vector of 2 components.
	/// @see core_precision
	typedef tvec2<float, highp> highp_fvec2;

	/// High Single-precision floating-point vector of 3 components.
	/// @see core_precision
	typedef tvec3<float, highp> highp_fvec3;

	/// High Single-precision floating-point vector of 4 components.
	/// @see core_precision
	typedef tvec4<float, highp> highp_fvec4;


	/// Low single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f32, lowp> lowp_f32vec1;

	/// Low single-precision floating-point vector of 2 components.
	/// @see core_precision
	typedef tvec2<f32, lowp> lowp_f32vec2;

	/// Low single-precision floating-point vector of 3 components.
	/// @see core_precision
	typedef tvec3<f32, lowp> lowp_f32vec3;

	/// Low single-precision floating-point vector of 4 components.
	/// @see core_precision
	typedef tvec4<f32, lowp> lowp_f32vec4;

	/// Medium single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f32, mediump> mediump_f32vec1;

	/// Medium single-precision floating-point vector of 2 components.
	/// @see core_precision
	typedef tvec2<f32, mediump> mediump_f32vec2;

	/// Medium single-precision floating-point vector of 3 components.
	/// @see core_precision
	typedef tvec3<f32, mediump> mediump_f32vec3;

	/// Medium single-precision floating-point vector of 4 components.
	/// @see core_precision
	typedef tvec4<f32, mediump> mediump_f32vec4;

	/// High single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f32, highp> highp_f32vec1;

	/// High single-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<f32, highp> highp_f32vec2;

	/// High single-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<f32, highp> highp_f32vec3;

	/// High single-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<f32, highp> highp_f32vec4;


	/// Low double-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f64, lowp> lowp_f64vec1;

	/// Low double-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<f64, lowp> lowp_f64vec2;

	/// Low double-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<f64, lowp> lowp_f64vec3;

	/// Low double-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<f64, lowp> lowp_f64vec4;

	/// Medium double-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f64, mediump> mediump_f64vec1;

	/// Medium double-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<f64, mediump> mediump_f64vec2;

	/// Medium double-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<f64, mediump> mediump_f64vec3;

	/// Medium double-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<f64, mediump> mediump_f64vec4;

	/// High double-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f64, highp> highp_f64vec1;

	/// High double-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<f64, highp> highp_f64vec2;

	/// High double-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<f64, highp> highp_f64vec3;

	/// High double-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<f64, highp> highp_f64vec4;


	//////////////////////
	// Float matrix types

	/// Low single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef lowp_f32 lowp_fmat1x1;

	/// Low single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, lowp> lowp_fmat2x2;

	/// Low single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, lowp> lowp_fmat2x3;

	/// Low single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, lowp> lowp_fmat2x4;

	/// Low single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, lowp> lowp_fmat3x2;

	/// Low single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, lowp> lowp_fmat3x3;

	/// Low single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, lowp> lowp_fmat3x4;

	/// Low single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, lowp> lowp_fmat4x2;

	/// Low single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, lowp> lowp_fmat4x3;

	/// Low single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, lowp> lowp_fmat4x4;

	/// Low single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef lowp_fmat1x1 lowp_fmat1;

	/// Low single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef lowp_fmat2x2 lowp_fmat2;

	/// Low single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef lowp_fmat3x3 lowp_fmat3;

	/// Low single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef lowp_fmat4x4 lowp_fmat4;


	/// Medium single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef mediump_f32 mediump_fmat1x1;

	/// Medium single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, mediump> mediump_fmat2x2;

	/// Medium single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, mediump> mediump_fmat2x3;

	/// Medium single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, mediump> mediump_fmat2x4;

	/// Medium single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, mediump> mediump_fmat3x2;

	/// Medium single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, mediump> mediump_fmat3x3;

	/// Medium single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, mediump> mediump_fmat3x4;

	/// Medium single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, mediump> mediump_fmat4x2;

	/// Medium single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, mediump> mediump_fmat4x3;

	/// Medium single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, mediump> mediump_fmat4x4;

	/// Medium single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef mediump_fmat1x1 mediump_fmat1;

	/// Medium single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef mediump_fmat2x2 mediump_fmat2;

	/// Medium single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef mediump_fmat3x3 mediump_fmat3;

	/// Medium single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef mediump_fmat4x4 mediump_fmat4;


	/// High single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef highp_f32 highp_fmat1x1;

	/// High single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, highp> highp_fmat2x2;

	/// High single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, highp> highp_fmat2x3;

	/// High single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, highp> highp_fmat2x4;

	/// High single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, highp> highp_fmat3x2;

	/// High single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, highp> highp_fmat3x3;

	/// High single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, highp> highp_fmat3x4;

	/// High single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, highp> highp_fmat4x2;

	/// High single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, highp> highp_fmat4x3;

	/// High single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, highp> highp_fmat4x4;

	/// High single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef highp_fmat1x1 highp_fmat1;

	/// High single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef highp_fmat2x2 highp_fmat2;

	/// High single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef highp_fmat3x3 highp_fmat3;
	
	/// High single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef highp_fmat4x4 highp_fmat4;


	/// Low single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f32 lowp_f32mat1x1;

	/// Low single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, lowp> lowp_f32mat2x2;

	/// Low single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, lowp> lowp_f32mat2x3;

	/// Low single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, lowp> lowp_f32mat2x4;

	/// Low single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, lowp> lowp_f32mat3x2;

	/// Low single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, lowp> lowp_f32mat3x3;

	/// Low single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, lowp> lowp_f32mat3x4;

	/// Low single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, lowp> lowp_f32mat4x2;

	/// Low single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, lowp> lowp_f32mat4x3;

	/// Low single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, lowp> lowp_f32mat4x4;

	/// Low single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef detail::tmat1x1<f32, lowp> lowp_f32mat1;

	/// Low single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef lowp_f32mat2x2 lowp_f32mat2;

	/// Low single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef lowp_f32mat3x3 lowp_f32mat3;

	/// Low single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef lowp_f32mat4x4 lowp_f32mat4;


	/// High single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f32 mediump_f32mat1x1;

	/// Low single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, mediump> mediump_f32mat2x2;

	/// Medium single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, mediump> mediump_f32mat2x3;

	/// Medium single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, mediump> mediump_f32mat2x4;

	/// Medium single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, mediump> mediump_f32mat3x2;

	/// Medium single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, mediump> mediump_f32mat3x3;

	/// Medium single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, mediump> mediump_f32mat3x4;

	/// Medium single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, mediump> mediump_f32mat4x2;

	/// Medium single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, mediump> mediump_f32mat4x3;

	/// Medium single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, mediump> mediump_f32mat4x4;

	/// Medium single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef detail::tmat1x1<f32, mediump> f32mat1;

	/// Medium single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef mediump_f32mat2x2 mediump_f32mat2;

	/// Medium single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef mediump_f32mat3x3 mediump_f32mat3;

	/// Medium single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef mediump_f32mat4x4 mediump_f32mat4;


	/// High single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f32 highp_f32mat1x1;

	/// High single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, highp> highp_f32mat2x2;

	/// High single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, highp> highp_f32mat2x3;

	/// High single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, highp> highp_f32mat2x4;

	/// High single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, highp> highp_f32mat3x2;

	/// High single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, highp> highp_f32mat3x3;

	/// High single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, highp> highp_f32mat3x4;

	/// High single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, highp> highp_f32mat4x2;

	/// High single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, highp> highp_f32mat4x3;

	/// High single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, highp> highp_f32mat4x4;

	/// High single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef detail::tmat1x1<f32, highp> f32mat1;

	/// High single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat2x2 highp_f32mat2;

	/// High single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat3x3 highp_f32mat3;

	/// High single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat4x4 highp_f32mat4;


	/// Low double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f64 lowp_f64mat1x1;

	/// Low double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f64, lowp> lowp_f64mat2x2;

	/// Low double-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f64, lowp> lowp_f64mat2x3;

	/// Low double-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f64, lowp> lowp_f64mat2x4;

	/// Low double-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f64, lowp> lowp_f64mat3x2;

	/// Low double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f64, lowp> lowp_f64mat3x3;

	/// Low double-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f64, lowp> lowp_f64mat3x4;

	/// Low double-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f64, lowp> lowp_f64mat4x2;

	/// Low double-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f64, lowp> lowp_f64mat4x3;
	
	/// Low double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f64, lowp> lowp_f64mat4x4;

	/// Low double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef lowp_f64mat1x1 lowp_f64mat1;

	/// Low double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef lowp_f64mat2x2 lowp_f64mat2;

	/// Low double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef lowp_f64mat3x3 lowp_f64mat3;

	/// Low double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef lowp_f64mat4x4 lowp_f64mat4;


	/// Medium double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f64 Highp_f64mat1x1;

	/// Medium double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f64, mediump> mediump_f64mat2x2;

	/// Medium double-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f64, mediump> mediump_f64mat2x3;

	/// Medium double-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f64, mediump> mediump_f64mat2x4;

	/// Medium double-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f64, mediump> mediump_f64mat3x2;

	/// Medium double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f64, mediump> mediump_f64mat3x3;

	/// Medium double-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f64, mediump> mediump_f64mat3x4;

	/// Medium double-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f64, mediump> mediump_f64mat4x2;

	/// Medium double-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f64, mediump> mediump_f64mat4x3;

	/// Medium double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f64, mediump> mediump_f64mat4x4;

	/// Medium double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef mediump_f64mat1x1 mediump_f64mat1;

	/// Medium double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef mediump_f64mat2x2 mediump_f64mat2;

	/// Medium double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef mediump_f64mat3x3 mediump_f64mat3;

	/// Medium double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef mediump_f64mat4x4 mediump_f64mat4;

	/// High double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f64 highp_f64mat1x1;

	/// High double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f64, highp> highp_f64mat2x2;

	/// High double-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f64, highp> highp_f64mat2x3;

	/// High double-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f64, highp> highp_f64mat2x4;

	/// High double-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f64, highp> highp_f64mat3x2;

	/// High double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f64, highp> highp_f64mat3x3;

	/// High double-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f64, highp> highp_f64mat3x4;

	/// High double-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f64, highp> highp_f64mat4x2;

	/// High double-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f64, highp> highp_f64mat4x3;

	/// High double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f64, highp> highp_f64mat4x4;

	/// High double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef highp_f64mat1x1 highp_f64mat1;

	/// High double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat2x2 highp_f64mat2;

	/// High double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat3x3 highp_f64mat3;

	/// High double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat4x4 highp_f64mat4;

	//////////////////////////
	// Quaternion types

	/// Low single-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f32, lowp> lowp_f32quat;

	/// Low double-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f64, lowp> lowp_f64quat;

	/// Medium single-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f32, mediump> mediump_f32quat;

	/// Medium double-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f64, mediump> mediump_f64quat;

	/// High single-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f32, highp> highp_f32quat;

	/// High double-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f64, highp> highp_f64quat;



# 2324 "/usr/local/include/glm/fwd.hpp" 3
                                              
	/// Default single-precision floating-point vector of 1 components.
	/// @see gtc_type_precision
	typedef highp_f32vec1			fvec1;

	/// Default single-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef highp_f32vec2			fvec2;

	/// Default single-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef highp_f32vec3			fvec3;

	/// Default single-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef highp_f32vec4			fvec4;

	/// Default single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat2x2			fmat2x2;

	/// Default single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat2x3			fmat2x3;

	/// Default single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat2x4			fmat2x4;

	/// Default single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat3x2			fmat3x2;

	/// Default single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat3x3			fmat3x3;

	/// Default single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat3x4			fmat3x4;

	/// Default single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat4x2			fmat4x2;

	/// Default single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat4x3			fmat4x3;

	/// Default single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat4x4			fmat4x4;
	
	/// Default single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef fmat2x2					fmat2;

	/// Default single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef fmat3x3					fmat3;

	/// Default single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef fmat4x4					fmat4;

	/// Default single-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef highp_fquat				fquat;
	


	/// Default single-precision floating-point vector of 1 components.
	/// @see gtc_type_precision
	typedef highp_f32vec1			f32vec1;

	/// Default single-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef highp_f32vec2			f32vec2;

	/// Default single-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef highp_f32vec3			f32vec3;

	/// Default single-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef highp_f32vec4			f32vec4;

	/// Default single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat2x2			f32mat2x2;

	/// Default single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat2x3			f32mat2x3;

	/// Default single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat2x4			f32mat2x4;

	/// Default single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat3x2			f32mat3x2;

	/// Default single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat3x3			f32mat3x3;

	/// Default single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat3x4			f32mat3x4;

	/// Default single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat4x2			f32mat4x2;

	/// Default single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat4x3			f32mat4x3;

	/// Default single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f32mat4x4			f32mat4x4;

	/// Default single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef f32mat2x2				f32mat2;

	/// Default single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef f32mat3x3				f32mat3;

	/// Default single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef f32mat4x4				f32mat4;

	/// Default single-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef highp_f32quat			f32quat;



# 2500 "/usr/local/include/glm/fwd.hpp" 3
      
	/// Default double-precision floating-point vector of 1 components.
	/// @see gtc_type_precision
	typedef highp_f64vec1			f64vec1;

	/// Default double-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef highp_f64vec2			f64vec2;

	/// Default double-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef highp_f64vec3			f64vec3;

	/// Default double-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef highp_f64vec4			f64vec4;

	/// Default double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat2x2			f64mat2x2;

	/// Default double-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat2x3			f64mat2x3;

	/// Default double-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat2x4			f64mat2x4;

	/// Default double-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat3x2			f64mat3x2;

	/// Default double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat3x3			f64mat3x3;

	/// Default double-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat3x4			f64mat3x4;

	/// Default double-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat4x2			f64mat4x2;

	/// Default double-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat4x3			f64mat4x3;

	/// Default double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef highp_f64mat4x4			f64mat4x4;

	/// Default double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef f64mat2x2				f64mat2;

	/// Default double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef f64mat3x3				f64mat3;

	/// Default double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef f64mat4x4				f64mat4;

	/// Default double-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef highp_f64quat			f64quat;


}//namespace glm

# 61 "/usr/local/include/glm/glm.hpp" 2 3





                     


# 1 "/usr/local/include/glm/vec2.hpp" 1 3
/// @ref core
/// @file glm/vec2.hpp




# 1 "/usr/local/include/glm/detail/type_vec2.hpp" 1 3
/// @ref core
/// @file glm/detail/type_vec2.hpp










                     


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec2
	{
		// -- Implementation detail --

		typedef T value_type;
		typedef tvec2<T, P> type;
		typedef tvec2<bool, P> bool_type;

		// -- Data --


# 69 "/usr/local/include/glm/detail/type_vec2.hpp" 3
        
			union {T x, r, s;};
			union {T y, g, t;};



                       


		// -- Component accesses --

		/// Return the count of components of the vector
		typedef length_t length_type;
		 static length_type length(){return 2;}

		 T & operator[](length_type i);
		 T __const & operator[](length_type i) __const;

		// -- Implicit basic constructors --

		  tvec2() ;
		  tvec2(tvec2<T, P> __const& v) ;
		template <precision Q>
		  tvec2(tvec2<T, Q> __const& v);

		// -- Explicit basic constructors --

		  explicit tvec2(ctor);
		  explicit tvec2(T scalar);
		  tvec2(T s1, T s2);

		// -- Conversion constructors --

		/// Explicit converions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B>
		  tvec2(A x, B y);
		template <typename A, typename B>
		  tvec2(tvec1<A, P> __const & v1, tvec1<B, P> __const & v2);

		// -- Conversion vector constructors --

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec2(tvec3<U, Q> __const & v);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec2(tvec4<U, Q> __const & v);

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec2(tvec2<U, Q> __const & v);

		// -- Swizzle constructors --






                                                                               

		// -- Unary arithmetic operators --

		 tvec2<T, P>& operator=(tvec2<T, P> __const & v) ;

		template <typename U>
		 tvec2<T, P>& operator=(tvec2<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator+=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator+=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator+=(tvec2<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator-=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator-=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator-=(tvec2<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator*=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator*=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator*=(tvec2<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator/=(U scalar);
		template <typename U>
		 tvec2<T, P>& operator/=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec2<T, P>& operator/=(tvec2<U, P> __const & v);

		// -- Increment and decrement operators --

		 tvec2<T, P> & operator++();
		 tvec2<T, P> & operator--();
		 tvec2<T, P> operator++(int);
		 tvec2<T, P> operator--(int);

		// -- Unary bit operators --

		template <typename U> 
		 tvec2<T, P> & operator%=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator%=(tvec1<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator%=(tvec2<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator&=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator&=(tvec1<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator&=(tvec2<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator|=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator|=(tvec1<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator|=(tvec2<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator^=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator^=(tvec1<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator^=(tvec2<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator<<=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator<<=(tvec1<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator<<=(tvec2<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator>>=(U scalar);
		template <typename U> 
		 tvec2<T, P> & operator>>=(tvec1<U, P> __const & v);
		template <typename U> 
		 tvec2<T, P> & operator>>=(tvec2<U, P> __const & v);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> __const & v);

	// -- Binary operators --

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator+(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(T scalar, tvec2<T, P> __const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator~(tvec2<T, P> __const & v);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2);

	template <precision P>
	 tvec2<bool, P> operator&&(tvec2<bool, P> __const & v1, tvec2<bool, P> __const & v2);

	template <precision P>
	 tvec2<bool, P> operator||(tvec2<bool, P> __const & v1, tvec2<bool, P> __const & v2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_vec2.inl" 1 3
/// @ref core
/// @file glm/core/type_tvec2.inl

namespace glm
{

# 18 "/usr/local/include/glm/detail/type_vec2.inl" 3
        
	// -- Implicit basic constructors --


		template <typename T, precision P>
		 __inline  tvec2<T, P>::tvec2()

				: x(0), y(0)

		{}



		template <typename T, precision P>
		 __inline  tvec2<T, P>::tvec2(tvec2<T, P> __const & v)
			: x(v.x), y(v.y)
		{}


	template <typename T, precision P>
	template <precision Q>
	 __inline  tvec2<T, P>::tvec2(tvec2<T, Q> __const & v)
		: x(v.x), y(v.y)
	{}

	// -- Explicit basic constructors --

	template <typename T, precision P>
	 __inline  tvec2<T, P>::tvec2(ctor)
	{}

	template <typename T, precision P>
	 __inline  tvec2<T, P>::tvec2(T scalar)
		: x(scalar), y(scalar)
	{}

	template <typename T, precision P>
	 __inline  tvec2<T, P>::tvec2(T s1, T s2)
		: x(s1), y(s2)
	{}

	// -- Conversion scalar constructors --

	template <typename T, precision P>
	template <typename A, typename B>
	 __inline  tvec2<T, P>::tvec2(A a, B b)
		: x(static_cast<T>(a))
		, y(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B>
	 __inline  tvec2<T, P>::tvec2(tvec1<A, P> __const & a, tvec1<B, P> __const & b)
		: x(static_cast<T>(a.x))
		, y(static_cast<T>(b.x))
	{}

	// -- Conversion vector constructors --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec2<T, P>::tvec2(tvec2<U, Q> __const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec2<T, P>::tvec2(tvec3<U, Q> __const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec2<T, P>::tvec2(tvec4<U, Q> __const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	// -- Component accesses --

	template <typename T, precision P>
	 __inline T & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i)
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	template <typename T, precision P>
	 __inline T __const & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i) __const
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	// -- Unary arithmetic operators --


		template <typename T, precision P>
		 __inline tvec2<T, P> & tvec2<T, P>::operator=(tvec2<T, P> __const & v)
		{
			this->x = v.x;
			this->y = v.y;
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> __const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> __const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> __const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> __const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> __const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> __const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> __const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		this->y /= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> __const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> __const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tvec2<T, P> & tvec2<T, P>::operator++()
	{
		++this->x;
		++this->y;
		return *this;
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> & tvec2<T, P>::operator--()
	{
		--this->x;
		--this->y;
		return *this;
	}

	template <typename T, precision P> 
	 __inline tvec2<T, P> tvec2<T, P>::operator++(int)
	{
		tvec2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 __inline tvec2<T, P> tvec2<T, P>::operator--(int)
	{
		tvec2<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary bit operators --

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		this->y %= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> __const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> __const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		this->y &= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> __const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> __const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		this->y |= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> __const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> __const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		this->y ^= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> __const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> __const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		this->y <<= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> __const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> __const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> __const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> __const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		return *this;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tvec2<T, P> operator+(tvec2<T, P> __const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator-(tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			-v.x, 
			-v.y);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tvec2<T, P> operator+(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x + scalar,
			v.y + scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator+(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.y + v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator+(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar + v.x,
			scalar + v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator+(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.x + v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator+(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.y + v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator-(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x - scalar,
			v.y - scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator-(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.y - v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator-(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar - v.x,
			scalar - v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator-(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.x - v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator-(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.y - v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator*(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x * scalar,
			v.y * scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator*(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.y * v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator*(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar * v.x,
			scalar * v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator*(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.x * v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator*(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.y * v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator/(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x / scalar,
			v.y / scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator/(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.y / v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator/(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar / v.x,
			scalar / v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator/(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.x / v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator/(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.y / v2.y);
	}

	// -- Binary bit operators --

	template <typename T, precision P>
	 __inline tvec2<T, P> operator%(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x % scalar,
			v.y % scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator%(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.y % v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator%(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar % v.x,
			scalar % v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator%(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.x % v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator%(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.y % v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator&(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x & scalar,
			v.y & scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator&(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.y & v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator&(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar & v.x,
			scalar & v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator&(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.x & v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator&(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.y & v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator|(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x | scalar,
			v.y | scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator|(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.y | v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator|(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar | v.x,
			scalar | v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator|(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.x | v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator|(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.y | v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator^(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x ^ scalar,
			v.y ^ scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator^(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator^(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar ^ v.x,
			scalar ^ v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator^(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.x ^ v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator^(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator<<(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x << scalar,
			v.y << scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator<<(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.y << v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator<<(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar << v.x,
			scalar << v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator<<(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.x << v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator<<(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.y << v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator>>(tvec2<T, P> __const & v, T scalar)
	{
		return tvec2<T, P>(
			v.x >> scalar,
			v.y >> scalar);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator>>(tvec2<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator>>(T scalar, tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			scalar >> v.x,
			scalar >> v.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator>>(tvec1<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.x >> v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator>>(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.y);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> operator~(tvec2<T, P> __const & v)
	{
		return tvec2<T, P>(
			~v.x,
			~v.y);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return (v1.x == v2.x) && (v1.y == v2.y);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tvec2<T, P> __const & v1, tvec2<T, P> __const & v2)
	{
		return (v1.x != v2.x) || (v1.y != v2.y);
	}

	template <precision P>
	 __inline tvec2<bool, P> operator&&(tvec2<bool, P> __const & v1, tvec2<bool, P> __const & v2)
	{
		return tvec2<bool, P>(v1.x && v2.x, v1.y && v2.y);
	}

	template <precision P>
	 __inline tvec2<bool, P> operator||(tvec2<bool, P> __const & v1, tvec2<bool, P> __const & v2)
	{
		return tvec2<bool, P>(v1.x || v2.x, v1.y || v2.y);
	}
}//namespace glm

# 387 "/usr/local/include/glm/detail/type_vec2.hpp" 2 3



# 6 "/usr/local/include/glm/vec2.hpp" 2 3


# 68 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/vec3.hpp" 1 3
/// @ref core
/// @file glm/vec3.hpp




# 1 "/usr/local/include/glm/detail/type_vec3.hpp" 1 3
/// @ref core
/// @file glm/detail/type_vec3.hpp










                                            


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec3
	{
		// -- Implementation detail --

		typedef T value_type;
		typedef tvec3<T, P> type;
		typedef tvec3<bool, P> bool_type;

		// -- Data --


# 68 "/usr/local/include/glm/detail/type_vec3.hpp" 3
        
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };



                       


		// -- Component accesses --

		/// Return the count of components of the vector
		typedef length_t length_type;
		 static length_type length(){return 3;}

		 T & operator[](length_type i);
		 T __const & operator[](length_type i) __const;

		// -- Implicit basic constructors --

		  tvec3() ;
		  tvec3(tvec3<T, P> __const & v) ;
		template <precision Q>
		  tvec3(tvec3<T, Q> __const & v);

		// -- Explicit basic constructors --

		  explicit tvec3(ctor);
		  explicit tvec3(T scalar);
		  tvec3(T a, T b, T c);

		// -- Conversion scalar constructors --

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C>
		  tvec3(A a, B b, C c);
		template <typename A, typename B, typename C>
		  tvec3(tvec1<A, P> __const & a, tvec1<B, P> __const & b, tvec1<C, P> __const & c);

		// -- Conversion vector constructors --

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec3(tvec2<A, Q> __const & a, B b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec3(tvec2<A, Q> __const & a, tvec1<B, Q> __const & b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec3(A a, tvec2<B, Q> __const & b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec3(tvec1<A, Q> __const & a, tvec2<B, Q> __const & b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec3(tvec4<U, Q> __const & v);

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec3(tvec3<U, Q> __const & v);

		// -- Swizzle constructors --

# 149 "/usr/local/include/glm/detail/type_vec3.hpp" 3
                                                                               

		// -- Unary arithmetic operators --

		 tvec3<T, P> & operator=(tvec3<T, P> __const & v) ;

		template <typename U>
		 tvec3<T, P> & operator=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator+=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator+=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator+=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator-=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator-=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator-=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator*=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator*=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator*=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator/=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator/=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator/=(tvec3<U, P> __const & v);

		// -- Increment and decrement operators --

		 tvec3<T, P> & operator++();
		 tvec3<T, P> & operator--();
		 tvec3<T, P> operator++(int);
		 tvec3<T, P> operator--(int);

		// -- Unary bit operators --

		template <typename U>
		 tvec3<T, P> & operator%=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator%=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator%=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator&=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator&=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator&=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator|=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator|=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator|=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator^=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator^=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator^=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator<<=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator<<=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator<<=(tvec3<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator>>=(U scalar);
		template <typename U>
		 tvec3<T, P> & operator>>=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec3<T, P> & operator>>=(tvec3<U, P> __const & v);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> __const & v);

	// -- Binary operators --

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator+(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator*(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator/(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator%(T __const & scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> __const & v1, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator&(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator|(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator^(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(T scalar, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec1<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P> 
	 tvec3<T, P> operator~(tvec3<T, P> __const & v);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2);

	template <precision P>
	 tvec3<bool, P> operator&&(tvec3<bool, P> __const & v1, tvec3<bool, P> __const & v2);

	template <precision P>
	 tvec3<bool, P> operator||(tvec3<bool, P> __const & v1, tvec3<bool, P> __const & v2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_vec3.inl" 1 3
/// @ref core
/// @file glm/detail/type_tvec3.inl

namespace glm
{


# 31 "/usr/local/include/glm/detail/type_vec3.inl" 3
        
	// -- Implicit basic constructors --


		template <typename T, precision P>
		 __inline  tvec3<T, P>::tvec3()

				: x(0), y(0), z(0)

		{}



		template <typename T, precision P>
		 __inline  tvec3<T, P>::tvec3(tvec3<T, P> __const & v)
			: x(v.x), y(v.y), z(v.z)
		{}


	template <typename T, precision P>
	template <precision Q>
	 __inline  tvec3<T, P>::tvec3(tvec3<T, Q> __const & v)
		: x(v.x), y(v.y), z(v.z)
	{}

	// -- Explicit basic constructors --

	template <typename T, precision P>
	 __inline  tvec3<T, P>::tvec3(ctor)
	{}

	template <typename T, precision P>
	 __inline  tvec3<T, P>::tvec3(T scalar)
		: x(scalar), y(scalar), z(scalar)
	{}

	template <typename T, precision P>
	 __inline  tvec3<T, P>::tvec3(T a, T b, T c)
		: x(a), y(b), z(c)
	{}

	// -- Conversion scalar constructors --

	template <typename T, precision P>
	template <typename A, typename B, typename C>
	 __inline  tvec3<T, P>::tvec3(A a, B b, C c) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C>
	 __inline  tvec3<T, P>::tvec3(tvec1<A, P> __const & a, tvec1<B, P> __const & b, tvec1<C, P> __const & c) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c))
	{}

	// -- Conversion vector constructors --

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec3<T, P>::tvec3(tvec2<A, Q> __const & a, B b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec3<T, P>::tvec3(tvec2<A, Q> __const & a, tvec1<B, Q> __const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec3<T, P>::tvec3(A a, tvec2<B, Q> __const & b) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec3<T, P>::tvec3(tvec1<A, Q> __const & a, tvec2<B, Q> __const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec3<T, P>::tvec3(tvec3<U, Q> __const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec3<T, P>::tvec3(tvec4<U, Q> __const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z))
	{}

	// -- Component accesses --

	template <typename T, precision P>
	 __inline T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	template <typename T, precision P>
	 __inline T __const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) __const
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	// -- Unary arithmetic operators --


		template <typename T, precision P>
		 __inline tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> __const & v)
		{
			this->x = v.x;
			this->y = v.y;
			this->z = v.z;
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> __const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		this->z += static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> __const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		this->z += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> __const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		this->z -= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> __const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		this->z -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> __const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		this->z *= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> __const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		this->z *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> __const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator/=(U v)
	{
		this->x /= static_cast<T>(v);
		this->y /= static_cast<T>(v);
		this->z /= static_cast<T>(v);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> __const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		this->z /= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> __const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tvec3<T, P> & tvec3<T, P>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		return *this;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> & tvec3<T, P>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		return *this;
	}

	template <typename T, precision P> 
	 __inline tvec3<T, P> tvec3<T, P>::operator++(int)
	{
		tvec3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 __inline tvec3<T, P> tvec3<T, P>::operator--(int)
	{
		tvec3<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary bit operators --

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)
	{
		this->x %= scalar;
		this->y %= scalar;
		this->z %= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> __const & v)
	{
		this->x %= v.x;
		this->y %= v.x;
		this->z %= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> __const & v)
	{
		this->x %= v.x;
		this->y %= v.y;
		this->z %= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)
	{
		this->x &= scalar;
		this->y &= scalar;
		this->z &= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> __const & v)
	{
		this->x &= v.x;
		this->y &= v.x;
		this->z &= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> __const & v)
	{
		this->x &= v.x;
		this->y &= v.y;
		this->z &= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)
	{
		this->x |= scalar;
		this->y |= scalar;
		this->z |= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> __const & v)
	{
		this->x |= v.x;
		this->y |= v.x;
		this->z |= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> __const & v)
	{
		this->x |= v.x;
		this->y |= v.y;
		this->z |= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)
	{
		this->x ^= scalar;
		this->y ^= scalar;
		this->z ^= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> __const & v)
	{
		this->x ^= v.x;
		this->y ^= v.x;
		this->z ^= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> __const & v)
	{
		this->x ^= v.x;
		this->y ^= v.y;
		this->z ^= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)
	{
		this->x <<= scalar;
		this->y <<= scalar;
		this->z <<= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> __const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		this->z <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> __const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		this->z <<= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		this->z >>= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> __const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		this->z >>= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> __const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		return *this;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tvec3<T, P> operator+(tvec3<T, P> __const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator-(tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			-v.x, 
			-v.y, 
			-v.z);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tvec3<T, P> operator+(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x + scalar,
			v.y + scalar,
			v.z + scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator+(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x + scalar.x,
			v.y + scalar.x,
			v.z + scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator+(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar + v.x,
			scalar + v.y,
			scalar + v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator+(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x + v.x,
			scalar.x + v.y,
			scalar.x + v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator+(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator-(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x - scalar,
			v.y - scalar,
			v.z - scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator-(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x - scalar.x,
			v.y - scalar.x,
			v.z - scalar.x);
	}

	template <typename T, precision P> 
	 __inline tvec3<T, P> operator-(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar - v.x,
			scalar - v.y,
			scalar - v.z);
	}

	template <typename T, precision P> 
	 __inline tvec3<T, P> operator-(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x - v.x,
			scalar.x - v.y,
			scalar.x - v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator-(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x * scalar,
			v.y * scalar,
			v.z * scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x * scalar.x,
			v.y * scalar.x,
			v.z * scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar * v.x,
			scalar * v.y,
			scalar * v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x * v.x,
			scalar.x * v.y,
			scalar.x * v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator/(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x / scalar,
			v.y / scalar,
			v.z / scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator/(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x / scalar.x,
			v.y / scalar.x,
			v.z / scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator/(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar / v.x,
			scalar / v.y,
			scalar / v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator/(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x / v.x,
			scalar.x / v.y,
			scalar.x / v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator/(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z);
	}

	// -- Binary bit operators --

	template <typename T, precision P>
	 __inline tvec3<T, P> operator%(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x % scalar,
			v.y % scalar,
			v.z % scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator%(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x % scalar.x,
			v.y % scalar.x,
			v.z % scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator%(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar % v.x,
			scalar % v.y,
			scalar % v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator%(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x % v.x,
			scalar.x % v.y,
			scalar.x % v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator%(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator&(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x & scalar,
			v.y & scalar,
			v.z & scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator&(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x & scalar.x,
			v.y & scalar.x,
			v.z & scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator&(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar & v.x,
			scalar & v.y,
			scalar & v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator&(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x & v.x,
			scalar.x & v.y,
			scalar.x & v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator&(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator|(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x | scalar,
			v.y | scalar,
			v.z | scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator|(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x | scalar.x,
			v.y | scalar.x,
			v.z | scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator|(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar | v.x,
			scalar | v.y,
			scalar | v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator|(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x | v.x,
			scalar.x | v.y,
			scalar.x | v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator|(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator^(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x ^ scalar,
			v.y ^ scalar,
			v.z ^ scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator^(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x ^ scalar.x,
			v.y ^ scalar.x,
			v.z ^ scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator^(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar ^ v.x,
			scalar ^ v.y,
			scalar ^ v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator^(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x ^ v.x,
			scalar.x ^ v.y,
			scalar.x ^ v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator^(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator<<(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x << scalar,
			v.y << scalar,
			v.z << scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator<<(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x << scalar.x,
			v.y << scalar.x,
			v.z << scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator<<(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar << v.x,
			scalar << v.y,
			scalar << v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator<<(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x << v.x,
			scalar.x << v.y,
			scalar.x << v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator<<(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator>>(tvec3<T, P> __const & v, T scalar)
	{
		return tvec3<T, P>(
			v.x >> scalar,
			v.y >> scalar,
			v.z >> scalar);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator>>(tvec3<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec3<T, P>(
			v.x >> scalar.x,
			v.y >> scalar.x,
			v.z >> scalar.x);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator>>(T scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar >> v.x,
			scalar >> v.y,
			scalar >> v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator>>(tvec1<T, P> __const & scalar, tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			scalar.x >> v.x,
			scalar.x >> v.y,
			scalar.x >> v.z);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator>>(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return tvec3<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z);
	}

	template <typename T, precision P> 
	 __inline tvec3<T, P> operator~(tvec3<T, P> __const & v)
	{
		return tvec3<T, P>(
			~v.x,
			~v.y,
			~v.z);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tvec3<T, P> __const & v1, tvec3<T, P> __const & v2)
	{
		return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
	}

	template <precision P>
	 __inline tvec3<bool, P> operator&&(tvec3<bool, P> __const & v1, tvec3<bool, P> __const & v2)
	{
		return tvec3<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
	}

	template <precision P>
	 __inline tvec3<bool, P> operator||(tvec3<bool, P> __const & v1, tvec3<bool, P> __const & v2)
	{
		return tvec3<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
	}
}//namespace glm

# 408 "/usr/local/include/glm/detail/type_vec3.hpp" 2 3



# 6 "/usr/local/include/glm/vec3.hpp" 2 3


# 69 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/vec4.hpp" 1 3
/// @ref core
/// @file glm/vec4.hpp




# 1 "/usr/local/include/glm/detail/type_vec4.hpp" 1 3
/// @ref core
/// @file glm/detail/type_vec4.hpp










                     


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec4
	{
		// -- Implementation detail --

		typedef T value_type;
		typedef tvec4<T, P> type;
		typedef tvec4<bool, P> bool_type;

		// -- Data --


# 70 "/usr/local/include/glm/detail/type_vec4.hpp" 3
        
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };
			union { T w, a, q; };



                       


		// -- Component accesses --

		/// Return the count of components of the vector
		typedef length_t length_type;
		 static length_type length(){return 4;}

		 T & operator[](length_type i);
		 T __const & operator[](length_type i) __const;

		// -- Implicit basic constructors --

		  tvec4() ;
		  tvec4(tvec4<T, P> __const& v) ;
		template <precision Q>
		  tvec4(tvec4<T, Q> __const& v);

		// -- Explicit basic constructors --

		  explicit tvec4(ctor);
		  explicit tvec4(T scalar);
		  tvec4(T a, T b, T c, T d);

		// -- Conversion scalar constructors --

		/// Explicit converions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C, typename D>
		  tvec4(A a, B b, C c, D d);
		template <typename A, typename B, typename C, typename D>
		  tvec4(tvec1<A, P> __const& a, tvec1<B, P> __const& b, tvec1<C, P> __const& c, tvec1<D, P> __const& d);

		// -- Conversion vector constructors --

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec2<A, Q> __const & a, B b, C c);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec2<A, Q> __const & a, tvec1<B, Q> __const & b, tvec1<C, Q> __const & c);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C, precision Q>
		  tvec4(A a, tvec2<B, Q> __const & b, C c);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec1<A, Q> __const & a, tvec2<B, Q> __const & b, tvec1<C, Q> __const & c);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C, precision Q>
		  tvec4(A a, B b, tvec2<C, Q> __const & c);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, typename C, precision Q>
		  tvec4(tvec1<A, Q> __const & a, tvec1<B, Q> __const & b, tvec2<C, Q> __const & c);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec4(tvec3<A, Q> __const & a, B b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec4(tvec3<A, Q> __const & a, tvec1<B, Q> __const & b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec4(A a, tvec3<B, Q> __const & b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec4(tvec1<A, Q> __const & a, tvec3<B, Q> __const & b);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename A, typename B, precision Q>
		  tvec4(tvec2<A, Q> __const & a, tvec2<B, Q> __const & b);

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec4(tvec4<U, Q> __const& v);

		// -- Swizzle constructors --

# 194 "/usr/local/include/glm/detail/type_vec4.hpp" 3
                                                                               

		// -- Unary arithmetic operators --

		 tvec4<T, P> & operator=(tvec4<T, P> __const & v) ;

		template <typename U>
		 tvec4<T, P> & operator=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator+=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator+=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator+=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator-=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator-=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator-=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator*=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator*=(tvec1<U, P> __const& v);
		template <typename U>
		 tvec4<T, P> & operator*=(tvec4<U, P> __const& v);
		template <typename U>
		 tvec4<T, P> & operator/=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator/=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator/=(tvec4<U, P> __const & v);

		// -- Increment and decrement operators --

		 tvec4<T, P> & operator++();
		 tvec4<T, P> & operator--();
		 tvec4<T, P> operator++(int);
		 tvec4<T, P> operator--(int);

		// -- Unary bit operators --

		template <typename U>
		 tvec4<T, P> & operator%=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator%=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator%=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator&=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator&=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator&=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator|=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator|=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator|=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator^=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator^=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator^=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator<<=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator<<=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator<<=(tvec4<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator>>=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator>>=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec4<T, P> & operator>>=(tvec4<U, P> __const & v);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> __const & v);

	// -- Binary operators --

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator+(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator*(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator/(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> __const & v, tvec1<T, P> __const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator%(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec1<T, P> __const & scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> __const & v, tvec1<T, P> __const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator&(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec1<T, P> __const & scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> __const & v, tvec1<T, P> __const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator|(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec1<T, P> __const & scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> __const & v, tvec1<T, P> __const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator^(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec1<T, P> __const & scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> __const & v, tvec1<T, P> __const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec1<T, P> __const & scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> __const & v, tvec1<T, P> __const & scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(T scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec1<T, P> __const & scalar, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P> 
	 tvec4<T, P> operator~(tvec4<T, P> __const & v);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2);

	template <precision P>
	 tvec4<bool, P> operator&&(tvec4<bool, P> __const & v1, tvec4<bool, P> __const & v2);

	template <precision P>
	 tvec4<bool, P> operator||(tvec4<bool, P> __const & v1, tvec4<bool, P> __const & v2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_vec4.inl" 1 3
/// @ref core
/// @file glm/detail/type_tvec4.inl

namespace glm{
namespace detail
{
	template <typename T>
	struct is_int
	{
		enum test {value = 0};
	};

	template <>
	struct is_int<uint32>
	{
		enum test {value = ~0};
	};

	template <>
	struct is_int<int32>
	{
		enum test {value = ~0};
	};

	template <>
	struct is_int<uint64>
	{
		enum test {value = ~0};
	};

	template <>
	struct is_int<int64>
	{
		enum test {value = ~0};
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_add
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_sub
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_mul
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_div
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_vec4_mod
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_and
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_or
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_xor
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_left
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_right
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_equal
	{
		 __inline static bool call(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
		{
			return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_nequal
	{
		 __inline static bool call(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
		{
			return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
		}
	};

	template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_bitwise_not
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const & v)
		{
			return tvec4<T, P>(~v.x, ~v.y, ~v.z, ~v.w);
		}
	};
}//namespace detail

	// -- Implicit basic constructors --


		template <typename T, precision P>
		 __inline  tvec4<T, P>::tvec4()

				: x(0), y(0), z(0), w(0)

		{}



		template <typename T, precision P>
		 __inline  tvec4<T, P>::tvec4(tvec4<T, P> __const & v)
			: x(v.x), y(v.y), z(v.z), w(v.w)
		{}


	template <typename T, precision P>
	template <precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec4<T, Q> __const & v)
		: x(v.x), y(v.y), z(v.z), w(v.w)
	{}

	// -- Explicit basic constructors --

	template <typename T, precision P>
	 __inline  tvec4<T, P>::tvec4(ctor)
	{}

	template <typename T, precision P>
	 __inline  tvec4<T, P>::tvec4(T scalar)
		: x(scalar), y(scalar), z(scalar), w(scalar)
	{}

	template <typename T, precision P>
	 __inline  tvec4<T, P>::tvec4(T a, T b, T c, T d)
		: x(a), y(b), z(c), w(d)
	{}

	// -- Conversion scalar constructors --

	template <typename T, precision P>
	template <typename A, typename B, typename C, typename D>
	 __inline  tvec4<T, P>::tvec4(A a, B b, C c, D d) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c)),
		w(static_cast<T>(d))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, typename D>
	 __inline  tvec4<T, P>::tvec4(tvec1<A, P> __const & a, tvec1<B, P> __const & b, tvec1<C, P> __const & c, tvec1<D, P> __const & d) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(c.x)),
		w(static_cast<T>(d.x))
	{}

	// -- Conversion vector constructors --

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec2<A, Q> __const & a, B b, C c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b)),
		w(static_cast<T>(c))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec2<A, Q> __const & a, tvec1<B, Q> __const & b, tvec1<C, Q> __const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x)),
		w(static_cast<T>(c.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 __inline  tvec4<T, P>::tvec4(A s1, tvec2<B, Q> __const & v, C s2) :
		x(static_cast<T>(s1)),
		y(static_cast<T>(v.x)),
		z(static_cast<T>(v.y)),
		w(static_cast<T>(s2))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec1<A, Q> __const & a, tvec2<B, Q> __const & b, tvec1<C, Q> __const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(c.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 __inline  tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> __const & v) :
		x(static_cast<T>(s1)),
		y(static_cast<T>(s2)),
		z(static_cast<T>(v.x)),
		w(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec1<A, Q> __const & a, tvec1<B, Q> __const & b, tvec2<C, Q> __const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(c.x)),
		w(static_cast<T>(c.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec3<A, Q> __const & a, B b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(a.z)),
		w(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec3<A, Q> __const & a, tvec1<B, Q> __const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(a.z)),
		w(static_cast<T>(b.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec4<T, P>::tvec4(A a, tvec3<B, Q> __const & b) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(b.z))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec1<A, Q> __const & a, tvec3<B, Q> __const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(b.z))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec2<A, Q> __const & a, tvec2<B, Q> __const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x)),
		w(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec4<T, P>::tvec4(tvec4<U, Q> __const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z)),
		w(static_cast<T>(v.w))
	{}

	// -- Component accesses --

	template <typename T, precision P>
	 __inline T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	template <typename T, precision P>
	 __inline T __const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) __const
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	// -- Unary arithmetic operators --


		template <typename T, precision P>
		 __inline tvec4<T, P>& tvec4<T, P>::operator=(tvec4<T, P> __const & v)
		{
			this->x = v.x;
			this->y = v.y;
			this->z = v.z;
			this->w = v.w;
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P>& tvec4<T, P>::operator=(tvec4<U, P> __const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		this->w = static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)
	{
		return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)
	{
		return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator*=(U scalar)
	{
		return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator/=(U scalar)
	{
		return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tvec4<T, P> & tvec4<T, P>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		++this->w;
		return *this;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> & tvec4<T, P>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		--this->w;
		return *this;
	}

	template <typename T, precision P> 
	 __inline tvec4<T, P> tvec4<T, P>::operator++(int)
	{
		tvec4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 __inline tvec4<T, P> tvec4<T, P>::operator--(int)
	{
		tvec4<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary bit operators --

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)
	{
		return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> __const& v)
	{
		return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> __const& v)
	{
		return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)
	{
		return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)
	{
		return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)
	{
		return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> __const & v)
	{
		return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
	}

	// -- Unary constant operators --

	template <typename T, precision P>
	 __inline tvec4<T, P> operator+(tvec4<T, P> __const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator-(tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(0) -= v;
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tvec4<T, P> operator+(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) += scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator+(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) += v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator+(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(v) += scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator+(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v2) += v1;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator+(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) += v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator-(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) -= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator-(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) -= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator-(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) -= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator-(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1.x) -= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator-(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) -= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) *= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) *= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(v) *= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v2) *= v1;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) *= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator/(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) /= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator/(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) /= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator/(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) /= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator/(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1.x) /= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator/(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) /= v2;
	}

	// -- Binary bit operators --

	template <typename T, precision P>
	 __inline tvec4<T, P> operator%(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) %= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator%(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) %= v2.x;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator%(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) %= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator%(tvec1<T, P> __const & scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar.x) %= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator%(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) %= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator&(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) &= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator&(tvec4<T, P> __const & v, tvec1<T, P> __const & scalar)
	{
		return tvec4<T, P>(v) &= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator&(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) &= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator&(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1.x) &= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator&(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) &= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator|(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) |= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator|(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) |= v2.x;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator|(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) |= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator|(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1.x) |= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator|(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) |= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator^(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) ^= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator^(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) ^= v2.x;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator^(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) ^= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator^(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1.x) ^= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator^(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) ^= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator<<(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) <<= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator<<(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) <<= v2.x;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator<<(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) <<= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator<<(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1.x) <<= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator<<(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) <<= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator>>(tvec4<T, P> __const & v, T scalar)
	{
		return tvec4<T, P>(v) >>= scalar;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator>>(tvec4<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) >>= v2.x;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator>>(T scalar, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(scalar) >>= v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator>>(tvec1<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1.x) >>= v2;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator>>(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return tvec4<T, P>(v1) >>= v2;
	}

	template <typename T, precision P> 
	 __inline tvec4<T, P> operator~(tvec4<T, P> __const & v)
	{
		return detail::compute_vec4_bitwise_not<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return detail::compute_vec4_equal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tvec4<T, P> __const & v1, tvec4<T, P> __const & v2)
	{
		return detail::compute_vec4_nequal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
	}

	template <precision P>
	 __inline tvec4<bool, P> operator&&(tvec4<bool, P> __const & v1, tvec4<bool, P> __const & v2)
	{
		return tvec4<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
	}

	template <precision P>
	 __inline tvec4<bool, P> operator||(tvec4<bool, P> __const & v1, tvec4<bool, P> __const & v2)
	{
		return tvec4<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
	}
}//namespace glm



       

# 453 "/usr/local/include/glm/detail/type_vec4.hpp" 2 3



# 6 "/usr/local/include/glm/vec4.hpp" 2 3


# 70 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/mat2x2.hpp" 1 3
/// @ref core
/// @file glm/mat2x2.hpp




# 1 "/usr/local/include/glm/detail/type_mat2x2.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat2x2.hpp









namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x2<T, P> type;
		typedef tmat2x2<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		// -- Constructors --

		 tmat2x2() ;
		 tmat2x2(tmat2x2<T, P> __const & m) ;
		template <precision Q>
		 tmat2x2(tmat2x2<T, Q> __const & m);

		  explicit tmat2x2(ctor);
		 explicit tmat2x2(T scalar);
		 tmat2x2(
			T __const & x1, T __const & y1,
			T __const & x2, T __const & y2);
		 tmat2x2(
			col_type __const & v1,
			col_type __const & v2);

		// -- Conversions --

		template <typename U, typename V, typename M, typename N>
		 tmat2x2(
			U __const & x1, V __const & y1,
			M __const & x2, N __const & y2);

		template <typename U, typename V>
		 tmat2x2(
			tvec2<U, P> __const & v1,
			tvec2<V, P> __const & v2);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat2x2(tmat2x2<U, Q> __const & m);

		  tmat2x2(tmat3x3<T, P> __const & x);
		  tmat2x2(tmat4x4<T, P> __const & x);
		  tmat2x2(tmat2x3<T, P> __const & x);
		  tmat2x2(tmat3x2<T, P> __const & x);
		  tmat2x2(tmat2x4<T, P> __const & x);
		  tmat2x2(tmat4x2<T, P> __const & x);
		  tmat2x2(tmat3x4<T, P> __const & x);
		  tmat2x2(tmat4x3<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 2;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat2x2<T, P> & operator=(tmat2x2<T, P> __const & v) ;

		template <typename U>
		 tmat2x2<T, P> & operator=(tmat2x2<U, P> __const & m);
		template <typename U>
		 tmat2x2<T, P> & operator+=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator+=(tmat2x2<U, P> __const & m);
		template <typename U>
		 tmat2x2<T, P> & operator-=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator-=(tmat2x2<U, P> __const & m);
		template <typename U>
		 tmat2x2<T, P> & operator*=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator*=(tmat2x2<U, P> __const & m);
		template <typename U>
		 tmat2x2<T, P> & operator/=(U s);
		template <typename U>
		 tmat2x2<T, P> & operator/=(tmat2x2<U, P> __const & m);

		// -- Increment and decrement operators --

		 tmat2x2<T, P> & operator++ ();
		 tmat2x2<T, P> & operator-- ();
		 tmat2x2<T, P> operator++(int);
		 tmat2x2<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat2x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::col_type operator*(tmat2x2<T, P> __const & m, typename tmat2x2<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::row_type operator*(typename tmat2x2<T, P>::col_type __const & v, tmat2x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat2x2<T, P> __const & m1, tmat3x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat2x2<T, P> __const & m1, tmat4x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(tmat2x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> __const & m, typename tmat2x2<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type __const & v, tmat2x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2);
} //namespace glm



# 1 "/usr/local/include/glm/detail/type_mat2x2.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat2x2.inl


# 1 "/usr/local/include/glm/detail/func_matrix.hpp" 1 3
/// @ref core
/// @file glm/detail/func_matrix.hpp
///
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.6 Matrix Functions</a>
/// 
/// @defgroup core_func_matrix Matrix functions
/// @ingroup core
/// 
/// For each of the following built-in matrix functions, there is both a 
/// single-precision floating point version, where all arguments and return values 
/// are single precision, and a double-precision floating version, where all 
/// arguments and return values are double precision. Only the single-precision 
/// floating point version is shown.



// Dependencies








# 1 "/usr/local/include/glm/detail/../mat2x3.hpp" 1 3
/// @ref core
/// @file glm/mat2x3.hpp




# 1 "/usr/local/include/glm/detail/type_mat2x3.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat2x3.hpp










namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x3<T, P> type;
		typedef tmat3x2<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		// -- Constructors --

		 tmat2x3() ;
		 tmat2x3(tmat2x3<T, P> __const & m) ;
		template <precision Q>
		 tmat2x3(tmat2x3<T, Q> __const & m);

		  explicit tmat2x3(ctor);
		 explicit tmat2x3(T scalar);
		 tmat2x3(
			T x0, T y0, T z0,
			T x1, T y1, T z1);
		 tmat2x3(
			col_type __const & v0,
			col_type __const & v1);

		// -- Conversions --

		template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
		 tmat2x3(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2);

		template <typename U, typename V>
		 tmat2x3(
			tvec3<U, P> __const & v1,
			tvec3<V, P> __const & v2);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat2x3(tmat2x3<U, Q> __const & m);

		  tmat2x3(tmat2x2<T, P> __const & x);
		  tmat2x3(tmat3x3<T, P> __const & x);
		  tmat2x3(tmat4x4<T, P> __const & x);
		  tmat2x3(tmat2x4<T, P> __const & x);
		  tmat2x3(tmat3x2<T, P> __const & x);
		  tmat2x3(tmat3x4<T, P> __const & x);
		  tmat2x3(tmat4x2<T, P> __const & x);
		  tmat2x3(tmat4x3<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 2;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat2x3<T, P> & operator=(tmat2x3<T, P> __const & m) ;

		template <typename U>
		 tmat2x3<T, P> & operator=(tmat2x3<U, P> __const & m);
		template <typename U>
		 tmat2x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat2x3<T, P> & operator+=(tmat2x3<U, P> __const & m);
		template <typename U>
		 tmat2x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat2x3<T, P> & operator-=(tmat2x3<U, P> __const & m);
		template <typename U>
		 tmat2x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat2x3<T, P> & operator/=(U s);

		// -- Increment and decrement operators --

		 tmat2x3<T, P> & operator++ ();
		 tmat2x3<T, P> & operator-- ();
		 tmat2x3<T, P> operator++(int);
		 tmat2x3<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat2x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat2x3<T, P>::col_type operator*(tmat2x3<T, P> __const & m, typename tmat2x3<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat2x3<T, P>::row_type operator*(typename tmat2x3<T, P>::col_type __const & v, tmat2x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat2x3<T, P> __const & m1, tmat2x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat2x3<T, P> __const & m1, tmat3x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat2x3<T, P> __const & m1, tmat4x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator/(tmat2x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> __const & m);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat2x3.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat2x3.inl

namespace glm
{
	// -- Constructors --


		template <typename T, precision P> 
		 __inline tmat2x3<T, P>::tmat2x3()
		{

				this->value[0] = col_type(1, 0, 0);
				this->value[1] = col_type(0, 1, 0);

		}



		template <typename T, precision P>
		 __inline tmat2x3<T, P>::tmat2x3(tmat2x3<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat2x3<T, P>::tmat2x3(tmat2x3<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P> 
	 __inline  tmat2x3<T, P>::tmat2x3(ctor)
	{}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0);
		this->value[1] = col_type(0, scalar, 0);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(col_type __const & v0, col_type __const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2>
	 __inline tmat2x3<T, P>::tmat2x3
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 __inline tmat2x3<T, P>::tmat2x3(tvec3<V1, P> __const & v1, tvec3<V2, P> __const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	// -- Matrix conversions --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat2x3<T, P>::tmat2x3(tmat2x3<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(tmat2x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 __inline  tmat2x3<T, P>::tmat2x3(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(tmat2x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(tmat3x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(tmat3x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(tmat4x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P>::tmat2x3(tmat4x3<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat2x3<T, P>::col_type & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat2x3<T, P>::col_type __const & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x3<T, P> & tmat2x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x3<T, P>& tmat2x3<T, P>::operator+=(tmat2x3<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(tmat2x3<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x3<T, P>& tmat2x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x3<T, P> & tmat2x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat2x3<T, P> & tmat2x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> & tmat2x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> tmat2x3<T, P>::operator++(int)
	{
		tmat2x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> tmat2x3<T, P>::operator--(int)
	{
		tmat2x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator+(tmat2x3<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator-(tmat2x3<T, P> __const & m)
	{
		return tmat2x3<T, P>(
			-m[0],
			-m[1]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P> 
	 __inline tmat2x3<T, P> operator+(tmat2x3<T, P> __const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P> operator+(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2)
	{
		return tmat2x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P> operator-(tmat2x3<T, P> __const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P> operator-(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2)
	{
		return tmat2x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x3<T, P> operator*(tmat2x3<T, P> __const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> __const & m)
	{
		return tmat2x3<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 __inline typename tmat2x3<T, P>::col_type operator*
	(
		tmat2x3<T, P> __const & m,
		typename tmat2x3<T, P>::row_type __const & v)
	{
		return typename tmat2x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}

	template <typename T, precision P>
	 __inline typename tmat2x3<T, P>::row_type operator*
	(
		typename tmat2x3<T, P>::col_type __const & v,
		tmat2x3<T, P> __const & m)
	{
		return typename tmat2x3<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator*(tmat2x3<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> operator*(tmat2x3<T, P> __const & m1, tmat3x2<T, P> __const & m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator*(tmat2x3<T, P> __const & m1, tmat4x2<T, P> __const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator/(tmat2x3<T, P> __const & m, T scalar)
	{
		return tmat2x3<T, P>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> __const & m)
	{
		return tmat2x3<T, P>(
			scalar / m[0],
			scalar / m[1]);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat2x3<T, P> __const & m1, tmat2x3<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} //namespace glm

# 164 "/usr/local/include/glm/detail/type_mat2x3.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat2x3.hpp" 2 3


namespace glm
{
	/// 2 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<float, lowp>		lowp_mat2x3;

	/// 2 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<float, mediump>		mediump_mat2x3;

	/// 2 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x3<float, highp>		highp_mat2x3;

}//namespace glm


# 25 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../mat2x4.hpp" 1 3
/// @ref core
/// @file glm/mat2x4.hpp




# 1 "/usr/local/include/glm/detail/type_mat2x4.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat2x4.hpp










namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x4<T, P> type;
		typedef tmat4x2<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		// -- Constructors --

		 tmat2x4() ;
		 tmat2x4(tmat2x4<T, P> __const & m) ;
		template <precision Q>
		 tmat2x4(tmat2x4<T, Q> __const & m);

		  explicit tmat2x4(ctor);
		 explicit tmat2x4(T scalar);
		 tmat2x4(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1);
		 tmat2x4(
			col_type __const & v0,
			col_type __const & v1);

		// -- Conversions --

		template <
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2>
		 tmat2x4(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2);

		template <typename U, typename V>
		 tmat2x4(
			tvec4<U, P> __const & v1,
			tvec4<V, P> __const & v2);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat2x4(tmat2x4<U, Q> __const & m);

		  tmat2x4(tmat2x2<T, P> __const & x);
		  tmat2x4(tmat3x3<T, P> __const & x);
		  tmat2x4(tmat4x4<T, P> __const & x);
		  tmat2x4(tmat2x3<T, P> __const & x);
		  tmat2x4(tmat3x2<T, P> __const & x);
		  tmat2x4(tmat3x4<T, P> __const & x);
		  tmat2x4(tmat4x2<T, P> __const & x);
		  tmat2x4(tmat4x3<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 2;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat2x4<T, P> & operator=(tmat2x4<T, P> __const & m) ;

		template <typename U>
		 tmat2x4<T, P> & operator=(tmat2x4<U, P> __const & m);
		template <typename U>
		 tmat2x4<T, P> & operator+=(U s);
		template <typename U>
		 tmat2x4<T, P> & operator+=(tmat2x4<U, P> __const & m);
		template <typename U>
		 tmat2x4<T, P> & operator-=(U s);
		template <typename U>
		 tmat2x4<T, P> & operator-=(tmat2x4<U, P> __const & m);
		template <typename U>
		 tmat2x4<T, P> & operator*=(U s);
		template <typename U>
		 tmat2x4<T, P> & operator/=(U s);

		// -- Increment and decrement operators --

		 tmat2x4<T, P> & operator++ ();
		 tmat2x4<T, P> & operator-- ();
		 tmat2x4<T, P> operator++(int);
		 tmat2x4<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat2x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> __const & m, typename tmat2x4<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type __const & v, tmat2x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat2x4<T, P> __const & m1, tmat4x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat2x4<T, P> __const & m1, tmat2x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat2x4<T, P> __const & m1, tmat3x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator/(tmat2x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> __const & m);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat2x4.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat2x4.inl

namespace glm
{
	// -- Constructors --


		template <typename T, precision P>
		 __inline tmat2x4<T, P>::tmat2x4()
		{

				this->value[0] = col_type(1, 0, 0, 0);
				this->value[1] = col_type(0, 1, 0, 0);

		}



		template <typename T, precision P>
		 __inline tmat2x4<T, P>::tmat2x4(tmat2x4<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat2x4<T, P>::tmat2x4(tmat2x4<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	 __inline  tmat2x4<T, P>::tmat2x4(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(T scalar)
	{
		value_type __const Zero(0);
		this->value[0] = col_type(scalar, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, scalar, Zero, Zero);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(col_type __const & v0, col_type __const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 __inline tmat2x4<T, P>::tmat2x4
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 __inline tmat2x4<T, P>::tmat2x4(tvec4<V1, P> __const & v1, tvec4<V2, P> __const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	// -- Matrix conversions --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat2x4<T, P>::tmat2x4(tmat2x4<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat2x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat2x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat3x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat3x4<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat4x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>::tmat2x4(tmat4x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat2x4<T, P>::col_type & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat2x4<T, P>::col_type __const & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(tmat2x4<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(tmat2x4<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x4<T, P> & tmat2x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P>& tmat2x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> tmat2x4<T, P>::operator++(int)
	{
		tmat2x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> tmat2x4<T, P>::operator--(int)
	{
		tmat2x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator+(tmat2x4<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator-(tmat2x4<T, P> __const & m)
	{
		return tmat2x4<T, P>(
			-m[0], 
			-m[1]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator+(tmat2x4<T, P> __const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P> 
	 __inline tmat2x4<T, P> operator+(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2)
	{
		return tmat2x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x4<T, P> operator-(tmat2x4<T, P> __const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator-(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2)
	{
		return tmat2x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator*(tmat2x4<T, P> __const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P> 
	 __inline tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> __const & m)
	{
		return tmat2x4<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 __inline typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> __const & m, typename tmat2x4<T, P>::row_type __const & v)
	{
		return typename tmat2x4<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}

	template <typename T, precision P>
	 __inline typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type __const & v, tmat2x4<T, P> __const & m)
	{
		return typename tmat2x4<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator*(tmat2x4<T, P> __const & m1, tmat4x2<T, P> __const & m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA03 = m1[0][3];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcA13 = m1[1][3];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		T SrcB30 = m2[3][0];
		T SrcB31 = m2[3][1];

		tmat4x4<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator*(tmat2x4<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator*(tmat2x4<T, P> __const & m1, tmat3x2<T, P> __const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x4<T, P> operator/(tmat2x4<T, P> __const & m, T scalar)
	{
		return tmat2x4<T, P>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> __const & m)
	{
		return tmat2x4<T, P>(
			scalar / m[0],
			scalar / m[1]);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat2x4<T, P> __const & m1, tmat2x4<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} //namespace glm

# 166 "/usr/local/include/glm/detail/type_mat2x4.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat2x4.hpp" 2 3


namespace glm
{
	/// 2 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<float, lowp>		lowp_mat2x4;
	
	/// 2 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<float, mediump>		mediump_mat2x4;
	
	/// 2 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x4<float, highp>		highp_mat2x4;

}//namespace glm

# 26 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../mat3x2.hpp" 1 3
/// @ref core
/// @file glm/mat3x2.hpp




# 1 "/usr/local/include/glm/detail/type_mat3x2.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat3x2.hpp










namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x2<T, P> type;
		typedef tmat2x3<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		// -- Constructors --

		 tmat3x2() ;
		 tmat3x2(tmat3x2<T, P> __const & m) ;
		template <precision Q>
		 tmat3x2(tmat3x2<T, Q> __const & m);

		  explicit tmat3x2(ctor);
		 explicit tmat3x2(T scalar);
		 tmat3x2(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2);
		 tmat3x2(
			col_type __const & v0,
			col_type __const & v1,
			col_type __const & v2);

		// -- Conversions --

		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		 tmat3x2(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template <typename V1, typename V2, typename V3>
		 tmat3x2(
			tvec2<V1, P> __const & v1,
			tvec2<V2, P> __const & v2,
			tvec2<V3, P> __const & v3);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat3x2(tmat3x2<U, Q> __const & m);

		  tmat3x2(tmat2x2<T, P> __const & x);
		  tmat3x2(tmat3x3<T, P> __const & x);
		  tmat3x2(tmat4x4<T, P> __const & x);
		  tmat3x2(tmat2x3<T, P> __const & x);
		  tmat3x2(tmat2x4<T, P> __const & x);
		  tmat3x2(tmat3x4<T, P> __const & x);
		  tmat3x2(tmat4x2<T, P> __const & x);
		  tmat3x2(tmat4x3<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 3;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat3x2<T, P> & operator=(tmat3x2<T, P> __const & m) ;

		template <typename U>
		 tmat3x2<T, P> & operator=(tmat3x2<U, P> __const & m);
		template <typename U>
		 tmat3x2<T, P> & operator+=(U s);
		template <typename U>
		 tmat3x2<T, P> & operator+=(tmat3x2<U, P> __const & m);
		template <typename U>
		 tmat3x2<T, P> & operator-=(U s);
		template <typename U>
		 tmat3x2<T, P> & operator-=(tmat3x2<U, P> __const & m);
		template <typename U>
		 tmat3x2<T, P> & operator*=(U s);
		template <typename U>
		 tmat3x2<T, P> & operator/=(U s);

		// -- Increment and decrement operators --

		 tmat3x2<T, P> & operator++ ();
		 tmat3x2<T, P> & operator-- ();
		 tmat3x2<T, P> operator++(int);
		 tmat3x2<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat3x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> __const & m, typename tmat3x2<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type __const & v, tmat3x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat3x2<T, P> __const & m1, tmat2x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat3x2<T, P> __const & m1, tmat3x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat3x2<T, P> __const & m1, tmat4x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator/(tmat3x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> __const & m);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2);

}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat3x2.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat3x2.inl

namespace glm
{
	// -- Constructors --


		template <typename T, precision P> 
		 __inline tmat3x2<T, P>::tmat3x2()
		{

				this->value[0] = col_type(1, 0);
				this->value[1] = col_type(0, 1);
				this->value[2] = col_type(0, 0);

		}



		template <typename T, precision P>
		 __inline tmat3x2<T, P>::tmat3x2(tmat3x2<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
			this->value[2] = m.value[2];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat3x2<T, P>::tmat3x2(tmat3x2<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 __inline  tmat3x2<T, P>::tmat3x2(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
		this->value[2] = col_type(0, 0);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2
	(
		col_type __const & v0,
		col_type __const & v1,
		col_type __const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3>
	 __inline tmat3x2<T, P>::tmat3x2
	(
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
	}

	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 __inline tmat3x2<T, P>::tmat3x2
	(
		tvec2<V1, P> __const & v1,
		tvec2<V2, P> __const & v2,
		tvec2<V3, P> __const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	// -- Matrix conversions --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat3x2<T, P>::tmat3x2(tmat3x2<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat2x2<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat2x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat2x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat3x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat4x2<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>::tmat3x2(tmat4x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat3x2<T, P>::col_type & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat3x2<T, P>::col_type __const & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			this->value[2] = m[2];
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(tmat3x2<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(tmat3x2<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x2<T, P> & tmat3x2<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P>& tmat3x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> tmat3x2<T, P>::operator++(int)
	{
		tmat3x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> tmat3x2<T, P>::operator--(int)
	{
		tmat3x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator+(tmat3x2<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P> 
	 __inline tmat3x2<T, P> operator-(tmat3x2<T, P> __const & m)
	{
		return tmat3x2<T, P>(
			-m[0],
			-m[1],
			-m[2]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator+(tmat3x2<T, P> __const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator+(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2)
	{
		return tmat3x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator-(tmat3x2<T, P> __const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template <typename T, precision P> 
	 __inline tmat3x2<T, P> operator-(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2)
	{
		return tmat3x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P> 
	 __inline tmat3x2<T, P> operator*(tmat3x2<T, P> __const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P> 
	 __inline tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> __const & m)
	{
		return tmat3x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
   
	template <typename T, precision P>
	 __inline typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> __const & m, typename tmat3x2<T, P>::row_type __const & v)
	{
		return typename tmat3x2<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}

	template <typename T, precision P>
	 __inline typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type __const & v, tmat3x2<T, P> __const & m)
	{
		return typename tmat3x2<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator*(tmat3x2<T, P> __const & m1, tmat2x3<T, P> __const & m2)
	{
		__const T SrcA00 = m1[0][0];
		__const T SrcA01 = m1[0][1];
		__const T SrcA10 = m1[1][0];
		__const T SrcA11 = m1[1][1];
		__const T SrcA20 = m1[2][0];
		__const T SrcA21 = m1[2][1];

		__const T SrcB00 = m2[0][0];
		__const T SrcB01 = m2[0][1];
		__const T SrcB02 = m2[0][2];
		__const T SrcB10 = m2[1][0];
		__const T SrcB11 = m2[1][1];
		__const T SrcB12 = m2[1][2];

		tmat2x2<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator*(tmat3x2<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator*(tmat3x2<T, P> __const & m1, tmat4x3<T, P> __const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator/(tmat3x2<T, P> __const & m, T scalar)
	{
		return tmat3x2<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template <typename T, precision P> 
	 __inline tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> __const & m)
	{
		return tmat3x2<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P> 
	 __inline bool operator!=(tmat3x2<T, P> __const & m1, tmat3x2<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} //namespace glm

# 172 "/usr/local/include/glm/detail/type_mat3x2.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat3x2.hpp" 2 3


namespace glm
{
	/// 3 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<float, lowp>		lowp_mat3x2;
	
	/// 3 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<float, mediump>		mediump_mat3x2;
	
	/// 3 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x2<float, highp>		highp_mat3x2;

}//namespace

# 27 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../mat3x3.hpp" 1 3
/// @ref core
/// @file glm/mat3x3.hpp




# 1 "/usr/local/include/glm/detail/type_mat3x3.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat3x3.hpp









namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x3<T, P> type;
		typedef tmat3x3<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		// -- Constructors --

		 tmat3x3() ;
		 tmat3x3(tmat3x3<T, P> __const & m) ;
		template <precision Q>
		 tmat3x3(tmat3x3<T, Q> __const & m);

		  explicit tmat3x3(ctor);
		 explicit tmat3x3(T scalar);
		 tmat3x3(
			T x0, T y0, T z0,
			T x1, T y1, T z1,
			T x2, T y2, T z2);
		 tmat3x3(
			col_type __const & v0,
			col_type __const & v1,
			col_type __const & v2);

		// -- Conversions --

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3>
		 tmat3x3(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2,
			X3 x3, Y3 y3, Z3 z3);

		template <typename V1, typename V2, typename V3>
		 tmat3x3(
			tvec3<V1, P> __const & v1,
			tvec3<V2, P> __const & v2,
			tvec3<V3, P> __const & v3);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat3x3(tmat3x3<U, Q> __const & m);

		  tmat3x3(tmat2x2<T, P> __const & x);
		  tmat3x3(tmat4x4<T, P> __const & x);
		  tmat3x3(tmat2x3<T, P> __const & x);
		  tmat3x3(tmat3x2<T, P> __const & x);
		  tmat3x3(tmat2x4<T, P> __const & x);
		  tmat3x3(tmat4x2<T, P> __const & x);
		  tmat3x3(tmat3x4<T, P> __const & x);
		  tmat3x3(tmat4x3<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 3;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat3x3<T, P> & operator=(tmat3x3<T, P> __const & m) ;

		template <typename U>
		 tmat3x3<T, P> & operator=(tmat3x3<U, P> __const & m);
		template <typename U>
		 tmat3x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator+=(tmat3x3<U, P> __const & m);
		template <typename U>
		 tmat3x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator-=(tmat3x3<U, P> __const & m);
		template <typename U>
		 tmat3x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator*=(tmat3x3<U, P> __const & m);
		template <typename U>
		 tmat3x3<T, P> & operator/=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator/=(tmat3x3<U, P> __const & m);

		// -- Increment and decrement operators --

		 tmat3x3<T, P> & operator++();
		 tmat3x3<T, P> & operator--();
		 tmat3x3<T, P> operator++(int);
		 tmat3x3<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat3x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> __const & m, typename tmat3x3<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type __const & v, tmat3x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat3x3<T, P> __const & m1, tmat2x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat3x3<T, P> __const & m1, tmat4x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(tmat3x3<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> __const & m, typename tmat3x3<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type __const & v, tmat3x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat3x3.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat3x3.inl



namespace glm
{
	// -- Constructors --


		template <typename T, precision P>
		 __inline tmat3x3<T, P>::tmat3x3()
		{

				this->value[0] = col_type(1, 0, 0);
				this->value[1] = col_type(0, 1, 0);
				this->value[2] = col_type(0, 0, 1);

		}



		template <typename T, precision P>
		 __inline tmat3x3<T, P>::tmat3x3(tmat3x3<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
			this->value[2] = m.value[2];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat3x3<T, P>::tmat3x3(tmat3x3<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 __inline  tmat3x3<T, P>::tmat3x3(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0);
		this->value[1] = col_type(0, scalar, 0);
		this->value[2] = col_type(0, 0, scalar);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1,
		T x2, T y2, T z2
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3
	(
		col_type __const & v0,
		col_type __const & v1,
		col_type __const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 __inline tmat3x3<T, P>::tmat3x3
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2,
		X3 x3, Y3 y3, Z3 z3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 __inline tmat3x3<T, P>::tmat3x3
	(
		tvec3<V1, P> __const & v1,
		tvec3<V2, P> __const & v2,
		tvec3<V3, P> __const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	// -- Matrix conversions --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat3x3<T, P>::tmat3x3(tmat3x3<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat2x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat2x3<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat3x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat2x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat4x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat3x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P>::tmat3x3(tmat4x3<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat3x3<T, P>::col_type & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat3x3<T, P>::col_type __const & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			this->value[2] = m[2];
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(tmat3x3<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(tmat3x3<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(tmat3x3<U, P> __const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(tmat3x3<U, P> __const & m)
	{
		return *this *= inverse(m);
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> & tmat3x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> tmat3x3<T, P>::operator++(int)
	{
		tmat3x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> tmat3x3<T, P>::operator--(int)
	{
		tmat3x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat3x3<T, P> operator+(tmat3x3<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> operator-(tmat3x3<T, P> __const & m)
	{
		return tmat3x3<T, P>(
			-m[0], 
			-m[1],
			-m[2]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator+(tmat3x3<T, P> __const & m, T scalar)
	{
		return tmat3x3<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> __const & m)
	{
		return tmat3x3<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator+(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		return tmat3x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator-(tmat3x3<T, P> __const & m, T scalar)
	{
		return tmat3x3<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> __const & m)
	{
		return tmat3x3<T, P>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2]);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator-(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		return tmat3x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator*(tmat3x3<T, P> __const & m, T scalar)
	{
		return tmat3x3<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> __const & m)
	{
		return tmat3x3<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P> 
	 __inline typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> __const & m, typename tmat3x3<T, P>::row_type __const & v)
	{
		return typename tmat3x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}

	template <typename T, precision P> 
	 __inline typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type __const & v, tmat3x3<T, P> __const & m)
	{
		return typename tmat3x3<T, P>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> operator*(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		T __const SrcA00 = m1[0][0];
		T __const SrcA01 = m1[0][1];
		T __const SrcA02 = m1[0][2];
		T __const SrcA10 = m1[1][0];
		T __const SrcA11 = m1[1][1];
		T __const SrcA12 = m1[1][2];
		T __const SrcA20 = m1[2][0];
		T __const SrcA21 = m1[2][1];
		T __const SrcA22 = m1[2][2];

		T __const SrcB00 = m2[0][0];
		T __const SrcB01 = m2[0][1];
		T __const SrcB02 = m2[0][2];
		T __const SrcB10 = m2[1][0];
		T __const SrcB11 = m2[1][1];
		T __const SrcB12 = m2[1][2];
		T __const SrcB20 = m2[2][0];
		T __const SrcB21 = m2[2][1];
		T __const SrcB22 = m2[2][2];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator*(tmat3x3<T, P> __const & m1, tmat2x3<T, P> __const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator*(tmat3x3<T, P> __const & m1, tmat4x3<T, P> __const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> operator/(tmat3x3<T, P> __const & m,	T scalar)
	{
		return tmat3x3<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> __const & m)
	{
		return tmat3x3<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	template <typename T, precision P>
	 __inline typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> __const & m, typename tmat3x3<T, P>::row_type __const & v)
	{
		return  inverse(m) * v;
	}

	template <typename T, precision P>
	 __inline typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type __const & v, tmat3x3<T, P> __const & m)
	{
		return v * inverse(m);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> operator/(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		tmat3x3<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat3x3<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} //namespace glm

# 189 "/usr/local/include/glm/detail/type_mat3x3.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat3x3.hpp" 2 3


namespace glm
{
	/// 3 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, lowp>		lowp_mat3;
	
	/// 3 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, mediump>		mediump_mat3;
	
	/// 3 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, highp>		highp_mat3;
	
	/// 3 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, lowp>		lowp_mat3x3;
	
	/// 3 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, mediump>		mediump_mat3x3;
	
	/// 3 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x3<float, highp>		highp_mat3x3;

}//namespace glm

# 28 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../mat3x4.hpp" 1 3
/// @ref core
/// @file glm/mat3x4.hpp




# 1 "/usr/local/include/glm/detail/type_mat3x4.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat3x4.hpp










namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x4<T, P> type;
		typedef tmat4x3<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		// -- Constructors --

		 tmat3x4() ;
		 tmat3x4(tmat3x4<T, P> __const & m) ;
		template <precision Q>
		 tmat3x4(tmat3x4<T, Q> __const & m);

		  explicit tmat3x4(ctor);
		 explicit tmat3x4(T scalar);
		 tmat3x4(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1,
			T x2, T y2, T z2, T w2);
		 tmat3x4(
			col_type __const & v0,
			col_type __const & v1,
			col_type __const & v2);

		// -- Conversions --

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3>
		 tmat3x4(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2,
			X3 x3, Y3 y3, Z3 z3, W3 w3);

		template <typename V1, typename V2, typename V3>
		 tmat3x4(
			tvec4<V1, P> __const & v1,
			tvec4<V2, P> __const & v2,
			tvec4<V3, P> __const & v3);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat3x4(tmat3x4<U, Q> __const & m);

		  tmat3x4(tmat2x2<T, P> __const & x);
		  tmat3x4(tmat3x3<T, P> __const & x);
		  tmat3x4(tmat4x4<T, P> __const & x);
		  tmat3x4(tmat2x3<T, P> __const & x);
		  tmat3x4(tmat3x2<T, P> __const & x);
		  tmat3x4(tmat2x4<T, P> __const & x);
		  tmat3x4(tmat4x2<T, P> __const & x);
		  tmat3x4(tmat4x3<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 3;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat3x4<T, P> & operator=(tmat3x4<T, P> __const & m) ;

		template <typename U>
		 tmat3x4<T, P> & operator=(tmat3x4<U, P> __const & m);
		template <typename U>
		 tmat3x4<T, P> & operator+=(U s);
		template <typename U>
		 tmat3x4<T, P> & operator+=(tmat3x4<U, P> __const & m);
		template <typename U>
		 tmat3x4<T, P> & operator-=(U s);
		template <typename U>
		 tmat3x4<T, P> & operator-=(tmat3x4<U, P> __const & m);
		template <typename U>
		 tmat3x4<T, P> & operator*=(U s);
		template <typename U>
		 tmat3x4<T, P> & operator/=(U s);

		// -- Increment and decrement operators --

		 tmat3x4<T, P> & operator++();
		 tmat3x4<T, P> & operator--();
		 tmat3x4<T, P> operator++(int);
		 tmat3x4<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat3x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat3x4<T, P>::col_type operator*(tmat3x4<T, P> __const & m, typename tmat3x4<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat3x4<T, P>::row_type operator*(typename tmat3x4<T, P>::col_type __const & v, tmat3x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat3x4<T, P> __const & m1,	tmat4x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat3x4<T, P> __const & m1, tmat2x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat3x4<T, P> __const & m1,	tmat3x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator/(tmat3x4<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> __const & m);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat3x4.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat3x4.inl

namespace glm
{
	// -- Constructors --


		template <typename T, precision P>
		 __inline tmat3x4<T, P>::tmat3x4()
		{

				this->value[0] = col_type(1, 0, 0, 0);
				this->value[1] = col_type(0, 1, 0, 0);
				this->value[2] = col_type(0, 0, 1, 0);

		}



		template <typename T, precision P>
		 __inline tmat3x4<T, P>::tmat3x4(tmat3x4<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
			this->value[2] = m.value[2];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat3x4<T, P>::tmat3x4(tmat3x4<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 __inline  tmat3x4<T, P>::tmat3x4(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0, 0);
		this->value[1] = col_type(0, scalar, 0, 0);
		this->value[2] = col_type(0, 0, scalar, 0);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1,
		T x2, T y2, T z2, T w2
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4
	(
		col_type __const & v0,
		col_type __const & v1,
		col_type __const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3>
	 __inline tmat3x4<T, P>::tmat3x4
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2,
		X3 x3, Y3 y3, Z3 z3, W3 w3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 __inline tmat3x4<T, P>::tmat3x4
	(
		tvec4<V1, P> __const & v1,
		tvec4<V2, P> __const & v2,
		tvec4<V3, P> __const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}
	
	// -- Matrix conversions --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat3x4<T, P>::tmat3x4(tmat3x4<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat2x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat2x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat3x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat2x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat4x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>::tmat3x4(tmat4x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat3x4<T, P>::col_type & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat3x4<T, P>::col_type __const & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			this->value[2] = m[2];
			return *this;
		}


	template <typename T, precision P> 
	template <typename U> 
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(tmat3x4<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(tmat3x4<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat3x4<T, P> & tmat3x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P>& tmat3x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> tmat3x4<T, P>::operator++(int)
	{
		tmat3x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> tmat3x4<T, P>::operator--(int)
	{
		tmat3x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator+(tmat3x4<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator-(tmat3x4<T, P> __const & m)
	{
		return tmat3x4<T, P>(
			-m[0],
			-m[1],
			-m[2]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator+(tmat3x4<T, P> __const & m, T scalar)
	{
		return tmat3x4<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator+(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2)
	{
		return tmat3x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator-(tmat3x4<T, P> __const & m,	T scalar)
	{
		return tmat3x4<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator-(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2)
	{
		return tmat3x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator*(tmat3x4<T, P> __const & m, T scalar)
	{
		return tmat3x4<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> __const & m)
	{
		return tmat3x4<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template <typename T, precision P>
	 __inline typename tmat3x4<T, P>::col_type operator*
	(
		tmat3x4<T, P> __const & m,
		typename tmat3x4<T, P>::row_type __const & v
	)
	{
		return typename tmat3x4<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}

	template <typename T, precision P>
	 __inline typename tmat3x4<T, P>::row_type operator*
	(
		typename tmat3x4<T, P>::col_type __const & v,
		tmat3x4<T, P> __const & m
	)
	{
		return typename tmat3x4<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator*(tmat3x4<T, P> __const & m1, tmat4x3<T, P> __const & m2)
	{
		__const T SrcA00 = m1[0][0];
		__const T SrcA01 = m1[0][1];
		__const T SrcA02 = m1[0][2];
		__const T SrcA03 = m1[0][3];
		__const T SrcA10 = m1[1][0];
		__const T SrcA11 = m1[1][1];
		__const T SrcA12 = m1[1][2];
		__const T SrcA13 = m1[1][3];
		__const T SrcA20 = m1[2][0];
		__const T SrcA21 = m1[2][1];
		__const T SrcA22 = m1[2][2];
		__const T SrcA23 = m1[2][3];

		__const T SrcB00 = m2[0][0];
		__const T SrcB01 = m2[0][1];
		__const T SrcB02 = m2[0][2];
		__const T SrcB10 = m2[1][0];
		__const T SrcB11 = m2[1][1];
		__const T SrcB12 = m2[1][2];
		__const T SrcB20 = m2[2][0];
		__const T SrcB21 = m2[2][1];
		__const T SrcB22 = m2[2][2];
		__const T SrcB30 = m2[3][0];
		__const T SrcB31 = m2[3][1];
		__const T SrcB32 = m2[3][2];

		tmat4x4<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator*(tmat3x4<T, P> __const & m1, tmat2x3<T, P> __const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator*(tmat3x4<T, P> __const & m1, tmat3x3<T, P> __const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator/(tmat3x4<T, P> __const & m,	T scalar)
	{
		return tmat3x4<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> __const & m)
	{
		return tmat3x4<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat3x4<T, P> __const & m1, tmat3x4<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} //namespace glm

# 171 "/usr/local/include/glm/detail/type_mat3x4.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat3x4.hpp" 2 3


namespace glm
{
	/// 3 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<float, lowp>		lowp_mat3x4;
	
	/// 3 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<float, mediump>		mediump_mat3x4;
	
	/// 3 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat3x4<float, highp>		highp_mat3x4;

}//namespace glm

# 29 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../mat4x2.hpp" 1 3
/// @ref core
/// @file glm/mat4x2.hpp




# 1 "/usr/local/include/glm/detail/type_mat4x2.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat4x2.hpp










namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x2<T, P> type;
		typedef tmat2x4<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		// -- Constructors --

		 tmat4x2() ;
		 tmat4x2(tmat4x2<T, P> __const & m) ;
		template <precision Q>
		 tmat4x2(tmat4x2<T, Q> __const & m);

		  explicit tmat4x2(ctor);
		 explicit tmat4x2(T scalar);
		 tmat4x2(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2,
			T x3, T y3);
		 tmat4x2(
			col_type __const & v0,
			col_type __const & v1,
			col_type __const & v2,
			col_type __const & v3);

		// -- Conversions --

		template <
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3,
			typename X4, typename Y4>
		 tmat4x2(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3,
			X4 x4, Y4 y4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x2(
			tvec2<V1, P> __const & v1,
			tvec2<V2, P> __const & v2,
			tvec2<V3, P> __const & v3,
			tvec2<V4, P> __const & v4);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat4x2(tmat4x2<U, Q> __const & m);

		  tmat4x2(tmat2x2<T, P> __const & x);
		  tmat4x2(tmat3x3<T, P> __const & x);
		  tmat4x2(tmat4x4<T, P> __const & x);
		  tmat4x2(tmat2x3<T, P> __const & x);
		  tmat4x2(tmat3x2<T, P> __const & x);
		  tmat4x2(tmat2x4<T, P> __const & x);
		  tmat4x2(tmat4x3<T, P> __const & x);
		  tmat4x2(tmat3x4<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 4;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat4x2<T, P> & operator=(tmat4x2<T, P> __const & m) ;

		template <typename U>
		 tmat4x2<T, P> & operator=(tmat4x2<U, P> __const & m);
		template <typename U>
		 tmat4x2<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x2<T, P> & operator+=(tmat4x2<U, P> __const & m);
		template <typename U>
		 tmat4x2<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x2<T, P> & operator-=(tmat4x2<U, P> __const & m);
		template <typename U>
		 tmat4x2<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x2<T, P> & operator/=(U s);

		// -- Increment and decrement operators --

		 tmat4x2<T, P> & operator++ ();
		 tmat4x2<T, P> & operator-- ();
		 tmat4x2<T, P> operator++(int);
		 tmat4x2<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> __const & m1, tmat4x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> __const & m1,	tmat4x2<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat4x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> __const & m, typename tmat4x2<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type __const & v, tmat4x2<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat4x2<T, P> __const & m1, tmat2x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat4x2<T, P> __const & m1, tmat3x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat4x2<T, P> __const & m1, tmat4x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator/(tmat4x2<T, P> __const & m, T scalar);

	template <typename T, precision P>
	 tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> __const & m);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat4x2<T, P> __const & m1, tmat4x2<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat4x2<T, P> __const & m1, tmat4x2<T, P> __const & m2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat4x2.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat4x2.inl

namespace glm
{






        
	// -- Constructors --


		template <typename T, precision P> 
		 __inline tmat4x2<T, P>::tmat4x2()
		{

				this->value[0] = col_type(1, 0);
				this->value[1] = col_type(0, 1);
				this->value[2] = col_type(0, 0);
				this->value[3] = col_type(0, 0);

		}



		template <typename T, precision P>
		 __inline tmat4x2<T, P>::tmat4x2(tmat4x2<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
			this->value[2] = m.value[2];
			this->value[3] = m.value[3];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat4x2<T, P>::tmat4x2(tmat4x2<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P>
	 __inline  tmat4x2<T, P>::tmat4x2(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
		this->value[2] = col_type(0, 0);
		this->value[3] = col_type(0, 0);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2,
		T x3, T y3
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
		this->value[3] = col_type(x3, y3);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2
	(
		col_type __const & v0,
		col_type __const & v1,
		col_type __const & v2,
		col_type __const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3,
		typename X4, typename Y4>
	 __inline tmat4x2<T, P>::tmat4x2
	(
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3,
		X4 x4, Y4 y4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 __inline tmat4x2<T, P>::tmat4x2
	(
		tvec2<V1, P> __const & v1,
		tvec2<V2, P> __const & v2,
		tvec2<V3, P> __const & v3,
		tvec2<V4, P> __const & v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	// -- Conversion --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat4x2<T, P>::tmat4x2(tmat4x2<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat2x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat2x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat3x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat2x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat4x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P>::tmat4x2(tmat3x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat4x2<T, P>::col_type & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat4x2<T, P>::col_type __const & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			this->value[2] = m[2];
			this->value[3] = m[3];
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(tmat4x2<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(tmat4x2<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> & tmat4x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> tmat4x2<T, P>::operator++(int)
	{
		tmat4x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> tmat4x2<T, P>::operator--(int)
	{
		tmat4x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator+(tmat4x2<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator-(tmat4x2<T, P> __const & m)
	{
		return tmat4x2<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator+(tmat4x2<T, P> __const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator+(tmat4x2<T, P> __const & m1, tmat4x2<T, P> __const & m2)
	{
		return tmat4x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator-(tmat4x2<T, P> __const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator-(tmat4x2<T, P> __const & m1, tmat4x2<T, P> __const & m2)
	{
		return tmat4x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator*(tmat4x2<T, P> __const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> __const & m)
	{
		return tmat4x2<T, P>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template <typename T, precision P>
	 __inline typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> __const & m, typename tmat4x2<T, P>::row_type __const & v)
	{
		return typename tmat4x2<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}

	template <typename T, precision P>
	 __inline typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type __const & v, tmat4x2<T, P> __const & m)
	{
		return typename tmat4x2<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator*(tmat4x2<T, P> __const & m1, tmat2x4<T, P> __const & m2)
	{
		T __const SrcA00 = m1[0][0];
		T __const SrcA01 = m1[0][1];
		T __const SrcA10 = m1[1][0];
		T __const SrcA11 = m1[1][1];
		T __const SrcA20 = m1[2][0];
		T __const SrcA21 = m1[2][1];
		T __const SrcA30 = m1[3][0];
		T __const SrcA31 = m1[3][1];

		T __const SrcB00 = m2[0][0];
		T __const SrcB01 = m2[0][1];
		T __const SrcB02 = m2[0][2];
		T __const SrcB03 = m2[0][3];
		T __const SrcB10 = m2[1][0];
		T __const SrcB11 = m2[1][1];
		T __const SrcB12 = m2[1][2];
		T __const SrcB13 = m2[1][3];

		tmat2x2<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator*(tmat4x2<T, P> __const & m1, tmat3x4<T, P> __const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator*(tmat4x2<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator/(tmat4x2<T, P> __const & m, T scalar)
	{
		return tmat4x2<T, P>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> __const & m)
	{
		return tmat4x2<T, P>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat4x2<T, P> __const & m1, tmat4x2<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat4x2<T, P> __const & m1, tmat4x2<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} //namespace glm

# 176 "/usr/local/include/glm/detail/type_mat4x2.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat4x2.hpp" 2 3


namespace glm
{
	/// 4 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<float, lowp>		lowp_mat4x2;
	
	/// 4 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<float, mediump>		mediump_mat4x2;
	
	/// 4 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x2<float, highp>		highp_mat4x2;

}//namespace glm

# 30 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../mat4x3.hpp" 1 3
/// @ref core
/// @file glm/mat4x3.hpp




# 1 "/usr/local/include/glm/detail/type_mat4x3.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat4x3.hpp










namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x3<T, P> type;
		typedef tmat3x4<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		// -- Constructors --

		 tmat4x3() ;
		 tmat4x3(tmat4x3<T, P> __const & m) ;
		template <precision Q>
		 tmat4x3(tmat4x3<T, Q> __const & m);

		  explicit tmat4x3(ctor);
		 explicit tmat4x3(T __const & x);
		 tmat4x3(
			T __const & x0, T __const & y0, T __const & z0,
			T __const & x1, T __const & y1, T __const & z1,
			T __const & x2, T __const & y2, T __const & z2,
			T __const & x3, T __const & y3, T __const & z3);
		 tmat4x3(
			col_type __const & v0,
			col_type __const & v1,
			col_type __const & v2,
			col_type __const & v3);

		// -- Conversions --

		template <
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3,
			typename X4, typename Y4, typename Z4>
		 tmat4x3(
			X1 __const & x1, Y1 __const & y1, Z1 __const & z1,
			X2 __const & x2, Y2 __const & y2, Z2 __const & z2,
			X3 __const & x3, Y3 __const & y3, Z3 __const & z3,
			X4 __const & x4, Y4 __const & y4, Z4 __const & z4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x3(
			tvec3<V1, P> __const & v1,
			tvec3<V2, P> __const & v2,
			tvec3<V3, P> __const & v3,
			tvec3<V4, P> __const & v4);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat4x3(tmat4x3<U, Q> __const & m);

		  tmat4x3(tmat2x2<T, P> __const & x);
		  tmat4x3(tmat3x3<T, P> __const & x);
		  tmat4x3(tmat4x4<T, P> __const & x);
		  tmat4x3(tmat2x3<T, P> __const & x);
		  tmat4x3(tmat3x2<T, P> __const & x);
		  tmat4x3(tmat2x4<T, P> __const & x);
		  tmat4x3(tmat4x2<T, P> __const & x);
		  tmat4x3(tmat3x4<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 4;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat4x3<T, P> & operator=(tmat4x3<T, P> __const & m) ;

		template <typename U>
		 tmat4x3<T, P> & operator=(tmat4x3<U, P> __const & m);
		template <typename U>
		 tmat4x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator+=(tmat4x3<U, P> __const & m);
		template <typename U>
		 tmat4x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator-=(tmat4x3<U, P> __const & m);
		template <typename U>
		 tmat4x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator/=(U s);

		// -- Increment and decrement operators --

		 tmat4x3<T, P> & operator++();
		 tmat4x3<T, P> & operator--();
		 tmat4x3<T, P> operator++(int);
		 tmat4x3<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat4x3<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(T __const & s, tmat4x3<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat4x3<T, P>::col_type operator*(tmat4x3<T, P> __const & m, typename tmat4x3<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat4x3<T, P>::row_type operator*(typename tmat4x3<T, P>::col_type __const & v, tmat4x3<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat4x3<T, P> __const & m1, tmat2x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat4x3<T, P> __const & m1,	tmat3x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat4x3<T, P> __const & m1, tmat4x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator/(tmat4x3<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator/(T __const & s, tmat4x3<T, P> __const & m);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat4x3.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat4x3.inl

namespace glm
{
	// -- Constructors --


		template <typename T, precision P>
		 __inline tmat4x3<T, P>::tmat4x3()
		{

				this->value[0] = col_type(1, 0, 0);
				this->value[1] = col_type(0, 1, 0);
				this->value[2] = col_type(0, 0, 1);
				this->value[3] = col_type(0, 0, 0);

		}



		template <typename T, precision P>
		 __inline tmat4x3<T, P>::tmat4x3(tmat4x3<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
			this->value[2] = m.value[2];
			this->value[3] = m.value[3];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat4x3<T, P>::tmat4x3(tmat4x3<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P>
	 __inline  tmat4x3<T, P>::tmat4x3(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(T __const & s)
	{
		this->value[0] = col_type(s, 0, 0);
		this->value[1] = col_type(0, s, 0);
		this->value[2] = col_type(0, 0, s);
		this->value[3] = col_type(0, 0, 0);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3
	(
		T __const & x0, T __const & y0, T __const & z0,
		T __const & x1, T __const & y1, T __const & z1,
		T __const & x2, T __const & y2, T __const & z2,
		T __const & x3, T __const & y3, T __const & z3
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
		this->value[3] = col_type(x3, y3, z3);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3
	(
		col_type __const & v0,
		col_type __const & v1,
		col_type __const & v2,
		col_type __const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3,
		typename X4, typename Y4, typename Z4>
	 __inline tmat4x3<T, P>::tmat4x3
	(
		X1 __const & x1, Y1 __const & y1, Z1 __const & z1,
		X2 __const & x2, Y2 __const & y2, Z2 __const & z2,
		X3 __const & x3, Y3 __const & y3, Z3 __const & z3,
		X4 __const & x4, Y4 __const & y4, Z4 __const & z4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 __inline tmat4x3<T, P>::tmat4x3
	(
		tvec3<V1, P> __const & v1,
		tvec3<V2, P> __const & v2,
		tvec3<V3, P> __const & v3,
		tvec3<V4, P> __const & v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	// -- Matrix conversions --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat4x3<T, P>::tmat4x3(tmat4x3<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat2x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat2x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat3x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat2x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat4x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(m[3], 0);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P>::tmat4x3(tmat3x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat4x3<T, P>::col_type & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat4x3<T, P>::col_type __const & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			this->value[2] = m[2];
			this->value[3] = m[3];
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(tmat4x3<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(tmat4x3<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> & tmat4x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> tmat4x3<T, P>::operator++(int)
	{
		tmat4x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> tmat4x3<T, P>::operator--(int)
	{
		tmat4x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator+(tmat4x3<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator-(tmat4x3<T, P> __const & m)
	{
		return tmat4x3<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator+(tmat4x3<T, P> __const & m, T __const & s)
	{
		return tmat4x3<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator+(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2)
	{
		return tmat4x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator-(tmat4x3<T, P> __const & m, T __const & s)
	{
		return tmat4x3<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator-(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2)
	{
		return tmat4x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator*(tmat4x3<T, P> __const & m, T __const & s)
	{
		return tmat4x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator*(T __const & s, tmat4x3<T, P> __const & m)
	{
		return tmat4x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 __inline typename tmat4x3<T, P>::col_type operator*
	(
		tmat4x3<T, P> __const & m,
		typename tmat4x3<T, P>::row_type __const & v)
	{
		return typename tmat4x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}

	template <typename T, precision P>
	 __inline typename tmat4x3<T, P>::row_type operator*
	(
		typename tmat4x3<T, P>::col_type __const & v,
		tmat4x3<T, P> __const & m)
	{
		return typename tmat4x3<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> operator*(tmat4x3<T, P> __const & m1, tmat2x4<T, P> __const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> operator*(tmat4x3<T, P> __const & m1, tmat3x4<T, P> __const & m2)
	{
		T __const SrcA00 = m1[0][0];
		T __const SrcA01 = m1[0][1];
		T __const SrcA02 = m1[0][2];
		T __const SrcA10 = m1[1][0];
		T __const SrcA11 = m1[1][1];
		T __const SrcA12 = m1[1][2];
		T __const SrcA20 = m1[2][0];
		T __const SrcA21 = m1[2][1];
		T __const SrcA22 = m1[2][2];
		T __const SrcA30 = m1[3][0];
		T __const SrcA31 = m1[3][1];
		T __const SrcA32 = m1[3][2];

		T __const SrcB00 = m2[0][0];
		T __const SrcB01 = m2[0][1];
		T __const SrcB02 = m2[0][2];
		T __const SrcB03 = m2[0][3];
		T __const SrcB10 = m2[1][0];
		T __const SrcB11 = m2[1][1];
		T __const SrcB12 = m2[1][2];
		T __const SrcB13 = m2[1][3];
		T __const SrcB20 = m2[2][0];
		T __const SrcB21 = m2[2][1];
		T __const SrcB22 = m2[2][2];
		T __const SrcB23 = m2[2][3];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator*(tmat4x3<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator/(tmat4x3<T, P> __const & m, T __const & s)
	{
		return tmat4x3<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> operator/(T __const & s, tmat4x3<T, P> __const & m)
	{
		return tmat4x3<T, P>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat4x3<T, P> __const & m1, tmat4x3<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} //namespace glm

# 176 "/usr/local/include/glm/detail/type_mat4x3.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat4x3.hpp" 2 3


namespace glm
{
	/// 4 columns of 3 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<float, lowp>		lowp_mat4x3;
	
	/// 4 columns of 3 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<float, mediump>		mediump_mat4x3;
	
	/// 4 columns of 3 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x3<float, highp>		highp_mat4x3;

}//namespace glm

# 31 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../mat4x4.hpp" 1 3
/// @ref core
/// @file glm/mat4x4.hpp




# 1 "/usr/local/include/glm/detail/type_mat4x4.hpp" 1 3
/// @ref core
/// @file glm/detail/type_mat4x4.hpp









namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x4<T, P> type;
		typedef tmat4x4<T, P> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		// -- Constructors --

		 tmat4x4() ;
		 tmat4x4(tmat4x4<T, P> __const & m) ;
		template <precision Q>
		 tmat4x4(tmat4x4<T, Q> __const & m);

		 explicit tmat4x4(ctor);
		 explicit tmat4x4(T __const & x);
		 tmat4x4(
			T __const & x0, T __const & y0, T __const & z0, T __const & w0,
			T __const & x1, T __const & y1, T __const & z1, T __const & w1,
			T __const & x2, T __const & y2, T __const & z2, T __const & w2,
			T __const & x3, T __const & y3, T __const & z3, T __const & w3);
		 tmat4x4(
			col_type __const & v0,
			col_type __const & v1,
			col_type __const & v2,
			col_type __const & v3);

		// -- Conversions --

		template <
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3,
			typename X4, typename Y4, typename Z4, typename W4>
		 tmat4x4(
			X1 __const & x1, Y1 __const & y1, Z1 __const & z1, W1 __const & w1,
			X2 __const & x2, Y2 __const & y2, Z2 __const & z2, W2 __const & w2,
			X3 __const & x3, Y3 __const & y3, Z3 __const & z3, W3 __const & w3,
			X4 __const & x4, Y4 __const & y4, Z4 __const & z4, W4 __const & w4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x4(
			tvec4<V1, P> __const & v1,
			tvec4<V2, P> __const & v2,
			tvec4<V3, P> __const & v3,
			tvec4<V4, P> __const & v4);

		// -- Matrix conversions --

		template <typename U, precision Q>
		  tmat4x4(tmat4x4<U, Q> __const & m);

		  tmat4x4(tmat2x2<T, P> __const & x);
		  tmat4x4(tmat3x3<T, P> __const & x);
		  tmat4x4(tmat2x3<T, P> __const & x);
		  tmat4x4(tmat3x2<T, P> __const & x);
		  tmat4x4(tmat2x4<T, P> __const & x);
		  tmat4x4(tmat4x2<T, P> __const & x);
		  tmat4x4(tmat3x4<T, P> __const & x);
		  tmat4x4(tmat4x3<T, P> __const & x);

		// -- Accesses --

		typedef length_t length_type;
		 static length_type length(){return 4;}

		 col_type & operator[](length_type i);
		 col_type __const & operator[](length_type i) __const;

		// -- Unary arithmetic operators --

		 tmat4x4<T, P> & operator=(tmat4x4<T, P> __const & m) ;

		template <typename U>
		 tmat4x4<T, P> & operator=(tmat4x4<U, P> __const & m);
		template <typename U>
		 tmat4x4<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator+=(tmat4x4<U, P> __const & m);
		template <typename U>
		 tmat4x4<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator-=(tmat4x4<U, P> __const & m);
		template <typename U>
		 tmat4x4<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator*=(tmat4x4<U, P> __const & m);
		template <typename U>
		 tmat4x4<T, P> & operator/=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator/=(tmat4x4<U, P> __const & m);

		// -- Increment and decrement operators --

		 tmat4x4<T, P> & operator++();
		 tmat4x4<T, P> & operator--();
		 tmat4x4<T, P> operator++(int);
		 tmat4x4<T, P> operator--(int);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(tmat4x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(tmat4x4<T, P> __const & m);

	// -- Binary operators --

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(tmat4x4<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(T __const & s, tmat4x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(tmat4x4<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(T __const & s, tmat4x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(tmat4x4<T, P> __const & m1,	tmat4x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat4x4<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(T __const & s, tmat4x4<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> __const & m, typename tmat4x4<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type __const & v, tmat4x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat4x4<T, P> __const & m1, tmat2x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat4x4<T, P> __const & m1, tmat3x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(tmat4x4<T, P> __const & m, T __const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(T __const & s, tmat4x4<T, P> __const & m);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> __const & m, typename tmat4x4<T, P>::row_type __const & v);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type __const & v, tmat4x4<T, P> __const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(tmat4x4<T, P> __const & m1,	tmat4x4<T, P> __const & m2);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2);

	template <typename T, precision P>
	 bool operator!=(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat4x4.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat4x4.inl



namespace glm
{
	// -- Constructors --


		template <typename T, precision P>
		 __inline tmat4x4<T, P>::tmat4x4()
		{

				this->value[0] = col_type(1, 0, 0, 0);
				this->value[1] = col_type(0, 1, 0, 0);
				this->value[2] = col_type(0, 0, 1, 0);
				this->value[3] = col_type(0, 0, 0, 1);

		}



		template <typename T, precision P>
		 __inline tmat4x4<T, P>::tmat4x4(tmat4x4<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			this->value[2] = m[2];
			this->value[3] = m[3];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(T __const & s)
	{
		this->value[0] = col_type(s, 0, 0, 0);
		this->value[1] = col_type(0, s, 0, 0);
		this->value[2] = col_type(0, 0, s, 0);
		this->value[3] = col_type(0, 0, 0, s);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4
	(
		T __const & x0, T __const & y0, T __const & z0, T __const & w0,
		T __const & x1, T __const & y1, T __const & z1, T __const & w1,
		T __const & x2, T __const & y2, T __const & z2, T __const & w2,
		T __const & x3, T __const & y3, T __const & z3, T __const & w3
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
		this->value[3] = col_type(x3, y3, z3, w3);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4
	(
		col_type __const & v0,
		col_type __const & v1,
		col_type __const & v2,
		col_type __const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat4x4<T, P>::tmat4x4
	(
		tmat4x4<U, Q> __const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	// -- Conversions --

	template <typename T, precision P> 
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3,
		typename X4, typename Y4, typename Z4, typename W4>
	 __inline tmat4x4<T, P>::tmat4x4
	(
		X1 __const & x1, Y1 __const & y1, Z1 __const & z1, W1 __const & w1,
		X2 __const & x2, Y2 __const & y2, Z2 __const & z2, W2 __const & w2,
		X3 __const & x3, Y3 __const & y3, Z3 __const & z3, W3 __const & w3,
		X4 __const & x4, Y4 __const & y4, Z4 __const & z4, W4 __const & w4
	)
	{
		;
		;
		;
		;

		;
		;
		;
		;

		;
		;
		;
		;

		;
		;
		;
		;

		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 __inline tmat4x4<T, P>::tmat4x4
	(
		tvec4<V1, P> __const & v1,
		tvec4<V2, P> __const & v2,
		tvec4<V3, P> __const & v3,
		tvec4<V4, P> __const & v4
	)		
	{
		;
		;
		;
		;

		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	// -- Matrix conversions --

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(m[3], 1);
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat4x4<T, P>::col_type __const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary arithmetic operators --


		template <typename T, precision P>
		 __inline tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<T, P> __const & m)
		{
			//memcpy could be faster
			//memcpy(&this->value, &m.value, 16 * sizeof(valType));
			this->value[0] = m[0];
			this->value[1] = m[1];
			this->value[2] = m[2];
			this->value[3] = m[3];
			return *this;
		}


	template <typename T, precision P> 
	template <typename U> 
	 __inline tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> __const & m)
	{
		//memcpy could be faster
		//memcpy(&this->value, &m.value, 16 * sizeof(valType));
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> __const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> __const & m)
	{
		return *this *= inverse(m);
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> & tmat4x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> tmat4x4<T, P>::operator++(int)
	{
		tmat4x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> tmat4x4<T, P>::operator--(int)
	{
		tmat4x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary constant operators --

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator+(tmat4x4<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator-(tmat4x4<T, P> __const & m)
	{
		return tmat4x4<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator+(tmat4x4<T, P> __const & m, T __const & s)
	{
		return tmat4x4<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator+(T __const & s, tmat4x4<T, P> __const & m)
	{
		return tmat4x4<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator+(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		return tmat4x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator-(tmat4x4<T, P> __const & m, T __const & s)
	{
		return tmat4x4<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator-(T __const & s, tmat4x4<T, P> __const & m)
	{
		return tmat4x4<T, P>(
			s - m[0],
			s - m[1],
			s - m[2],
			s - m[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator-(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		return tmat4x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator*(tmat4x4<T, P> __const & m, T __const  & s)
	{
		return tmat4x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator*(T __const & s, tmat4x4<T, P> __const & m)
	{
		return tmat4x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 __inline typename tmat4x4<T, P>::col_type operator*
	(
		tmat4x4<T, P> __const & m,
		typename tmat4x4<T, P>::row_type __const & v
	)
	{

# 524 "/usr/local/include/glm/detail/type_mat4x4.inl" 3


		typename tmat4x4<T, P>::col_type __const Mov0(v[0]);
		typename tmat4x4<T, P>::col_type __const Mov1(v[1]);
		typename tmat4x4<T, P>::col_type __const Mul0 = m[0] * Mov0;
		typename tmat4x4<T, P>::col_type __const Mul1 = m[1] * Mov1;
		typename tmat4x4<T, P>::col_type __const Add0 = Mul0 + Mul1;
		typename tmat4x4<T, P>::col_type __const Mov2(v[2]);
		typename tmat4x4<T, P>::col_type __const Mov3(v[3]);
		typename tmat4x4<T, P>::col_type __const Mul2 = m[2] * Mov2;
		typename tmat4x4<T, P>::col_type __const Mul3 = m[3] * Mov3;
		typename tmat4x4<T, P>::col_type __const Add1 = Mul2 + Mul3;
		typename tmat4x4<T, P>::col_type __const Add2 = Add0 + Add1;
		return Add2;








	}

	template <typename T, precision P>
	 __inline typename tmat4x4<T, P>::row_type operator*
	(
		typename tmat4x4<T, P>::col_type __const & v,
		tmat4x4<T, P> __const & m
	)
	{
		return typename tmat4x4<T, P>::row_type(
			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> operator*(tmat4x4<T, P> __const & m1, tmat2x4<T, P> __const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> operator*(tmat4x4<T, P> __const & m1, tmat3x4<T, P> __const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator*(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		typename tmat4x4<T, P>::col_type __const SrcA0 = m1[0];
		typename tmat4x4<T, P>::col_type __const SrcA1 = m1[1];
		typename tmat4x4<T, P>::col_type __const SrcA2 = m1[2];
		typename tmat4x4<T, P>::col_type __const SrcA3 = m1[3];

		typename tmat4x4<T, P>::col_type __const SrcB0 = m2[0];
		typename tmat4x4<T, P>::col_type __const SrcB1 = m2[1];
		typename tmat4x4<T, P>::col_type __const SrcB2 = m2[2];
		typename tmat4x4<T, P>::col_type __const SrcB3 = m2[3];

		tmat4x4<T, P> Result(uninitialize);
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator/(tmat4x4<T, P> __const & m, T __const & s)
	{
		return tmat4x4<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator/(T __const & s,	tmat4x4<T, P> __const & m)
	{
		return tmat4x4<T, P>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	template <typename T, precision P>
	 __inline typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> __const & m, typename tmat4x4<T, P>::row_type __const & v)
	{
		return inverse(m) * v;
	}

	template <typename T, precision P>
	 __inline typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type __const & v, tmat4x4<T, P> __const & m)
	{
		return v * inverse(m);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> operator/(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		tmat4x4<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat4x4<T, P> __const & m1, tmat4x4<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_mat4x4_simd.inl" 1 3
/// @ref core
/// @file glm/detail/type_mat4x4_sse2.inl

namespace glm
{

}//namespace glm

# 670 "/usr/local/include/glm/detail/type_mat4x4.inl" 2 3



# 194 "/usr/local/include/glm/detail/type_mat4x4.hpp" 2 3



# 6 "/usr/local/include/glm/detail/../mat4x4.hpp" 2 3


namespace glm
{
	/// 4 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, lowp>		lowp_mat4;
	
	/// 4 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, mediump>		mediump_mat4;
	
	/// 4 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, highp>		highp_mat4;
	
	/// 4 columns of 4 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, lowp>		lowp_mat4x4;
	
	/// 4 columns of 4 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, mediump>		mediump_mat4x4;
	
	/// 4 columns of 4 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat4x4<float, highp>		highp_mat4x4;

}//namespace glm

# 32 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


namespace glm{
namespace detail
{
	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec2>
	{
		typedef tmat2x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec3>
	{
		typedef tmat3x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec4>
	{
		typedef tmat4x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec2>
	{
		typedef tmat2x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec3>
	{
		typedef tmat3x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec4>
	{
		typedef tmat4x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec2>
	{
		typedef tmat2x4<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec3>
	{
		typedef tmat3x4<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec4>
	{
		typedef tmat4x4<T, P> type;
	};

}//namespace detail

	/// @addtogroup core_func_matrix
	/// @{

	/// Multiply matrix x by matrix y component-wise, i.e., 
	/// result[i][j] is the scalar product of x[i][j] and y[i][j].
	/// 
	/// @tparam matType Floating-point matrix types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/matrixCompMult.xml">GLSL matrixCompMult man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.6 Matrix Functions</a>
	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> matrixCompMult(matType<T, P> __const & x, matType<T, P> __const & y);

	/// Treats the first parameter c as a column vector
	/// and the second parameter r as a row vector
	/// and does a linear algebraic matrix multiply c * r.
	/// 
	/// @tparam matType Floating-point matrix types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/outerProduct.xml">GLSL outerProduct man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.6 Matrix Functions</a>
	template <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
	 typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> __const & c, vecTypeB<T, P> __const & r);

	/// Returns the transposed matrix of x
	/// 
	/// @tparam matType Floating-point matrix types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/transpose.xml">GLSL transpose man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.6 Matrix Functions</a>



        
	
	/// Return the determinant of a squared matrix.
	/// 
	/// @tparam valType Floating-point scalar types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/determinant.xml">GLSL determinant man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.6 Matrix Functions</a>	
	template <typename T, precision P, template <typename, precision> class matType>
	 T determinant(matType<T, P> __const & m);

	/// Return the inverse of a squared matrix.
	/// 
	/// @tparam valType Floating-point scalar types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/inverse.xml">GLSL inverse man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.6 Matrix Functions</a>	 
	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> inverse(matType<T, P> __const & m);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_matrix.inl" 1 3
/// @ref core
/// @file glm/detail/func_matrix.inl


# 1 "/usr/local/include/glm/detail/../geometric.hpp" 1 3
/// @ref core
/// @file glm/geometric.hpp




# 1 "/usr/local/include/glm/detail/func_geometric.hpp" 1 3
/// @ref core
/// @file glm/detail/func_geometric.hpp
///
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
/// 
/// @defgroup core_func_geometric Geometric functions
/// @ingroup core
/// 
/// These operate on vectors as vectors, not component-wise.





namespace glm
{
	/// @addtogroup core_func_geometric
	/// @{

	/// Returns the length of x, i.e., sqrt(x * x).
	/// 
	/// @tparam genType Floating-point vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/length.xml">GLSL length man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 T length(
		vecType<T, P> __const & x);

	/// Returns the distance betwwen p0 and p1, i.e., length(p0 - p1).
	///
	/// @tparam genType Floating-point vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/distance.xml">GLSL distance man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 T distance(
		vecType<T, P> __const & p0,
		vecType<T, P> __const & p1);

	/// Returns the dot product of x and y, i.e., result = x * y.
	///
	/// @tparam genType Floating-point vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/dot.xml">GLSL dot man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 T dot(
		vecType<T, P> __const & x,
		vecType<T, P> __const & y);

	/// Returns the cross product of x and y.
	///
	/// @tparam valType Floating-point scalar types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/cross.xml">GLSL cross man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename T, precision P>
	 tvec3<T, P> cross(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y);

	/// Returns a vector in the same direction as x but with length of 1.
	/// According to issue 10 GLSL 1.10 specification, if length(x) == 0 then result is undefined and generate an error.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/normalize.xml">GLSL normalize man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> normalize(
		vecType<T, P> __const & x);

	/// If dot(Nref, I) < 0.0, return N, otherwise, return -N.
	///
	/// @tparam genType Floating-point vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/faceforward.xml">GLSL faceforward man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> faceforward(
		vecType<T, P> __const & N,
		vecType<T, P> __const & I,
		vecType<T, P> __const & Nref);

	/// For the incident vector I and surface orientation N, 
	/// returns the reflection direction : result = I - 2.0 * dot(N, I) * N.
	///
	/// @tparam genType Floating-point vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/reflect.xml">GLSL reflect man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename genType>
	 genType reflect(
		genType __const & I,
		genType __const & N);

	/// For the incident vector I and surface normal N, 
	/// and the ratio of indices of refraction eta, 
	/// return the refraction vector.
	///
	/// @tparam genType Floating-point vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/refract.xml">GLSL refract man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.5 Geometric Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> refract(
		vecType<T, P> __const & I,
		vecType<T, P> __const & N,
		T eta);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_geometric.inl" 1 3
/// @ref core
/// @file glm/detail/func_geometric.inl


# 1 "/usr/local/include/glm/detail/func_exponential.hpp" 1 3
/// @ref core
/// @file glm/detail/func_exponential.hpp
/// 
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
///
/// @defgroup core_func_exponential Exponential functions
/// @ingroup core
/// 
/// These all operate component-wise. The description is per component.




# 1 "/usr/local/include/glm/detail/type_vec1.hpp" 1 3
/// @ref core
/// @file glm/detail/type_vec1.hpp











                     


namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec1
	{
		// -- Implementation detail --

		typedef T value_type;
		typedef tvec1<T, P> type;
		typedef tvec1<bool, P> bool_type;

		// -- Data --


# 69 "/usr/local/include/glm/detail/type_vec1.hpp" 3
        
			union {T x, r, s;};






		// -- Component accesses --

		/// Return the count of components of the vector
		typedef length_t length_type;
		 static length_type length(){return 1;}

		 T & operator[](length_type i);
		 T __const & operator[](length_type i) __const;

		// -- Implicit basic constructors --

		  tvec1() ;
		  tvec1(tvec1<T, P> __const & v) ;
		template <precision Q>
		  tvec1(tvec1<T, Q> __const & v);

		// -- Explicit basic constructors --

		  explicit tvec1(ctor);
		  explicit tvec1(T scalar);

		// -- Conversion vector constructors --

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec1(tvec2<U, Q> __const & v);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec1(tvec3<U, Q> __const & v);
		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec1(tvec4<U, Q> __const & v);

		/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)
		template <typename U, precision Q>
		   tvec1(tvec1<U, Q> __const & v);

		// -- Swizzle constructors --









		// -- Unary arithmetic operators --

		 tvec1<T, P> & operator=(tvec1<T, P> __const & v) ;

		template <typename U>
		 tvec1<T, P> & operator=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator+=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator+=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator-=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator-=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator*=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator*=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator/=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator/=(tvec1<U, P> __const & v);

		// -- Increment and decrement operators --

		 tvec1<T, P> & operator++();
		 tvec1<T, P> & operator--();
		 tvec1<T, P> operator++(int);
		 tvec1<T, P> operator--(int);

		// -- Unary bit operators --

		template <typename U>
		 tvec1<T, P> & operator%=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator%=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator&=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator&=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator|=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator|=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator^=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator^=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator<<=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator<<=(tvec1<U, P> __const & v);
		template <typename U>
		 tvec1<T, P> & operator>>=(U scalar);
		template <typename U>
		 tvec1<T, P> & operator>>=(tvec1<U, P> __const & v);
	};

	// -- Unary operators --

	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator-(tvec1<T, P> __const & v);

	// -- Binary operators --

	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator+(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator-(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator-(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator-	(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator*(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator*(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator*(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator/(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator/(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator/(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator%(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator%(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator%(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator&(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator&(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator&(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator|(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator|(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator|(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator^(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator^(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator^(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(tvec1<T, P> __const & v, T scalar);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(T scalar, tvec1<T, P> __const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator~(tvec1<T, P> __const & v);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2);

	template <precision P>
	 tvec1<bool, P> operator&&(tvec1<bool, P> __const & v1, tvec1<bool, P> __const & v2);

	template <precision P>
	 tvec1<bool, P> operator||(tvec1<bool, P> __const & v1, tvec1<bool, P> __const & v2);
}//namespace glm



# 1 "/usr/local/include/glm/detail/type_vec1.inl" 1 3
/// @ref core
/// @file glm/detail/type_vec1.inl

namespace glm
{
	// -- Implicit basic constructors --


		template <typename T, precision P>
		 __inline  tvec1<T, P>::tvec1()

				: x(0)

		{}



		template <typename T, precision P>
		 __inline  tvec1<T, P>::tvec1(tvec1<T, P> __const & v)
			: x(v.x)
		{}


	template <typename T, precision P>
	template <precision Q>
	 __inline  tvec1<T, P>::tvec1(tvec1<T, Q> __const & v)
		: x(v.x)
	{}

	// -- Explicit basic constructors --

	template <typename T, precision P>
	 __inline  tvec1<T, P>::tvec1(ctor)
	{}

	template <typename T, precision P>
	 __inline  tvec1<T, P>::tvec1(T scalar)
		: x(scalar)
	{}

	// -- Conversion vector constructors --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec1<T, P>::tvec1(tvec1<U, Q> __const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec1<T, P>::tvec1(tvec2<U, Q> __const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec1<T, P>::tvec1(tvec3<U, Q> __const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tvec1<T, P>::tvec1(tvec4<U, Q> __const & v)
		: x(static_cast<T>(v.x))
	{}

	// -- Component accesses --

	template <typename T, precision P>
	 __inline T & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i)
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	template <typename T, precision P>
	 __inline T __const & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i) __const
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	// -- Unary arithmetic operators --


		template <typename T, precision P>
		 __inline tvec1<T, P> & tvec1<T, P>::operator=(tvec1<T, P> __const & v)
		{
			this->x = v.x;
			return *this;
		}


	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator=(tvec1<U, P> __const & v)
	{
		this->x = static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator+=(tvec1<U, P> __const & v)
	{
		this->x += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator-=(tvec1<U, P> __const & v)
	{
		this->x -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator*=(tvec1<U, P> __const & v)
	{
		this->x *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator/=(tvec1<U, P> __const & v)
	{
		this->x /= static_cast<T>(v.x);
		return *this;
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tvec1<T, P> & tvec1<T, P>::operator++()
	{
		++this->x;
		return *this;
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> & tvec1<T, P>::operator--()
	{
		--this->x;
		return *this;
	}

	template <typename T, precision P> 
	 __inline tvec1<T, P> tvec1<T, P>::operator++(int)
	{
		tvec1<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 __inline tvec1<T, P> tvec1<T, P>::operator--(int)
	{
		tvec1<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary bit operators --

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator%=(tvec1<U, P> __const & v)
	{
		this->x %= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator&=(tvec1<U, P> __const & v)
	{
		this->x &= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator|=(tvec1<U, P> __const & v)
	{
		this->x |= U(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator^=(tvec1<U, P> __const & v)
	{
		this->x ^= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator<<=(tvec1<U, P> __const & v)
	{
		this->x <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 __inline tvec1<T, P> & tvec1<T, P>::operator>>=(tvec1<U, P> __const & v)
	{
		this->x >>= static_cast<T>(v.x);
		return *this;
	}

	// -- Unary constant operators --

	template <typename T, precision P>
	 __inline tvec1<T, P> operator+(tvec1<T, P> __const & v)
	{
		return v;
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator-(tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			-v.x);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P> 
	 __inline tvec1<T, P> operator+(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x + scalar);
	}

	template <typename T, precision P> 
	 __inline tvec1<T, P> operator+(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar + v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator+(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x + v2.x);
	}

	//operator-
	template <typename T, precision P> 
	 __inline tvec1<T, P> operator-(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x - scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator-(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar - v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator-(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x - v2.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator*(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x * scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator*(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar * v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator*(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x * v2.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator/(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x / scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator/(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar / v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator/(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x / v2.x);
	}

	// -- Binary bit operators --

	template <typename T, precision P>
	 __inline tvec1<T, P> operator%(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x % scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator%(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar % v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator%(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x % v2.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator&(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x & scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator&(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar & v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator&(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x & v2.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator|(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x | scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator|(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar | v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator|(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x | v2.x);
	}
		
	template <typename T, precision P>
	 __inline tvec1<T, P> operator^(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x ^ scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator^(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar ^ v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator^(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x ^ v2.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator<<(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x << scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator<<(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar << v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator<<(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x << v2.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator>>(tvec1<T, P> __const & v, T scalar)
	{
		return tvec1<T, P>(
			v.x >> scalar);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator>>(T scalar, tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			scalar >> v.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator>>(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return tvec1<T, P>(
			v1.x >> v2.x);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> operator~(tvec1<T, P> __const & v)
	{
		return tvec1<T, P>(
			~v.x);
	}

	// -- Boolean operators --

	template <typename T, precision P> 
	 __inline bool operator==(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return (v1.x == v2.x);
	}

	template <typename T, precision P> 
	 __inline bool operator!=(tvec1<T, P> __const & v1, tvec1<T, P> __const & v2)
	{
		return (v1.x != v2.x);
	}

	template <precision P>
	 __inline tvec1<bool, P> operator&&(tvec1<bool, P> __const & v1, tvec1<bool, P> __const & v2)
	{
		return tvec1<bool, P>(v1.x && v2.x);
	}

	template <precision P>
	 __inline tvec1<bool, P> operator||(tvec1<bool, P> __const & v1, tvec1<bool, P> __const & v2)
	{
		return tvec1<bool, P>(v1.x || v2.x);
	}
}//namespace glm

# 301 "/usr/local/include/glm/detail/type_vec1.hpp" 2 3



# 13 "/usr/local/include/glm/detail/func_exponential.hpp" 2 3






namespace glm
{
	/// @addtogroup core_func_exponential
	/// @{

	/// Returns 'base' raised to the power 'exponent'. 
	///
	/// @param base Floating point value. pow function is defined for input values of 'base' defined in the range (inf-, inf+) in the limit of the type precision.
	/// @param exponent Floating point value representing the 'exponent'.
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/pow.xml">GLSL pow man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> pow(vecType<T, P> __const & base, vecType<T, P> __const & exponent);

	/// Returns the natural exponentiation of x, i.e., e^x.
	///
	/// @param v exp function is defined for input values of v defined in the range (inf-, inf+) in the limit of the type precision.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/exp.xml">GLSL exp man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> exp(vecType<T, P> __const & v);

	/// Returns the natural logarithm of v, i.e., 
	/// returns the value y which satisfies the equation x = e^y. 
	/// Results are undefined if v <= 0.
	///
	/// @param v log function is defined for input values of v defined in the range (0, inf+) in the limit of the type precision.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/log.xml">GLSL log man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> log(vecType<T, P> __const & v);

	/// Returns 2 raised to the v power.
	/// 
	/// @param v exp2 function is defined for input values of v defined in the range (inf-, inf+) in the limit of the type precision.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/exp2.xml">GLSL exp2 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> exp2(vecType<T, P> __const & v);

	/// Returns the base 2 log of x, i.e., returns the value y, 
	/// which satisfies the equation x = 2 ^ y.
	/// 
	/// @param v log2 function is defined for input values of v defined in the range (0, inf+) in the limit of the type precision.
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/log2.xml">GLSL log2 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> log2(vecType<T, P> __const & v);

	/// Returns the positive square root of v.
	/// 
	/// @param v sqrt function is defined for input values of v defined in the range [0, inf+) in the limit of the type precision.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/sqrt.xml">GLSL sqrt man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
	//template <typename genType>
	// genType sqrt(genType __const & x);
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sqrt(vecType<T, P> __const & v);
	
	/// Returns the reciprocal of the positive square root of v.
	/// 
	/// @param v inversesqrt function is defined for input values of v defined in the range [0, inf+) in the limit of the type precision.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/inversesqrt.xml">GLSL inversesqrt man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.2 Exponential Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> inversesqrt(vecType<T, P> __const & v);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_exponential.inl" 1 3
/// @ref core
/// @file glm/detail/func_exponential.inl


# 1 "/usr/local/include/glm/detail/func_vector_relational.hpp" 1 3
/// @ref core
/// @file glm/detail/func_vector_relational.hpp
///
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
/// 
/// @defgroup core_func_vector_relational Vector Relational Functions
/// @ingroup core
/// 
/// Relational and equality operators (<, <=, >, >=, ==, !=) are defined to 
/// operate on scalars and produce scalar Boolean results. For vector results, 
/// use the following built-in functions. 
/// 
/// In all cases, the sizes of all the input and return vectors for any particular 
/// call must match.






namespace glm
{
	/// @addtogroup core_func_vector_relational
	/// @{

	/// Returns the component-wise comparison result of x < y.
	/// 
	/// @tparam vecType Floating-point or integer vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/lessThan.xml">GLSL lessThan man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> lessThan(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns the component-wise comparison of result x <= y.
	///
	/// @tparam vecType Floating-point or integer vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/lessThanEqual.xml">GLSL lessThanEqual man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> lessThanEqual(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns the component-wise comparison of result x > y.
	///
	/// @tparam vecType Floating-point or integer vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/greaterThan.xml">GLSL greaterThan man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> greaterThan(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns the component-wise comparison of result x >= y.
	///
	/// @tparam vecType Floating-point or integer vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/greaterThanEqual.xml">GLSL greaterThanEqual man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> greaterThanEqual(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns the component-wise comparison of result x == y.
	///
	/// @tparam vecType Floating-point, integer or boolean vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/equal.xml">GLSL equal man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> equal(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns the component-wise comparison of result x != y.
	/// 
	/// @tparam vecType Floating-point, integer or boolean vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/notEqual.xml">GLSL notEqual man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> notEqual(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns true if any component of x is true.
	///
	/// @tparam vecType Boolean vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/any.xml">GLSL any man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 bool any(vecType<bool, P> __const & v);

	/// Returns true if all components of x are true.
	///
	/// @tparam vecType Boolean vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/all.xml">GLSL all man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 bool all(vecType<bool, P> __const & v);

	/// Returns the component-wise logical complement of x.
	/// /!\ Because of language incompatibilities between C++ and GLSL, GLM defines the function not but not_ instead.
	///
	/// @tparam vecType Boolean vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/not.xml">GLSL not man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.7 Vector Relational Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 vecType<bool, P> not_(vecType<bool, P> __const & v);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_vector_relational.inl" 1 3
/// @ref core
/// @file glm/detail/func_vector_relational.inl



namespace glm
{
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> lessThan(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		assert(x.length() == y.length());

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] < y[i];

		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> lessThanEqual(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		assert(x.length() == y.length());

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> greaterThan(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		assert(x.length() == y.length());

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> greaterThanEqual(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		assert(x.length() == y.length());

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> equal(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		assert(x.length() == y.length());

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> notEqual(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		assert(x.length() == y.length());

		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline bool any(vecType<bool, P> __const & v)
	{
		bool Result = false;
		for(length_t i = 0; i < v.length(); ++i)
			Result = Result || v[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline bool all(vecType<bool, P> __const & v)
	{
		bool Result = true;
		for(length_t i = 0; i < v.length(); ++i)
			Result = Result && v[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> not_(vecType<bool, P> __const & v)
	{
		vecType<bool, P> Result(uninitialize);
		for(length_t i = 0; i < v.length(); ++i)
			Result[i] = !v[i];
		return Result;
	}
}//namespace glm



       

# 111 "/usr/local/include/glm/detail/func_vector_relational.hpp" 2 3


# 4 "/usr/local/include/glm/detail/func_exponential.inl" 2 3


# 1 "/usr/local/include/glm/detail/_vectorize.hpp" 1 3
/// @ref core
/// @file glm/detail/_vectorize.hpp








namespace glm{
namespace detail
{
	template <typename R, typename T, precision P, template <typename, precision> class vecType>
	struct functor1{};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec1>
	{
		 __inline static tvec1<R, P> call(R (*Func) (T x), tvec1<T, P> __const & v)
		{
			return tvec1<R, P>(Func(v.x));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec2>
	{
		 __inline static tvec2<R, P> call(R (*Func) (T x), tvec2<T, P> __const & v)
		{
			return tvec2<R, P>(Func(v.x), Func(v.y));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec3>
	{
		 __inline static tvec3<R, P> call(R (*Func) (T x), tvec3<T, P> __const & v)
		{
			return tvec3<R, P>(Func(v.x), Func(v.y), Func(v.z));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec4>
	{
		 __inline static tvec4<R, P> call(R (*Func) (T x), tvec4<T, P> __const & v)
		{
			return tvec4<R, P>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct functor2{};

	template <typename T, precision P>
	struct functor2<T, P, tvec1>
	{
		 __inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> __const & a, tvec1<T, P> __const & b)
		{
			return tvec1<T, P>(Func(a.x, b.x));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec2>
	{
		 __inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> __const & a, tvec2<T, P> __const & b)
		{
			return tvec2<T, P>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec3>
	{
		 __inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> __const & a, tvec3<T, P> __const & b)
		{
			return tvec3<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec4>
	{
		 __inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> __const & a, tvec4<T, P> __const & b)
		{
			return tvec4<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct functor2_vec_sca{};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec1>
	{
		 __inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> __const & a, T b)
		{
			return tvec1<T, P>(Func(a.x, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec2>
	{
		 __inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> __const & a, T b)
		{
			return tvec2<T, P>(Func(a.x, b), Func(a.y, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec3>
	{
		 __inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> __const & a, T b)
		{
			return tvec3<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec4>
	{
		 __inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> __const & a, T b)
		{
			return tvec4<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
		}
	};
}//namespace detail
}//namespace glm

# 5 "/usr/local/include/glm/detail/func_exponential.inl" 2 3





namespace glm{
namespace detail
{


       
		template <typename genType>
		genType log2(genType Value)
		{
			return std::log(Value) * static_cast<genType>(1.4426950408889634073599246810019);
		}


	template <typename T, precision P, template <class, precision> class vecType, bool isFloat, bool Aligned>
	struct compute_log2
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & vec)
		{
			return detail::functor1<T, T, P, vecType>::call(log2, vec);
		}
	};

	template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_sqrt
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(std::sqrt, x);
		}
	};

	template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_inversesqrt
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return static_cast<T>(1) / sqrt(x);
		}
	};
		
	template <template <class, precision> class vecType, bool Aligned>
	struct compute_inversesqrt<vecType, float, lowp, Aligned>
	{
		 __inline static vecType<float, lowp> call(vecType<float, lowp> __const & x)
		{
			vecType<float, lowp> tmp(x);
			vecType<float, lowp> xhalf(tmp * 0.5f);
			vecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));
			vecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));
			vecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);
			tmp = *ptmp;
			tmp = tmp * (1.5f - xhalf * tmp * tmp);
			return tmp;
		}
	};
}//namespace detail

	// pow
	using std::pow;
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> pow(vecType<T, P> __const & base, vecType<T, P> __const & exponent)
	{
		return detail::functor2<T, P, vecType>::call(pow, base, exponent);
	}

	// exp
	using std::exp;
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> exp(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(exp, x);
	}

	// log
	using std::log;
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> log(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(log, x);
	}

	//exp2, ln2 = 0.69314718055994530941723212145818f
	template <typename genType>
	 __inline genType exp2(genType x)
	{
		;

		return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> exp2(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(exp2, x);
	}

	// log2, ln2 = 0.69314718055994530941723212145818f
	template <typename genType>
	 __inline genType log2(genType x)
	{
		return log2(tvec1<genType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> log2(vecType<T, P> __const & x)
	{
		return detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
	}

	// sqrt
	using std::sqrt;
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> sqrt(vecType<T, P> __const & x)
	{
		;
		return detail::compute_sqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
	}

	// inversesqrt
	template <typename genType>
	 __inline genType inversesqrt(genType x)
	{
		return static_cast<genType>(1) / sqrt(x);
	}
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> inversesqrt(vecType<T, P> __const & x)
	{
		;
		return detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
	}
}//namespace glm



       


# 103 "/usr/local/include/glm/detail/func_exponential.hpp" 2 3


# 4 "/usr/local/include/glm/detail/func_geometric.inl" 2 3


# 1 "/usr/local/include/glm/detail/func_common.hpp" 1 3
/// @ref core
/// @file glm/detail/func_common.hpp
/// 
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
///
/// @defgroup core_func_common Common functions
/// @ingroup core
/// 
/// These all operate component-wise. The description is per component.







# 1 "/usr/local/include/glm/detail/_fixes.hpp" 1 3
/// @ref core
/// @file glm/detail/_fixes.hpp



//! Workaround for compatibility with other libraries


       

//! Workaround for compatibility with other libraries


       

//! Workaround for Android


       

//! Workaround for Android


       

//! Workaround for Chrone Native Client


       


# 16 "/usr/local/include/glm/detail/func_common.hpp" 2 3


namespace glm
{
	/// @addtogroup core_func_common
	/// @{

	/// Returns x if x >= 0; otherwise, it returns -x.
	/// 
	/// @tparam genType floating-point or __signed integer; scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/abs.xml">GLSL abs man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType abs(genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> abs(vecType<T, P> __const & x);

	/// Returns 1.0 if x > 0, 0.0 if x == 0, or -1.0 if x < 0. 
	/// 
	/// @tparam genType Floating-point or __signed integer; scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/sign.xml">GLSL sign man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sign(vecType<T, P> __const & x);

	/// Returns a value equal to the nearest integer that is less then or equal to x. 
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floor.xml">GLSL floor man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> floor(vecType<T, P> __const & x);

	/// Returns a value equal to the nearest integer to x
	/// whose absolute value is not larger than the absolute value of x.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/trunc.xml">GLSL trunc man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> trunc(vecType<T, P> __const & x);

	/// Returns a value equal to the nearest integer to x.
	/// The fraction 0.5 will round in a direction chosen by the
	/// implementation, presumably the direction that is fastest.
	/// This includes the possibility that round(x) returns the
	/// same value as roundEven(x) for all values of x.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/round.xml">GLSL round man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> round(vecType<T, P> __const & x);

	/// Returns a value equal to the nearest integer to x.
	/// A fractional part of 0.5 will round toward the nearest even
	/// integer. (Both 3.5 and 4.5 for x will return 4.0.)
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/roundEven.xml">GLSL roundEven man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	/// @see <a href="http://developer.amd.com/documentation/articles/pages/New-Round-to-Even-Technique.aspx">New round to even technique</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> roundEven(vecType<T, P> __const & x);

	/// Returns a value equal to the nearest integer
	/// that is greater than or equal to x.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/ceil.xml">GLSL ceil man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> ceil(vecType<T, P> __const & x);

	/// Return x - floor(x).
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/fract.xml">GLSL fract man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType fract(genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fract(vecType<T, P> __const & x);

	/// Modulus. Returns x - y * floor(x / y)
	/// for each component in x using the floating point value y.
	///
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/mod.xml">GLSL mod man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType mod(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> __const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns the fractional part of x and sets i to the integer
	/// part (as a whole number floating point value). Both the
	/// return value and the output parameter will have the same
	/// sign as x.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/modf.xml">GLSL modf man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType modf(genType x, genType & i);

	/// Returns y if y < x; otherwise, it returns x.
	///
	/// @tparam genType Floating-point or integer; scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/min.xml">GLSL min man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType min(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> min(vecType<T, P> __const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> min(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns y if x < y; otherwise, it returns x.
	/// 
	/// @tparam genType Floating-point or integer; scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/max.xml">GLSL max man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType max(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> max(vecType<T, P> __const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> max(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns min(max(x, minVal), maxVal) for each component in x 
	/// using the floating-point values minVal and maxVal.
	///
	/// @tparam genType Floating-point or integer; scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/clamp.xml">GLSL clamp man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType clamp(genType x, genType minVal, genType maxVal);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> clamp(vecType<T, P> __const & x, T minVal, T maxVal);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> clamp(vecType<T, P> __const & x, vecType<T, P> __const & minVal, vecType<T, P> __const & maxVal);

	/// If genTypeU is a floating scalar or vector:
	/// Returns x * (1.0 - a) + y * a, i.e., the linear blend of
	/// x and y using the floating-point value a.
	/// The value for a is not restricted to the range [0, 1].
	/// 
	/// If genTypeU is a boolean scalar or vector:
	/// Selects which vector each returned component comes
	/// from. For a component of <a> that is false, the
	/// corresponding component of x is returned. For a
	/// component of a that is true, the corresponding
	/// component of y is returned. Components of x and y that
	/// are not selected are allowed to be invalid floating point
	/// values and will have no effect on the results. Thus, this
	/// provides different functionality than
	/// genType mix(genType x, genType y, genType(a))
	/// where a is a Boolean vector.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/mix.xml">GLSL mix man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	/// 
	/// @param[in]  x Value to interpolate.
	/// @param[in]  y Value to interpolate.
	/// @param[in]  a Interpolant.
	/// 
	/// @tparam	genTypeT Floating point scalar or vector.
	/// @tparam genTypeU Floating point or boolean scalar or vector. It can't be a vector if it is the length of genTypeT.
	/// 
	/// @code
	/// #include <glm/glm.hpp>
	/// ...
	/// float a;
	/// bool b;
	/// glm::dvec3 e;
	/// glm::dvec3 f;
	/// glm::vec4 g;
	/// glm::vec4 h;
	/// ...
	/// glm::vec4 r = glm::mix(g, h, a); // Interpolate with a floating-point scalar two vectors. 
	/// glm::vec4 s = glm::mix(g, h, b); // Teturns g or h;
	/// glm::dvec3 t = glm::mix(e, f, a); // Types of the third parameter is not required to match with the first and the second.
	/// glm::vec4 u = glm::mix(g, h, r); // Interpolations can be perform per component with a vector for the last parameter.
	/// @endcode
	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mix(vecType<T, P> __const & x, vecType<T, P> __const & y, vecType<U, P> __const & a);

	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mix(vecType<T, P> __const & x, vecType<T, P> __const & y, U a);

	template <typename genTypeT, typename genTypeU>
	 genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

	/// Returns 0.0 if x < edge, otherwise it returns 1.0 for each component of a genType.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/step.xml">GLSL step man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType step(genType edge, genType x);

	/// Returns 0.0 if x < edge, otherwise it returns 1.0.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/step.xml">GLSL step man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <template <typename, precision> class vecType, typename T, precision P>
	 vecType<T, P> step(T edge, vecType<T, P> __const & x);

	/// Returns 0.0 if x < edge, otherwise it returns 1.0.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/step.xml">GLSL step man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <template <typename, precision> class vecType, typename T, precision P>
	 vecType<T, P> step(vecType<T, P> __const & edge, vecType<T, P> __const & x);

	/// Returns 0.0 if x <= edge0 and 1.0 if x >= edge1 and
	/// performs smooth Hermite interpolation between 0 and 1
	/// when edge0 < x < edge1. This is useful in cases where
	/// you would want a threshold function with a smooth
	/// transition. This is equivalent to:
	/// genType t;
	/// t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);
	/// return t * t * (3 - 2 * t);
	/// Results are undefined if edge0 >= edge1.
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/smoothstep.xml">GLSL smoothstep man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType smoothstep(genType edge0, genType edge1, genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> __const & x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> smoothstep(vecType<T, P> __const & edge0, vecType<T, P> __const & edge1, vecType<T, P> __const & x);

	/// Returns true if x holds a NaN (not a number)
	/// representation in the underlying implementation's set of
	/// floating point representations. Returns false otherwise,
	/// including for implementations with no NaN
	/// representations.
	/// 
	/// /!\ When using compiler fast math, this function may fail.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/isnan.xml">GLSL isnan man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isnan(vecType<T, P> __const & x);

	/// Returns true if x holds a positive infinity or negative
	/// infinity representation in the underlying implementation's
	/// set of floating point representations. Returns false
	/// otherwise, including for implementations with no infinity
	/// representations.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/isinf.xml">GLSL isinf man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isinf(vecType<T, P> __const & x);

	/// Returns a __signed integer value representing
	/// the encoding of a floating-point value. The floating-point
	/// value's bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToInt.xml">GLSL floatBitsToInt man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	 int floatBitsToInt(float __const & v);

	/// Returns a __signed integer value representing
	/// the encoding of a floating-point value. The floatingpoint
	/// value's bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToInt.xml">GLSL floatBitsToInt man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <template <typename, precision> class vecType, precision P>
	 vecType<int, P> floatBitsToInt(vecType<float, P> __const & v);

	/// Returns a unsigned integer value representing
	/// the encoding of a floating-point value. The floatingpoint
	/// value's bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToUint.xml">GLSL floatBitsToUint man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	 uint floatBitsToUint(float __const & v);

	/// Returns a unsigned integer value representing
	/// the encoding of a floating-point value. The floatingpoint
	/// value's bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/floatBitsToUint.xml">GLSL floatBitsToUint man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <template <typename, precision> class vecType, precision P>
	 vecType<uint, P> floatBitsToUint(vecType<float, P> __const & v);

	/// Returns a floating-point value corresponding to a __signed
	/// integer encoding of a floating-point value.
	/// If an inf or NaN is passed in, it will not signal, and the
	/// resulting floating point value is unspecified. Otherwise,
	/// the bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/intBitsToFloat.xml">GLSL intBitsToFloat man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	 float intBitsToFloat(int __const & v);

	/// Returns a floating-point value corresponding to a __signed
	/// integer encoding of a floating-point value.
	/// If an inf or NaN is passed in, it will not signal, and the
	/// resulting floating point value is unspecified. Otherwise,
	/// the bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/intBitsToFloat.xml">GLSL intBitsToFloat man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <template <typename, precision> class vecType, precision P>
	 vecType<float, P> intBitsToFloat(vecType<int, P> __const & v);

	/// Returns a floating-point value corresponding to a
	/// unsigned integer encoding of a floating-point value.
	/// If an inf or NaN is passed in, it will not signal, and the
	/// resulting floating point value is unspecified. Otherwise,
	/// the bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/uintBitsToFloat.xml">GLSL uintBitsToFloat man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	 float uintBitsToFloat(uint __const & v);

	/// Returns a floating-point value corresponding to a
	/// unsigned integer encoding of a floating-point value.
	/// If an inf or NaN is passed in, it will not signal, and the
	/// resulting floating point value is unspecified. Otherwise,
	/// the bit-level representation is preserved.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/uintBitsToFloat.xml">GLSL uintBitsToFloat man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <template <typename, precision> class vecType, precision P>
	 vecType<float, P> uintBitsToFloat(vecType<uint, P> __const & v);

	/// Computes and returns a * b + c.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/fma.xml">GLSL fma man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType>
	 genType fma(genType __const & a, genType __const & b, genType __const & c);

	/// Splits x into a floating-point significand in the range
	/// [0.5, 1.0) and an integral exponent of two, such that:
	/// x = significand * exp(2, exponent)
	/// 
	/// The significand is returned by the function and the
	/// exponent is returned in the parameter exp. For a
	/// floating-point value of zero, the significant and exponent
	/// are both zero. For a floating-point value that is an
	/// infinity or is not a number, the results are undefined.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/frexp.xml">GLSL frexp man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType, typename genIType>
	 genType frexp(genType __const & x, genIType & exp);

	/// Builds a floating-point number from x and the
	/// corresponding integral exponent of two in exp, returning:
	/// significand * exp(2, exponent)
	/// 
	/// If this product is too large to be represented in the
	/// floating-point type, the result is undefined.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	///  
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/ldexp.xml">GLSL ldexp man page</a>; 
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genType, typename genIType>
	 genType ldexp(genType __const & x, genIType __const & exp);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_common.inl" 1 3
/// @ref core
/// @file glm/detail/func_common.inl








namespace glm
{
	// min
	template <typename genType>
	 __inline genType min(genType x, genType y)
	{
		;
		return x < y ? x : y;
	}

	// max
	template <typename genType>
	 __inline genType max(genType x, genType y)
	{
		;

		return x > y ? x : y;
	}

	// abs
	template <>
	 __inline int32 abs(int32 x)
	{
		int32 __const y = x >> 31;
		return (x ^ y) - y;
	}

	// round


       
		template <typename genType>
		 __inline genType round(genType x)
		{
			;

			return x < static_cast<genType>(0) ? static_cast<genType>(int(x - static_cast<genType>(0.5))) : static_cast<genType>(int(x + static_cast<genType>(0.5)));
		}


	// trunc


       
		template <typename genType>
		 __inline genType trunc(genType x)
		{
			;

			return x < static_cast<genType>(0) ? -std::floor(-x) : std::floor(x);
		}


}//namespace glm

namespace glm{
namespace detail
{
	template <typename genFIType, bool >
	struct compute_abs
	{};

	template <typename genFIType>
	struct compute_abs<genFIType, true>
	{
		 __inline static genFIType call(genFIType x)
		{
			

                                                                           ;

			return x >= genFIType(0) ? x : -x;
			// TODO, perf comp with: *(((int *) &x) + 1) &= 0x7fffffff;
		}
	};

	
# 96 "/usr/local/include/glm/detail/func_common.inl" 3
        

	template <typename genFIType>
	struct compute_abs<genFIType, false>
	{
		 __inline static genFIType call(genFIType x)
		{
			

                                                                           ;
			return x;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_abs_vector
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(abs, x);
		}
	};

	template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_vector
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, vecType<T, P> __const & y, vecType<U, P> __const & a)
		{
			;

			return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_vector<T, bool, P, vecType, Aligned>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, vecType<T, P> __const & y, vecType<bool, P> __const & a)
		{
			vecType<T, P> Result(uninitialize);
			for(length_t i = 0; i < x.length(); ++i)
				Result[i] = a[i] ? y[i] : x[i];
			return Result;
		}
	};

	template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_scalar
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, vecType<T, P> __const & y, U __const & a)
		{
			;

			return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mix_scalar<T, bool, P, vecType, Aligned>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, vecType<T, P> __const & y, bool __const & a)
		{
			return a ? y : x;
		}
	};

	template <typename T, typename U>
	struct compute_mix
	{
		 __inline static T call(T __const & x, T __const & y, U __const & a)
		{
			;

			return static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));
		}
	};

	template <typename T>
	struct compute_mix<T, bool>
	{
		 __inline static T call(T __const & x, T __const & y, bool __const & a)
		{
			return a ? y : x;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool isFloat, bool Aligned>
	struct compute_sign
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return vecType<T, P>(glm::lessThan(vecType<T, P>(0), x)) - vecType<T, P>(glm::lessThan(x, vecType<T, P>(0)));
		}
	};


# 203 "/usr/local/include/glm/detail/func_common.inl" 3
        

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_floor
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(std::floor, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_ceil
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(std::ceil, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_fract
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return x - floor(x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_trunc
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(trunc, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_round
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			return detail::functor1<T, T, P, vecType>::call(round, x);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_mod
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & a, vecType<T, P> __const & b)
		{
			;
			return a - b * floor(a / b);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_min_vector
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, vecType<T, P> __const & y)
		{
			return detail::functor2<T, P, vecType>::call(min, x, y);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_max_vector
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, vecType<T, P> __const & y)
		{
			return detail::functor2<T, P, vecType>::call(max, x, y);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_clamp_vector
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, vecType<T, P> __const & minVal, vecType<T, P> __const & maxVal)
		{
			return min(max(x, minVal), maxVal);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_step_vector
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & edge, vecType<T, P> __const & x)
		{
			return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, edge));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_smoothstep_vector
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & edge0, vecType<T, P> __const & edge1, vecType<T, P> __const & x)
		{
			;
			vecType<T, P> __const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
			return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
		}
	};
}//namespace detail

	template <typename genFIType>
	 __inline genFIType abs(genFIType x)
	{
		return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> abs(vecType<T, P> __const & x)
	{
		return detail::compute_abs_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	// sign
	// fast and works for any type
	template <typename genFIType> 
	 __inline genFIType sign(genFIType x)
	{
		

                                      ;
		
		return detail::compute_sign<genFIType, defaultp, tvec1, std::numeric_limits<genFIType>::is_iec559, highp>::call(tvec1<genFIType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> sign(vecType<T, P> __const & x)
	{
		

                                      ;

		return detail::compute_sign<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
	}

	// floor
	using ::std::floor;
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> floor(vecType<T, P> __const & x)
	{
		;
		return detail::compute_floor<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> trunc(vecType<T, P> __const & x)
	{
		;
		return detail::compute_trunc<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> round(vecType<T, P> __const & x)
	{
		;
		return detail::compute_round<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}


# 374 "/usr/local/include/glm/detail/func_common.inl" 3


	// roundEven
	template <typename genType>
	 __inline genType roundEven(genType x)
	{
		;
		
		int Integer = static_cast<int>(x);
		genType IntegerPart = static_cast<genType>(Integer);
		genType FractionalPart = fract(x);

		if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= static_cast<genType>(0)) // Work around... 
		{
			return IntegerPart - static_cast<genType>(1);
		}
		else
		{
			return IntegerPart + static_cast<genType>(1);
		}
		//else // Bug on MinGW 4.5.2
		//{
		//	return mix(IntegerPart + genType(-1), IntegerPart + genType(1), x <= genType(0));
		//}
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> roundEven(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(roundEven, x);
	}

	// ceil
	using ::std::ceil;
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> ceil(vecType<T, P> __const & x)
	{
		;
		return detail::compute_ceil<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	// fract
	template <typename genType>
	 __inline genType fract(genType x)
	{
		return fract(tvec1<genType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fract(vecType<T, P> __const & x)
	{
		;
		return detail::compute_fract<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	// mod
	template <typename genType>
	 __inline genType mod(genType x, genType y)
	{




        
			return mod(tvec1<genType, defaultp>(x), y).x;

	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> mod(vecType<T, P> __const & x, T y)
	{
		return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(y));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> mod(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, y);
	}

	// modf
	template <typename genType>
	 __inline genType modf(genType x, genType & i)
	{
		;
		return std::modf(x, &i);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> modf(tvec1<T, P> __const & x, tvec1<T, P> & i)
	{
		return tvec1<T, P>(
			modf(x.x, i.x));
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> modf(tvec2<T, P> __const & x, tvec2<T, P> & i)
	{
		return tvec2<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> modf(tvec3<T, P> __const & x, tvec3<T, P> & i)
	{
		return tvec3<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> modf(tvec4<T, P> __const & x, tvec4<T, P> & i)
	{
		return tvec4<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}

	//// Only valid if (INT_MIN <= x-y <= INT_MAX)
	//// min(x,y)
	//r = y + ((x - y) & ((x - y) >> (sizeof(int) *
	//CHAR_BIT - 1)));
	//// max(x,y)
	//r = x - ((x - y) & ((x - y) >> (sizeof(int) *
	//CHAR_BIT - 1)));

	// min
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> min(vecType<T, P> __const & a, T b)
	{
		;
		return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> min(vecType<T, P> __const & a, vecType<T, P> __const & b)
	{
		return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
	}

	// max
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> max(vecType<T, P> __const & a, T b)
	{
		;
		return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> max(vecType<T, P> __const & a, vecType<T, P> __const & b)
	{
		return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
	}

	// clamp
	template <typename genType>
	 __inline genType clamp(genType x, genType minVal, genType maxVal)
	{
		;
		return min(max(x, minVal), maxVal);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> clamp(vecType<T, P> __const & x, T minVal, T maxVal)
	{
		;
		return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(minVal), vecType<T, P>(maxVal));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> clamp(vecType<T, P> __const & x, vecType<T, P> __const & minVal, vecType<T, P> __const & maxVal)
	{
		;
		return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, minVal, maxVal);
	}

	template <typename genTypeT, typename genTypeU>
	 __inline genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
	{
		return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
	}

	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> mix(vecType<T, P> __const & x, vecType<T, P> __const & y, U a)
	{
		return detail::compute_mix_scalar<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
	}
	
	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> mix(vecType<T, P> __const & x, vecType<T, P> __const & y, vecType<U, P> __const & a)
	{
		return detail::compute_mix_vector<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
	}

	// step
	template <typename genType>
	 __inline genType step(genType edge, genType x)
	{
		return mix(static_cast<genType>(1), static_cast<genType>(0), glm::lessThan(x, edge));
	}

	template <template <typename, precision> class vecType, typename T, precision P>
	 __inline vecType<T, P> step(T edge, vecType<T, P> __const & x)
	{
		return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge), x);
	}

	template <template <typename, precision> class vecType, typename T, precision P>
	 __inline vecType<T, P> step(vecType<T, P> __const & edge, vecType<T, P> __const & x)
	{
		return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge, x);
	}

	// smoothstep
	template <typename genType>
	 __inline genType smoothstep(genType edge0, genType edge1, genType x)
	{
		;

		genType __const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> __const & x)
	{
		return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge0), vecType<T, P>(edge1), x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> smoothstep(vecType<T, P> __const & edge0, vecType<T, P> __const & edge1, vecType<T, P> __const & x)
	{
		return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge0, edge1, x);
	}



       
		template <typename genType> 
		 __inline bool isnan(genType x)
		{
			;


# 644 "/usr/local/include/glm/detail/func_common.inl" 3
         
				return std::isnan(x);

		}


	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> isnan(vecType<T, P> __const & x)
	{
		;

		return detail::functor1<bool, T, P, vecType>::call(isnan, x);
	}



       
		template <typename genType> 
		 __inline bool isinf(genType x)
		{
			;









                                                                


          
					return std::isinf(x);






          
	}


	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> isinf(vecType<T, P> __const & x)
	{
		;

		return detail::functor1<bool, T, P, vecType>::call(isinf, x);
	}

	 __inline int floatBitsToInt(float __const & v)
	{
		return reinterpret_cast<int&>(const_cast<float&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 __inline vecType<int, P> floatBitsToInt(vecType<float, P> __const & v)
	{
		return reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));
	}

	 __inline uint floatBitsToUint(float __const & v)
	{
		return reinterpret_cast<uint&>(const_cast<float&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 __inline vecType<uint, P> floatBitsToUint(vecType<float, P> __const & v)
	{
		return reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));
	}

	 __inline float intBitsToFloat(int __const & v)
	{
		return reinterpret_cast<float&>(const_cast<int&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 __inline vecType<float, P> intBitsToFloat(vecType<int, P> __const & v)
	{
		return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));
	}

	 __inline float uintBitsToFloat(uint __const & v)
	{
		return reinterpret_cast<float&>(const_cast<uint&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 __inline vecType<float, P> uintBitsToFloat(vecType<uint, P> __const & v)
	{
		return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));
	}
	
	template <typename genType>
	 __inline genType fma(genType __const & a, genType __const & b, genType __const & c)
	{
		return a * b + c;
	}

	template <typename genType>
	 __inline genType frexp(genType x, int & exp)
	{
		;

		return std::frexp(x, &exp);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> frexp(tvec1<T, P> __const & x, tvec1<int, P> & exp)
	{
		;

		return tvec1<T, P>(std::frexp(x.x, &exp.x));
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> frexp(tvec2<T, P> __const & x, tvec2<int, P> & exp)
	{
		;

		return tvec2<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y));
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> frexp(tvec3<T, P> __const & x, tvec3<int, P> & exp)
	{
		;

		return tvec3<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y),
			frexp(x.z, exp.z));
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> frexp(tvec4<T, P> __const & x, tvec4<int, P> & exp)
	{
		;

		return tvec4<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y),
			frexp(x.z, exp.z),
			frexp(x.w, exp.w));
	}

	template <typename genType>
	 __inline genType ldexp(genType __const & x, int __const & exp)
	{
		;

		return std::ldexp(x, exp);
	}

	template <typename T, precision P>
	 __inline tvec1<T, P> ldexp(tvec1<T, P> __const & x, tvec1<int, P> __const & exp)
	{
		;

		return tvec1<T, P>(
			ldexp(x.x, exp.x));
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> ldexp(tvec2<T, P> __const & x, tvec2<int, P> __const & exp)
	{
		;

		return tvec2<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y));
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> ldexp(tvec3<T, P> __const & x, tvec3<int, P> __const & exp)
	{
		;

		return tvec3<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y),
			ldexp(x.z, exp.z));
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> ldexp(tvec4<T, P> __const & x, tvec4<int, P> __const & exp)
	{
		;

		return tvec4<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y),
			ldexp(x.z, exp.z),
			ldexp(x.w, exp.w));
	}
}//namespace glm



       

# 426 "/usr/local/include/glm/detail/func_common.hpp" 2 3



# 5 "/usr/local/include/glm/detail/func_geometric.inl" 2 3





namespace glm{
namespace detail
{
	template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_length
	{
		 __inline static T call(vecType<T, P> __const & v)
		{
			return sqrt(dot(v, v));
		}
	};

	template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_distance
	{
		 __inline static T call(vecType<T, P> __const & p0, vecType<T, P> __const & p1)
		{
			return length(p1 - p0);
		}
	};

	template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_dot{};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec1, T, P, Aligned>
	{
		 __inline static T call(tvec1<T, P> __const & a, tvec1<T, P> __const & b)
		{
			return a.x * b.x;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec2, T, P, Aligned>
	{
		 __inline static T call(tvec2<T, P> __const & x, tvec2<T, P> __const & y)
		{
			tvec2<T, P> tmp(x * y);
			return tmp.x + tmp.y;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec3, T, P, Aligned>
	{
		 __inline static T call(tvec3<T, P> __const & x, tvec3<T, P> __const & y)
		{
			tvec3<T, P> tmp(x * y);
			return tmp.x + tmp.y + tmp.z;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_dot<tvec4, T, P, Aligned>
	{
		 __inline static T call(tvec4<T, P> __const & x, tvec4<T, P> __const & y)
		{
			tvec4<T, P> tmp(x * y);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_cross
	{
		 __inline static tvec3<T, P> call(tvec3<T, P> __const & x, tvec3<T, P> __const & y)
		{
			;

			return tvec3<T, P>(
				x.y * y.z - y.y * x.z,
				x.z * y.x - y.z * x.x,
				x.x * y.y - y.x * x.y);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_normalize
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & v)
		{
			;

			return v * inversesqrt(dot(v, v));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_faceforward
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & N, vecType<T, P> __const & I, vecType<T, P> __const & Nref)
		{
			;

			return dot(Nref, I) < static_cast<T>(0) ? N : -N;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_reflect
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & I, vecType<T, P> __const & N)
		{
			return I - N * dot(N, I) * static_cast<T>(2);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_refract
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & I, vecType<T, P> __const & N, T eta)
		{
			T __const dotValue(dot(N, I));
			T __const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
			return (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));
		}
	};
}//namespace detail

	// length
	template <typename genType>
	 __inline genType length(genType x)
	{
		;

		return abs(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T length(vecType<T, P> __const & v)
	{
		;

		return detail::compute_length<vecType, T, P, detail::is_aligned<P>::value>::call(v);
	}

	// distance
	template <typename genType>
	 __inline genType distance(genType __const & p0, genType __const & p1)
	{
		;

		return length(p1 - p0);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T distance(vecType<T, P> __const & p0, vecType<T, P> __const & p1)
	{
		return detail::compute_distance<vecType, T, P, detail::is_aligned<P>::value>::call(p0, p1);
	}

	// dot
	template <typename T>
	 __inline T dot(T x, T y)
	{
		;
		return x * y;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T dot(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		;
		return detail::compute_dot<vecType, T, P, detail::is_aligned<P>::value>::call(x, y);
	}

	// cross
	template <typename T, precision P>
	 __inline tvec3<T, P> cross(tvec3<T, P> __const & x, tvec3<T, P> __const & y)
	{
		return detail::compute_cross<T, P, detail::is_aligned<P>::value>::call(x, y);
	}

	// normalize
	template <typename genType>
	 __inline genType normalize(genType __const & x)
	{
		;

		return x < genType(0) ? genType(-1) : genType(1);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> normalize(vecType<T, P> __const & x)
	{
		;

		return detail::compute_normalize<T, P, vecType, detail::is_aligned<P>::value>::call(x);
	}

	// faceforward
	template <typename genType>
	 __inline genType faceforward(genType __const & N, genType __const & I, genType __const & Nref)
	{
		return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> faceforward(vecType<T, P> __const & N, vecType<T, P> __const & I, vecType<T, P> __const & Nref)
	{
		return detail::compute_faceforward<T, P, vecType, detail::is_aligned<P>::value>::call(N, I, Nref);
	}

	// reflect
	template <typename genType>
	 __inline genType reflect(genType __const & I, genType __const & N)
	{
		return I - N * dot(N, I) * genType(2);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> reflect(vecType<T, P> __const & I, vecType<T, P> __const & N)
	{
		return detail::compute_reflect<T, P, vecType, detail::is_aligned<P>::value>::call(I, N);
	}

	// refract
	template <typename genType>
	 __inline genType refract(genType __const & I, genType __const & N, genType eta)
	{
		;
		genType __const dotValue(dot(N, I));
		genType __const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> refract(vecType<T, P> __const & I, vecType<T, P> __const & N, T eta)
	{
		;
		return detail::compute_refract<T, P, vecType, detail::is_aligned<P>::value>::call(I, N, eta);
	}
}//namespace glm



       

# 113 "/usr/local/include/glm/detail/func_geometric.hpp" 2 3


# 6 "/usr/local/include/glm/detail/../geometric.hpp" 2 3


# 4 "/usr/local/include/glm/detail/func_matrix.inl" 2 3



namespace glm{
namespace detail
{
	template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_matrixCompMult
	{
		 __inline static matType<T, P> call(matType<T, P> __const& x, matType<T, P> __const& y)
		{
			matType<T, P> result(uninitialize);
			for(length_t i = 0; i < result.length(); ++i)
				result[i] = x[i] * y[i];
			return result;
		}
	};

	template <template <class, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_transpose{};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat2x2, T, P, Aligned>
	{
		 __inline static tmat2x2<T, P> call(tmat2x2<T, P> __const & m)
		{
			tmat2x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat2x3, T, P, Aligned>
	{
		 __inline static tmat3x2<T, P> call(tmat2x3<T, P> __const & m)
		{
			tmat3x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat2x4, T, P, Aligned>
	{
		 __inline static tmat4x2<T, P> call(tmat2x4<T, P> __const & m)
		{
			tmat4x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat3x2, T, P, Aligned>
	{
		 __inline static tmat2x3<T, P> call(tmat3x2<T, P> __const & m)
		{
			tmat2x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat3x3, T, P, Aligned>
	{
		 __inline static tmat3x3<T, P> call(tmat3x3<T, P> __const & m)
		{
			tmat3x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];

			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];

			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat3x4, T, P, Aligned>
	{
		 __inline static tmat4x3<T, P> call(tmat3x4<T, P> __const & m)
		{
			tmat4x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			result[3][2] = m[2][3];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat4x2, T, P, Aligned>
	{
		 __inline static tmat2x4<T, P> call(tmat4x2<T, P> __const & m)
		{
			tmat2x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat4x3, T, P, Aligned>
	{
		 __inline static tmat3x4<T, P> call(tmat4x3<T, P> __const & m)
		{
			tmat3x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[2][3] = m[3][2];
			return result;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_transpose<tmat4x4, T, P, Aligned>
	{
		 __inline static tmat4x4<T, P> call(tmat4x4<T, P> __const & m)
		{
			tmat4x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];

			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];

			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[2][3] = m[3][2];

			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			result[3][2] = m[2][3];
			result[3][3] = m[3][3];
			return result;
		}
	};

	template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_determinant{};

	template <typename T, precision P, bool Aligned>
	struct compute_determinant<tmat2x2, T, P, Aligned>
	{
		 __inline static T call(tmat2x2<T, P> __const & m)
		{
			return m[0][0] * m[1][1] - m[1][0] * m[0][1];
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_determinant<tmat3x3, T, P, Aligned>
	{
		 __inline static T call(tmat3x3<T, P> __const & m)
		{
			return
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_determinant<tmat4x4, T, P, Aligned>
	{
		 __inline static T call(tmat4x4<T, P> __const & m)
		{
			T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

			tvec4<T, P> DetCof(
				+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
				- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
				+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
				- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

			return
				m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
				m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
		}
	};

	template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
	struct compute_inverse{};

	template <typename T, precision P, bool Aligned>
	struct compute_inverse<tmat2x2, T, P, Aligned>
	{
		 __inline static tmat2x2<T, P> call(tmat2x2<T, P> __const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * m[1][1]
				- m[1][0] * m[0][1]);

			tmat2x2<T, P> Inverse(
				+ m[1][1] * OneOverDeterminant,
				- m[0][1] * OneOverDeterminant,
				- m[1][0] * OneOverDeterminant,
				+ m[0][0] * OneOverDeterminant);

			return Inverse;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_inverse<tmat3x3, T, P, Aligned>
	{
		 __inline static tmat3x3<T, P> call(tmat3x3<T, P> __const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

			tmat3x3<T, P> Inverse(uninitialize);
			Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
			Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
			Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
			Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
			Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

			return Inverse;
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_inverse<tmat4x4, T, P, Aligned>
	{
		 __inline static tmat4x4<T, P> call(tmat4x4<T, P> __const& m)
		{
			T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
			T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

			T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
			T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

			T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
			T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

			T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
			T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

			T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
			T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

			T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
			T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
			T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

			tvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);
			tvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);
			tvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);
			tvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);
			tvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);
			tvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);

			tvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
			tvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
			tvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
			tvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

			tvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
			tvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
			tvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
			tvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

			tvec4<T, P> SignA(+1, -1, +1, -1);
			tvec4<T, P> SignB(-1, +1, -1, +1);
			tmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

			tvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

			tvec4<T, P> Dot0(m[0] * Row0);
			T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

			T OneOverDeterminant = static_cast<T>(1) / Dot1;

			return Inverse * OneOverDeterminant;
		}
	};
}//namespace detail

	template <typename T, precision P, template <typename, precision> class matType>
	 __inline matType<T, P> matrixCompMult(matType<T, P> __const & x, matType<T, P> __const & y)
	{
		;
		return detail::compute_matrixCompMult<matType, T, P, detail::is_aligned<P>::value>::call(x, y);
	}

	template<typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
	 __inline typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> __const & c, vecTypeB<T, P> __const & r)
	{
		;

		typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type m(uninitialize);
		for(length_t i = 0; i < m.length(); ++i)
			m[i] = c * r[i];
		return m;
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 __inline typename matType<T, P>::transpose_type transpose(matType<T, P> __const & m)
	{
		;
		return detail::compute_transpose<matType, T, P, detail::is_aligned<P>::value>::call(m);
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 __inline T determinant(matType<T, P> __const & m)
	{
		;
		return detail::compute_determinant<matType, T, P, detail::is_aligned<P>::value>::call(m);
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 __inline matType<T, P> inverse(matType<T, P> __const & m)
	{
		;
		return detail::compute_inverse<matType, T, P, detail::is_aligned<P>::value>::call(m);
	}
}//namespace glm



       


# 149 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


# 4 "/usr/local/include/glm/detail/type_mat2x2.inl" 2 3


namespace glm
{
	// -- Constructors --


		template <typename T, precision P>
		 __inline tmat2x2<T, P>::tmat2x2()
		{

				this->value[0] = col_type(1, 0);
				this->value[1] = col_type(0, 1);

		}



		template <typename T, precision P>
		 __inline tmat2x2<T, P>::tmat2x2(tmat2x2<T, P> __const & m)
		{
			this->value[0] = m.value[0];
			this->value[1] = m.value[1];
		}


	template <typename T, precision P>
	template <precision Q>
	 __inline tmat2x2<T, P>::tmat2x2(tmat2x2<T, Q> __const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	 __inline  tmat2x2<T, P>::tmat2x2(ctor)
	{}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2
	(
		T __const & x0, T __const & y0,
		T __const & x1, T __const & y1
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(col_type __const & v0, col_type __const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <typename X1, typename Y1, typename X2, typename Y2>
	 __inline tmat2x2<T, P>::tmat2x2
	(
		X1 __const & x1, Y1 __const & y1,
		X2 __const & x2, Y2 __const & y2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 __inline tmat2x2<T, P>::tmat2x2(tvec2<V1, P> __const & v1, tvec2<V2, P> __const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	// -- mat2x2 matrix conversions --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline tmat2x2<T, P>::tmat2x2(tmat2x2<U, Q> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(tmat3x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(tmat4x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x2<T, P>::tmat2x2(tmat2x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(tmat3x2<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(tmat2x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(tmat4x2<T, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(tmat3x4<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>::tmat2x2(tmat4x3<T, P> __const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	// -- Accesses --

	template <typename T, precision P>
	 __inline typename tmat2x2<T, P>::col_type & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i)
	{
		assert(i < this->length());
		return this->value[i];
	}

	template <typename T, precision P>
	 __inline typename tmat2x2<T, P>::col_type __const & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i) __const
	{
		assert(i < this->length());
		return this->value[i];
	}

	// -- Unary updatable operators --


		template <typename T, precision P>
		 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<T, P> __const & m)
		{
			this->value[0] = m[0];
			this->value[1] = m[1];
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<U, P> __const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(U scalar)
	{
		this->value[0] += scalar;
		this->value[1] += scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(tmat2x2<U, P> __const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(U scalar)
	{
		this->value[0] -= scalar;
		this->value[1] -= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(tmat2x2<U, P> __const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(U scalar)
	{
		this->value[0] *= scalar;
		this->value[1] *= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(tmat2x2<U, P> __const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(U scalar)
	{
		this->value[0] /= scalar;
		this->value[1] /= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(tmat2x2<U, P> __const & m)
	{
		return *this *= inverse(m);
	}

	// -- Increment and decrement operators --

	template <typename T, precision P>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P>& tmat2x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> tmat2x2<T, P>::operator++(int)
	{
		tmat2x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> tmat2x2<T, P>::operator--(int)
	{
		tmat2x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	// -- Unary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator+(tmat2x2<T, P> __const & m)
	{
		return m;
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator-(tmat2x2<T, P> __const & m)
	{
		return tmat2x2<T, P>(
			-m[0], 
			-m[1]);
	}

	// -- Binary arithmetic operators --

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator+(tmat2x2<T, P> __const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> __const & m)
	{
		return tmat2x2<T, P>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator+(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{
		return tmat2x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator-(tmat2x2<T, P> __const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> __const & m)
	{
		return tmat2x2<T, P>(
			scalar - m[0],
			scalar - m[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator-(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{
		return tmat2x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator*(tmat2x2<T, P> __const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> __const & m)
	{
		return tmat2x2<T, P>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template <typename T, precision P>
	 __inline typename tmat2x2<T, P>::col_type operator*
	(
		tmat2x2<T, P> __const & m,
		typename tmat2x2<T, P>::row_type __const & v
	)
	{
		return tvec2<T, P>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}

	template <typename T, precision P>
	 __inline typename tmat2x2<T, P>::row_type operator*
	(
		typename tmat2x2<T, P>::col_type __const & v,
		tmat2x2<T, P> __const & m
	)
	{
		return tvec2<T, P>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator*(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{
		return tmat2x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> operator*(tmat2x2<T, P> __const & m1, tmat3x2<T, P> __const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> operator*(tmat2x2<T, P> __const & m1, tmat4x2<T, P> __const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}

	template <typename T, precision P> 
	 __inline tmat2x2<T, P> operator/(tmat2x2<T, P> __const & m, T scalar)
	{
		return tmat2x2<T, P>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template <typename T, precision P> 
	 __inline tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> __const & m)
	{
		return tmat2x2<T, P>(
			scalar / m[0],
			scalar / m[1]);
	}

	template <typename T, precision P>
	 __inline typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> __const & m, typename tmat2x2<T, P>::row_type __const & v)
	{
		return inverse(m) * v;
	}

	template <typename T, precision P>
	 __inline typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type __const & v, tmat2x2<T, P> __const & m)
	{
		return v *  inverse(m);
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> operator/(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{	
		tmat2x2<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tmat2x2<T, P> __const & m1, tmat2x2<T, P> __const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} //namespace glm

# 182 "/usr/local/include/glm/detail/type_mat2x2.hpp" 2 3



# 6 "/usr/local/include/glm/mat2x2.hpp" 2 3


namespace glm
{
	/// 2 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, lowp>		lowp_mat2;
	
	/// 2 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, mediump>		mediump_mat2;
	
	/// 2 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, highp>		highp_mat2;
	
	/// 2 columns of 2 components matrix of low precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, lowp>		lowp_mat2x2;
	
	/// 2 columns of 2 components matrix of medium precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, mediump>		mediump_mat2x2;
	
	/// 2 columns of 2 components matrix of high precision floating-point numbers.
	/// There is no guarantee on the actual precision.
	///
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.1.6 Matrices</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 4.7.2 Precision Qualifier</a>
	typedef tmat2x2<float, highp>		highp_mat2x2;

}//namespace glm

# 71 "/usr/local/include/glm/glm.hpp" 2 3











# 1 "/usr/local/include/glm/trigonometric.hpp" 1 3
/// @ref core
/// @file glm/trigonometric.hpp




# 1 "/usr/local/include/glm/detail/func_trigonometric.hpp" 1 3
/// @ref core
/// @file glm/detail/func_trigonometric.hpp
///
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
/// 
/// @defgroup core_func_trigonometric Angle and Trigonometry Functions
/// @ingroup core
/// 
/// Function parameters specified as angle are assumed to be in units of radians. 
/// In no case will any of these functions result in a divide by zero error. If 
/// the divisor of a ratio is 0, then results will be undefined.
/// 
/// These all operate component-wise. The description is per component.






namespace glm
{
	/// @addtogroup core_func_trigonometric
	/// @{

	/// Converts degrees to radians and returns the result.
	///
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/radians.xml">GLSL radians man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	  vecType<T, P> radians(vecType<T, P> __const & degrees);

	/// Converts radians to degrees and returns the result.
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/degrees.xml">GLSL degrees man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	  vecType<T, P> degrees(vecType<T, P> __const & radians);

	/// The standard trigonometric sine function. 
	/// The values returned by this function will range from [-1, 1].
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/sin.xml">GLSL sin man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sin(vecType<T, P> __const & angle);

	/// The standard trigonometric cosine function. 
	/// The values returned by this function will range from [-1, 1].
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/cos.xml">GLSL cos man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> cos(vecType<T, P> __const & angle);

	/// The standard trigonometric tangent function.
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/tan.xml">GLSL tan man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> tan(vecType<T, P> __const & angle); 

	/// Arc sine. Returns an angle whose sine is x. 
	/// The range of values returned by this function is [-PI/2, PI/2]. 
	/// Results are undefined if |x| > 1.
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/asin.xml">GLSL asin man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> asin(vecType<T, P> __const & x);

	/// Arc cosine. Returns an angle whose sine is x. 
	/// The range of values returned by this function is [0, PI]. 
	/// Results are undefined if |x| > 1.
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/acos.xml">GLSL acos man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> acos(vecType<T, P> __const & x);

	/// Arc tangent. Returns an angle whose tangent is y/x. 
	/// The signs of x and y are used to determine what 
	/// quadrant the angle is in. The range of values returned 
	/// by this function is [-PI, PI]. Results are undefined 
	/// if x and y are both 0. 
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/atan.xml">GLSL atan man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atan(vecType<T, P> __const & y, vecType<T, P> __const & x);

	/// Arc tangent. Returns an angle whose tangent is y_over_x. 
	/// The range of values returned by this function is [-PI/2, PI/2].
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/atan.xml">GLSL atan man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atan(vecType<T, P> __const & y_over_x);

	/// Returns the hyperbolic sine function, (exp(x) - exp(-x)) / 2
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/sinh.xml">GLSL sinh man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sinh(vecType<T, P> __const & angle);

	/// Returns the hyperbolic cosine function, (exp(x) + exp(-x)) / 2
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/cosh.xml">GLSL cosh man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> cosh(vecType<T, P> __const & angle);

	/// Returns the hyperbolic tangent function, sinh(angle) / cosh(angle)
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/tanh.xml">GLSL tanh man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> tanh(vecType<T, P> __const & angle);

	/// Arc hyperbolic sine; returns the inverse of sinh.
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/asinh.xml">GLSL asinh man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> asinh(vecType<T, P> __const & x);
	
	/// Arc hyperbolic cosine; returns the non-negative inverse
	/// of cosh. Results are undefined if x < 1.
	///
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/acosh.xml">GLSL acosh man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> acosh(vecType<T, P> __const & x);

	/// Arc hyperbolic tangent; returns the inverse of tanh.
	/// Results are undefined if abs(x) >= 1.
	///
	/// @tparam genType Floating-point scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/atanh.xml">GLSL atanh man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.1 Angle and Trigonometry Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atanh(vecType<T, P> __const & x);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_trigonometric.inl" 1 3
/// @ref core
/// @file glm/detail/func_trigonometric.inl





namespace glm
{
	// radians
	template <typename genType>
	 __inline  genType radians(genType degrees)
	{
		;

		return degrees * static_cast<genType>(0.01745329251994329576923690768489);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline  vecType<T, P> radians(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(radians, v);
	}
	
	// degrees
	template <typename genType>
	 __inline  genType degrees(genType radians)
	{
		;

		return radians * static_cast<genType>(57.295779513082320876798154814105);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline  vecType<T, P> degrees(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(degrees, v);
	}

	// sin
	using ::std::sin;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> sin(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(sin, v);
	}

	// cos
	using std::cos;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> cos(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(cos, v);
	}

	// tan
	using std::tan;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> tan(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(tan, v);
	}

	// asin
	using std::asin;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> asin(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(asin, v);
	}

	// acos
	using std::acos;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> acos(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(acos, v);
	}

	// atan
	template <typename genType>
	 __inline genType atan(genType y, genType x)
	{
		;

		return ::std::atan2(y, x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> atan(vecType<T, P> __const & a, vecType<T, P> __const & b)
	{
		return detail::functor2<T, P, vecType>::call(::std::atan2, a, b);
	}

	using std::atan;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> atan(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(atan, v);
	}

	// sinh
	using std::sinh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> sinh(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(sinh, v);
	}

	// cosh
	using std::cosh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> cosh(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(cosh, v);
	}

	// tanh
	using std::tanh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> tanh(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(tanh, v);
	}

	// asinh


       
		template <typename genType>
		 __inline genType asinh(genType x)
		{
			;

			return (x < static_cast<genType>(0) ? static_cast<genType>(-1) : (x > static_cast<genType>(0) ? static_cast<genType>(1) : static_cast<genType>(0))) * log(std::abs(x) + sqrt(static_cast<genType>(1) + x * x));
		}


	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> asinh(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(asinh, v);
	}

	// acosh


       
		template <typename genType> 
		 __inline genType acosh(genType x)
		{
			;

			if(x < static_cast<genType>(1))
				return static_cast<genType>(0);
			return log(x + sqrt(x * x - static_cast<genType>(1)));
		}


	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> acosh(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(acosh, v);
	}

	// atanh


       
		template <typename genType>
		 __inline genType atanh(genType x)
		{
			;
		
			if(std::abs(x) >= static_cast<genType>(1))
				return 0;
			return static_cast<genType>(0.5) * log((static_cast<genType>(1) + x) / (static_cast<genType>(1) - x));
		}


	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> atanh(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(atanh, v);
	}
}//namespace glm



       


# 176 "/usr/local/include/glm/detail/func_trigonometric.hpp" 2 3


# 6 "/usr/local/include/glm/trigonometric.hpp" 2 3


# 81 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/exponential.hpp" 1 3
/// @ref core
/// @file glm/exponential.hpp





# 82 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/common.hpp" 1 3
/// @ref core
/// @file glm/common.hpp





# 83 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/packing.hpp" 1 3
/// @ref core
/// @file glm/packing.hpp




# 1 "/usr/local/include/glm/detail/func_packing.hpp" 1 3
/// @ref core
/// @file glm/detail/func_packing.hpp
///
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
/// @see gtc_packing
///
/// @defgroup core_func_packing Floating-Point Pack and Unpack Functions
/// @ingroup core
///
/// These functions do not operate component-wise, rather as described in each case.






namespace glm
{
	/// @addtogroup core_func_packing
	/// @{

	/// First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	/// 
	/// The conversion for component c of v to fixed point is done as follows:
	/// packUnorm2x16: round(clamp(c, 0, +1) * 65535.0) 
	/// 
	/// The first component of the vector will be written to the least significant bits of the output; 
	/// the last component will be written to the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm2x16.xml">GLSL packUnorm2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint packUnorm2x16(vec2 __const & v);

	/// First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	/// 
	/// The conversion for component c of v to fixed point is done as follows:
	/// packSnorm2x16: round(clamp(v, -1, +1) * 32767.0)
	/// 
	/// The first component of the vector will be written to the least significant bits of the output; 
	/// the last component will be written to the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm2x16.xml">GLSL packSnorm2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint packSnorm2x16(vec2 __const & v);

	/// First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	/// 
	/// The conversion for component c of v to fixed point is done as follows:
	/// packUnorm4x8:	round(clamp(c, 0, +1) * 255.0)
	/// 
	/// The first component of the vector will be written to the least significant bits of the output; 
	/// the last component will be written to the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm4x8.xml">GLSL packUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint packUnorm4x8(vec4 __const & v);

	/// First, converts each component of the normalized floating-point value v into 8- or 16-bit integer values. 
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	/// 
	/// The conversion for component c of v to fixed point is done as follows:
	/// packSnorm4x8:	round(clamp(c, -1, +1) * 127.0) 
	/// 
	/// The first component of the vector will be written to the least significant bits of the output; 
	/// the last component will be written to the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm4x8.xml">GLSL packSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint packSnorm4x8(vec4 __const & v);

	/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackUnorm2x16: f / 65535.0 
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm2x16.xml">GLSL unpackUnorm2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec2 unpackUnorm2x16(uint p);

	/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm2x16: clamp(f / 32767.0, -1, +1)
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm2x16.xml">GLSL unpackSnorm2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec2 unpackSnorm2x16(uint p);

	/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackUnorm4x8: f / 255.0
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm4x8.xml">GLSL unpackUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec4 unpackUnorm4x8(uint p);

	/// First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers, or four 8-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm4x8: clamp(f / 127.0, -1, +1)
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm4x8.xml">GLSL unpackSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec4 unpackSnorm4x8(uint p);

	/// Returns a double-precision value obtained by packing the components of v into a 64-bit value. 
	/// If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating point value is unspecified. 
	/// Otherwise, the bit- level representation of v is preserved. 
	/// The first vector component specifies the 32 least significant bits; 
	/// the second component specifies the 32 most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packDouble2x32.xml">GLSL packDouble2x32 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 double packDouble2x32(uvec2 __const & v);

	/// Returns a two-component unsigned integer vector representation of v. 
	/// The bit-level representation of v is preserved. 
	/// The first component of the vector contains the 32 least significant bits of the double; 
	/// the second component consists the 32 most significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackDouble2x32.xml">GLSL unpackDouble2x32 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uvec2 unpackDouble2x32(double v);

	/// Returns an unsigned integer obtained by converting the components of a two-component floating-point vector 
	/// to the 16-bit floating-point representation found in the OpenGL Specification, 
	/// and then packing these two 16- bit integers into a 32-bit unsigned integer.
	/// The first vector component specifies the 16 least-significant bits of the result; 
	/// the second component specifies the 16 most-significant bits.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packHalf2x16.xml">GLSL packHalf2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint packHalf2x16(vec2 __const & v);
	
	/// Returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, 
	/// interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, 
	/// and converting them to 32-bit floating-point values.
	/// The first component of the vector is obtained from the 16 least-significant bits of v; 
	/// the second component is obtained from the 16 most-significant bits of v.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackHalf2x16.xml">GLSL unpackHalf2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec2 unpackHalf2x16(uint v);
	
	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_packing.inl" 1 3
/// @ref core
/// @file glm/detail/func_packing.inl



# 1 "/usr/local/include/glm/detail/type_half.hpp" 1 3
/// @ref core
/// @file glm/detail/type_half.hpp





namespace glm{
namespace detail
{
	typedef short hdata;

	 float toFloat32(hdata value);
	 hdata toFloat16(float __const & value);

}//namespace detail
}//namespace glm


# 1 "/usr/local/include/glm/detail/type_half.inl" 1 3
/// @ref core
/// @file glm/detail/type_half.inl

namespace glm{
namespace detail
{
	 __inline float overflow()
	{
		__volatile float f = 1e10;

		for(int i = 0; i < 10; ++i)	
			f *= f; // this will overflow before the for loop terminates
		return f;
	}

	union uif32
	{
		 __inline uif32() :
			i(0)
		{}

		 __inline uif32(float f_) :
			f(f_)
		{}

		 __inline uif32(uint32 i_) :
			i(i_)
		{}

		float f;
		uint32 i;
	};

	 __inline float toFloat32(hdata value)
	{
		int s = (value >> 15) & 0x00000001;
		int e = (value >> 10) & 0x0000001f;
		int m =  value        & 0x000003ff;

		if(e == 0)
		{
			if(m == 0)
			{
				//
				// Plus or minus zero
				//

				detail::uif32 result;
				result.i = (unsigned int)(s << 31);
				return result.f;
			}
			else
			{
				//
				// Denormalized number -- renormalize it
				//

				while(!(m & 0x00000400))
				{
					m <<= 1;
					e -=  1;
				}

				e += 1;
				m &= ~0x00000400;
			}
		}
		else if(e == 31)
		{
			if(m == 0)
			{
				//
				// Positive or negative infinity
				//

				uif32 result;
				result.i = (unsigned int)((s << 31) | 0x7f800000);
				return result.f;
			}
			else
			{
				//
				// Nan -- preserve sign and significand bits
				//

				uif32 result;
				result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
				return result.f;
			}
		}

		//
		// Normalized number
		//

		e = e + (127 - 15);
		m = m << 13;

		//
		// Assemble s, e and m.
		//

		uif32 Result;
		Result.i = (unsigned int)((s << 31) | (e << 23) | m);
		return Result.f;
	}

	 __inline hdata toFloat16(float __const & f)
	{
		uif32 Entry;
		Entry.f = f;
		int i = (int)Entry.i;

		//
		// Our floating point number, f, is represented by the bit
		// pattern in integer i.  Disassemble that bit pattern into
		// the sign, s, the exponent, e, and the significand, m.
		// Shift s into the position where it will go in in the
		// resulting half number.
		// Adjust e, accounting for the different exponent bias
		// of float and half (127 versus 15).
		//

		int s =  (i >> 16) & 0x00008000;
		int e = ((i >> 23) & 0x000000ff) - (127 - 15);
		int m =   i        & 0x007fffff;

		//
		// Now reassemble s, e and m into a half:
		//

		if(e <= 0)
		{
			if(e < -10)
			{
				//
				// E is less than -10.  The absolute value of f is
				// less than half_MIN (f may be a small normalized
				// float, a denormalized float or a zero).
				//
				// We convert f to a half zero.
				//

				return hdata(s);
			}

			//
			// E is between -10 and 0.  F is a normalized float,
			// whose magnitude is less than __half_NRM_MIN.
			//
			// We convert f to a denormalized half.
			// 

			m = (m | 0x00800000) >> (1 - e);

			//
			// Round to nearest, round "0.5" up.
			//
			// Rounding may cause the significand to overflow and make
			// our number normalized.  Because of the way a half's bits
			// are laid out, we don't have to treat this case separately;
			// the code below will handle it correctly.
			// 

			if(m & 0x00001000) 
				m += 0x00002000;

			//
			// Assemble the half from s, e (zero) and m.
			//

			return hdata(s | (m >> 13));
		}
		else if(e == 0xff - (127 - 15))
		{
			if(m == 0)
			{
				//
				// F is an infinity; convert f to a half
				// infinity with the same sign as f.
				//

				return hdata(s | 0x7c00);
			}
			else
			{
				//
				// F is a NAN; we produce a half NAN that preserves
				// the sign bit and the 10 leftmost bits of the
				// significand of f, with one exception: If the 10
				// leftmost bits are all zero, the NAN would turn 
				// into an infinity, so we have to set at least one
				// bit in the significand.
				//

				m >>= 13;

				return hdata(s | 0x7c00 | m | (m == 0));
			}
		}
		else
		{
			//
			// E is greater than zero.  F is a normalized float.
			// We try to convert f to a normalized half.
			//

			//
			// Round to nearest, round "0.5" up
			//

			if(m &  0x00001000)
			{
				m += 0x00002000;

				if(m & 0x00800000)
				{
					m =  0;     // overflow in significand,
					e += 1;     // adjust exponent
				}
			}

			//
			// Handle exponent overflow
			//

			if (e > 30)
			{
				overflow();        // Cause a hardware floating point overflow;

				return hdata(s | 0x7c00);
				// if this returns, the half becomes an
			}   // infinity with the same sign as f.

			//
			// Assemble the half from s, e and m.
			//

			return hdata(s | (e << 10) | (m >> 13));
		}
	}

}//namespace detail
}//namespace glm

# 19 "/usr/local/include/glm/detail/type_half.hpp" 2 3


# 5 "/usr/local/include/glm/detail/func_packing.inl" 2 3



namespace glm
{
	 __inline uint packUnorm2x16(vec2 __const & v)
	{
		union
		{
			u16  in[2];
			uint out;
		} u;

		u16vec2 result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	 __inline vec2 unpackUnorm2x16(uint p)
	{
		union
		{
			uint in;
			u16  out[2];
		} u;

		u.in = p;

		return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
	}

	 __inline uint packSnorm2x16(vec2 __const & v)
	{
		union
		{
			i16  in[2];
			uint out;
		} u;

		i16vec2 result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	 __inline vec2 unpackSnorm2x16(uint p)
	{
		union
		{
			uint in;
			i16  out[2];
		} u;

		u.in = p;

		return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
	}

	 __inline uint packUnorm4x8(vec4 __const & v)
	{
		union
		{
			u8   in[4];
			uint out;
		} u;

		u8vec4 result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}

	 __inline vec4 unpackUnorm4x8(uint p)
	{
		union
		{
			uint in;
			u8   out[4];
		} u;

		u.in = p;

		return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
	}
	
	 __inline uint packSnorm4x8(vec4 __const & v)
	{
		union
		{
			i8   in[4];
			uint out;
		} u;

		i8vec4 result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}
	
	 __inline glm::vec4 unpackSnorm4x8(uint p)
	{
		union
		{
			uint in;
			i8   out[4];
		} u;

		u.in = p;

		return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
	}

	 __inline double packDouble2x32(uvec2 __const & v)
	{
		union
		{
			uint   in[2];
			double out;
		} u;

		u.in[0] = v[0];
		u.in[1] = v[1];

		return u.out;
	}

	 __inline uvec2 unpackDouble2x32(double v)
	{
		union
		{
			double in;
			uint   out[2];
		} u;

		u.in = v;

		return uvec2(u.out[0], u.out[1]);
	}

	 __inline uint packHalf2x16(vec2 __const & v)
	{
		union
		{
			i16  in[2];
			uint out;
		} u;

		u.in[0] = detail::toFloat16(v.x);
		u.in[1] = detail::toFloat16(v.y);

		return u.out;
	}

	 __inline vec2 unpackHalf2x16(uint v)
	{
		union
		{
			uint in;
			i16  out[2];
		} u;

		u.in = v;

		return vec2(
			detail::toFloat32(u.out[0]),
			detail::toFloat32(u.out[1]));
	}
}//namespace glm



       


# 168 "/usr/local/include/glm/detail/func_packing.hpp" 2 3


# 6 "/usr/local/include/glm/packing.hpp" 2 3


# 84 "/usr/local/include/glm/glm.hpp" 2 3



# 1 "/usr/local/include/glm/matrix.hpp" 1 3
/// @ref core
/// @file glm/matrix.hpp





# 86 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/vector_relational.hpp" 1 3
/// @ref core
/// @file glm/vector_relational.hpp





# 87 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/integer.hpp" 1 3
/// @ref core
/// @file glm/integer.hpp




# 1 "/usr/local/include/glm/detail/func_integer.hpp" 1 3
/// @ref core
/// @file glm/detail/func_integer.hpp
///
/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
/// 
/// @defgroup core_func_integer Integer functions
/// @ingroup core
/// 
/// These all operate component-wise. The description is per component. 
/// The notation [a, b] means the set of bits from bit-number a through bit-number 
/// b, inclusive. The lowest-order bit is bit 0.








namespace glm
{
	/// @addtogroup core_func_integer
	/// @{

	/// Adds 32-bit unsigned integer x and y, returning the sum
	/// modulo pow(2, 32). The value carry is set to 0 if the sum was
	/// less than pow(2, 32), or to 1 otherwise.
	///
	/// @tparam genUType Unsigned integer scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/uaddCarry.xml">GLSL uaddCarry man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 vecType<uint, P> uaddCarry(
		vecType<uint, P> __const & x,
		vecType<uint, P> __const & y,
		vecType<uint, P> & carry);

	/// Subtracts the 32-bit unsigned integer y from x, returning
	/// the difference if non-negative, or pow(2, 32) plus the difference
	/// otherwise. The value borrow is set to 0 if x >= y, or to 1 otherwise.
	///
	/// @tparam genUType Unsigned integer scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/usubBorrow.xml">GLSL usubBorrow man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 vecType<uint, P> usubBorrow(
		vecType<uint, P> __const & x,
		vecType<uint, P> __const & y,
		vecType<uint, P> & borrow);

	/// Multiplies 32-bit integers x and y, producing a 64-bit
	/// result. The 32 least-significant bits are returned in lsb.
	/// The 32 most-significant bits are returned in msb.
	///
	/// @tparam genUType Unsigned integer scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/umulExtended.xml">GLSL umulExtended man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 void umulExtended(
		vecType<uint, P> __const & x,
		vecType<uint, P> __const & y,
		vecType<uint, P> & msb,
		vecType<uint, P> & lsb);
		
	/// Multiplies 32-bit integers x and y, producing a 64-bit
	/// result. The 32 least-significant bits are returned in lsb.
	/// The 32 most-significant bits are returned in msb.
	/// 
	/// @tparam genIType Signed integer scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/imulExtended.xml">GLSL imulExtended man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 void imulExtended(
		vecType<int, P> __const & x,
		vecType<int, P> __const & y,
		vecType<int, P> & msb,
		vecType<int, P> & lsb);

	/// Extracts bits [offset, offset + bits - 1] from value,
	/// returning them in the least significant bits of the result.
	/// For unsigned data types, the most significant bits of the
	/// result will be set to zero. For __signed data types, the
	/// most significant bits will be set to the value of bit offset + base - 1.
	///
	/// If bits is zero, the result will be zero. The result will be
	/// undefined if offset or bits is negative, or if the sum of
	/// offset and bits is greater than the number of bits used
	/// to store the operand.
	///
	/// @tparam T Signed or unsigned integer scalar or vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/bitfieldExtract.xml">GLSL bitfieldExtract man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldExtract(
		vecType<T, P> __const & Value,
		int Offset,
		int Bits);

	/// Returns the insertion the bits least-significant bits of insert into base.
	///
	/// The result will have bits [offset, offset + bits - 1] taken
	/// from bits [0, bits - 1] of insert, and all other bits taken
	/// directly from the corresponding bits of base. If bits is
	/// zero, the result will simply be base. The result will be
	/// undefined if offset or bits is negative, or if the sum of
	/// offset and bits is greater than the number of bits used to
	/// store the operand.
	///
	/// @tparam T Signed or unsigned integer scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/bitfieldInsert.xml">GLSL bitfieldInsert man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldInsert(
		vecType<T, P> __const & Base,
		vecType<T, P> __const & Insert,
		int Offset,
		int Bits);

	/// Returns the reversal of the bits of value. 
	/// The bit numbered n of the result will be taken from bit (bits - 1) - n of value, 
	/// where bits is the total number of bits used to represent value.
	///
	/// @tparam T Signed or unsigned integer scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/bitfieldReverse.xml">GLSL bitfieldReverse man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldReverse(vecType<T, P> __const & v);

	/// Returns the number of bits set to 1 in the binary representation of value.
	///
	/// @tparam T Signed or unsigned integer scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/bitCount.xml">GLSL bitCount man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename genType>
	 int bitCount(genType v);

	/// Returns the number of bits set to 1 in the binary representation of value.
	///
	/// @tparam T Signed or unsigned integer scalar or vector types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/bitCount.xml">GLSL bitCount man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<int, P> bitCount(vecType<T, P> __const & v);

	/// Returns the bit number of the least significant bit set to
	/// 1 in the binary representation of value. 
	/// If value is zero, -1 will be returned.
	///
	/// @tparam T Signed or unsigned integer scalar types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/findLSB.xml">GLSL findLSB man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename genIUType>
	 int findLSB(genIUType x);

	/// Returns the bit number of the least significant bit set to
	/// 1 in the binary representation of value. 
	/// If value is zero, -1 will be returned.
	///
	/// @tparam T Signed or unsigned integer scalar types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/findLSB.xml">GLSL findLSB man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<int, P> findLSB(vecType<T, P> __const & v);

	/// Returns the bit number of the most significant bit in the binary representation of value.
	/// For positive integers, the result will be the bit number of the most significant bit set to 1. 
	/// For negative integers, the result will be the bit number of the most significant
	/// bit set to 0. For a value of zero or negative one, -1 will be returned.
	///
	/// @tparam T Signed or unsigned integer scalar types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/findMSB.xml">GLSL findMSB man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename genIUType>
	 int findMSB(genIUType x);

	/// Returns the bit number of the most significant bit in the binary representation of value.
	/// For positive integers, the result will be the bit number of the most significant bit set to 1. 
	/// For negative integers, the result will be the bit number of the most significant
	/// bit set to 0. For a value of zero or negative one, -1 will be returned.
	///
	/// @tparam T Signed or unsigned integer scalar types.
	///
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/findMSB.xml">GLSL findMSB man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.8 Integer Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<int, P> findMSB(vecType<T, P> __const & v);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/detail/func_integer.inl" 1 3
/// @ref core
/// @file glm/detail/func_integer.inl









                                                                    





        


# 20 "/usr/local/include/glm/detail/func_integer.inl" 3
#pragma clang diagnostic ignored "-Wc++11-long-long"
# 20 "/usr/local/include/glm/detail/func_integer.inl" 3




namespace glm{
namespace detail
{
	template <typename T>
	 __inline T mask(T Bits)
	{
		return Bits >= sizeof(T) * 8 ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
	}

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
	struct compute_bitfieldReverseStep
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & v, T, T)
		{
			return v;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
	struct compute_bitfieldReverseStep<T, P, vecType, Aligned, true>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & v, T Mask, T Shift)
		{
			return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
	struct compute_bitfieldBitCountStep
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & v, T, T)
		{
			return v;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
	struct compute_bitfieldBitCountStep<T, P, vecType, Aligned, true>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & v, T Mask, T Shift)
		{
			return (v & Mask) + ((v >> Shift) & Mask);
		}
	};

	template <typename genIUType, size_t Bits>
	struct compute_findLSB
	{
		 __inline static int call(genIUType Value)
		{
			if(Value == 0)
				return -1;

			return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
		}
	};


# 105 "/usr/local/include/glm/detail/func_integer.inl" 3
                                 

	template <typename T, glm::precision P, template <class, glm::precision> class vecType, bool EXEC = true>
	struct compute_findMSB_step_vec
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, T Shift)
		{
			return x | (x >> Shift);
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
	struct compute_findMSB_step_vec<T, P, vecType, false>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x, T)
		{
			return x;
		}
	};

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType, int>
	struct compute_findMSB_vec
	{
		 __inline static vecType<int, P> call(vecType<T, P> __const & vec)
		{
			vecType<T, P> x(vec);
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 1));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 2));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 4));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
			x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
			return vecType<int, P>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
		}
	};


# 177 "/usr/local/include/glm/detail/func_integer.inl" 3
                                 
}//namespace detail

	// uaddCarry
	 __inline uint uaddCarry(uint __const & x, uint __const & y, uint & Carry)
	{
		uint64 __const Value64(static_cast<uint64>(x) + static_cast<uint64>(y));
		uint64 __const Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
		Carry = Value64 > Max32 ? 1u : 0u;
		return static_cast<uint32>(Value64 % (Max32 + static_cast<uint64>(1)));
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline vecType<uint, P> uaddCarry(vecType<uint, P> __const & x, vecType<uint, P> __const & y, vecType<uint, P> & Carry)
	{
		vecType<uint64, P> Value64(vecType<uint64, P>(x) + vecType<uint64, P>(y));
		vecType<uint64, P> Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
		Carry = mix(vecType<uint32, P>(0), vecType<uint32, P>(1), greaterThan(Value64, Max32));
		return vecType<uint32,P>(Value64 % (Max32 + static_cast<uint64>(1)));
	}

	// usubBorrow
	 __inline uint usubBorrow(uint __const & x, uint __const & y, uint & Borrow)
	{
		;

		Borrow = x >= y ? static_cast<uint32>(0) : static_cast<uint32>(1);
		if(y >= x)
			return y - x;
		else
			return static_cast<uint32>((static_cast<int64>(1) << static_cast<int64>(32)) + (static_cast<int64>(y) - static_cast<int64>(x)));
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline vecType<uint, P> usubBorrow(vecType<uint, P> __const & x, vecType<uint, P> __const & y, vecType<uint, P> & Borrow)
	{
		Borrow = mix(vecType<uint, P>(1), vecType<uint, P>(0), greaterThanEqual(x, y));
		vecType<uint, P> __const YgeX(y - x);
		vecType<uint, P> __const XgeY(vecType<uint32, P>((static_cast<int64>(1) << static_cast<int64>(32)) + (vecType<int64, P>(y) - vecType<int64, P>(x))));
		return mix(XgeY, YgeX, greaterThanEqual(y, x));
	}

	// umulExtended
	 __inline void umulExtended(uint __const & x, uint __const & y, uint & msb, uint & lsb)
	{
		;

		uint64 Value64 = static_cast<uint64>(x) * static_cast<uint64>(y);
		msb = static_cast<uint>(Value64 >> static_cast<uint64>(32));
		lsb = static_cast<uint>(Value64);
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline void umulExtended(vecType<uint, P> __const & x, vecType<uint, P> __const & y, vecType<uint, P> & msb, vecType<uint, P> & lsb)
	{
		;

		vecType<uint64, P> Value64(vecType<uint64, P>(x) * vecType<uint64, P>(y));
		msb = vecType<uint32, P>(Value64 >> static_cast<uint64>(32));
		lsb = vecType<uint32, P>(Value64);
	}

	// imulExtended
	 __inline void imulExtended(int x, int y, int & msb, int & lsb)
	{
		;

		int64 Value64 = static_cast<int64>(x) * static_cast<int64>(y);
		msb = static_cast<int>(Value64 >> static_cast<int64>(32));
		lsb = static_cast<int>(Value64);
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline void imulExtended(vecType<int, P> __const & x, vecType<int, P> __const & y, vecType<int, P> & msb, vecType<int, P> & lsb)
	{
		;

		vecType<int64, P> Value64(vecType<int64, P>(x) * vecType<int64, P>(y));
		lsb = vecType<int32, P>(Value64 & static_cast<int64>(0xFFFFFFFF));
		msb = vecType<int32, P>((Value64 >> static_cast<int64>(32)) & static_cast<int64>(0xFFFFFFFF));
	}

	// bitfieldExtract
	template <typename genIUType>
	 __inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
	{
		return bitfieldExtract(tvec1<genIUType>(Value), Offset, Bits).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> bitfieldExtract(vecType<T, P> __const & Value, int Offset, int Bits)
	{
		;

		return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
	}

	// bitfieldInsert
	template <typename genIUType>
	 __inline genIUType bitfieldInsert(genIUType __const & Base, genIUType __const & Insert, int Offset, int Bits)
	{
		return bitfieldInsert(tvec1<genIUType>(Base), tvec1<genIUType>(Insert), Offset, Bits).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> bitfieldInsert(vecType<T, P> __const & Base, vecType<T, P> __const & Insert, int Offset, int Bits)
	{
		;

		T __const Mask = static_cast<T>(detail::mask(Bits) << Offset);
		return (Base & ~Mask) | (Insert & Mask);
	}

	// bitfieldReverse
	template <typename genType>
	 __inline genType bitfieldReverse(genType x)
	{
		return bitfieldReverse(glm::tvec1<genType, glm::defaultp>(x)).x;
	}

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
	 __inline vecType<T, P> bitfieldReverse(vecType<T, P> __const & v)
	{
		vecType<T, P> x(v);
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  2>::call(x, T(0x5555555555555555ull), static_cast<T>( 1));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  4>::call(x, T(0x3333333333333333ull), static_cast<T>( 2));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  8>::call(x, T(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, T(0x00FF00FF00FF00FFull), static_cast<T>( 8));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, T(0x0000FFFF0000FFFFull), static_cast<T>(16));
		x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, T(0x00000000FFFFFFFFull), static_cast<T>(32));
		return x;
	}

	// bitCount
	template <typename genType>
	 __inline int bitCount(genType x)
	{
		return bitCount(glm::tvec1<genType, glm::defaultp>(x)).x;
	}

	template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
	 __inline vecType<int, P> bitCount(vecType<T, P> __const & v)
	{
		vecType<typename detail::make_unsigned<T>::type, P> x(*reinterpret_cast<vecType<typename detail::make_unsigned<T>::type, P> __const *>(&v));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>=  8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
		x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
		return vecType<int, P>(x);
	}

	// findLSB
	template <typename genIUType>
	 __inline int findLSB(genIUType Value)
	{
		;

		return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<int, P> findLSB(vecType<T, P> __const & x)
	{
		;

		return detail::functor1<int, T, P, vecType>::call(findLSB, x);
	}

	// findMSB
	template <typename genIUType>
	 __inline int findMSB(genIUType x)
	{
		;

		return findMSB(tvec1<genIUType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<int, P> findMSB(vecType<T, P> __const & x)
	{
		;

		return detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(x);
	}
}//namespace glm



       


# 203 "/usr/local/include/glm/detail/func_integer.hpp" 2 3


# 6 "/usr/local/include/glm/integer.hpp" 2 3


# 88 "/usr/local/include/glm/glm.hpp" 2 3


# 12 "common_utils_cpp.h" 2
# 1 "/usr/local/include/glm/gtc/matrix_transform.hpp" 1 3
/// @ref gtc_matrix_transform
/// @file glm/gtc/matrix_transform.hpp
///
/// @see core (dependence)
/// @see gtx_transform
/// @see gtx_transform2
/// 
/// @defgroup gtc_matrix_transform GLM_GTC_matrix_transform
/// @ingroup gtc
///
/// @brief Defines functions that generate common transformation matrices.
///
/// The matrices generated by this extension use standard OpenGL fixed-function
/// conventions. For example, the lookAt function generates a transform from world
/// space into the specific eye space that the projective matrix functions 
/// (perspective, ortho, etc) are designed to expect. The OpenGL compatibility
/// specifications defines the particular layout of this eye space.
///
/// <glm/gtc/matrix_transform.hpp> need to be included to use these functionalities.



// Dependencies





# 1 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 1 3
/// @ref gtc_constants
/// @file glm/gtc/constants.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
///
/// @defgroup gtc_constants GLM_GTC_constants
/// @ingroup gtc
/// 
/// @brief Provide a list of constants and precomputed useful values.
/// 
/// <glm/gtc/constants.hpp> need to be included to use these features.



// Dependencies




       

namespace glm
{
	/// @addtogroup gtc_constants
	/// @{

	/// Return the epsilon constant for floating point types.
	/// @see gtc_constants
	template <typename genType>
	  genType epsilon();

	/// Return 0.
	/// @see gtc_constants
	template <typename genType>
	  genType zero();

	/// Return 1.
	/// @see gtc_constants
	template <typename genType>
	  genType one();

	/// Return the pi constant.
	/// @see gtc_constants
	template <typename genType>
	  genType pi();

	/// Return pi * 2.
	/// @see gtc_constants
	template <typename genType>
	  genType two_pi();

	/// Return square root of pi.
	/// @see gtc_constants
	template <typename genType>
	  genType root_pi();

	/// Return pi / 2.
	/// @see gtc_constants
	template <typename genType>
	  genType half_pi();

	/// Return pi / 2 * 3.
	/// @see gtc_constants
	template <typename genType>
	  genType three_over_two_pi();

	/// Return pi / 4.
	/// @see gtc_constants
	template <typename genType>
	  genType quarter_pi();

	/// Return 1 / pi.
	/// @see gtc_constants
	template <typename genType>
	  genType one_over_pi();

	/// Return 1 / (pi * 2).
	/// @see gtc_constants
	template <typename genType>
	  genType one_over_two_pi();

	/// Return 2 / pi.
	/// @see gtc_constants
	template <typename genType>
	  genType two_over_pi();

	/// Return 4 / pi.
	/// @see gtc_constants
	template <typename genType>
	  genType four_over_pi();

	/// Return 2 / sqrt(pi).
	/// @see gtc_constants
	template <typename genType>
	  genType two_over_root_pi();

	/// Return 1 / sqrt(2).
	/// @see gtc_constants
	template <typename genType>
	  genType one_over_root_two();

	/// Return sqrt(pi / 2).
	/// @see gtc_constants
	template <typename genType>
	  genType root_half_pi();

	/// Return sqrt(2 * pi).
	/// @see gtc_constants
	template <typename genType>
	  genType root_two_pi();

	/// Return sqrt(ln(4)).
	/// @see gtc_constants
	template <typename genType>
	  genType root_ln_four();

	/// Return e constant.
	/// @see gtc_constants
	template <typename genType>
	  genType e();

	/// Return Euler's constant.
	/// @see gtc_constants
	template <typename genType>
	  genType euler();

	/// Return sqrt(2).
	/// @see gtc_constants
	template <typename genType>
	  genType root_two();

	/// Return sqrt(3).
	/// @see gtc_constants
	template <typename genType>
	  genType root_three();

	/// Return sqrt(5).
	/// @see gtc_constants
	template <typename genType>
	  genType root_five();

	/// Return ln(2).
	/// @see gtc_constants
	template <typename genType>
	  genType ln_two();

	/// Return ln(10).
	/// @see gtc_constants
	template <typename genType>
	  genType ln_ten();

	/// Return ln(ln(2)).
	/// @see gtc_constants
	template <typename genType>
	  genType ln_ln_two();

	/// Return 1 / 3.
	/// @see gtc_constants
	template <typename genType>
	  genType third();

	/// Return 2 / 3.
	/// @see gtc_constants
	template <typename genType>
	  genType two_thirds();

	/// Return the golden ratio constant.
	/// @see gtc_constants
	template <typename genType>
	  genType golden_ratio();

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/gtc/constants.inl" 1 3
/// @ref gtc_constants
/// @file glm/gtc/constants.inl



namespace glm
{
	template <typename genType>
	 __inline  genType epsilon()
	{
		return std::numeric_limits<genType>::epsilon();
	}

	template <typename genType>
	 __inline  genType zero()
	{
		return genType(0);
	}

	template <typename genType>
	 __inline  genType one()
	{
		return genType(1);
	}

	template <typename genType>
	 __inline  genType pi()
	{
		return genType(3.14159265358979323846264338327950288);
	}

	template <typename genType>
	 __inline  genType two_pi()
	{
		return genType(6.28318530717958647692528676655900576);
	}

	template <typename genType>
	 __inline  genType root_pi()
	{
		return genType(1.772453850905516027);
	}

	template <typename genType>
	 __inline  genType half_pi()
	{
		return genType(1.57079632679489661923132169163975144);
	}

	template <typename genType>
	 __inline  genType three_over_two_pi()
	{
		return genType(4.71238898038468985769396507491925432);           
	}

	template <typename genType>
	 __inline  genType quarter_pi()
	{
		return genType(0.785398163397448309615660845819875721);
	}

	template <typename genType>
	 __inline  genType one_over_pi()
	{
		return genType(0.318309886183790671537767526745028724);
	}

	template <typename genType>
	 __inline  genType one_over_two_pi()
	{
		return genType(0.159154943091895335768883763372514362);
	}

	template <typename genType>
	 __inline  genType two_over_pi()
	{
		return genType(0.636619772367581343075535053490057448);
	}

	template <typename genType>
	 __inline  genType four_over_pi()
	{
		return genType(1.273239544735162686151070106980114898);
	}

	template <typename genType>
	 __inline  genType two_over_root_pi()
	{
		return genType(1.12837916709551257389615890312154517);
	}

	template <typename genType>
	 __inline  genType one_over_root_two()
	{
		return genType(0.707106781186547524400844362104849039);
	}

	template <typename genType>
	 __inline  genType root_half_pi()
	{
		return genType(1.253314137315500251);
	}

	template <typename genType>
	 __inline  genType root_two_pi()
	{
		return genType(2.506628274631000502);
	}

	template <typename genType>
	 __inline  genType root_ln_four()
	{
		return genType(1.17741002251547469);
	}

	template <typename genType>
	 __inline  genType e()
	{
		return genType(2.71828182845904523536);
	}

	template <typename genType>
	 __inline  genType euler()
	{
		return genType(0.577215664901532860606);
	}

	template <typename genType>
	 __inline  genType root_two()
	{
		return genType(1.41421356237309504880168872420969808);
	}

	template <typename genType>
	 __inline  genType root_three()
	{
		return genType(1.73205080756887729352744634150587236);
	}

	template <typename genType>
	 __inline  genType root_five()
	{
		return genType(2.23606797749978969640917366873127623);
	}

	template <typename genType>
	 __inline  genType ln_two()
	{
		return genType(0.693147180559945309417232121458176568);
	}

	template <typename genType>
	 __inline  genType ln_ten()
	{
		return genType(2.30258509299404568401799145468436421);
	}

	template <typename genType>
	 __inline  genType ln_ln_two()
	{
		return genType(-0.3665129205816643);
	}

	template <typename genType>
	 __inline  genType third()
	{
		return genType(0.3333333333333333333333333333333333333333);
	}

	template <typename genType>
	 __inline  genType two_thirds()
	{
		return genType(0.666666666666666666666666666666666666667);
	}

	template <typename genType>
	 __inline  genType golden_ratio()
	{
		return genType(1.61803398874989484820458683436563811);
	}
} //namespace glm

# 176 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 2 3


# 28 "/usr/local/include/glm/gtc/matrix_transform.hpp" 2 3




       

namespace glm
{
	/// @addtogroup gtc_matrix_transform
	/// @{

	/// Builds a translation 4 * 4 matrix created from a vector of 3 components.
	/// 
	/// @param m Input matrix multiplied by this translation matrix.
	/// @param v Coordinates of a translation vector.
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @code
	/// #include <glm/glm.hpp>
	/// #include <glm/gtc/matrix_transform.hpp>
	/// ...
	/// glm::mat4 m = glm::translate(glm::mat4(1.0f), glm::vec3(1.0f));
	/// // m[0][0] == 1.0f, m[0][1] == 0.0f, m[0][2] == 0.0f, m[0][3] == 0.0f
	/// // m[1][0] == 0.0f, m[1][1] == 1.0f, m[1][2] == 0.0f, m[1][3] == 0.0f
	/// // m[2][0] == 0.0f, m[2][1] == 0.0f, m[2][2] == 1.0f, m[2][3] == 0.0f
	/// // m[3][0] == 1.0f, m[3][1] == 1.0f, m[3][2] == 1.0f, m[3][3] == 1.0f
	/// @endcode
	/// @see gtc_matrix_transform
	/// @see - translate(tmat4x4<T, P> __const & m, T x, T y, T z)
	/// @see - translate(tvec3<T, P> __const & v)
	template <typename T, precision P>
	 tmat4x4<T, P> translate(
		tmat4x4<T, P> __const & m,
		tvec3<T, P> __const & v);
		
	/// Builds a rotation 4 * 4 matrix created from an axis vector and an angle. 
	/// 
	/// @param m Input matrix multiplied by this rotation matrix.
	/// @param angle Rotation angle expressed in radians.
	/// @param axis Rotation axis, recommended to be normalized.
	/// @tparam T Value type used to build the matrix. Supported: half, float or double.
	/// @see gtc_matrix_transform
	/// @see - rotate(tmat4x4<T, P> __const & m, T angle, T x, T y, T z) 
	/// @see - rotate(T angle, tvec3<T, P> __const & v) 
	template <typename T, precision P>
	 tmat4x4<T, P> rotate(
		tmat4x4<T, P> __const & m,
		T angle,
		tvec3<T, P> __const & axis);

	/// Builds a scale 4 * 4 matrix created from 3 scalars. 
	/// 
	/// @param m Input matrix multiplied by this scale matrix.
	/// @param v Ratio of scaling for each axis.
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	/// @see - scale(tmat4x4<T, P> __const & m, T x, T y, T z)
	/// @see - scale(tvec3<T, P> __const & v)
	template <typename T, precision P>
	 tmat4x4<T, P> scale(
		tmat4x4<T, P> __const & m,
		tvec3<T, P> __const & v);

	/// Creates a matrix for an orthographic parallel viewing volume, using the default handedness.
	///
	/// @param left
	/// @param right
	/// @param bottom
	/// @param top
	/// @param zNear
	/// @param zFar
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	/// @see - glm::ortho(T __const & left, T __const & right, T __const & bottom, T __const & top)
	template <typename T>
	 tmat4x4<T, defaultp> ortho(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar);

	/// Creates a matrix for an orthographic parallel viewing volume, using left-handedness.
	///
	/// @param left
	/// @param right
	/// @param bottom
	/// @param top
	/// @param zNear
	/// @param zFar
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	/// @see - glm::ortho(T __const & left, T __const & right, T __const & bottom, T __const & top)
	template <typename T>
	 tmat4x4<T, defaultp> orthoLH(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar);

	/// Creates a matrix for an orthographic parallel viewing volume, using right-handedness.
	///
	/// @param left
	/// @param right
	/// @param bottom
	/// @param top
	/// @param zNear
	/// @param zFar
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	/// @see - glm::ortho(T __const & left, T __const & right, T __const & bottom, T __const & top)
	template <typename T>
	 tmat4x4<T, defaultp> orthoRH(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar);

	/// Creates a matrix for projecting two-dimensional coordinates onto the screen.
	///
	/// @param left
	/// @param right
	/// @param bottom
	/// @param top
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	/// @see - glm::ortho(T __const & left, T __const & right, T __const & bottom, T __const & top, T __const & zNear, T __const & zFar)
	template <typename T>
	 tmat4x4<T, defaultp> ortho(
		T left,
		T right,
		T bottom,
		T top);

	/// Creates a frustum matrix with default handedness.
	///
	/// @param left
	/// @param right
	/// @param bottom
	/// @param top
	/// @param near
	/// @param far
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> frustum(
		T left,
		T right,
		T bottom,
		T top,
		T near,
		T far);

	/// Creates a left handed frustum matrix.
	///
	/// @param left
	/// @param right
	/// @param bottom
	/// @param top
	/// @param near
	/// @param far
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> frustumLH(
		T left,
		T right,
		T bottom,
		T top,
		T near,
		T far);

	/// Creates a right handed frustum matrix.
	///
	/// @param left
	/// @param right
	/// @param bottom
	/// @param top
	/// @param near
	/// @param far
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> frustumRH(
		T left,
		T right,
		T bottom,
		T top,
		T near,
		T far);

	/// Creates a matrix for a symetric perspective-view frustum based on the default handedness.
	/// 
	/// @param fovy Specifies the field of view angle in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @param far Specifies the distance from the viewer to the far clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> perspective(
		T fovy,
		T aspect,
		T near,
		T far);

	/// Creates a matrix for a right handed, symetric perspective-view frustum.
	/// 
	/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @param far Specifies the distance from the viewer to the far clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveRH(
		T fovy,
		T aspect,
		T near,
		T far);

	/// Creates a matrix for a left handed, symetric perspective-view frustum.
	/// 
	/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @param far Specifies the distance from the viewer to the far clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveLH(
		T fovy,
		T aspect,
		T near,
		T far);

	/// Builds a perspective projection matrix based on a field of view and the default handedness.
	/// 
	/// @param fov Expressed in radians.
	/// @param width 
	/// @param height 
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @param far Specifies the distance from the viewer to the far clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveFov(
		T fov,
		T width,
		T height,
		T near,
		T far);

	/// Builds a right handed perspective projection matrix based on a field of view.
	/// 
	/// @param fov Expressed in radians.
	/// @param width 
	/// @param height 
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @param far Specifies the distance from the viewer to the far clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveFovRH(
		T fov,
		T width,
		T height,
		T near,
		T far);

	/// Builds a left handed perspective projection matrix based on a field of view.
	/// 
	/// @param fov Expressed in radians.
	/// @param width 
	/// @param height 
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @param far Specifies the distance from the viewer to the far clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveFovLH(
		T fov,
		T width,
		T height,
		T near,
		T far);

	/// Creates a matrix for a symmetric perspective-view frustum with far plane at infinite with default handedness.
	///
	/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> infinitePerspective(
		T fovy, T aspect, T near);

	/// Creates a matrix for a left handed, symmetric perspective-view frustum with far plane at infinite.
	///
	/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> infinitePerspectiveLH(
		T fovy, T aspect, T near);

	/// Creates a matrix for a right handed, symmetric perspective-view frustum with far plane at infinite.
	///
	/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> infinitePerspectiveRH(
		T fovy, T aspect, T near);

	/// Creates a matrix for a symmetric perspective-view frustum with far plane at infinite for graphics hardware that doesn't support depth clamping.
	/// 
	/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T near);

	/// Creates a matrix for a symmetric perspective-view frustum with far plane at infinite for graphics hardware that doesn't support depth clamping.
	/// 
	/// @param fovy Specifies the field of view angle, in degrees, in the y direction. Expressed in radians.
	/// @param aspect Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height).
	/// @param near Specifies the distance from the viewer to the near clipping plane (always positive).
	/// @param ep 
	/// @tparam T Value type used to build the matrix. Currently supported: half (not recommanded), float or double.
	/// @see gtc_matrix_transform
	template <typename T>
	 tmat4x4<T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T near, T ep);

	/// Map the specified object coordinates (obj.x, obj.y, obj.z) into window coordinates.
	/// 
	/// @param obj Specify the object coordinates.
	/// @param model Specifies the current modelview matrix
	/// @param proj Specifies the current projection matrix
	/// @param viewport Specifies the current viewport
	/// @return Return the computed window coordinates.
	/// @tparam T Native type used for the computation. Currently supported: half (not recommanded), float or double.
	/// @tparam U Currently supported: Floating-point types and integer types.
	/// @see gtc_matrix_transform
	template <typename T, typename U, precision P>
	 tvec3<T, P> project(
		tvec3<T, P> __const & obj,
		tmat4x4<T, P> __const & model,
		tmat4x4<T, P> __const & proj,
		tvec4<U, P> __const & viewport);

	/// Map the specified window coordinates (win.x, win.y, win.z) into object coordinates.
	///
	/// @param win Specify the window coordinates to be mapped.
	/// @param model Specifies the modelview matrix
	/// @param proj Specifies the projection matrix
	/// @param viewport Specifies the viewport
	/// @return Returns the computed object coordinates.
	/// @tparam T Native type used for the computation. Currently supported: half (not recommanded), float or double.
	/// @tparam U Currently supported: Floating-point types and integer types.
	/// @see gtc_matrix_transform
	template <typename T, typename U, precision P>
	 tvec3<T, P> unProject(
		tvec3<T, P> __const & win,
		tmat4x4<T, P> __const & model,
		tmat4x4<T, P> __const & proj,
		tvec4<U, P> __const & viewport);

	/// Define a picking region
	///
	/// @param center
	/// @param delta
	/// @param viewport
	/// @tparam T Native type used for the computation. Currently supported: half (not recommanded), float or double.
	/// @tparam U Currently supported: Floating-point types and integer types.
	/// @see gtc_matrix_transform
	template <typename T, precision P, typename U>
	 tmat4x4<T, P> pickMatrix(
		tvec2<T, P> __const & center,
		tvec2<T, P> __const & delta,
		tvec4<U, P> __const & viewport);

	/// Build a look at view matrix based on the default handedness.
	///
	/// @param eye Position of the camera
	/// @param center Position where the camera is looking at
	/// @param up Normalized up vector, how the camera is oriented. Typically (0, 0, 1)
	/// @see gtc_matrix_transform
	/// @see - frustum(T __const & left, T __const & right, T __const & bottom, T __const & top, T __const & nearVal, T __const & farVal) frustum(T __const & left, T __const & right, T __const & bottom, T __const & top, T __const & nearVal, T __const & farVal)
	template <typename T, precision P>
	 tmat4x4<T, P> lookAt(
		tvec3<T, P> __const & eye,
		tvec3<T, P> __const & center,
		tvec3<T, P> __const & up);

	/// Build a right handed look at view matrix.
	///
	/// @param eye Position of the camera
	/// @param center Position where the camera is looking at
	/// @param up Normalized up vector, how the camera is oriented. Typically (0, 0, 1)
	/// @see gtc_matrix_transform
	/// @see - frustum(T __const & left, T __const & right, T __const & bottom, T __const & top, T __const & nearVal, T __const & farVal) frustum(T __const & left, T __const & right, T __const & bottom, T __const & top, T __const & nearVal, T __const & farVal)
	template <typename T, precision P>
	 tmat4x4<T, P> lookAtRH(
		tvec3<T, P> __const & eye,
		tvec3<T, P> __const & center,
		tvec3<T, P> __const & up);

	/// Build a left handed look at view matrix.
	///
	/// @param eye Position of the camera
	/// @param center Position where the camera is looking at
	/// @param up Normalized up vector, how the camera is oriented. Typically (0, 0, 1)
	/// @see gtc_matrix_transform
	/// @see - frustum(T __const & left, T __const & right, T __const & bottom, T __const & top, T __const & nearVal, T __const & farVal) frustum(T __const & left, T __const & right, T __const & bottom, T __const & top, T __const & nearVal, T __const & farVal)
	template <typename T, precision P>
	 tmat4x4<T, P> lookAtLH(
		tvec3<T, P> __const & eye,
		tvec3<T, P> __const & center,
		tvec3<T, P> __const & up);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/matrix_transform.inl" 1 3
/// @ref gtc_matrix_transform
/// @file glm/gtc/matrix_transform.inl





namespace glm
{
	template <typename T, precision P>
	 __inline tmat4x4<T, P> translate(tmat4x4<T, P> __const & m, tvec3<T, P> __const & v)
	{
		tmat4x4<T, P> Result(m);
		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
		return Result;
	}
	
	template <typename T, precision P>
	 __inline tmat4x4<T, P> rotate(tmat4x4<T, P> __const & m, T angle, tvec3<T, P> __const & v)
	{
		T __const a = angle;
		T __const c = cos(a);
		T __const s = sin(a);

		tvec3<T, P> axis(normalize(v));
		tvec3<T, P> temp((T(1) - c) * axis);

		tmat4x4<T, P> Rotate(uninitialize);
		Rotate[0][0] = c + temp[0] * axis[0];
		Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
		Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

		Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
		Rotate[1][1] = c + temp[1] * axis[1];
		Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

		Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
		Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
		Rotate[2][2] = c + temp[2] * axis[2];

		tmat4x4<T, P> Result(uninitialize);
		Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
		Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
		Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
		Result[3] = m[3];
		return Result;
	}
		
	template <typename T, precision P>
	 __inline tmat4x4<T, P> rotate_slow(tmat4x4<T, P> __const & m, T angle, tvec3<T, P> __const & v)
	{
		T __const a = angle;
		T __const c = cos(a);
		T __const s = sin(a);
		tmat4x4<T, P> Result;

		tvec3<T, P> axis = normalize(v);

		Result[0][0] = c + (static_cast<T>(1) - c)      * axis.x     * axis.x;
		Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
		Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
		Result[0][3] = static_cast<T>(0);

		Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
		Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
		Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
		Result[1][3] = static_cast<T>(0);

		Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
		Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
		Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
		Result[2][3] = static_cast<T>(0);

		Result[3] = tvec4<T, P>(0, 0, 0, 1);
		return m * Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> scale(tmat4x4<T, P> __const & m, tvec3<T, P> __const & v)
	{
		tmat4x4<T, P> Result(uninitialize);
		Result[0] = m[0] * v[0];
		Result[1] = m[1] * v[1];
		Result[2] = m[2] * v[2];
		Result[3] = m[3];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> scale_slow(tmat4x4<T, P> __const & m, tvec3<T, P> __const & v)
	{
		tmat4x4<T, P> Result(T(1));
		Result[0][0] = v.x;
		Result[1][1] = v.y;
		Result[2][2] = v.z;
		return m * Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> ortho
	(
		T left, T right,
		T bottom, T top,
		T zNear, T zFar
	)
	{


        
			return orthoRH(left, right, bottom, top, zNear, zFar);

	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> orthoLH
	(
		T left, T right,
		T bottom, T top,
		T zNear, T zFar
	)
	{
		tmat4x4<T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);




        
			Result[2][2] = static_cast<T>(2) / (zFar - zNear);
			Result[3][2] = - (zFar + zNear) / (zFar - zNear);


		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> orthoRH
	(
		T left, T right,
		T bottom, T top,
		T zNear, T zFar
	)
	{
		tmat4x4<T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);




        
			Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
			Result[3][2] = - (zFar + zNear) / (zFar - zNear);


		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> ortho
	(
		T left, T right,
		T bottom, T top
	)
	{
		tmat4x4<T, defaultp> Result(static_cast<T>(1));
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> frustum
	(
		T left, T right,
		T bottom, T top,
		T nearVal, T farVal
	)
	{


        
			return frustumRH(left, right, bottom, top, nearVal, farVal);

	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> frustumLH
	(
		T left, T right,
		T bottom, T top,
		T nearVal, T farVal
	)
	{
		tmat4x4<T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][3] = static_cast<T>(1);




        
			Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
			Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);


		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> frustumRH
	(
		T left, T right,
		T bottom, T top,
		T nearVal, T farVal
	)
	{
		tmat4x4<T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][3] = static_cast<T>(-1);




        
			Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
			Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);


		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
	{


        
			return perspectiveRH(fovy, aspect, zNear, zFar);

	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
	{
		assert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));

		T __const tanHalfFovy = tan(fovy / static_cast<T>(2));

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][3] = - static_cast<T>(1);




        
			Result[2][2] = - (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


		return Result;
	}
	
	template <typename T>
	 __inline tmat4x4<T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
	{
		assert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));

		T __const tanHalfFovy = tan(fovy / static_cast<T>(2));
		
		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][3] = static_cast<T>(1);




        
			Result[2][2] = (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
	{


        
			return perspectiveFovRH(fov, width, height, zNear, zFar);

	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
	{
		assert(width > static_cast<T>(0));
		assert(height > static_cast<T>(0));
		assert(fov > static_cast<T>(0));
	
		T __const rad = fov;
		T __const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T __const w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][3] = - static_cast<T>(1);




        
			Result[2][2] = - (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
	{
		assert(width > static_cast<T>(0));
		assert(height > static_cast<T>(0));
		assert(fov > static_cast<T>(0));
	
		T __const rad = fov;
		T __const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T __const w = h * height / width; ///todo max(width , Height) / min(width , Height)?

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][3] = static_cast<T>(1);




        
			Result[2][2] = (zFar + zNear) / (zFar - zNear);
			Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
	{


        
			return infinitePerspectiveRH(fovy, aspect, zNear);

	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> infinitePerspectiveRH(T fovy, T aspect, T zNear)
	{
		T __const range = tan(fovy / static_cast<T>(2)) * zNear;
		T __const left = -range * aspect;
		T __const right = range * aspect;
		T __const bottom = -range;
		T __const top = range;

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - static_cast<T>(2) * zNear;
		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> infinitePerspectiveLH(T fovy, T aspect, T zNear)
	{
		T __const range = tan(fovy / static_cast<T>(2)) * zNear;
		T __const left = -range * aspect;
		T __const right = range * aspect;
		T __const bottom = -range;
		T __const top = range;

		tmat4x4<T, defaultp> Result(T(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = static_cast<T>(1);
		Result[2][3] = static_cast<T>(1);
		Result[3][2] = - static_cast<T>(2) * zNear;
		return Result;
	}

	// Infinite projection matrix: http://www.terathon.com/gdc07_lengyel.pdf
	template <typename T>
	 __inline tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
	{
		T __const range = tan(fovy / static_cast<T>(2)) * zNear;	
		T __const left = -range * aspect;
		T __const right = range * aspect;
		T __const bottom = -range;
		T __const top = range;

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = ep - static_cast<T>(1);
		Result[2][3] = static_cast<T>(-1);
		Result[3][2] = (ep - static_cast<T>(2)) * zNear;
		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
	{
		return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
	}

	template <typename T, typename U, precision P>
	 __inline tvec3<T, P> project
	(
		tvec3<T, P> __const & obj,
		tmat4x4<T, P> __const & model,
		tmat4x4<T, P> __const & proj,
		tvec4<U, P> __const & viewport
	)
	{
		tvec4<T, P> tmp = tvec4<T, P>(obj, static_cast<T>(1));
		tmp = model * tmp;
		tmp = proj * tmp;

		tmp /= tmp.w;



        
			tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);

		tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
		tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

		return tvec3<T, P>(tmp);
	}

	template <typename T, typename U, precision P>
	 __inline tvec3<T, P> unProject
	(
		tvec3<T, P> __const & win,
		tmat4x4<T, P> __const & model,
		tmat4x4<T, P> __const & proj,
		tvec4<U, P> __const & viewport
	)
	{
		tmat4x4<T, P> Inverse = inverse(proj * model);

		tvec4<T, P> tmp = tvec4<T, P>(win, T(1));
		tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
		tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);



        
			tmp = tmp * static_cast<T>(2) - static_cast<T>(1);


		tvec4<T, P> obj = Inverse * tmp;
		obj /= obj.w;

		return tvec3<T, P>(obj);
	}

	template <typename T, precision P, typename U>
	 __inline tmat4x4<T, P> pickMatrix(tvec2<T, P> __const & center, tvec2<T, P> __const & delta, tvec4<U, P> __const & viewport)
	{
		assert(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0));
		tmat4x4<T, P> Result(static_cast<T>(1));

		if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
			return Result; // Error

		tvec3<T, P> Temp(
			(static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
			(static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
			static_cast<T>(0));

		// Translate and scale the picked region to the entire window
		Result = translate(Result, Temp);
		return scale(Result, tvec3<T, P>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> lookAt(tvec3<T, P> __const & eye, tvec3<T, P> __const & center, tvec3<T, P> __const & up)
	{


        
			return lookAtRH(eye, center, up);

	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> lookAtRH
	(
		tvec3<T, P> __const & eye,
		tvec3<T, P> __const & center,
		tvec3<T, P> __const & up
	)
	{
		tvec3<T, P> __const f(normalize(center - eye));
		tvec3<T, P> __const s(normalize(cross(f, up)));
		tvec3<T, P> __const u(cross(s, f));

		tmat4x4<T, P> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] =-f.x;
		Result[1][2] =-f.y;
		Result[2][2] =-f.z;
		Result[3][0] =-dot(s, eye);
		Result[3][1] =-dot(u, eye);
		Result[3][2] = dot(f, eye);
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> lookAtLH
	(
		tvec3<T, P> __const & eye,
		tvec3<T, P> __const & center,
		tvec3<T, P> __const & up
	)
	{
		tvec3<T, P> __const f(normalize(center - eye));
		tvec3<T, P> __const s(normalize(cross(up, f)));
		tvec3<T, P> __const u(cross(f, s));

		tmat4x4<T, P> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] = f.x;
		Result[1][2] = f.y;
		Result[2][2] = f.z;
		Result[3][0] = -dot(s, eye);
		Result[3][1] = -dot(u, eye);
		Result[3][2] = -dot(f, eye);
		return Result;
	}
}//namespace glm

# 465 "/usr/local/include/glm/gtc/matrix_transform.hpp" 2 3


# 13 "common_utils_cpp.h" 2
# 1 "/usr/local/include/glm/gtc/type_ptr.hpp" 1 3
/// @ref gtc_type_ptr
/// @file glm/gtc/type_ptr.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtc_quaternion (dependence)
///
/// @defgroup gtc_type_ptr GLM_GTC_type_ptr
/// @ingroup gtc
///
/// @brief Handles the interaction between pointers and vector, matrix types.
///
/// This extension defines an overloaded function, glm::value_ptr, which
/// takes any of the \ref core_template "core template types". It returns
/// a pointer to the memory layout of the object. Matrix types store their values
/// in column-major order.
/// 
/// This is useful for uploading data to matrices or copying data to buffer objects.
///
/// Example:
/// @code
/// #include <glm/glm.hpp>
/// #include <glm/gtc/type_ptr.hpp>
///
/// glm::vec3 aVector(3);
/// glm::mat4 someMatrix(1.0);
///
/// glUniform3fv(uniformLoc, 1, glm::value_ptr(aVector));
/// glUniformMatrix4fv(uniformMatrixLoc, 1, GL_FALSE, glm::value_ptr(someMatrix));
/// @endcode
///
/// <glm/gtc/type_ptr.hpp> need to be included to use these functionalities.



// Dependency:

# 1 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 1 3
/// @ref gtc_quaternion
/// @file glm/gtc/quaternion.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtc_constants (dependence)
///
/// @defgroup gtc_quaternion GLM_GTC_quaternion
/// @ingroup gtc
///
/// @brief Defines a templated quaternion type and several quaternion operations.
///
/// <glm/gtc/quaternion.hpp> need to be included to use these functionalities.



// Dependency:








       

namespace glm
{
	/// @addtogroup gtc_quaternion
	/// @{

	template <typename T, precision P = defaultp>
	struct tquat
	{
		// -- Implementation detail --

		typedef tquat<T, P> type;
		typedef T value_type;

		// -- Data --


# 66 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
        
			T x, y, z, w;


		// -- Component accesses --

		typedef length_t length_type;
		/// Return the count of components of a quaternion
		 static length_type length(){return 4;}

		 T & operator[](length_type i);
		 T __const & operator[](length_type i) __const;

		// -- Implicit basic constructors --

		  tquat() ;
		  tquat(tquat<T, P> __const & q) ;
		template <precision Q>
		  tquat(tquat<T, Q> __const & q);

		// -- Explicit basic constructors --

		  explicit tquat(ctor);
		  tquat(T __const & s, tvec3<T, P> __const & v);
		  tquat(T __const & w, T __const & x, T __const & y, T __const & z);

		// -- Conversion constructors --

		template <typename U, precision Q>
		   tquat(tquat<U, Q> __const & q);

		/// Explicit conversion operators



         

		/// Create a quaternion from two normalized axis
		///
		/// @param u A first normalized axis
		/// @param v A second normalized axis
		/// @see gtc_quaternion
		/// @see http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors
		 tquat(tvec3<T, P> __const & u, tvec3<T, P> __const & v);

		/// Build a quaternion from euler angles (pitch, yaw, roll), in radians.
		  tquat(tvec3<T, P> __const & eulerAngles);
		  tquat(tmat3x3<T, P> __const & m);
		  tquat(tmat4x4<T, P> __const & m);

		// -- Unary arithmetic operators --

		 tquat<T, P> & operator=(tquat<T, P> __const & m) ;

		template <typename U>
		 tquat<T, P> & operator=(tquat<U, P> __const & m);
		template <typename U>
		 tquat<T, P> & operator+=(tquat<U, P> __const & q);
		template <typename U>
		 tquat<T, P> & operator-=(tquat<U, P> __const & q);
		template <typename U>
		 tquat<T, P> & operator*=(tquat<U, P> __const & q);
		template <typename U>
		 tquat<T, P> & operator*=(U s);
		template <typename U>
		 tquat<T, P> & operator/=(U s);
	};

	// -- Unary bit operators --

	template <typename T, precision P>
	 tquat<T, P> operator+(tquat<T, P> __const & q);

	template <typename T, precision P>
	 tquat<T, P> operator-(tquat<T, P> __const & q);

	// -- Binary operators --

	template <typename T, precision P>
	 tquat<T, P> operator+(tquat<T, P> __const & q, tquat<T, P> __const & p);

	template <typename T, precision P>
	 tquat<T, P> operator*(tquat<T, P> __const & q, tquat<T, P> __const & p);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tquat<T, P> __const & q, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> __const & v, tquat<T, P> __const & q);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tquat<T, P> __const & q, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> __const & v, tquat<T, P> __const & q);

	template <typename T, precision P>
	 tquat<T, P> operator*(tquat<T, P> __const & q, T __const & s);

	template <typename T, precision P>
	 tquat<T, P> operator*(T __const & s, tquat<T, P> __const & q);

	template <typename T, precision P>
	 tquat<T, P> operator/(tquat<T, P> __const & q, T __const & s);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tquat<T, P> __const & q1, tquat<T, P> __const & q2);

	template <typename T, precision P>
	 bool operator!=(tquat<T, P> __const & q1, tquat<T, P> __const & q2);

	/// Returns the length of the quaternion.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 T length(tquat<T, P> __const & q);

	/// Returns the normalized quaternion.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> normalize(tquat<T, P> __const & q);
		
	/// Returns dot product of q1 and q2, i.e., q1[0] * q2[0] + q1[1] * q2[1] + ...
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P, template <typename, precision> class quatType>
	 T dot(quatType<T, P> __const & x, quatType<T, P> __const & y);

	/// Spherical linear interpolation of two quaternions.
	/// The interpolation is oriented and the rotation is performed at constant speed.
	/// For short path spherical linear interpolation, use the slerp function.
	/// 
	/// @param x A quaternion
	/// @param y A quaternion
	/// @param a Interpolation factor. The interpolation is defined beyond the range [0, 1].
	/// @tparam T Value type used to build the quaternion. Supported: half, float or double.
	/// @see gtc_quaternion
	/// @see - slerp(tquat<T, P> __const & x, tquat<T, P> __const & y, T __const & a)
	template <typename T, precision P>
	 tquat<T, P> mix(tquat<T, P> __const & x, tquat<T, P> __const & y, T a);

	/// Linear interpolation of two quaternions.
	/// The interpolation is oriented.
	/// 
	/// @param x A quaternion
	/// @param y A quaternion
	/// @param a Interpolation factor. The interpolation is defined in the range [0, 1].
	/// @tparam T Value type used to build the quaternion. Supported: half, float or double.
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> lerp(tquat<T, P> __const & x, tquat<T, P> __const & y, T a);

	/// Spherical linear interpolation of two quaternions.
	/// The interpolation always take the short path and the rotation is performed at constant speed.
	/// 
	/// @param x A quaternion
	/// @param y A quaternion
	/// @param a Interpolation factor. The interpolation is defined beyond the range [0, 1].
	/// @tparam T Value type used to build the quaternion. Supported: half, float or double.
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> slerp(tquat<T, P> __const & x, tquat<T, P> __const & y, T a);

	/// Returns the q conjugate.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> conjugate(tquat<T, P> __const & q);

	/// Returns the q inverse.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> inverse(tquat<T, P> __const & q);

	/// Rotates a quaternion from a vector of 3 components axis and an angle.
	/// 
	/// @param q Source orientation
	/// @param angle Angle expressed in radians.
	/// @param axis Axis of the rotation
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> rotate(tquat<T, P> __const & q, T __const & angle, tvec3<T, P> __const & axis);

	/// Returns euler angles, pitch as x, yaw as y, roll as z.
	/// The result is expressed in radians if GLM_FORCE_RADIANS is defined or degrees otherwise.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec3<T, P> eulerAngles(tquat<T, P> __const & x);

	/// Returns roll value of euler angles expressed in radians.
	///
	/// @see gtx_quaternion
	template <typename T, precision P>
	 T roll(tquat<T, P> __const & x);

	/// Returns pitch value of euler angles expressed in radians.
	///
	/// @see gtx_quaternion
	template <typename T, precision P>
	 T pitch(tquat<T, P> __const & x);

	/// Returns yaw value of euler angles expressed in radians.
	///
	/// @see gtx_quaternion
	template <typename T, precision P>
	 T yaw(tquat<T, P> __const & x);

	/// Converts a quaternion to a 3 * 3 matrix.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tmat3x3<T, P> mat3_cast(tquat<T, P> __const & x);

	/// Converts a quaternion to a 4 * 4 matrix.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tmat4x4<T, P> mat4_cast(tquat<T, P> __const & x);

	/// Converts a 3 * 3 matrix to a quaternion.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> quat_cast(tmat3x3<T, P> __const & x);

	/// Converts a 4 * 4 matrix to a quaternion.
	/// 
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> quat_cast(tmat4x4<T, P> __const & x);

	/// Returns the quaternion rotation angle.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 T angle(tquat<T, P> __const & x);

	/// Returns the q rotation axis.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec3<T, P> axis(tquat<T, P> __const & x);

	/// Build a quaternion from an angle and a normalized axis.
	///
	/// @param angle Angle expressed in radians.
	/// @param axis Axis of the quaternion, must be normalized.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tquat<T, P> angleAxis(T __const & angle, tvec3<T, P> __const & axis);

	/// Returns the component-wise comparison result of x < y.
	/// 
	/// @tparam quatType Floating-point quaternion types.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec4<bool, P> lessThan(tquat<T, P> __const & x, tquat<T, P> __const & y);

	/// Returns the component-wise comparison of result x <= y.
	///
	/// @tparam quatType Floating-point quaternion types.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec4<bool, P> lessThanEqual(tquat<T, P> __const & x, tquat<T, P> __const & y);

	/// Returns the component-wise comparison of result x > y.
	///
	/// @tparam quatType Floating-point quaternion types.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec4<bool, P> greaterThan(tquat<T, P> __const & x, tquat<T, P> __const & y);

	/// Returns the component-wise comparison of result x >= y.
	///
	/// @tparam quatType Floating-point quaternion types.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec4<bool, P> greaterThanEqual(tquat<T, P> __const & x, tquat<T, P> __const & y);

	/// Returns the component-wise comparison of result x == y.
	///
	/// @tparam quatType Floating-point quaternion types.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec4<bool, P> equal(tquat<T, P> __const & x, tquat<T, P> __const & y);

	/// Returns the component-wise comparison of result x != y.
	/// 
	/// @tparam quatType Floating-point quaternion types.
	///
	/// @see gtc_quaternion
	template <typename T, precision P>
	 tvec4<bool, P> notEqual(tquat<T, P> __const & x, tquat<T, P> __const & y);

	/// Returns true if x holds a NaN (not a number)
	/// representation in the underlying implementation's set of
	/// floating point representations. Returns false otherwise,
	/// including for implementations with no NaN
	/// representations.
	/// 
	/// /!\ When using compiler fast math, this function may fail.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	template <typename T, precision P>
	 tvec4<bool, P> isnan(tquat<T, P> __const & x);

	/// Returns true if x holds a positive infinity or negative
	/// infinity representation in the underlying implementation's
	/// set of floating point representations. Returns false
	/// otherwise, including for implementations with no infinity
	/// representations.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	template <typename T, precision P>
	 tvec4<bool, P> isinf(tquat<T, P> __const & x);

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/gtc/quaternion.inl" 1 3
/// @ref gtc_quaternion
/// @file glm/gtc/quaternion.inl






namespace glm{
namespace detail
{
	template <typename T, precision P, bool Aligned>
	struct compute_dot<tquat, T, P, Aligned>
	{
		static  __inline T call(tquat<T, P> __const& x, tquat<T, P> __const& y)
		{
			tvec4<T, P> tmp(x.x * y.x, x.y * y.y, x.z * y.z, x.w * y.w);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_add
	{
		static tquat<T, P> call(tquat<T, P> __const& q, tquat<T, P> __const& p)
		{
			return tquat<T, P>(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_sub
	{
		static tquat<T, P> call(tquat<T, P> __const& q, tquat<T, P> __const& p)
		{
			return tquat<T, P>(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_mul_scalar
	{
		static tquat<T, P> call(tquat<T, P> __const& q, T s)
		{
			return tquat<T, P>(q.w * s, q.x * s, q.y * s, q.z * s);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_div_scalar
	{
		static tquat<T, P> call(tquat<T, P> __const& q, T s)
		{
			return tquat<T, P>(q.w / s, q.x / s, q.y / s, q.z / s);
		}
	};

	template <typename T, precision P, bool Aligned>
	struct compute_quat_mul_vec4
	{
		static tvec4<T, P> call(tquat<T, P> __const & q, tvec4<T, P> __const & v)
		{
			return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
		}
	};
}//namespace detail

	// -- Component accesses --

	template <typename T, precision P>
	 __inline T & tquat<T, P>::operator[](typename tquat<T, P>::length_type i)
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	template <typename T, precision P>
	 __inline T __const & tquat<T, P>::operator[](typename tquat<T, P>::length_type i) __const
	{
		assert(i >= 0 && i < this->length());
		return (&x)[i];
	}

	// -- Implicit basic constructors --


		template <typename T, precision P>
		 __inline  tquat<T, P>::tquat()

				: x(0), y(0), z(0), w(1)

		{}



		template <typename T, precision P>
		 __inline  tquat<T, P>::tquat(tquat<T, P> __const & q)
			: x(q.x), y(q.y), z(q.z), w(q.w)
		{}


	template <typename T, precision P>
	template <precision Q>
	 __inline  tquat<T, P>::tquat(tquat<T, Q> __const & q)
		: x(q.x), y(q.y), z(q.z), w(q.w)
	{}

	// -- Explicit basic constructors --

	template <typename T, precision P>
	 __inline  tquat<T, P>::tquat(ctor)
	{}

	template <typename T, precision P>
	 __inline  tquat<T, P>::tquat(T __const & s, tvec3<T, P> __const & v)
		: x(v.x), y(v.y), z(v.z), w(s)
	{}

	template <typename T, precision P>
	 __inline  tquat<T, P>::tquat(T __const & w, T __const & x, T __const & y, T __const & z)
		: x(x), y(y), z(z), w(w)
	{}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tquat<T, P>::tquat(tquat<U, Q> __const & q)
		: x(static_cast<T>(q.x))
		, y(static_cast<T>(q.y))
		, z(static_cast<T>(q.z))
		, w(static_cast<T>(q.w))
	{}

	//template <typename valType> 
	// __inline tquat<valType>::tquat
	//(
	//	valType __const & pitch,
	//	valType __const & yaw,
	//	valType __const & roll
	//)
	//{
	//	tvec3<valType> eulerAngle(pitch * valType(0.5), yaw * valType(0.5), roll * valType(0.5));
	//	tvec3<valType> c = glm::cos(eulerAngle * valType(0.5));
	//	tvec3<valType> s = glm::sin(eulerAngle * valType(0.5));
	//	
	//	this->w = c.x * c.y * c.z + s.x * s.y * s.z;
	//	this->x = s.x * c.y * c.z - c.x * s.y * s.z;
	//	this->y = c.x * s.y * c.z + s.x * c.y * s.z;
	//	this->z = c.x * c.y * s.z - s.x * s.y * c.z;
	//}

	template <typename T, precision P>
	 __inline tquat<T, P>::tquat(tvec3<T, P> __const & u, tvec3<T, P> __const & v)
	{
		tvec3<T, P> __const LocalW(cross(u, v));
		T Dot = detail::compute_dot<tvec3, T, P, detail::is_aligned<P>::value>::call(u, v);
		tquat<T, P> q(T(1) + Dot, LocalW.x, LocalW.y, LocalW.z);

		*this = normalize(q);
	}

	template <typename T, precision P>
	 __inline tquat<T, P>::tquat(tvec3<T, P> __const & eulerAngle)
	{
		tvec3<T, P> c = glm::cos(eulerAngle * T(0.5));
		tvec3<T, P> s = glm::sin(eulerAngle * T(0.5));
		
		this->w = c.x * c.y * c.z + s.x * s.y * s.z;
		this->x = s.x * c.y * c.z - c.x * s.y * s.z;
		this->y = c.x * s.y * c.z + s.x * c.y * s.z;
		this->z = c.x * c.y * s.z - s.x * s.y * c.z;
	}

	template <typename T, precision P>
	 __inline tquat<T, P>::tquat(tmat3x3<T, P> __const & m)
	{
		*this = quat_cast(m);
	}

	template <typename T, precision P>
	 __inline tquat<T, P>::tquat(tmat4x4<T, P> __const & m)
	{
		*this = quat_cast(m);
	}


# 199 "/usr/local/include/glm/gtc/quaternion.inl" 3
                                               

	template <typename T, precision P>
	 __inline tquat<T, P> conjugate(tquat<T, P> __const & q)
	{
		return tquat<T, P>(q.w, -q.x, -q.y, -q.z);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> inverse(tquat<T, P> __const & q)
	{
		return conjugate(q) / dot(q, q);
	}

	// -- Unary arithmetic operators --


		template <typename T, precision P>
		 __inline tquat<T, P> & tquat<T, P>::operator=(tquat<T, P> __const & q)
		{
			this->w = q.w;
			this->x = q.x;
			this->y = q.y;
			this->z = q.z;
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tquat<T, P> & tquat<T, P>::operator=(tquat<U, P> __const & q)
	{
		this->w = static_cast<T>(q.w);
		this->x = static_cast<T>(q.x);
		this->y = static_cast<T>(q.y);
		this->z = static_cast<T>(q.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tquat<T, P> & tquat<T, P>::operator+=(tquat<U, P> __const& q)
	{
		return (*this = detail::compute_quat_add<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tquat<T, P> & tquat<T, P>::operator-=(tquat<U, P> __const& q)
	{
		return (*this = detail::compute_quat_sub<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tquat<T, P> & tquat<T, P>::operator*=(tquat<U, P> __const & r)
	{
		tquat<T, P> __const p(*this);
		tquat<T, P> __const q(r);

		this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
		this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
		this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
		this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tquat<T, P> & tquat<T, P>::operator*=(U s)
	{
		return (*this = detail::compute_quat_mul_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tquat<T, P> & tquat<T, P>::operator/=(U s)
	{
		return (*this = detail::compute_quat_div_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
	}

	// -- Unary bit operators --

	template <typename T, precision P>
	 __inline tquat<T, P> operator+(tquat<T, P> __const & q)
	{
		return q;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> operator-(tquat<T, P> __const & q)
	{
		return tquat<T, P>(-q.w, -q.x, -q.y, -q.z);
	}

	// -- Binary operators --

	template <typename T, precision P>
	 __inline tquat<T, P> operator+(tquat<T, P> __const & q,	tquat<T, P> __const & p)
	{
		return tquat<T, P>(q) += p;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> operator*(tquat<T, P> __const & q,	tquat<T, P> __const & p)
	{
		return tquat<T, P>(q) *= p;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tquat<T, P> __const & q,	tvec3<T, P> __const & v)
	{
		tvec3<T, P> __const QuatVector(q.x, q.y, q.z);
		tvec3<T, P> __const uv(glm::cross(QuatVector, v));
		tvec3<T, P> __const uuv(glm::cross(QuatVector, uv));

		return v + ((uv * q.w) + uuv) * static_cast<T>(2);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tvec3<T, P> __const & v, tquat<T, P> __const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tquat<T, P> __const& q, tvec4<T, P> __const& v)
	{
		return detail::compute_quat_mul_vec4<T, P, detail::is_aligned<P>::value>::call(q, v);
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tvec4<T, P> __const & v, tquat<T, P> __const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> operator*(tquat<T, P> __const & q, T __const & s)
	{
		return tquat<T, P>(
			q.w * s, q.x * s, q.y * s, q.z * s);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> operator*(T __const & s, tquat<T, P> __const & q)
	{
		return q * s;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> operator/(tquat<T, P> __const & q, T __const & s)
	{
		return tquat<T, P>(
			q.w / s, q.x / s, q.y / s, q.z / s);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tquat<T, P> __const & q1, tquat<T, P> __const & q2)
	{
		return (q1.x == q2.x) && (q1.y == q2.y) && (q1.z == q2.z) && (q1.w == q2.w);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tquat<T, P> __const & q1, tquat<T, P> __const & q2)
	{
		return (q1.x != q2.x) || (q1.y != q2.y) || (q1.z != q2.z) || (q1.w != q2.w);
	}

	// -- Operations --

	template <typename T, precision P>
	 __inline T length(tquat<T, P> __const & q)
	{
		return glm::sqrt(dot(q, q));
	}

	template <typename T, precision P>
	 __inline tquat<T, P> normalize(tquat<T, P> __const & q)
	{
		T len = length(q);
		if(len <= T(0)) // Problem
			return tquat<T, P>(1, 0, 0, 0);
		T oneOverLen = T(1) / len;
		return tquat<T, P>(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> cross(tquat<T, P> __const & q1, tquat<T, P> __const & q2)
	{
		return tquat<T, P>(
			q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
			q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
			q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
			q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
	}

# 472 "/usr/local/include/glm/gtc/quaternion.inl" 3


	template <typename T, precision P>
	 __inline tquat<T, P> mix(tquat<T, P> __const & x, tquat<T, P> __const & y, T a)
	{
		T cosTheta = dot(x, y);

		// Perform a linear interpolation when cosTheta is close to 1 to avoid side effect of sin(angle) becoming a zero denominator
		if(cosTheta > T(1) - epsilon<T>())
		{
			// Linear interpolation
			return tquat<T, P>(
				mix(x.w, y.w, a),
				mix(x.x, y.x, a),
				mix(x.y, y.y, a),
				mix(x.z, y.z, a));
		}
		else
		{
			// Essential Mathematics, page 467
			T angle = acos(cosTheta);
			return (sin((T(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
		}
	}

	template <typename T, precision P>
	 __inline tquat<T, P> lerp(tquat<T, P> __const & x, tquat<T, P> __const & y, T a)
	{
		// Lerp is only defined in [0, 1]
		assert(a >= static_cast<T>(0));
		assert(a <= static_cast<T>(1));

		return x * (T(1) - a) + (y * a);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> slerp(tquat<T, P> __const & x,	tquat<T, P> __const & y, T a)
	{
		tquat<T, P> z = y;

		T cosTheta = dot(x, y);

		// If cosTheta < 0, the interpolation will take the long way around the sphere. 
		// To fix this, one quat must be negated.
		if (cosTheta < T(0))
		{
			z        = -y;
			cosTheta = -cosTheta;
		}

		// Perform a linear interpolation when cosTheta is close to 1 to avoid side effect of sin(angle) becoming a zero denominator
		if(cosTheta > T(1) - epsilon<T>())
		{
			// Linear interpolation
			return tquat<T, P>(
				mix(x.w, z.w, a),
				mix(x.x, z.x, a),
				mix(x.y, z.y, a),
				mix(x.z, z.z, a));
		}
		else
		{
			// Essential Mathematics, page 467
			T angle = acos(cosTheta);
			return (sin((T(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
		}
	}

	template <typename T, precision P>
	 __inline tquat<T, P> rotate(tquat<T, P> __const & q, T __const & angle, tvec3<T, P> __const & v)
	{
		tvec3<T, P> Tmp = v;

		// Axis of rotation must be normalised
		T len = glm::length(Tmp);
		if(abs(len - T(1)) > T(0.001))
		{
			T oneOverLen = static_cast<T>(1) / len;
			Tmp.x *= oneOverLen;
			Tmp.y *= oneOverLen;
			Tmp.z *= oneOverLen;
		}

		T __const AngleRad(angle);
		T __const Sin = sin(AngleRad * T(0.5));

		return q * tquat<T, P>(cos(AngleRad * T(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
		//return gtc::quaternion::cross(q, tquat<T, P>(cos(AngleRad * T(0.5)), Tmp.x * fSin, Tmp.y * fSin, Tmp.z * fSin));
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> eulerAngles(tquat<T, P> __const & x)
	{
		return tvec3<T, P>(pitch(x), yaw(x), roll(x));
	}

	template <typename T, precision P>
	 __inline T roll(tquat<T, P> __const & q)
	{
		return T(atan(T(2) * (q.x * q.y + q.w * q.z), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z));
	}

	template <typename T, precision P>
	 __inline T pitch(tquat<T, P> __const & q)
	{
		return T(atan(T(2) * (q.y * q.z + q.w * q.x), q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z));
	}

	template <typename T, precision P>
	 __inline T yaw(tquat<T, P> __const & q)
	{
		return asin(clamp(T(-2) * (q.x * q.z - q.w * q.y), T(-1), T(1)));
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> mat3_cast(tquat<T, P> __const & q)
	{
		tmat3x3<T, P> Result(T(1));
		T qxx(q.x * q.x);
		T qyy(q.y * q.y);
		T qzz(q.z * q.z);
		T qxz(q.x * q.z);
		T qxy(q.x * q.y);
		T qyz(q.y * q.z);
		T qwx(q.w * q.x);
		T qwy(q.w * q.y);
		T qwz(q.w * q.z);

		Result[0][0] = T(1) - T(2) * (qyy +  qzz);
		Result[0][1] = T(2) * (qxy + qwz);
		Result[0][2] = T(2) * (qxz - qwy);

		Result[1][0] = T(2) * (qxy - qwz);
		Result[1][1] = T(1) - T(2) * (qxx +  qzz);
		Result[1][2] = T(2) * (qyz + qwx);

		Result[2][0] = T(2) * (qxz + qwy);
		Result[2][1] = T(2) * (qyz - qwx);
		Result[2][2] = T(1) - T(2) * (qxx +  qyy);
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> mat4_cast(tquat<T, P> __const & q)
	{
		return tmat4x4<T, P>(mat3_cast(q));
	}

	template <typename T, precision P>
	 __inline tquat<T, P> quat_cast(tmat3x3<T, P> __const & m)
	{
		T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
		T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
		T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
		T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

		int biggestIndex = 0;
		T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
		if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourXSquaredMinus1;
			biggestIndex = 1;
		}
		if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourYSquaredMinus1;
			biggestIndex = 2;
		}
		if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourZSquaredMinus1;
			biggestIndex = 3;
		}

		T biggestVal = sqrt(fourBiggestSquaredMinus1 + T(1)) * T(0.5);
		T mult = static_cast<T>(0.25) / biggestVal;

		tquat<T, P> Result(uninitialize);
		switch(biggestIndex)
		{
		case 0:
			Result.w = biggestVal;
			Result.x = (m[1][2] - m[2][1]) * mult;
			Result.y = (m[2][0] - m[0][2]) * mult;
			Result.z = (m[0][1] - m[1][0]) * mult;
			break;
		case 1:
			Result.w = (m[1][2] - m[2][1]) * mult;
			Result.x = biggestVal;
			Result.y = (m[0][1] + m[1][0]) * mult;
			Result.z = (m[2][0] + m[0][2]) * mult;
			break;
		case 2:
			Result.w = (m[2][0] - m[0][2]) * mult;
			Result.x = (m[0][1] + m[1][0]) * mult;
			Result.y = biggestVal;
			Result.z = (m[1][2] + m[2][1]) * mult;
			break;
		case 3:
			Result.w = (m[0][1] - m[1][0]) * mult;
			Result.x = (m[2][0] + m[0][2]) * mult;
			Result.y = (m[1][2] + m[2][1]) * mult;
			Result.z = biggestVal;
			break;
			
		default:					// Silence a -Wswitch-default warning in GCC. Should never actually get here. Assert is just for sanity.
			assert(false);
			break;
		}
		return Result;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> quat_cast(tmat4x4<T, P> __const & m4)
	{
		return quat_cast(tmat3x3<T, P>(m4));
	}

	template <typename T, precision P>
	 __inline T angle(tquat<T, P> __const & x)
	{
		return acos(x.w) * T(2);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> axis(tquat<T, P> __const & x)
	{
		T tmp1 = static_cast<T>(1) - x.w * x.w;
		if(tmp1 <= static_cast<T>(0))
			return tvec3<T, P>(0, 0, 1);
		T tmp2 = static_cast<T>(1) / sqrt(tmp1);
		return tvec3<T, P>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> angleAxis(T __const & angle, tvec3<T, P> __const & v)
	{
		tquat<T, P> Result(uninitialize);

		T __const a(angle);
		T __const s = glm::sin(a * static_cast<T>(0.5));

		Result.w = glm::cos(a * static_cast<T>(0.5));
		Result.x = v.x * s;
		Result.y = v.y * s;
		Result.z = v.z * s;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> lessThan(tquat<T, P> __const & x, tquat<T, P> __const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> lessThanEqual(tquat<T, P> __const & x, tquat<T, P> __const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> greaterThan(tquat<T, P> __const & x, tquat<T, P> __const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> greaterThanEqual(tquat<T, P> __const & x, tquat<T, P> __const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> equal(tquat<T, P> __const & x, tquat<T, P> __const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> notEqual(tquat<T, P> __const & x, tquat<T, P> __const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> isnan(tquat<T, P> __const& q)
	{
		;

		return tvec4<bool, P>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> isinf(tquat<T, P> __const& q)
	{
		;

		return tvec4<bool, P>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
	}
}//namespace glm



       


# 397 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 2 3


# 37 "/usr/local/include/glm/gtc/type_ptr.hpp" 2 3

















       

namespace glm
{
	/// @addtogroup gtc_type_ptr
	/// @{

	/// Return the constant address to the data of the input parameter.
	/// @see gtc_type_ptr
	template<typename genType>
	 typename genType::value_type __const * value_ptr(genType __const & vec);

	/// Build a vector from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tvec2<T, defaultp> make_vec2(T __const * __const ptr);

	/// Build a vector from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tvec3<T, defaultp> make_vec3(T __const * __const ptr);

	/// Build a vector from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tvec4<T, defaultp> make_vec4(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat2x2<T, defaultp> make_mat2x2(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat2x3<T, defaultp> make_mat2x3(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat2x4<T, defaultp> make_mat2x4(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat3x2<T, defaultp> make_mat3x2(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat3x3<T, defaultp> make_mat3x3(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat3x4<T, defaultp> make_mat3x4(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat4x2<T, defaultp> make_mat4x2(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat4x3<T, defaultp> make_mat4x3(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat4x4<T, defaultp> make_mat4x4(T __const * __const ptr);
	
	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat2x2<T, defaultp> make_mat2(T __const * __const ptr);

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat3x3<T, defaultp> make_mat3(T __const * __const ptr);
		
	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tmat4x4<T, defaultp> make_mat4(T __const * __const ptr);

	/// Build a quaternion from a pointer.
	/// @see gtc_type_ptr
	template<typename T>
	 tquat<T, defaultp> make_quat(T __const * __const ptr);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/type_ptr.inl" 1 3
/// @ref gtc_type_ptr
/// @file glm/gtc/type_ptr.inl



namespace glm
{
	/// @addtogroup gtc_type_ptr
	/// @{

	/// Return the constant address to the data of the vector input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tvec2<T, P> __const & vec
	)
	{
		return &(vec.x);
	}

	//! Return the address to the data of the vector input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tvec2<T, P> & vec
	)
	{
		return &(vec.x);
	}

	/// Return the constant address to the data of the vector input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tvec3<T, P> __const & vec
	)
	{
		return &(vec.x);
	}

	//! Return the address to the data of the vector input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tvec3<T, P> & vec
	)
	{
		return &(vec.x);
	}
		
	/// Return the constant address to the data of the vector input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(	
		tvec4<T, P> __const & vec
	)
	{
		return &(vec.x);
	}

	//! Return the address to the data of the vector input.
	//! From GLM_GTC_type_ptr extension.
	template<typename T, precision P>
	 __inline T * value_ptr
	(	
		tvec4<T, P> & vec
	)
	{
		return &(vec.x);
	}

	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat2x2<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tmat2x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat3x3<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tmat3x3<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat4x4<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	//! From GLM_GTC_type_ptr extension.
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tmat4x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}

	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat2x3<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tmat2x3<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat3x2<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tmat3x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat2x4<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tmat2x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat4x2<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(	
		tmat4x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat3x4<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	//! Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tmat3x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	/// Return the constant address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tmat4x3<T, P> __const & mat
	)
	{
		return &(mat[0].x);
	}

	/// Return the address to the data of the matrix input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr(tmat4x3<T, P> & mat)
	{
		return &(mat[0].x);
	}

	/// Return the constant address to the data of the input parameter.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T __const * value_ptr
	(
		tquat<T, P> __const & q
	)
	{
		return &(q[0]);
	}

	/// Return the address to the data of the quaternion input.
	/// @see gtc_type_ptr
	template<typename T, precision P>
	 __inline T * value_ptr
	(
		tquat<T, P> & q
	)
	{
		return &(q[0]);
	}

	/// Build a vector from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tvec2<T, defaultp> make_vec2(T __const * __const ptr)
	{
		tvec2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));
		return Result;
	}

	/// Build a vector from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tvec3<T, defaultp> make_vec3(T __const * __const ptr)
	{
		tvec3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));
		return Result;
	}

	/// Build a vector from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tvec4<T, defaultp> make_vec4(T __const * __const ptr)
	{
		tvec4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));
		return Result;
	}

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat2x2<T, defaultp> make_mat2x2(T __const * __const ptr)
	{
		tmat2x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));
		return Result;
	}

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat2x3<T, defaultp> make_mat2x3(T __const * __const ptr)
	{
		tmat2x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));
		return Result;
	}

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat2x4<T, defaultp> make_mat2x4(T __const * __const ptr)
	{
		tmat2x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));
		return Result;
	}

	/// Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat3x2<T, defaultp> make_mat3x2(T __const * __const ptr)
	{
		tmat3x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));
		return Result;
	}

	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat3x3<T, defaultp> make_mat3x3(T __const * __const ptr)
	{
		tmat3x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));
		return Result;
	}

	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat3x4<T, defaultp> make_mat3x4(T __const * __const ptr)
	{
		tmat3x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));
		return Result;
	}

	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat4x2<T, defaultp> make_mat4x2(T __const * __const ptr)
	{
		tmat4x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));
		return Result;
	}

	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat4x3<T, defaultp> make_mat4x3(T __const * __const ptr)
	{
		tmat4x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));
		return Result;
	}

	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat4x4<T, defaultp> make_mat4x4(T __const * __const ptr)
	{
		tmat4x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));
		return Result;
	}

	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat2x2<T, defaultp> make_mat2(T __const * __const ptr)
	{
		return make_mat2x2(ptr);
	}

	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat3x3<T, defaultp> make_mat3(T __const * __const ptr)
	{
		return make_mat3x3(ptr);
	}
		
	//! Build a matrix from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tmat4x4<T, defaultp> make_mat4(T __const * __const ptr)
	{
		return make_mat4x4(ptr);
	}

	//! Build a quaternion from a pointer.
	/// @see gtc_type_ptr
	template <typename T>
	 __inline tquat<T, defaultp> make_quat(T __const * __const ptr)
	{
		tquat<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));
		return Result;
	}

	/// @}
}//namespace glm


# 149 "/usr/local/include/glm/gtc/type_ptr.hpp" 2 3


# 14 "common_utils_cpp.h" 2
# 1 "/usr/local/include/glm/ext.hpp" 1 3
/// @file glm/ext.hpp
///
/// @ref core (Dependence)
/// 
/// @defgroup gtc GTC Extensions (Stable)
///
/// @brief Functions and types that the GLSL specification doesn't define, but useful to have for a C++ program.
/// 
/// GTC extensions aim to be stable. 
/// 
/// Even if it's highly unrecommended, it's possible to include all the extensions at once by
/// including <glm/ext.hpp>. Otherwise, each extension needs to be included  a specific file.
/// 
/// @defgroup gtx GTX Extensions (Experimental)
/// 
/// @brief Functions and types that the GLSL specification doesn't define, but 
/// useful to have for a C++ program.
/// 
/// Experimental extensions are useful functions and types, but the development of
/// their API and functionality is not necessarily stable. They can change 
/// substantially between versions. Backwards compatibility is not much of an issue
/// for them.
/// 
/// Even if it's highly unrecommended, it's possible to include all the extensions 
/// at once by including <glm/ext.hpp>. Otherwise, each extension needs to be 
/// included  a specific file.








                     


# 1 "/usr/local/include/glm/./gtc/bitfield.hpp" 1 3
/// @ref gtc_bitfield
/// @file glm/gtc/bitfield.hpp
///
/// @see core (dependence)
/// @see gtc_bitfield (dependence)
///
/// @defgroup gtc_bitfield GLM_GTC_bitfield
/// @ingroup gtc
/// 
/// @brief Allow to perform bit operations on integer values
/// 
/// <glm/gtc/bitfield.hpp> need to be included to use these functionalities.



// Dependencies








       

namespace glm
{
	/// @addtogroup gtc_bitfield
	/// @{

	/// Build a mask of 'count' bits
	///
	/// @see gtc_bitfield
	template <typename genIUType>
	 genIUType mask(genIUType Bits);
	
	/// Build a mask of 'count' bits
	///
	/// @see gtc_bitfield
	template <typename T, precision P, template <typename, precision> class vecIUType>
	 vecIUType<T, P> mask(vecIUType<T, P> __const & v);

	/// Rotate all bits to the right. All the bits dropped in the right side are inserted back on the left side.
	///
	/// @see gtc_bitfield
	template <typename genIUType>
	 genIUType bitfieldRotateRight(genIUType In, int Shift);

	/// Rotate all bits to the right. All the bits dropped in the right side are inserted back on the left side.
	///
	/// @see gtc_bitfield
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldRotateRight(vecType<T, P> __const & In, int Shift);

	/// Rotate all bits to the left. All the bits dropped in the left side are inserted back on the right side.
	///
	/// @see gtc_bitfield
	template <typename genIUType>
	 genIUType bitfieldRotateLeft(genIUType In, int Shift);

	/// Rotate all bits to the left. All the bits dropped in the left side are inserted back on the right side.
	///
	/// @see gtc_bitfield
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldRotateLeft(vecType<T, P> __const & In, int Shift);

	/// Set to 1 a range of bits.
	///
	/// @see gtc_bitfield
	template <typename genIUType>
	 genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount);

	/// Set to 1 a range of bits.
	///
	/// @see gtc_bitfield
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldFillOne(vecType<T, P> __const & Value, int FirstBit, int BitCount);

	/// Set to 0 a range of bits.
	///
	/// @see gtc_bitfield
	template <typename genIUType>
	 genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount);

	/// Set to 0 a range of bits.
	///
	/// @see gtc_bitfield
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> bitfieldFillZero(vecType<T, P> __const & Value, int FirstBit, int BitCount);

	/// Interleaves the bits of x and y.
	/// The first bit is the first bit of x followed by the first bit of y.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int16 bitfieldInterleave(int8 x, int8 y);

	/// Interleaves the bits of x and y.
	/// The first bit is the first bit of x followed by the first bit of y.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint16 bitfieldInterleave(uint8 x, uint8 y);

	/// Interleaves the bits of x and y.
	/// The first bit is the first bit of x followed by the first bit of y.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int32 bitfieldInterleave(int16 x, int16 y);

	/// Interleaves the bits of x and y.
	/// The first bit is the first bit of x followed by the first bit of y.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint32 bitfieldInterleave(uint16 x, uint16 y);

	/// Interleaves the bits of x and y.
	/// The first bit is the first bit of x followed by the first bit of y.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int64 bitfieldInterleave(int32 x, int32 y);

	/// Interleaves the bits of x and y.
	/// The first bit is the first bit of x followed by the first bit of y.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint64 bitfieldInterleave(uint32 x, uint32 y);

	/// Interleaves the bits of x, y and z.
	/// The first bit is the first bit of x followed by the first bit of y and the first bit of z.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int32 bitfieldInterleave(int8 x, int8 y, int8 z);

	/// Interleaves the bits of x, y and z.
	/// The first bit is the first bit of x followed by the first bit of y and the first bit of z.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z);

	/// Interleaves the bits of x, y and z.
	/// The first bit is the first bit of x followed by the first bit of y and the first bit of z.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int64 bitfieldInterleave(int16 x, int16 y, int16 z);

	/// Interleaves the bits of x, y and z. 
	/// The first bit is the first bit of x followed by the first bit of y and the first bit of z.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z);

	/// Interleaves the bits of x, y and z. 
	/// The first bit is the first bit of x followed by the first bit of y and the first bit of z.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int64 bitfieldInterleave(int32 x, int32 y, int32 z);

	/// Interleaves the bits of x, y and z. 
	/// The first bit is the first bit of x followed by the first bit of y and the first bit of z.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z);

	/// Interleaves the bits of x, y, z and w. 
	/// The first bit is the first bit of x followed by the first bit of y, the first bit of z and finally the first bit of w.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w);

	/// Interleaves the bits of x, y, z and w. 
	/// The first bit is the first bit of x followed by the first bit of y, the first bit of z and finally the first bit of w.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w);

	/// Interleaves the bits of x, y, z and w. 
	/// The first bit is the first bit of x followed by the first bit of y, the first bit of z and finally the first bit of w.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w);

	/// Interleaves the bits of x, y, z and w. 
	/// The first bit is the first bit of x followed by the first bit of y, the first bit of z and finally the first bit of w.
	/// The other bits are interleaved following the previous sequence.
	/// 
	/// @see gtc_bitfield
	 uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w);

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/gtc/bitfield.inl" 1 3
/// @ref gtc_bitfield
/// @file glm/gtc/bitfield.inl


# 1 "/usr/local/include/glm/gtc/../simd/integer.h" 1 3
/// @ref simd
/// @file glm/simd/integer.h





 __inline glm_uvec4 glm_i128_interleave(glm_uvec4 x)
{
	glm_uvec4 __const Mask4 = _mm_set1_epi32(0x0000FFFF);
	glm_uvec4 __const Mask3 = _mm_set1_epi32(0x00FF00FF);
	glm_uvec4 __const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
	glm_uvec4 __const Mask1 = _mm_set1_epi32(0x33333333);
	glm_uvec4 __const Mask0 = _mm_set1_epi32(0x55555555);

	glm_uvec4 Reg1;
	glm_uvec4 Reg2;

	// REG1 = x;
	// REG2 = y;
	//Reg1 = _mm_unpacklo_epi64(x, y);
	Reg1 = x;

	//REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x0000FFFF0000FFFF);
	//REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x0000FFFF0000FFFF);
	Reg2 = __extension__ ({
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, ( 2)*8); });
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask4);

	//REG1 = ((REG1 <<  8) | REG1) & glm::uint64(0x00FF00FF00FF00FF);
	//REG2 = ((REG2 <<  8) | REG2) & glm::uint64(0x00FF00FF00FF00FF);
	Reg2 = __extension__ ({
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, ( 1)*8); });
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask3);

	//REG1 = ((REG1 <<  4) | REG1) & glm::uint64(0x0F0F0F0F0F0F0F0F);
	//REG2 = ((REG2 <<  4) | REG2) & glm::uint64(0x0F0F0F0F0F0F0F0F);
	Reg2 = _mm_slli_epi32(Reg1, 4);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask2);

	//REG1 = ((REG1 <<  2) | REG1) & glm::uint64(0x3333333333333333);
	//REG2 = ((REG2 <<  2) | REG2) & glm::uint64(0x3333333333333333);
	Reg2 = _mm_slli_epi32(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask1);

	//REG1 = ((REG1 <<  1) | REG1) & glm::uint64(0x5555555555555555);
	//REG2 = ((REG2 <<  1) | REG2) & glm::uint64(0x5555555555555555);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask0);

	//return REG1 | (REG2 << 1);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg2 = __extension__ ({
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg2);
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_psrldqi128(__a, ( 8)*8); });
	Reg1 = _mm_or_si128(Reg1, Reg2);
	
	return Reg1;
}

 __inline glm_uvec4 glm_i128_interleave2(glm_uvec4 x, glm_uvec4 y)
{
	glm_uvec4 __const Mask4 = _mm_set1_epi32(0x0000FFFF);
	glm_uvec4 __const Mask3 = _mm_set1_epi32(0x00FF00FF);
	glm_uvec4 __const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
	glm_uvec4 __const Mask1 = _mm_set1_epi32(0x33333333);
	glm_uvec4 __const Mask0 = _mm_set1_epi32(0x55555555);

	glm_uvec4 Reg1;
	glm_uvec4 Reg2;

	// REG1 = x;
	// REG2 = y;
	Reg1 = _mm_unpacklo_epi64(x, y);

	//REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x0000FFFF0000FFFF);
	//REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x0000FFFF0000FFFF);
	Reg2 = __extension__ ({
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, ( 2)*8); });
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask4);

	//REG1 = ((REG1 <<  8) | REG1) & glm::uint64(0x00FF00FF00FF00FF);
	//REG2 = ((REG2 <<  8) | REG2) & glm::uint64(0x00FF00FF00FF00FF);
	Reg2 = __extension__ ({
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, ( 1)*8); });
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask3);

	//REG1 = ((REG1 <<  4) | REG1) & glm::uint64(0x0F0F0F0F0F0F0F0F);
	//REG2 = ((REG2 <<  4) | REG2) & glm::uint64(0x0F0F0F0F0F0F0F0F);
	Reg2 = _mm_slli_epi32(Reg1, 4);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask2);

	//REG1 = ((REG1 <<  2) | REG1) & glm::uint64(0x3333333333333333);
	//REG2 = ((REG2 <<  2) | REG2) & glm::uint64(0x3333333333333333);
	Reg2 = _mm_slli_epi32(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask1);

	//REG1 = ((REG1 <<  1) | REG1) & glm::uint64(0x5555555555555555);
	//REG2 = ((REG2 <<  1) | REG2) & glm::uint64(0x5555555555555555);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask0);

	//return REG1 | (REG2 << 1);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg2 = __extension__ ({
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg2);
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_psrldqi128(__a, ( 8)*8); });
	Reg1 = _mm_or_si128(Reg1, Reg2);
	
	return Reg1;
}



# 4 "/usr/local/include/glm/gtc/bitfield.inl" 2 3


namespace glm{
namespace detail
{
	template <typename PARAM, typename RET>
	 RET bitfieldInterleave(PARAM x, PARAM y);

	template <typename PARAM, typename RET>
	 RET bitfieldInterleave(PARAM x, PARAM y, PARAM z);

	template <typename PARAM, typename RET>
	 RET bitfieldInterleave(PARAM x, PARAM y, PARAM z, PARAM w);

	template <>
	 __inline glm::uint16 bitfieldInterleave(glm::uint8 x, glm::uint8 y)
	{
		glm::uint16 REG1(x);
		glm::uint16 REG2(y);

		REG1 = ((REG1 <<  4) | REG1) & glm::uint16(0x0F0F);
		REG2 = ((REG2 <<  4) | REG2) & glm::uint16(0x0F0F);

		REG1 = ((REG1 <<  2) | REG1) & glm::uint16(0x3333);
		REG2 = ((REG2 <<  2) | REG2) & glm::uint16(0x3333);

		REG1 = ((REG1 <<  1) | REG1) & glm::uint16(0x5555);
		REG2 = ((REG2 <<  1) | REG2) & glm::uint16(0x5555);

		return REG1 | (REG2 << 1);
	}

	template <>
	 __inline glm::uint32 bitfieldInterleave(glm::uint16 x, glm::uint16 y)
	{
		glm::uint32 REG1(x);
		glm::uint32 REG2(y);

		REG1 = ((REG1 <<  8) | REG1) & glm::uint32(0x00FF00FF);
		REG2 = ((REG2 <<  8) | REG2) & glm::uint32(0x00FF00FF);

		REG1 = ((REG1 <<  4) | REG1) & glm::uint32(0x0F0F0F0F);
		REG2 = ((REG2 <<  4) | REG2) & glm::uint32(0x0F0F0F0F);

		REG1 = ((REG1 <<  2) | REG1) & glm::uint32(0x33333333);
		REG2 = ((REG2 <<  2) | REG2) & glm::uint32(0x33333333);

		REG1 = ((REG1 <<  1) | REG1) & glm::uint32(0x55555555);
		REG2 = ((REG2 <<  1) | REG2) & glm::uint32(0x55555555);

		return REG1 | (REG2 << 1);
	}

	template <>
	 __inline glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);

		REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x0000FFFF0000FFFFull);
		REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x0000FFFF0000FFFFull);

		REG1 = ((REG1 <<  8) | REG1) & glm::uint64(0x00FF00FF00FF00FFull);
		REG2 = ((REG2 <<  8) | REG2) & glm::uint64(0x00FF00FF00FF00FFull);

		REG1 = ((REG1 <<  4) | REG1) & glm::uint64(0x0F0F0F0F0F0F0F0Full);
		REG2 = ((REG2 <<  4) | REG2) & glm::uint64(0x0F0F0F0F0F0F0F0Full);

		REG1 = ((REG1 <<  2) | REG1) & glm::uint64(0x3333333333333333ull);
		REG2 = ((REG2 <<  2) | REG2) & glm::uint64(0x3333333333333333ull);

		REG1 = ((REG1 <<  1) | REG1) & glm::uint64(0x5555555555555555ull);
		REG2 = ((REG2 <<  1) | REG2) & glm::uint64(0x5555555555555555ull);

		return REG1 | (REG2 << 1);
	}

	template <>
	 __inline glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z)
	{
		glm::uint32 REG1(x);
		glm::uint32 REG2(y);
		glm::uint32 REG3(z);

		REG1 = ((REG1 << 16) | REG1) & glm::uint32(0x00FF0000FF0000FF);
		REG2 = ((REG2 << 16) | REG2) & glm::uint32(0x00FF0000FF0000FF);
		REG3 = ((REG3 << 16) | REG3) & glm::uint32(0x00FF0000FF0000FF);

		REG1 = ((REG1 <<  8) | REG1) & glm::uint32(0xF00F00F00F00F00F);
		REG2 = ((REG2 <<  8) | REG2) & glm::uint32(0xF00F00F00F00F00F);
		REG3 = ((REG3 <<  8) | REG3) & glm::uint32(0xF00F00F00F00F00F);

		REG1 = ((REG1 <<  4) | REG1) & glm::uint32(0x30C30C30C30C30C3);
		REG2 = ((REG2 <<  4) | REG2) & glm::uint32(0x30C30C30C30C30C3);
		REG3 = ((REG3 <<  4) | REG3) & glm::uint32(0x30C30C30C30C30C3);

		REG1 = ((REG1 <<  2) | REG1) & glm::uint32(0x9249249249249249);
		REG2 = ((REG2 <<  2) | REG2) & glm::uint32(0x9249249249249249);
		REG3 = ((REG3 <<  2) | REG3) & glm::uint32(0x9249249249249249);

		return REG1 | (REG2 << 1) | (REG3 << 2);
	}
		
	template <>
	 __inline glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);
		glm::uint64 REG3(z);

		REG1 = ((REG1 << 32) | REG1) & glm::uint64(0xFFFF00000000FFFFull);
		REG2 = ((REG2 << 32) | REG2) & glm::uint64(0xFFFF00000000FFFFull);
		REG3 = ((REG3 << 32) | REG3) & glm::uint64(0xFFFF00000000FFFFull);

		REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x00FF0000FF0000FFull);
		REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x00FF0000FF0000FFull);
		REG3 = ((REG3 << 16) | REG3) & glm::uint64(0x00FF0000FF0000FFull);

		REG1 = ((REG1 <<  8) | REG1) & glm::uint64(0xF00F00F00F00F00Full);
		REG2 = ((REG2 <<  8) | REG2) & glm::uint64(0xF00F00F00F00F00Full);
		REG3 = ((REG3 <<  8) | REG3) & glm::uint64(0xF00F00F00F00F00Full);

		REG1 = ((REG1 <<  4) | REG1) & glm::uint64(0x30C30C30C30C30C3ull);
		REG2 = ((REG2 <<  4) | REG2) & glm::uint64(0x30C30C30C30C30C3ull);
		REG3 = ((REG3 <<  4) | REG3) & glm::uint64(0x30C30C30C30C30C3ull);

		REG1 = ((REG1 <<  2) | REG1) & glm::uint64(0x9249249249249249ull);
		REG2 = ((REG2 <<  2) | REG2) & glm::uint64(0x9249249249249249ull);
		REG3 = ((REG3 <<  2) | REG3) & glm::uint64(0x9249249249249249ull);

		return REG1 | (REG2 << 1) | (REG3 << 2);
	}

	template <>
	 __inline glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y, glm::uint32 z)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);
		glm::uint64 REG3(z);

		REG1 = ((REG1 << 32) | REG1) & glm::uint64(0xFFFF00000000FFFFull);
		REG2 = ((REG2 << 32) | REG2) & glm::uint64(0xFFFF00000000FFFFull);
		REG3 = ((REG3 << 32) | REG3) & glm::uint64(0xFFFF00000000FFFFull);

		REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x00FF0000FF0000FFull);
		REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x00FF0000FF0000FFull);
		REG3 = ((REG3 << 16) | REG3) & glm::uint64(0x00FF0000FF0000FFull);

		REG1 = ((REG1 <<  8) | REG1) & glm::uint64(0xF00F00F00F00F00Full);
		REG2 = ((REG2 <<  8) | REG2) & glm::uint64(0xF00F00F00F00F00Full);
		REG3 = ((REG3 <<  8) | REG3) & glm::uint64(0xF00F00F00F00F00Full);

		REG1 = ((REG1 <<  4) | REG1) & glm::uint64(0x30C30C30C30C30C3ull);
		REG2 = ((REG2 <<  4) | REG2) & glm::uint64(0x30C30C30C30C30C3ull);
		REG3 = ((REG3 <<  4) | REG3) & glm::uint64(0x30C30C30C30C30C3ull);

		REG1 = ((REG1 <<  2) | REG1) & glm::uint64(0x9249249249249249ull);
		REG2 = ((REG2 <<  2) | REG2) & glm::uint64(0x9249249249249249ull);
		REG3 = ((REG3 <<  2) | REG3) & glm::uint64(0x9249249249249249ull);

		return REG1 | (REG2 << 1) | (REG3 << 2);
	}

	template <>
	 __inline glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z, glm::uint8 w)
	{
		glm::uint32 REG1(x);
		glm::uint32 REG2(y);
		glm::uint32 REG3(z);
		glm::uint32 REG4(w);

		REG1 = ((REG1 << 12) | REG1) & glm::uint32(0x000F000F000F000F);
		REG2 = ((REG2 << 12) | REG2) & glm::uint32(0x000F000F000F000F);
		REG3 = ((REG3 << 12) | REG3) & glm::uint32(0x000F000F000F000F);
		REG4 = ((REG4 << 12) | REG4) & glm::uint32(0x000F000F000F000F);

		REG1 = ((REG1 <<  6) | REG1) & glm::uint32(0x0303030303030303);
		REG2 = ((REG2 <<  6) | REG2) & glm::uint32(0x0303030303030303);
		REG3 = ((REG3 <<  6) | REG3) & glm::uint32(0x0303030303030303);
		REG4 = ((REG4 <<  6) | REG4) & glm::uint32(0x0303030303030303);

		REG1 = ((REG1 <<  3) | REG1) & glm::uint32(0x1111111111111111);
		REG2 = ((REG2 <<  3) | REG2) & glm::uint32(0x1111111111111111);
		REG3 = ((REG3 <<  3) | REG3) & glm::uint32(0x1111111111111111);
		REG4 = ((REG4 <<  3) | REG4) & glm::uint32(0x1111111111111111);

		return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
	}

	template <>
	 __inline glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z, glm::uint16 w)
	{
		glm::uint64 REG1(x);
		glm::uint64 REG2(y);
		glm::uint64 REG3(z);
		glm::uint64 REG4(w);

		REG1 = ((REG1 << 24) | REG1) & glm::uint64(0x000000FF000000FFull);
		REG2 = ((REG2 << 24) | REG2) & glm::uint64(0x000000FF000000FFull);
		REG3 = ((REG3 << 24) | REG3) & glm::uint64(0x000000FF000000FFull);
		REG4 = ((REG4 << 24) | REG4) & glm::uint64(0x000000FF000000FFull);

		REG1 = ((REG1 << 12) | REG1) & glm::uint64(0x000F000F000F000Full);
		REG2 = ((REG2 << 12) | REG2) & glm::uint64(0x000F000F000F000Full);
		REG3 = ((REG3 << 12) | REG3) & glm::uint64(0x000F000F000F000Full);
		REG4 = ((REG4 << 12) | REG4) & glm::uint64(0x000F000F000F000Full);

		REG1 = ((REG1 <<  6) | REG1) & glm::uint64(0x0303030303030303ull);
		REG2 = ((REG2 <<  6) | REG2) & glm::uint64(0x0303030303030303ull);
		REG3 = ((REG3 <<  6) | REG3) & glm::uint64(0x0303030303030303ull);
		REG4 = ((REG4 <<  6) | REG4) & glm::uint64(0x0303030303030303ull);

		REG1 = ((REG1 <<  3) | REG1) & glm::uint64(0x1111111111111111ull);
		REG2 = ((REG2 <<  3) | REG2) & glm::uint64(0x1111111111111111ull);
		REG3 = ((REG3 <<  3) | REG3) & glm::uint64(0x1111111111111111ull);
		REG4 = ((REG4 <<  3) | REG4) & glm::uint64(0x1111111111111111ull);

		return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
	}
}//namespace detail

	template <typename genIUType>
	 __inline genIUType mask(genIUType Bits)
	{
		;

		return Bits >= sizeof(genIUType) * 8 ? ~static_cast<genIUType>(0) : (static_cast<genIUType>(1) << Bits) - static_cast<genIUType>(1);
	}

	template <typename T, precision P, template <typename, precision> class vecIUType>
	 __inline vecIUType<T, P> mask(vecIUType<T, P> __const& v)
	{
		;

		return detail::functor1<T, T, P, vecIUType>::call(mask, v);
	}

	template <typename genIType>
	 __inline genIType bitfieldRotateRight(genIType In, int Shift)
	{
		;

		int __const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
		return (In << static_cast<genIType>(Shift)) | (In >> static_cast<genIType>(BitSize - Shift));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> bitfieldRotateRight(vecType<T, P> __const & In, int Shift)
	{
		;

		int __const BitSize = static_cast<int>(sizeof(T) * 8);
		return (In << static_cast<T>(Shift)) | (In >> static_cast<T>(BitSize - Shift));
	}

	template <typename genIType>
	 __inline genIType bitfieldRotateLeft(genIType In, int Shift)
	{
		;

		int __const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
		return (In >> static_cast<genIType>(Shift)) | (In << static_cast<genIType>(BitSize - Shift));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> bitfieldRotateLeft(vecType<T, P> __const& In, int Shift)
	{
		;

		int __const BitSize = static_cast<int>(sizeof(T) * 8);
		return (In >> static_cast<T>(Shift)) | (In << static_cast<T>(BitSize - Shift));
	}

	template <typename genIUType>
	 __inline genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount)
	{
		return Value | static_cast<genIUType>(mask(BitCount) << FirstBit);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> bitfieldFillOne(vecType<T, P> __const& Value, int FirstBit, int BitCount)
	{
		return Value | static_cast<T>(mask(BitCount) << FirstBit);
	}

	template <typename genIUType>
	 __inline genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount)
	{
		return Value & static_cast<genIUType>(~(mask(BitCount) << FirstBit));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> bitfieldFillZero(vecType<T, P> __const& Value, int FirstBit, int BitCount)
	{
		return Value & static_cast<T>(~(mask(BitCount) << FirstBit));
	}

	 __inline int16 bitfieldInterleave(int8 x, int8 y)
	{
		union sign8
		{
			int8 i;
			uint8 u;
		} sign_x, sign_y;

		union sign16
		{
			int16 i;
			uint16 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u);

		return result.i;
	}

	 __inline uint16 bitfieldInterleave(uint8 x, uint8 y)
	{
		return detail::bitfieldInterleave<uint8, uint16>(x, y);
	}

	 __inline int32 bitfieldInterleave(int16 x, int16 y)
	{
		union sign16
		{
			int16 i;
			uint16 u;
		} sign_x, sign_y;

		union sign32
		{
			int32 i;
			uint32 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u);

		return result.i;
	}

	 __inline uint32 bitfieldInterleave(uint16 x, uint16 y)
	{
		return detail::bitfieldInterleave<uint16, uint32>(x, y);
	}

	 __inline int64 bitfieldInterleave(int32 x, int32 y)
	{
		union sign32
		{
			int32 i;
			uint32 u;
		} sign_x, sign_y;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u);

		return result.i;
	}

	 __inline uint64 bitfieldInterleave(uint32 x, uint32 y)
	{
		return detail::bitfieldInterleave<uint32, uint64>(x, y);
	}

	 __inline int32 bitfieldInterleave(int8 x, int8 y, int8 z)
	{
		union sign8
		{
			int8 i;
			uint8 u;
		} sign_x, sign_y, sign_z;

		union sign32
		{
			int32 i;
			uint32 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

		return result.i;
	}

	 __inline uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z)
	{
		return detail::bitfieldInterleave<uint8, uint32>(x, y, z);
	}

	 __inline int64 bitfieldInterleave(int16 x, int16 y, int16 z)
	{
		union sign16
		{
			int16 i;
			uint16 u;
		} sign_x, sign_y, sign_z;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

		return result.i;
	}

	 __inline uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z)
	{
		return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
	}

	 __inline int64 bitfieldInterleave(int32 x, int32 y, int32 z)
	{
		union sign16
		{
			int32 i;
			uint32 u;
		} sign_x, sign_y, sign_z;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

		return result.i;
	}

	 __inline uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z)
	{
		return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
	}

	 __inline int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w)
	{
		union sign8
		{
			int8 i;
			uint8 u;
		} sign_x, sign_y, sign_z, sign_w;

		union sign32
		{
			int32 i;
			uint32 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		sign_w.i = w;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

		return result.i;
	}

	 __inline uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w)
	{
		return detail::bitfieldInterleave<uint8, uint32>(x, y, z, w);
	}

	 __inline int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w)
	{
		union sign16
		{
			int16 i;
			uint16 u;
		} sign_x, sign_y, sign_z, sign_w;

		union sign64
		{
			int64 i;
			uint64 u;
		} result;

		sign_x.i = x;
		sign_y.i = y;
		sign_z.i = z;
		sign_w.i = w;
		result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

		return result.i;
	}

	 __inline uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w)
	{
		return detail::bitfieldInterleave<uint16, uint64>(x, y, z, w);
	}
}//namespace glm

# 207 "/usr/local/include/glm/./gtc/bitfield.hpp" 2 3


# 37 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/color_space.hpp" 1 3
/// @ref gtc_color_space
/// @file glm/gtc/color_space.hpp
///
/// @see core (dependence)
/// @see gtc_color_space (dependence)
///
/// @defgroup gtc_color_space GLM_GTC_color_space
/// @ingroup gtc
///
/// @brief Allow to perform bit operations on integer values
///
/// <glm/gtc/color.hpp> need to be included to use these functionalities.



// Dependencies









       

namespace glm
{
	/// @addtogroup gtc_color_space
	/// @{

	/// Convert a linear color to sRGB color using a standard gamma correction.
	/// IEC 61966-2-1:1999 specification https://www.w3.org/Graphics/Color/srgb
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> convertLinearToSRGB(vecType<T, P> __const & ColorLinear);

	/// Convert a linear color to sRGB color using a custom gamma correction.
	/// IEC 61966-2-1:1999 specification https://www.w3.org/Graphics/Color/srgb
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> convertLinearToSRGB(vecType<T, P> __const & ColorLinear, T Gamma);

	/// Convert a sRGB color to linear color using a standard gamma correction.
	/// IEC 61966-2-1:1999 specification https://www.w3.org/Graphics/Color/srgb
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> convertSRGBToLinear(vecType<T, P> __const & ColorSRGB);

	/// Convert a sRGB color to linear color using a custom gamma correction.
	// IEC 61966-2-1:1999 specification https://www.w3.org/Graphics/Color/srgb
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> convertSRGBToLinear(vecType<T, P> __const & ColorSRGB, T Gamma);

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/gtc/color_space.inl" 1 3
/// @ref gtc_color_space
/// @file glm/gtc/color_space.inl

namespace glm{
namespace detail
{
	template <typename T, precision P, template <typename, precision> class vecType>
	struct compute_rgbToSrgb
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const& ColorRGB, T GammaCorrection)
		{
			vecType<T, P> __const ClampedColor(clamp(ColorRGB, static_cast<T>(0), static_cast<T>(1)));

			return mix(
				pow(ClampedColor, vecType<T, P>(GammaCorrection)) * static_cast<T>(1.055) - static_cast<T>(0.055),
				ClampedColor * static_cast<T>(12.92),
				lessThan(ClampedColor, vecType<T, P>(static_cast<T>(0.0031308))));
		}
	};

	template <typename T, precision P>
	struct compute_rgbToSrgb<T, P, tvec4>
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const& ColorRGB, T GammaCorrection)
		{
			return tvec4<T, P>(compute_rgbToSrgb<T, P, tvec3>::call(tvec3<T, P>(ColorRGB), GammaCorrection), ColorRGB.w);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct compute_srgbToRgb
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const& ColorSRGB, T Gamma)
		{
			return mix(
				pow((ColorSRGB + static_cast<T>(0.055)) * static_cast<T>(0.94786729857819905213270142180095), vecType<T, P>(Gamma)),
				ColorSRGB * static_cast<T>(0.07739938080495356037151702786378),
				lessThanEqual(ColorSRGB, vecType<T, P>(static_cast<T>(0.04045))));
		}
	};

	template <typename T, precision P>
	struct compute_srgbToRgb<T, P, tvec4>
	{
		 __inline static tvec4<T, P> call(tvec4<T, P> __const& ColorSRGB, T Gamma)
		{
			return tvec4<T, P>(compute_srgbToRgb<T, P, tvec3>::call(tvec3<T, P>(ColorSRGB), Gamma), ColorSRGB.w);
		}
	};
}//namespace detail

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> convertLinearToSRGB(vecType<T, P> __const& ColorLinear)
	{
		return detail::compute_rgbToSrgb<T, P, vecType>::call(ColorLinear, static_cast<T>(0.41666));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> convertLinearToSRGB(vecType<T, P> __const& ColorLinear, T Gamma)
	{
		return detail::compute_rgbToSrgb<T, P, vecType>::call(ColorLinear, static_cast<T>(1) / Gamma);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> convertSRGBToLinear(vecType<T, P> __const& ColorSRGB)
	{
		return detail::compute_srgbToRgb<T, P, vecType>::call(ColorSRGB, static_cast<T>(2.4));
	}
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> convertSRGBToLinear(vecType<T, P> __const& ColorSRGB, T Gamma)
	{
		return detail::compute_srgbToRgb<T, P, vecType>::call(ColorSRGB, Gamma);
	}
}//namespace glm

# 56 "/usr/local/include/glm/./gtc/color_space.hpp" 2 3


# 38 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtc/epsilon.hpp" 1 3
/// @ref gtc_epsilon
/// @file glm/gtc/epsilon.hpp
/// 
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtc_quaternion (dependence)
///
/// @defgroup gtc_epsilon GLM_GTC_epsilon
/// @ingroup gtc
/// 
/// @brief Comparison functions for a user defined epsilon values.
/// 
/// <glm/gtc/epsilon.hpp> need to be included to use these functionalities.



// Dependencies





       

namespace glm
{
	/// @addtogroup gtc_epsilon
	/// @{

	/// Returns the component-wise comparison of |x - y| < epsilon.
	/// True if this expression is satisfied.
	///
	/// @see gtc_epsilon
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> epsilonEqual(
		vecType<T, P> __const & x,
		vecType<T, P> __const & y,
		T __const & epsilon);

	/// Returns the component-wise comparison of |x - y| < epsilon.
	/// True if this expression is satisfied.
	///
	/// @see gtc_epsilon
	template <typename genType>
	 bool epsilonEqual(
		genType __const & x,
		genType __const & y,
		genType __const & epsilon);

	/// Returns the component-wise comparison of |x - y| < epsilon.
	/// True if this expression is not satisfied.
	///
	/// @see gtc_epsilon
	template <typename genType>
	 typename genType::boolType epsilonNotEqual(
		genType __const & x,
		genType __const & y,
		typename genType::value_type __const & epsilon);

	/// Returns the component-wise comparison of |x - y| >= epsilon.
	/// True if this expression is not satisfied.
	///
	/// @see gtc_epsilon
	template <typename genType>
	 bool epsilonNotEqual(
		genType __const & x,
		genType __const & y,
		genType __const & epsilon);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/epsilon.inl" 1 3
/// @ref gtc_epsilon
/// @file glm/gtc/epsilon.inl

// Dependency:







namespace glm
{
	template <>
	 __inline bool epsilonEqual
	(
		float __const & x,
		float __const & y,
		float __const & epsilon
	)
	{
		return abs(x - y) < epsilon;
	}

	template <>
	 __inline bool epsilonEqual
	(
		double __const & x,
		double __const & y,
		double __const & epsilon
	)
	{
		return abs(x - y) < epsilon;
	}

	template <>
	 __inline bool epsilonNotEqual
	(
		float __const & x,
		float __const & y,
		float __const & epsilon
	)
	{
		return abs(x - y) >= epsilon;
	}

	template <>
	 __inline bool epsilonNotEqual
	(
		double __const & x,
		double __const & y,
		double __const & epsilon
	)
	{
		return abs(x - y) >= epsilon;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> epsilonEqual
	(
		vecType<T, P> __const & x,
		vecType<T, P> __const & y,
		T __const & epsilon
	)
	{
		return lessThan(abs(x - y), vecType<T, P>(epsilon));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> epsilonEqual
	(
		vecType<T, P> __const & x,
		vecType<T, P> __const & y,
		vecType<T, P> __const & epsilon
	)
	{
		return lessThan(abs(x - y), vecType<T, P>(epsilon));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> epsilonNotEqual
	(
		vecType<T, P> __const & x,
		vecType<T, P> __const & y,
		T __const & epsilon
	)
	{
		return greaterThanEqual(abs(x - y), vecType<T, P>(epsilon));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> epsilonNotEqual
	(
		vecType<T, P> __const & x,
		vecType<T, P> __const & y,
		vecType<T, P> __const & epsilon
	)
	{
		return greaterThanEqual(abs(x - y), vecType<T, P>(epsilon));
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> epsilonEqual
	(
		tquat<T, P> __const & x,
		tquat<T, P> __const & y,
		T __const & epsilon
	)
	{
		tvec4<T, P> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
		return lessThan(abs(v), tvec4<T, P>(epsilon));
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> epsilonNotEqual
	(
		tquat<T, P> __const & x,
		tquat<T, P> __const & y,
		T __const & epsilon
	)
	{
		tvec4<T, P> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
		return greaterThanEqual(abs(v), tvec4<T, P>(epsilon));
	}
}//namespace glm

# 73 "/usr/local/include/glm/./gtc/epsilon.hpp" 2 3


# 40 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/functions.hpp" 1 3
/// @ref gtc_functions
/// @file glm/gtc/functions.hpp
/// 
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtc_quaternion (dependence)
///
/// @defgroup gtc_functions GLM_GTC_functions
/// @ingroup gtc
/// 
/// @brief List of useful common functions.
/// 
/// <glm/gtc/functions.hpp> need to be included to use these functionalities.



// Dependencies






       

namespace glm
{
	/// @addtogroup gtc_functions
	/// @{

	/// 1D gauss function
	///
	/// @see gtc_epsilon
	template <typename T>
	 T gauss(
		T x,
		T ExpectedValue,
		T StandardDeviation);

	/// 2D gauss function
	///
	/// @see gtc_epsilon
	template <typename T, precision P>
	 T gauss(
		tvec2<T, P> __const& Coord,
		tvec2<T, P> __const& ExpectedValue,
		tvec2<T, P> __const& StandardDeviation);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/functions.inl" 1 3
/// @ref gtc_functions
/// @file glm/gtc/functions.inl



namespace glm
{
	template <typename T>
	 __inline T gauss
	(
		T x,
		T ExpectedValue,
		T StandardDeviation
	)
	{
		return exp(-((x - ExpectedValue) * (x - ExpectedValue)) / (static_cast<T>(2) * StandardDeviation * StandardDeviation)) / (StandardDeviation * sqrt(static_cast<T>(6.28318530717958647692528676655900576)));
	}

	template <typename T, precision P>
	 __inline T gauss
	(
		tvec2<T, P> __const& Coord,
		tvec2<T, P> __const& ExpectedValue,
		tvec2<T, P> __const& StandardDeviation
	)
	{
		tvec2<T, P> __const Squared = ((Coord - ExpectedValue) * (Coord - ExpectedValue)) / (static_cast<T>(2) * StandardDeviation * StandardDeviation);
		return exp(-(Squared.x + Squared.y));
	}
}//namespace glm


# 52 "/usr/local/include/glm/./gtc/functions.hpp" 2 3



# 41 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/integer.hpp" 1 3
/// @ref gtc_integer
/// @file glm/gtc/integer.hpp
///
/// @see core (dependence)
/// @see gtc_integer (dependence)
///
/// @defgroup gtc_integer GLM_GTC_integer
/// @ingroup gtc
///
/// @brief Allow to perform bit operations on integer values
///
/// <glm/gtc/integer.hpp> need to be included to use these functionalities.



// Dependencies









       

namespace glm
{
	/// @addtogroup gtc_integer
	/// @{

	/// Returns the log2 of x for integer values. Can be reliably using to compute mipmap count from the texture size.
	/// @see gtc_integer
	template <typename genIUType>
	 genIUType log2(genIUType x);

	/// Modulus. Returns x % y
	/// for each component in x using the floating point value y.
	///
	/// @tparam genIUType Integer-point scalar or vector types.
	///
	/// @see gtc_integer
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/mod.xml">GLSL mod man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename genIUType>
	 genIUType mod(genIUType x, genIUType y);

	/// Modulus. Returns x % y
	/// for each component in x using the floating point value y.
	///
	/// @tparam T Integer scalar types.
	/// @tparam vecType vector types.
	///
	/// @see gtc_integer
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/mod.xml">GLSL mod man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> __const & x, T y);

	/// Modulus. Returns x % y
	/// for each component in x using the floating point value y.
	///
	/// @tparam T Integer scalar types.
	/// @tparam vecType vector types.
	///
	/// @see gtc_integer
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/mod.xml">GLSL mod man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.3 Common Functions</a>
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Returns a value equal to the nearest integer to x.
	/// The fraction 0.5 will round in a direction chosen by the
	/// implementation, presumably the direction that is fastest.
	/// 
	/// @param x The values of the argument must be greater or equal to zero.
	/// @tparam T floating point scalar types.
	/// @tparam vecType vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/round.xml">GLSL round man page</a>
	/// @see gtc_integer
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<int, P> iround(vecType<T, P> __const & x);

	/// Returns a value equal to the nearest integer to x.
	/// The fraction 0.5 will round in a direction chosen by the
	/// implementation, presumably the direction that is fastest.
	/// 
	/// @param x The values of the argument must be greater or equal to zero.
	/// @tparam T floating point scalar types.
	/// @tparam vecType vector types.
	/// 
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/round.xml">GLSL round man page</a>
	/// @see gtc_integer
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<uint, P> uround(vecType<T, P> __const & x);

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/gtc/integer.inl" 1 3
/// @ref gtc_integer
/// @file glm/gtc/integer.inl

namespace glm{
namespace detail
{
	template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
	struct compute_log2<T, P, vecType, false, Aligned>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & vec)
		{
			//Equivalent to return findMSB(vec); but save one function call in ASM with VC
			//return findMSB(vec);
			return vecType<T, P>(detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(vec));
		}
	};


# 34 "/usr/local/include/glm/gtc/integer.inl" 3
                                 
}//namespace detail
	template <typename genType>
	 __inline int iround(genType x)
	{
		;
		assert(static_cast<genType>(0.0) <= x);

		return static_cast<int>(x + static_cast<genType>(0.5));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<int, P> iround(vecType<T, P> __const& x)
	{
		;
		assert(all(lessThanEqual(vecType<T, P>(0), x)));

		return vecType<int, P>(x + static_cast<T>(0.5));
	}

	template <typename genType>
	 __inline uint uround(genType x)
	{
		;
		assert(static_cast<genType>(0.0) <= x);

		return static_cast<uint>(x + static_cast<genType>(0.5));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<uint, P> uround(vecType<T, P> __const& x)
	{
		;
		assert(all(lessThanEqual(vecType<T, P>(0), x)));

		return vecType<uint, P>(x + static_cast<T>(0.5));
	}
}//namespace glm

# 102 "/usr/local/include/glm/./gtc/integer.hpp" 2 3


# 42 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/matrix_access.hpp" 1 3
/// @ref gtc_matrix_access
/// @file glm/gtc/matrix_access.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_matrix_access GLM_GTC_matrix_access
/// @ingroup gtc
/// 
/// Defines functions to access rows or columns of a matrix easily.
/// <glm/gtc/matrix_access.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtc_matrix_access
	/// @{

	/// Get a specific row of a matrix.
	/// @see gtc_matrix_access
	template <typename genType>
	 typename genType::row_type row(
		genType __const & m,
		length_t index);

	/// Set a specific row to a matrix.
	/// @see gtc_matrix_access
	template <typename genType>
	 genType row(
		genType __const & m,
		length_t index,
		typename genType::row_type __const & x);

	/// Get a specific column of a matrix.
	/// @see gtc_matrix_access
	template <typename genType>
	 typename genType::col_type column(
		genType __const & m,
		length_t index);

	/// Set a specific column to a matrix.
	/// @see gtc_matrix_access
	template <typename genType>
	 genType column(
		genType __const & m,
		length_t index,
		typename genType::col_type __const & x);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/matrix_access.inl" 1 3
/// @ref gtc_matrix_access
/// @file glm/gtc/matrix_access.inl

namespace glm
{
	template <typename genType>
	 __inline genType row
	(
		genType __const & m,
		length_t index,
		typename genType::row_type __const & x
	)
	{
		assert(index >= 0 && index < m[0].length());

		genType Result = m;
		for(length_t i = 0; i < m.length(); ++i)
			Result[i][index] = x[i];
		return Result;
	}

	template <typename genType>
	 __inline typename genType::row_type row
	(
		genType __const & m,
		length_t index
	)
	{
		assert(index >= 0 && index < m[0].length());

		typename genType::row_type Result;
		for(length_t i = 0; i < m.length(); ++i)
			Result[i] = m[i][index];
		return Result;
	}

	template <typename genType>
	 __inline genType column
	(
		genType __const & m,
		length_t index,
		typename genType::col_type __const & x
	)
	{
		assert(index >= 0 && index < m.length());

		genType Result = m;
		Result[index] = x;
		return Result;
	}

	template <typename genType>
	 __inline typename genType::col_type column
	(
		genType __const & m,
		length_t index
	)
	{
		assert(index >= 0 && index < m.length());

		return m[index];
	}
}//namespace glm

# 59 "/usr/local/include/glm/./gtc/matrix_access.hpp" 2 3


# 43 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 1 3
/// @ref gtc_matrix_integer
/// @file glm/gtc/matrix_integer.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_matrix_integer GLM_GTC_matrix_integer
/// @ingroup gtc
///
/// Defines a number of matrices with integer types.
/// <glm/gtc/matrix_integer.hpp> need to be included to use these functionalities.



// Dependency:












       

namespace glm
{
	/// @addtogroup gtc_matrix_integer
	/// @{

	/// High-precision __signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<int, highp>				highp_imat2;

	/// High-precision __signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<int, highp>				highp_imat3;

	/// High-precision __signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<int, highp>				highp_imat4;

	/// High-precision __signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<int, highp>				highp_imat2x2;

	/// High-precision __signed integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x3<int, highp>				highp_imat2x3;

	/// High-precision __signed integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x4<int, highp>				highp_imat2x4;

	/// High-precision __signed integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x2<int, highp>				highp_imat3x2;

	/// High-precision __signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<int, highp>				highp_imat3x3;

	/// High-precision __signed integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x4<int, highp>				highp_imat3x4;

	/// High-precision __signed integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x2<int, highp>				highp_imat4x2;

	/// High-precision __signed integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x3<int, highp>				highp_imat4x3;

	/// High-precision __signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<int, highp>				highp_imat4x4;


	/// Medium-precision __signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<int, mediump>			mediump_imat2;

	/// Medium-precision __signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<int, mediump>			mediump_imat3;

	/// Medium-precision __signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<int, mediump>			mediump_imat4;


	/// Medium-precision __signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<int, mediump>			mediump_imat2x2;

	/// Medium-precision __signed integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x3<int, mediump>			mediump_imat2x3;

	/// Medium-precision __signed integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x4<int, mediump>			mediump_imat2x4;

	/// Medium-precision __signed integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x2<int, mediump>			mediump_imat3x2;

	/// Medium-precision __signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<int, mediump>			mediump_imat3x3;

	/// Medium-precision __signed integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x4<int, mediump>			mediump_imat3x4;

	/// Medium-precision __signed integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x2<int, mediump>			mediump_imat4x2;

	/// Medium-precision __signed integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x3<int, mediump>			mediump_imat4x3;

	/// Medium-precision __signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<int, mediump>			mediump_imat4x4;


	/// Low-precision __signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<int, lowp>				lowp_imat2;
	
	/// Low-precision __signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<int, lowp>				lowp_imat3;

	/// Low-precision __signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<int, lowp>				lowp_imat4;


	/// Low-precision __signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<int, lowp>				lowp_imat2x2;

	/// Low-precision __signed integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x3<int, lowp>				lowp_imat2x3;

	/// Low-precision __signed integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x4<int, lowp>				lowp_imat2x4;

	/// Low-precision __signed integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x2<int, lowp>				lowp_imat3x2;

	/// Low-precision __signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<int, lowp>				lowp_imat3x3;

	/// Low-precision __signed integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x4<int, lowp>				lowp_imat3x4;

	/// Low-precision __signed integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x2<int, lowp>				lowp_imat4x2;

	/// Low-precision __signed integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x3<int, lowp>				lowp_imat4x3;

	/// Low-precision __signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<int, lowp>				lowp_imat4x4;


	/// High-precision unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<uint, highp>				highp_umat2;	

	/// High-precision unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<uint, highp>				highp_umat3;

	/// High-precision unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<uint, highp>				highp_umat4;

	/// High-precision unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<uint, highp>				highp_umat2x2;

	/// High-precision unsigned integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x3<uint, highp>				highp_umat2x3;

	/// High-precision unsigned integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x4<uint, highp>				highp_umat2x4;

	/// High-precision unsigned integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x2<uint, highp>				highp_umat3x2;

	/// High-precision unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<uint, highp>				highp_umat3x3;

	/// High-precision unsigned integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x4<uint, highp>				highp_umat3x4;

	/// High-precision unsigned integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x2<uint, highp>				highp_umat4x2;

	/// High-precision unsigned integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x3<uint, highp>				highp_umat4x3;

	/// High-precision unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<uint, highp>				highp_umat4x4;


	/// Medium-precision unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<uint, mediump>			mediump_umat2;

	/// Medium-precision unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<uint, mediump>			mediump_umat3;

	/// Medium-precision unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<uint, mediump>			mediump_umat4;


	/// Medium-precision unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<uint, mediump>			mediump_umat2x2;

	/// Medium-precision unsigned integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x3<uint, mediump>			mediump_umat2x3;

	/// Medium-precision unsigned integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x4<uint, mediump>			mediump_umat2x4;

	/// Medium-precision unsigned integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x2<uint, mediump>			mediump_umat3x2;

	/// Medium-precision unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<uint, mediump>			mediump_umat3x3;

	/// Medium-precision unsigned integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x4<uint, mediump>			mediump_umat3x4;

	/// Medium-precision unsigned integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x2<uint, mediump>			mediump_umat4x2;

	/// Medium-precision unsigned integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x3<uint, mediump>			mediump_umat4x3;

	/// Medium-precision unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<uint, mediump>			mediump_umat4x4;


	/// Low-precision unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<uint, lowp>				lowp_umat2;
	
	/// Low-precision unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<uint, lowp>				lowp_umat3;

	/// Low-precision unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<uint, lowp>				lowp_umat4;


	/// Low-precision unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x2<uint, lowp>				lowp_umat2x2;

	/// Low-precision unsigned integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x3<uint, lowp>				lowp_umat2x3;

	/// Low-precision unsigned integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat2x4<uint, lowp>				lowp_umat2x4;

	/// Low-precision unsigned integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x2<uint, lowp>				lowp_umat3x2;

	/// Low-precision unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x3<uint, lowp>				lowp_umat3x3;

	/// Low-precision unsigned integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat3x4<uint, lowp>				lowp_umat3x4;

	/// Low-precision unsigned integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x2<uint, lowp>				lowp_umat4x2;

	/// Low-precision unsigned integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x3<uint, lowp>				lowp_umat4x3;

	/// Low-precision unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef tmat4x4<uint, lowp>				lowp_umat4x4;


# 357 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
                                               

	/// Signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat2							imat2;

	/// Signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat3							imat3;

	/// Signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat4							imat4;

	/// Signed integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat2x2							imat2x2;

	/// Signed integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat2x3							imat2x3;

	/// Signed integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat2x4							imat2x4;

	/// Signed integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat3x2							imat3x2;

	/// Signed integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat3x3							imat3x3;

	/// Signed integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat3x4							imat3x4;

	/// Signed integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat4x2							imat4x2;

	/// Signed integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat4x3							imat4x3;

	/// Signed integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_imat4x4							imat4x4;



# 434 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
                                                
	
	/// Unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat2							umat2;

	/// Unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat3							umat3;

	/// Unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat4							umat4;

	/// Unsigned integer 2x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat2x2							umat2x2;

	/// Unsigned integer 2x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat2x3							umat2x3;

	/// Unsigned integer 2x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat2x4							umat2x4;

	/// Unsigned integer 3x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat3x2							umat3x2;

	/// Unsigned integer 3x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat3x3							umat3x3;

	/// Unsigned integer 3x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat3x4							umat3x4;

	/// Unsigned integer 4x2 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat4x2							umat4x2;

	/// Unsigned integer 4x3 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat4x3							umat4x3;

	/// Unsigned integer 4x4 matrix.
	/// @see gtc_matrix_integer
	typedef mediump_umat4x4							umat4x4;


	/// @}
}//namespace glm

# 44 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 1 3
/// @ref gtc_matrix_inverse
/// @file glm/gtc/matrix_inverse.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_matrix_inverse GLM_GTC_matrix_inverse
/// @ingroup gtc
///
/// Defines additional matrix inverting functions.
/// <glm/gtc/matrix_inverse.hpp> need to be included to use these functionalities.



// Dependencies








       

namespace glm
{
	/// @addtogroup gtc_matrix_inverse
	/// @{

	/// Fast matrix inverse for affine matrix.
	/// 
	/// @param m Input matrix to invert.
	/// @tparam genType Squared floating-point matrix: half, float or double. Inverse of matrix based of half-precision floating point value is highly innacurate.
	/// @see gtc_matrix_inverse
	template <typename genType> 
	 genType affineInverse(genType __const & m);

	/// Compute the inverse transpose of a matrix.
	/// 
	/// @param m Input matrix to invert transpose.
	/// @tparam genType Squared floating-point matrix: half, float or double. Inverse of matrix based of half-precision floating point value is highly innacurate.
	/// @see gtc_matrix_inverse
	template <typename genType>
	 genType inverseTranspose(genType __const & m);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/matrix_inverse.inl" 1 3
/// @ref gtc_matrix_inverse
/// @file glm/gtc/matrix_inverse.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tmat3x3<T, P> affineInverse(tmat3x3<T, P> __const & m)
	{
		tmat2x2<T, P> __const Inv(inverse(tmat2x2<T, P>(m)));

		return tmat3x3<T, P>(
			tvec3<T, P>(Inv[0], static_cast<T>(0)),
			tvec3<T, P>(Inv[1], static_cast<T>(0)),
			tvec3<T, P>(-Inv * tvec2<T, P>(m[2]), static_cast<T>(1)));
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> affineInverse(tmat4x4<T, P> __const & m)
	{
		tmat3x3<T, P> __const Inv(inverse(tmat3x3<T, P>(m)));

		return tmat4x4<T, P>(
			tvec4<T, P>(Inv[0], static_cast<T>(0)),
			tvec4<T, P>(Inv[1], static_cast<T>(0)),
			tvec4<T, P>(Inv[2], static_cast<T>(0)),
			tvec4<T, P>(-Inv * tvec3<T, P>(m[3]), static_cast<T>(1)));
	}

	template <typename T, precision P>
	 __inline tmat2x2<T, P> inverseTranspose(tmat2x2<T, P> __const & m)
	{
		T Determinant = m[0][0] * m[1][1] - m[1][0] * m[0][1];

		tmat2x2<T, P> Inverse(
			+ m[1][1] / Determinant,
			- m[0][1] / Determinant,
			- m[1][0] / Determinant,
			+ m[0][0] / Determinant);

		return Inverse;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> inverseTranspose(tmat3x3<T, P> __const & m)
	{
		T Determinant =
			+ m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
			- m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
			+ m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

		tmat3x3<T, P> Inverse(uninitialize);
		Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
		Inverse[0][1] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
		Inverse[0][2] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
		Inverse[1][0] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
		Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
		Inverse[1][2] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
		Inverse[2][0] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		Inverse[2][1] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
		Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
		Inverse /= Determinant;

		return Inverse;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> inverseTranspose(tmat4x4<T, P> __const & m)
	{
		T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
		T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
		T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
		T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
		T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
		T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
		T SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
		T SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
		T SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
		T SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
		T SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
		T SubFactor11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
		T SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
		T SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
		T SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
		T SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
		T SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
		T SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
		T SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

		tmat4x4<T, P> Inverse(uninitialize);
		Inverse[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);
		Inverse[0][1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);
		Inverse[0][2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);
		Inverse[0][3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);

		Inverse[1][0] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);
		Inverse[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);
		Inverse[1][2] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);
		Inverse[1][3] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);

		Inverse[2][0] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);
		Inverse[2][1] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);
		Inverse[2][2] = + (m[0][0] * SubFactor11 - m[0][1] * SubFactor09 + m[0][3] * SubFactor12);
		Inverse[2][3] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor12);

		Inverse[3][0] = - (m[0][1] * SubFactor13 - m[0][2] * SubFactor14 + m[0][3] * SubFactor15);
		Inverse[3][1] = + (m[0][0] * SubFactor13 - m[0][2] * SubFactor16 + m[0][3] * SubFactor17);
		Inverse[3][2] = - (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][3] * SubFactor18);
		Inverse[3][3] = + (m[0][0] * SubFactor15 - m[0][1] * SubFactor17 + m[0][2] * SubFactor18);

		T Determinant =
			+ m[0][0] * Inverse[0][0]
			+ m[0][1] * Inverse[0][1]
			+ m[0][2] * Inverse[0][2]
			+ m[0][3] * Inverse[0][3];

		Inverse /= Determinant;

		return Inverse;
	}
}//namespace glm

# 49 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 2 3


# 45 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtc/noise.hpp" 1 3
/// @ref gtc_noise
/// @file glm/gtc/noise.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_noise GLM_GTC_noise
/// @ingroup gtc
///
/// Defines 2D, 3D and 4D procedural noise functions 
/// Based on the work of Stefan Gustavson and Ashima Arts on "webgl-noise": 
/// https://github.com/ashima/webgl-noise 
/// Following Stefan Gustavson's paper "Simplex noise demystified": 
/// http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
/// <glm/gtc/noise.hpp> need to be included to use these functionalities.



// Dependencies



# 1 "/usr/local/include/glm/gtc/../detail/_noise.hpp" 1 3
/// @ref core
/// @file glm/detail/_noise.hpp








namespace glm{
namespace detail
{
	template <typename T>
	 __inline T mod289(T __const & x)
	{
		return x - floor(x * static_cast<T>(1.0) / static_cast<T>(289.0)) * static_cast<T>(289.0);
	}

	template <typename T>
	 __inline T permute(T __const & x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> permute(tvec2<T, P> __const & x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}
	
	template <typename T, precision P>
	 __inline tvec3<T, P> permute(tvec3<T, P> __const & x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}
	
	template <typename T, precision P>
	 __inline tvec4<T, P> permute(tvec4<T, P> __const & x)
	{
		return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
	}







	template <typename T>
	 __inline T taylorInvSqrt(T __const & r)
	{
		return T(1.79284291400159) - T(0.85373472095314) * r;
	}
	
	template <typename T, precision P>
	 __inline tvec2<T, P> taylorInvSqrt(tvec2<T, P> __const & r)
	{
		return T(1.79284291400159) - T(0.85373472095314) * r;
	}
	
	template <typename T, precision P>
	 __inline tvec3<T, P> taylorInvSqrt(tvec3<T, P> __const & r)
	{
		return T(1.79284291400159) - T(0.85373472095314) * r;
	}
	
	template <typename T, precision P>
	 __inline tvec4<T, P> taylorInvSqrt(tvec4<T, P> __const & r)
	{
		return T(1.79284291400159) - T(0.85373472095314) * r;
	}







	
	template <typename T, precision P>
	 __inline tvec2<T, P> fade(tvec2<T, P> __const & t)
	{
		return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
	}
	
	template <typename T, precision P>
	 __inline tvec3<T, P> fade(tvec3<T, P> __const & t)
	{
		return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
	}
	
	template <typename T, precision P>
	 __inline tvec4<T, P> fade(tvec4<T, P> __const & t)
	{
		return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
	}







}//namespace detail
}//namespace glm


# 21 "/usr/local/include/glm/./gtc/noise.hpp" 2 3










       

namespace glm
{
	/// @addtogroup gtc_noise
	/// @{

	/// Classic perlin noise.
	/// @see gtc_noise
	template <typename T, precision P, template<typename, precision> class vecType>
	 T perlin(
		vecType<T, P> __const & p);
		
	/// Periodic perlin noise.
	/// @see gtc_noise
	template <typename T, precision P, template<typename, precision> class vecType>
	 T perlin(
		vecType<T, P> __const & p,
		vecType<T, P> __const & rep);

	/// Simplex noise.
	/// @see gtc_noise
	template <typename T, precision P, template<typename, precision> class vecType>
	 T simplex(
		vecType<T, P> __const & p);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/noise.inl" 1 3
/// @ref gtc_noise
/// @file glm/gtc/noise.inl
///
// Based on the work of Stefan Gustavson and Ashima Arts on "webgl-noise": 
// https://github.com/ashima/webgl-noise 
// Following Stefan Gustavson's paper "Simplex noise demystified": 
// http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf

namespace glm{
namespace gtc
{
	template <typename T, precision P>
	 __inline tvec4<T, P> grad4(T __const & j, tvec4<T, P> __const & ip)
	{
		tvec3<T, P> pXYZ = floor(fract(tvec3<T, P>(j) * tvec3<T, P>(ip)) * T(7)) * ip[2] - T(1);
		T pW = static_cast<T>(1.5) - dot(abs(pXYZ), tvec3<T, P>(1));
		tvec4<T, P> s = tvec4<T, P>(lessThan(tvec4<T, P>(pXYZ, pW), tvec4<T, P>(0.0)));
		pXYZ = pXYZ + (tvec3<T, P>(s) * T(2) - T(1)) * s.w; 
		return tvec4<T, P>(pXYZ, pW);
	}
}//namespace gtc

	// Classic Perlin noise
	template <typename T, precision P>
	 __inline T perlin(tvec2<T, P> __const & Position)
	{
		tvec4<T, P> Pi = glm::floor(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) + tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
		tvec4<T, P> Pf = glm::fract(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) - tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
		Pi = mod(Pi, tvec4<T, P>(289)); // To avoid truncation effects in permutation
		tvec4<T, P> ix(Pi.x, Pi.z, Pi.x, Pi.z);
		tvec4<T, P> iy(Pi.y, Pi.y, Pi.w, Pi.w);
		tvec4<T, P> fx(Pf.x, Pf.z, Pf.x, Pf.z);
		tvec4<T, P> fy(Pf.y, Pf.y, Pf.w, Pf.w);

		tvec4<T, P> i = detail::permute(detail::permute(ix) + iy);

		tvec4<T, P> gx = static_cast<T>(2) * glm::fract(i / T(41)) - T(1);
		tvec4<T, P> gy = glm::abs(gx) - T(0.5);
		tvec4<T, P> tx = glm::floor(gx + T(0.5));
		gx = gx - tx;

		tvec2<T, P> g00(gx.x, gy.x);
		tvec2<T, P> g10(gx.y, gy.y);
		tvec2<T, P> g01(gx.z, gy.z);
		tvec2<T, P> g11(gx.w, gy.w);

		tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
		g00 *= norm.x;
		g01 *= norm.y;
		g10 *= norm.z;
		g11 *= norm.w;

		T n00 = dot(g00, tvec2<T, P>(fx.x, fy.x));
		T n10 = dot(g10, tvec2<T, P>(fx.y, fy.y));
		T n01 = dot(g01, tvec2<T, P>(fx.z, fy.z));
		T n11 = dot(g11, tvec2<T, P>(fx.w, fy.w));

		tvec2<T, P> fade_xy = detail::fade(tvec2<T, P>(Pf.x, Pf.y));
		tvec2<T, P> n_x = mix(tvec2<T, P>(n00, n01), tvec2<T, P>(n10, n11), fade_xy.x);
		T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
		return T(2.3) * n_xy;
	}

	// Classic Perlin noise
	template <typename T, precision P>
	 __inline T perlin(tvec3<T, P> __const & Position)
	{
		tvec3<T, P> Pi0 = floor(Position); // Integer part for indexing
		tvec3<T, P> Pi1 = Pi0 + T(1); // Integer part + 1
		Pi0 = detail::mod289(Pi0);
		Pi1 = detail::mod289(Pi1);
		tvec3<T, P> Pf0 = fract(Position); // Fractional part for interpolation
		tvec3<T, P> Pf1 = Pf0 - T(1); // Fractional part - 1.0
		tvec4<T, P> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		tvec4<T, P> iy = tvec4<T, P>(tvec2<T, P>(Pi0.y), tvec2<T, P>(Pi1.y));
		tvec4<T, P> iz0(Pi0.z);
		tvec4<T, P> iz1(Pi1.z);

		tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
		tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
		tvec4<T, P> ixy1 = detail::permute(ixy + iz1);

		tvec4<T, P> gx0 = ixy0 * T(1.0 / 7.0);
		tvec4<T, P> gy0 = fract(floor(gx0) * T(1.0 / 7.0)) - T(0.5);
		gx0 = fract(gx0);
		tvec4<T, P> gz0 = tvec4<T, P>(0.5) - abs(gx0) - abs(gy0);
		tvec4<T, P> sz0 = step(gz0, tvec4<T, P>(0.0));
		gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
		gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

		tvec4<T, P> gx1 = ixy1 * T(1.0 / 7.0);
		tvec4<T, P> gy1 = fract(floor(gx1) * T(1.0 / 7.0)) - T(0.5);
		gx1 = fract(gx1);
		tvec4<T, P> gz1 = tvec4<T, P>(0.5) - abs(gx1) - abs(gy1);
		tvec4<T, P> sz1 = step(gz1, tvec4<T, P>(0.0));
		gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
		gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

		tvec3<T, P> g000(gx0.x, gy0.x, gz0.x);
		tvec3<T, P> g100(gx0.y, gy0.y, gz0.y);
		tvec3<T, P> g010(gx0.z, gy0.z, gz0.z);
		tvec3<T, P> g110(gx0.w, gy0.w, gz0.w);
		tvec3<T, P> g001(gx1.x, gy1.x, gz1.x);
		tvec3<T, P> g101(gx1.y, gy1.y, gz1.y);
		tvec3<T, P> g011(gx1.z, gy1.z, gz1.z);
		tvec3<T, P> g111(gx1.w, gy1.w, gz1.w);

		tvec4<T, P> norm0 = detail::taylorInvSqrt(tvec4<T, P>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		g000 *= norm0.x;
		g010 *= norm0.y;
		g100 *= norm0.z;
		g110 *= norm0.w;
		tvec4<T, P> norm1 = detail::taylorInvSqrt(tvec4<T, P>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		g001 *= norm1.x;
		g011 *= norm1.y;
		g101 *= norm1.z;
		g111 *= norm1.w;

		T n000 = dot(g000, Pf0);
		T n100 = dot(g100, tvec3<T, P>(Pf1.x, Pf0.y, Pf0.z));
		T n010 = dot(g010, tvec3<T, P>(Pf0.x, Pf1.y, Pf0.z));
		T n110 = dot(g110, tvec3<T, P>(Pf1.x, Pf1.y, Pf0.z));
		T n001 = dot(g001, tvec3<T, P>(Pf0.x, Pf0.y, Pf1.z));
		T n101 = dot(g101, tvec3<T, P>(Pf1.x, Pf0.y, Pf1.z));
		T n011 = dot(g011, tvec3<T, P>(Pf0.x, Pf1.y, Pf1.z));
		T n111 = dot(g111, Pf1);

		tvec3<T, P> fade_xyz = detail::fade(Pf0);
		tvec4<T, P> n_z = mix(tvec4<T, P>(n000, n100, n010, n110), tvec4<T, P>(n001, n101, n011, n111), fade_xyz.z);
		tvec2<T, P> n_yz = mix(tvec2<T, P>(n_z.x, n_z.y), tvec2<T, P>(n_z.z, n_z.w), fade_xyz.y);
		T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		return T(2.2) * n_xyz;
	}
	
# 207 "/usr/local/include/glm/gtc/noise.inl" 3

	// Classic Perlin noise
	template <typename T, precision P>
	 __inline T perlin(tvec4<T, P> __const & Position)
	{
		tvec4<T, P> Pi0 = floor(Position);	// Integer part for indexing
		tvec4<T, P> Pi1 = Pi0 + T(1);		// Integer part + 1
		Pi0 = mod(Pi0, tvec4<T, P>(289));
		Pi1 = mod(Pi1, tvec4<T, P>(289));
		tvec4<T, P> Pf0 = fract(Position);	// Fractional part for interpolation
		tvec4<T, P> Pf1 = Pf0 - T(1);		// Fractional part - 1.0
		tvec4<T, P> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		tvec4<T, P> iy(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
		tvec4<T, P> iz0(Pi0.z);
		tvec4<T, P> iz1(Pi1.z);
		tvec4<T, P> iw0(Pi0.w);
		tvec4<T, P> iw1(Pi1.w);

		tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
		tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
		tvec4<T, P> ixy1 = detail::permute(ixy + iz1);
		tvec4<T, P> ixy00 = detail::permute(ixy0 + iw0);
		tvec4<T, P> ixy01 = detail::permute(ixy0 + iw1);
		tvec4<T, P> ixy10 = detail::permute(ixy1 + iw0);
		tvec4<T, P> ixy11 = detail::permute(ixy1 + iw1);

		tvec4<T, P> gx00 = ixy00 / T(7);
		tvec4<T, P> gy00 = floor(gx00) / T(7);
		tvec4<T, P> gz00 = floor(gy00) / T(6);
		gx00 = fract(gx00) - T(0.5);
		gy00 = fract(gy00) - T(0.5);
		gz00 = fract(gz00) - T(0.5);
		tvec4<T, P> gw00 = tvec4<T, P>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
		tvec4<T, P> sw00 = step(gw00, tvec4<T, P>(0.0));
		gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
		gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

		tvec4<T, P> gx01 = ixy01 / T(7);
		tvec4<T, P> gy01 = floor(gx01) / T(7);
		tvec4<T, P> gz01 = floor(gy01) / T(6);
		gx01 = fract(gx01) - T(0.5);
		gy01 = fract(gy01) - T(0.5);
		gz01 = fract(gz01) - T(0.5);
		tvec4<T, P> gw01 = tvec4<T, P>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
		tvec4<T, P> sw01 = step(gw01, tvec4<T, P>(0.0));
		gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
		gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

		tvec4<T, P> gx10 = ixy10 / T(7);
		tvec4<T, P> gy10 = floor(gx10) / T(7);
		tvec4<T, P> gz10 = floor(gy10) / T(6);
		gx10 = fract(gx10) - T(0.5);
		gy10 = fract(gy10) - T(0.5);
		gz10 = fract(gz10) - T(0.5);
		tvec4<T, P> gw10 = tvec4<T, P>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
		tvec4<T, P> sw10 = step(gw10, tvec4<T, P>(0));
		gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
		gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

		tvec4<T, P> gx11 = ixy11 / T(7);
		tvec4<T, P> gy11 = floor(gx11) / T(7);
		tvec4<T, P> gz11 = floor(gy11) / T(6);
		gx11 = fract(gx11) - T(0.5);
		gy11 = fract(gy11) - T(0.5);
		gz11 = fract(gz11) - T(0.5);
		tvec4<T, P> gw11 = tvec4<T, P>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
		tvec4<T, P> sw11 = step(gw11, tvec4<T, P>(0.0));
		gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
		gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

		tvec4<T, P> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
		tvec4<T, P> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
		tvec4<T, P> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
		tvec4<T, P> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
		tvec4<T, P> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
		tvec4<T, P> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
		tvec4<T, P> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
		tvec4<T, P> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
		tvec4<T, P> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
		tvec4<T, P> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
		tvec4<T, P> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
		tvec4<T, P> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
		tvec4<T, P> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
		tvec4<T, P> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
		tvec4<T, P> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
		tvec4<T, P> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

		tvec4<T, P> norm00 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
		g0000 *= norm00.x;
		g0100 *= norm00.y;
		g1000 *= norm00.z;
		g1100 *= norm00.w;

		tvec4<T, P> norm01 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
		g0001 *= norm01.x;
		g0101 *= norm01.y;
		g1001 *= norm01.z;
		g1101 *= norm01.w;

		tvec4<T, P> norm10 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
		g0010 *= norm10.x;
		g0110 *= norm10.y;
		g1010 *= norm10.z;
		g1110 *= norm10.w;

		tvec4<T, P> norm11 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
		g0011 *= norm11.x;
		g0111 *= norm11.y;
		g1011 *= norm11.z;
		g1111 *= norm11.w;

		T n0000 = dot(g0000, Pf0);
		T n1000 = dot(g1000, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
		T n0100 = dot(g0100, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
		T n1100 = dot(g1100, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
		T n0010 = dot(g0010, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
		T n1010 = dot(g1010, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
		T n0110 = dot(g0110, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
		T n1110 = dot(g1110, tvec4<T, P>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
		T n0001 = dot(g0001, tvec4<T, P>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
		T n1001 = dot(g1001, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
		T n0101 = dot(g0101, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
		T n1101 = dot(g1101, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
		T n0011 = dot(g0011, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
		T n1011 = dot(g1011, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
		T n0111 = dot(g0111, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
		T n1111 = dot(g1111, Pf1);

		tvec4<T, P> fade_xyzw = detail::fade(Pf0);
		tvec4<T, P> n_0w = mix(tvec4<T, P>(n0000, n1000, n0100, n1100), tvec4<T, P>(n0001, n1001, n0101, n1101), fade_xyzw.w);
		tvec4<T, P> n_1w = mix(tvec4<T, P>(n0010, n1010, n0110, n1110), tvec4<T, P>(n0011, n1011, n0111, n1111), fade_xyzw.w);
		tvec4<T, P> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
		tvec2<T, P> n_yzw = mix(tvec2<T, P>(n_zw.x, n_zw.y), tvec2<T, P>(n_zw.z, n_zw.w), fade_xyzw.y);
		T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
		return T(2.2) * n_xyzw;
	}

	// Classic Perlin noise, periodic variant
	template <typename T, precision P>
	 __inline T perlin(tvec2<T, P> __const & Position, tvec2<T, P> __const & rep)
	{
		tvec4<T, P> Pi = floor(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) + tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
		tvec4<T, P> Pf = fract(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) - tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
		Pi = mod(Pi, tvec4<T, P>(rep.x, rep.y, rep.x, rep.y)); // To create noise with explicit period
		Pi = mod(Pi, tvec4<T, P>(289)); // To avoid truncation effects in permutation
		tvec4<T, P> ix(Pi.x, Pi.z, Pi.x, Pi.z);
		tvec4<T, P> iy(Pi.y, Pi.y, Pi.w, Pi.w);
		tvec4<T, P> fx(Pf.x, Pf.z, Pf.x, Pf.z);
		tvec4<T, P> fy(Pf.y, Pf.y, Pf.w, Pf.w);

		tvec4<T, P> i = detail::permute(detail::permute(ix) + iy);

		tvec4<T, P> gx = static_cast<T>(2) * fract(i / T(41)) - T(1);
		tvec4<T, P> gy = abs(gx) - T(0.5);
		tvec4<T, P> tx = floor(gx + T(0.5));
		gx = gx - tx;

		tvec2<T, P> g00(gx.x, gy.x);
		tvec2<T, P> g10(gx.y, gy.y);
		tvec2<T, P> g01(gx.z, gy.z);
		tvec2<T, P> g11(gx.w, gy.w);

		tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
		g00 *= norm.x;
		g01 *= norm.y;
		g10 *= norm.z;
		g11 *= norm.w;

		T n00 = dot(g00, tvec2<T, P>(fx.x, fy.x));
		T n10 = dot(g10, tvec2<T, P>(fx.y, fy.y));
		T n01 = dot(g01, tvec2<T, P>(fx.z, fy.z));
		T n11 = dot(g11, tvec2<T, P>(fx.w, fy.w));

		tvec2<T, P> fade_xy = detail::fade(tvec2<T, P>(Pf.x, Pf.y));
		tvec2<T, P> n_x = mix(tvec2<T, P>(n00, n01), tvec2<T, P>(n10, n11), fade_xy.x);
		T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
		return T(2.3) * n_xy;
	}

	// Classic Perlin noise, periodic variant
	template <typename T, precision P>
	 __inline T perlin(tvec3<T, P> __const & Position, tvec3<T, P> __const & rep)
	{
		tvec3<T, P> Pi0 = mod(floor(Position), rep); // Integer part, modulo period
		tvec3<T, P> Pi1 = mod(Pi0 + tvec3<T, P>(T(1)), rep); // Integer part + 1, mod period
		Pi0 = mod(Pi0, tvec3<T, P>(289));
		Pi1 = mod(Pi1, tvec3<T, P>(289));
		tvec3<T, P> Pf0 = fract(Position); // Fractional part for interpolation
		tvec3<T, P> Pf1 = Pf0 - tvec3<T, P>(T(1)); // Fractional part - 1.0
		tvec4<T, P> ix = tvec4<T, P>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		tvec4<T, P> iy = tvec4<T, P>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
		tvec4<T, P> iz0(Pi0.z);
		tvec4<T, P> iz1(Pi1.z);

		tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
		tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
		tvec4<T, P> ixy1 = detail::permute(ixy + iz1);

		tvec4<T, P> gx0 = ixy0 / T(7);
		tvec4<T, P> gy0 = fract(floor(gx0) / T(7)) - T(0.5);
		gx0 = fract(gx0);
		tvec4<T, P> gz0 = tvec4<T, P>(0.5) - abs(gx0) - abs(gy0);
		tvec4<T, P> sz0 = step(gz0, tvec4<T, P>(0));
		gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
		gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

		tvec4<T, P> gx1 = ixy1 / T(7);
		tvec4<T, P> gy1 = fract(floor(gx1) / T(7)) - T(0.5);
		gx1 = fract(gx1);
		tvec4<T, P> gz1 = tvec4<T, P>(0.5) - abs(gx1) - abs(gy1);
		tvec4<T, P> sz1 = step(gz1, tvec4<T, P>(T(0)));
		gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
		gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

		tvec3<T, P> g000 = tvec3<T, P>(gx0.x, gy0.x, gz0.x);
		tvec3<T, P> g100 = tvec3<T, P>(gx0.y, gy0.y, gz0.y);
		tvec3<T, P> g010 = tvec3<T, P>(gx0.z, gy0.z, gz0.z);
		tvec3<T, P> g110 = tvec3<T, P>(gx0.w, gy0.w, gz0.w);
		tvec3<T, P> g001 = tvec3<T, P>(gx1.x, gy1.x, gz1.x);
		tvec3<T, P> g101 = tvec3<T, P>(gx1.y, gy1.y, gz1.y);
		tvec3<T, P> g011 = tvec3<T, P>(gx1.z, gy1.z, gz1.z);
		tvec3<T, P> g111 = tvec3<T, P>(gx1.w, gy1.w, gz1.w);

		tvec4<T, P> norm0 = detail::taylorInvSqrt(tvec4<T, P>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		g000 *= norm0.x;
		g010 *= norm0.y;
		g100 *= norm0.z;
		g110 *= norm0.w;
		tvec4<T, P> norm1 = detail::taylorInvSqrt(tvec4<T, P>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		g001 *= norm1.x;
		g011 *= norm1.y;
		g101 *= norm1.z;
		g111 *= norm1.w;

		T n000 = dot(g000, Pf0);
		T n100 = dot(g100, tvec3<T, P>(Pf1.x, Pf0.y, Pf0.z));
		T n010 = dot(g010, tvec3<T, P>(Pf0.x, Pf1.y, Pf0.z));
		T n110 = dot(g110, tvec3<T, P>(Pf1.x, Pf1.y, Pf0.z));
		T n001 = dot(g001, tvec3<T, P>(Pf0.x, Pf0.y, Pf1.z));
		T n101 = dot(g101, tvec3<T, P>(Pf1.x, Pf0.y, Pf1.z));
		T n011 = dot(g011, tvec3<T, P>(Pf0.x, Pf1.y, Pf1.z));
		T n111 = dot(g111, Pf1);

		tvec3<T, P> fade_xyz = detail::fade(Pf0);
		tvec4<T, P> n_z = mix(tvec4<T, P>(n000, n100, n010, n110), tvec4<T, P>(n001, n101, n011, n111), fade_xyz.z);
		tvec2<T, P> n_yz = mix(tvec2<T, P>(n_z.x, n_z.y), tvec2<T, P>(n_z.z, n_z.w), fade_xyz.y);
		T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
		return T(2.2) * n_xyz;
	}

	// Classic Perlin noise, periodic version
	template <typename T, precision P>
	 __inline T perlin(tvec4<T, P> __const & Position, tvec4<T, P> __const & rep)
	{
		tvec4<T, P> Pi0 = mod(floor(Position), rep); // Integer part modulo rep
		tvec4<T, P> Pi1 = mod(Pi0 + T(1), rep); // Integer part + 1 mod rep
		tvec4<T, P> Pf0 = fract(Position); // Fractional part for interpolation
		tvec4<T, P> Pf1 = Pf0 - T(1); // Fractional part - 1.0
		tvec4<T, P> ix = tvec4<T, P>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		tvec4<T, P> iy = tvec4<T, P>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
		tvec4<T, P> iz0(Pi0.z);
		tvec4<T, P> iz1(Pi1.z);
		tvec4<T, P> iw0(Pi0.w);
		tvec4<T, P> iw1(Pi1.w);

		tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
		tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
		tvec4<T, P> ixy1 = detail::permute(ixy + iz1);
		tvec4<T, P> ixy00 = detail::permute(ixy0 + iw0);
		tvec4<T, P> ixy01 = detail::permute(ixy0 + iw1);
		tvec4<T, P> ixy10 = detail::permute(ixy1 + iw0);
		tvec4<T, P> ixy11 = detail::permute(ixy1 + iw1);

		tvec4<T, P> gx00 = ixy00 / T(7);
		tvec4<T, P> gy00 = floor(gx00) / T(7);
		tvec4<T, P> gz00 = floor(gy00) / T(6);
		gx00 = fract(gx00) - T(0.5);
		gy00 = fract(gy00) - T(0.5);
		gz00 = fract(gz00) - T(0.5);
		tvec4<T, P> gw00 = tvec4<T, P>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
		tvec4<T, P> sw00 = step(gw00, tvec4<T, P>(0));
		gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
		gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

		tvec4<T, P> gx01 = ixy01 / T(7);
		tvec4<T, P> gy01 = floor(gx01) / T(7);
		tvec4<T, P> gz01 = floor(gy01) / T(6);
		gx01 = fract(gx01) - T(0.5);
		gy01 = fract(gy01) - T(0.5);
		gz01 = fract(gz01) - T(0.5);
		tvec4<T, P> gw01 = tvec4<T, P>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
		tvec4<T, P> sw01 = step(gw01, tvec4<T, P>(0.0));
		gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
		gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

		tvec4<T, P> gx10 = ixy10 / T(7);
		tvec4<T, P> gy10 = floor(gx10) / T(7);
		tvec4<T, P> gz10 = floor(gy10) / T(6);
		gx10 = fract(gx10) - T(0.5);
		gy10 = fract(gy10) - T(0.5);
		gz10 = fract(gz10) - T(0.5);
		tvec4<T, P> gw10 = tvec4<T, P>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
		tvec4<T, P> sw10 = step(gw10, tvec4<T, P>(0.0));
		gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
		gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

		tvec4<T, P> gx11 = ixy11 / T(7);
		tvec4<T, P> gy11 = floor(gx11) / T(7);
		tvec4<T, P> gz11 = floor(gy11) / T(6);
		gx11 = fract(gx11) - T(0.5);
		gy11 = fract(gy11) - T(0.5);
		gz11 = fract(gz11) - T(0.5);
		tvec4<T, P> gw11 = tvec4<T, P>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
		tvec4<T, P> sw11 = step(gw11, tvec4<T, P>(T(0)));
		gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
		gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

		tvec4<T, P> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
		tvec4<T, P> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
		tvec4<T, P> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
		tvec4<T, P> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
		tvec4<T, P> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
		tvec4<T, P> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
		tvec4<T, P> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
		tvec4<T, P> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
		tvec4<T, P> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
		tvec4<T, P> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
		tvec4<T, P> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
		tvec4<T, P> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
		tvec4<T, P> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
		tvec4<T, P> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
		tvec4<T, P> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
		tvec4<T, P> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

		tvec4<T, P> norm00 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
		g0000 *= norm00.x;
		g0100 *= norm00.y;
		g1000 *= norm00.z;
		g1100 *= norm00.w;

		tvec4<T, P> norm01 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
		g0001 *= norm01.x;
		g0101 *= norm01.y;
		g1001 *= norm01.z;
		g1101 *= norm01.w;

		tvec4<T, P> norm10 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
		g0010 *= norm10.x;
		g0110 *= norm10.y;
		g1010 *= norm10.z;
		g1110 *= norm10.w;

		tvec4<T, P> norm11 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
		g0011 *= norm11.x;
		g0111 *= norm11.y;
		g1011 *= norm11.z;
		g1111 *= norm11.w;

		T n0000 = dot(g0000, Pf0);
		T n1000 = dot(g1000, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
		T n0100 = dot(g0100, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
		T n1100 = dot(g1100, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
		T n0010 = dot(g0010, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
		T n1010 = dot(g1010, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
		T n0110 = dot(g0110, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
		T n1110 = dot(g1110, tvec4<T, P>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
		T n0001 = dot(g0001, tvec4<T, P>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
		T n1001 = dot(g1001, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
		T n0101 = dot(g0101, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
		T n1101 = dot(g1101, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
		T n0011 = dot(g0011, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
		T n1011 = dot(g1011, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
		T n0111 = dot(g0111, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
		T n1111 = dot(g1111, Pf1);

		tvec4<T, P> fade_xyzw = detail::fade(Pf0);
		tvec4<T, P> n_0w = mix(tvec4<T, P>(n0000, n1000, n0100, n1100), tvec4<T, P>(n0001, n1001, n0101, n1101), fade_xyzw.w);
		tvec4<T, P> n_1w = mix(tvec4<T, P>(n0010, n1010, n0110, n1110), tvec4<T, P>(n0011, n1011, n0111, n1111), fade_xyzw.w);
		tvec4<T, P> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
		tvec2<T, P> n_yzw = mix(tvec2<T, P>(n_zw.x, n_zw.y), tvec2<T, P>(n_zw.z, n_zw.w), fade_xyzw.y);
		T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
		return T(2.2) * n_xyzw;
	}

	template <typename T, precision P>
	 __inline T simplex(glm::tvec2<T, P> __const & v)
	{
		tvec4<T, P> __const C = tvec4<T, P>(
			T( 0.211324865405187),  // (3.0 -  sqrt(3.0)) / 6.0
			T( 0.366025403784439),  //  0.5 * (sqrt(3.0)  - 1.0)
			T(-0.577350269189626),	// -1.0 + 2.0 * C.x
			T( 0.024390243902439)); //  1.0 / 41.0

		// First corner
		tvec2<T, P> i  = floor(v + dot(v, tvec2<T, P>(C[1])));
		tvec2<T, P> x0 = v -   i + dot(i, tvec2<T, P>(C[0]));

		// Other corners
		//i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
		//i1.y = 1.0 - i1.x;
		tvec2<T, P> i1 = (x0.x > x0.y) ? tvec2<T, P>(1, 0) : tvec2<T, P>(0, 1);
		// x0 = x0 - 0.0 + 0.0 * C.xx ;
		// x1 = x0 - i1 + 1.0 * C.xx ;
		// x2 = x0 - 1.0 + 2.0 * C.xx ;
		tvec4<T, P> x12 = tvec4<T, P>(x0.x, x0.y, x0.x, x0.y) + tvec4<T, P>(C.x, C.x, C.z, C.z);
		x12 = tvec4<T, P>(tvec2<T, P>(x12) - i1, x12.z, x12.w);

		// Permutations
		i = mod(i, tvec2<T, P>(289)); // Avoid truncation effects in permutation
		tvec3<T, P> p = detail::permute(
			detail::permute(i.y + tvec3<T, P>(T(0), i1.y, T(1)))
			+ i.x + tvec3<T, P>(T(0), i1.x, T(1)));

		tvec3<T, P> m = max(tvec3<T, P>(0.5) - tvec3<T, P>(
			dot(x0, x0),
			dot(tvec2<T, P>(x12.x, x12.y), tvec2<T, P>(x12.x, x12.y)), 
			dot(tvec2<T, P>(x12.z, x12.w), tvec2<T, P>(x12.z, x12.w))), tvec3<T, P>(0));
		m = m * m ;
		m = m * m ;

		// Gradients: 41 points uniformly over a line, mapped onto a diamond.
		// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

		tvec3<T, P> x = static_cast<T>(2) * fract(p * C.w) - T(1);
		tvec3<T, P> h = abs(x) - T(0.5);
		tvec3<T, P> ox = floor(x + T(0.5));
		tvec3<T, P> a0 = x - ox;

		// Normalise gradients implicitly by scaling m
		// Inlined for speed: m *= taylorInvSqrt( a0*a0 + h*h );
		m *= static_cast<T>(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);

		// Compute final noise value at P
		tvec3<T, P> g;
		g.x  = a0.x  * x0.x  + h.x  * x0.y;
		//g.yz = a0.yz * x12.xz + h.yz * x12.yw;
		g.y = a0.y * x12.x + h.y * x12.y;
		g.z = a0.z * x12.z + h.z * x12.w;
		return T(130) * dot(m, g);
	}

	template <typename T, precision P>
	 __inline T simplex(tvec3<T, P> __const & v)
	{
		tvec2<T, P> __const C(1.0 / 6.0, 1.0 / 3.0);
		tvec4<T, P> __const D(0.0, 0.5, 1.0, 2.0);

		// First corner
		tvec3<T, P> i(floor(v + dot(v, tvec3<T, P>(C.y))));
		tvec3<T, P> x0(v - i + dot(i, tvec3<T, P>(C.x)));

		// Other corners
		tvec3<T, P> g(step(tvec3<T, P>(x0.y, x0.z, x0.x), x0));
		tvec3<T, P> l(T(1) - g);
		tvec3<T, P> i1(min(g, tvec3<T, P>(l.z, l.x, l.y)));
		tvec3<T, P> i2(max(g, tvec3<T, P>(l.z, l.x, l.y)));

		//   x0 = x0 - 0.0 + 0.0 * C.xxx;
		//   x1 = x0 - i1  + 1.0 * C.xxx;
		//   x2 = x0 - i2  + 2.0 * C.xxx;
		//   x3 = x0 - 1.0 + 3.0 * C.xxx;
		tvec3<T, P> x1(x0 - i1 + C.x);
		tvec3<T, P> x2(x0 - i2 + C.y); // 2.0*C.x = 1/3 = C.y
		tvec3<T, P> x3(x0 - D.y);      // -1.0+3.0*C.x = -0.5 = -D.y

		// Permutations
		i = detail::mod289(i);
		tvec4<T, P> p(detail::permute(detail::permute(detail::permute(
			i.z + tvec4<T, P>(T(0), i1.z, i2.z, T(1))) +
			i.y + tvec4<T, P>(T(0), i1.y, i2.y, T(1))) +
			i.x + tvec4<T, P>(T(0), i1.x, i2.x, T(1))));

		// Gradients: 7x7 points over a square, mapped onto an octahedron.
		// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
		T n_ = static_cast<T>(0.142857142857); // 1.0/7.0
		tvec3<T, P> ns(n_ * tvec3<T, P>(D.w, D.y, D.z) - tvec3<T, P>(D.x, D.z, D.x));

		tvec4<T, P> j(p - T(49) * floor(p * ns.z * ns.z));  //  mod(p,7*7)

		tvec4<T, P> x_(floor(j * ns.z));
		tvec4<T, P> y_(floor(j - T(7) * x_));    // mod(j,N)

		tvec4<T, P> x(x_ * ns.x + ns.y);
		tvec4<T, P> y(y_ * ns.x + ns.y);
		tvec4<T, P> h(T(1) - abs(x) - abs(y));

		tvec4<T, P> b0(x.x, x.y, y.x, y.y);
		tvec4<T, P> b1(x.z, x.w, y.z, y.w);

		// vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
		// vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
		tvec4<T, P> s0(floor(b0) * T(2) + T(1));
		tvec4<T, P> s1(floor(b1) * T(2) + T(1));
		tvec4<T, P> sh(-step(h, tvec4<T, P>(0.0)));

		tvec4<T, P> a0 = tvec4<T, P>(b0.x, b0.z, b0.y, b0.w) + tvec4<T, P>(s0.x, s0.z, s0.y, s0.w) * tvec4<T, P>(sh.x, sh.x, sh.y, sh.y);
		tvec4<T, P> a1 = tvec4<T, P>(b1.x, b1.z, b1.y, b1.w) + tvec4<T, P>(s1.x, s1.z, s1.y, s1.w) * tvec4<T, P>(sh.z, sh.z, sh.w, sh.w);

		tvec3<T, P> p0(a0.x, a0.y, h.x);
		tvec3<T, P> p1(a0.z, a0.w, h.y);
		tvec3<T, P> p2(a1.x, a1.y, h.z);
		tvec3<T, P> p3(a1.z, a1.w, h.w);

		// Normalise gradients
		tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;

		// Mix final noise value
		tvec4<T, P> m = max(T(0.6) - tvec4<T, P>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), tvec4<T, P>(0));
		m = m * m;
		return T(42) * dot(m * m, tvec4<T, P>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
	}

	template <typename T, precision P>
	 __inline T simplex(tvec4<T, P> __const & v)
	{
		tvec4<T, P> __const C(
			0.138196601125011,  // (5 - sqrt(5))/20  G4
			0.276393202250021,  // 2 * G4
			0.414589803375032,  // 3 * G4
			-0.447213595499958); // -1 + 4 * G4

		// (sqrt(5) - 1)/4 = F4, used once below
		T __const F4 = static_cast<T>(0.309016994374947451);

		// First corner
		tvec4<T, P> i  = floor(v + dot(v, vec4(F4)));
		tvec4<T, P> x0 = v -   i + dot(i, vec4(C.x));

		// Other corners

		// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
		tvec4<T, P> i0;
		tvec3<T, P> isX = step(tvec3<T, P>(x0.y, x0.z, x0.w), tvec3<T, P>(x0.x));
		tvec3<T, P> isYZ = step(tvec3<T, P>(x0.z, x0.w, x0.w), tvec3<T, P>(x0.y, x0.y, x0.z));
		//  i0.x = dot(isX, vec3(1.0));
		//i0.x = isX.x + isX.y + isX.z;
		//i0.yzw = static_cast<T>(1) - isX;
		i0 = tvec4<T, P>(isX.x + isX.y + isX.z, T(1) - isX);
		//  i0.y += dot(isYZ.xy, vec2(1.0));
		i0.y += isYZ.x + isYZ.y;
		//i0.zw += 1.0 - tvec2<T, P>(isYZ.x, isYZ.y);
		i0.z += static_cast<T>(1) - isYZ.x;
		i0.w += static_cast<T>(1) - isYZ.y;
		i0.z += isYZ.z;
		i0.w += static_cast<T>(1) - isYZ.z;

		// i0 now contains the unique values 0,1,2,3 in each channel
		tvec4<T, P> i3 = clamp(i0, T(0), T(1));
		tvec4<T, P> i2 = clamp(i0 - T(1), T(0), T(1));
		tvec4<T, P> i1 = clamp(i0 - T(2), T(0), T(1));

		//  x0 = x0 - 0.0 + 0.0 * C.xxxx
		//  x1 = x0 - i1  + 0.0 * C.xxxx
		//  x2 = x0 - i2  + 0.0 * C.xxxx
		//  x3 = x0 - i3  + 0.0 * C.xxxx
		//  x4 = x0 - 1.0 + 4.0 * C.xxxx
		tvec4<T, P> x1 = x0 - i1 + C.x;
		tvec4<T, P> x2 = x0 - i2 + C.y;
		tvec4<T, P> x3 = x0 - i3 + C.z;
		tvec4<T, P> x4 = x0 + C.w;

		// Permutations
		i = mod(i, tvec4<T, P>(289)); 
		T j0 = detail::permute(detail::permute(detail::permute(detail::permute(i.w) + i.z) + i.y) + i.x);
		tvec4<T, P> j1 = detail::permute(detail::permute(detail::permute(detail::permute(
			i.w + tvec4<T, P>(i1.w, i2.w, i3.w, T(1))) +
			i.z + tvec4<T, P>(i1.z, i2.z, i3.z, T(1))) +
			i.y + tvec4<T, P>(i1.y, i2.y, i3.y, T(1))) +
			i.x + tvec4<T, P>(i1.x, i2.x, i3.x, T(1)));

		// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
		// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
		tvec4<T, P> ip = tvec4<T, P>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));

		tvec4<T, P> p0 = gtc::grad4(j0,   ip);
		tvec4<T, P> p1 = gtc::grad4(j1.x, ip);
		tvec4<T, P> p2 = gtc::grad4(j1.y, ip);
		tvec4<T, P> p3 = gtc::grad4(j1.z, ip);
		tvec4<T, P> p4 = gtc::grad4(j1.w, ip);

		// Normalise gradients
		tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;
		p4 *= detail::taylorInvSqrt(dot(p4, p4));

		// Mix contributions from the five corners
		tvec3<T, P> m0 = max(T(0.6) - tvec3<T, P>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), tvec3<T, P>(0));
		tvec2<T, P> m1 = max(T(0.6) - tvec2<T, P>(dot(x3, x3), dot(x4, x4)             ), tvec2<T, P>(0));
		m0 = m0 * m0;
		m1 = m1 * m1;
		return T(49) * 
			(dot(m0 * m0, tvec3<T, P>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + 
			dot(m1 * m1, tvec2<T, P>(dot(p3, x3), dot(p4, x4))));
	}
}//namespace glm

# 60 "/usr/local/include/glm/./gtc/noise.hpp" 2 3


# 47 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/packing.hpp" 1 3
/// @ref gtc_packing
/// @file glm/gtc/packing.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_packing GLM_GTC_packing
/// @ingroup gtc
///
/// @brief This extension provides a set of function to convert vertors to packed
/// formats.
///
/// <glm/gtc/packing.hpp> need to be included to use these features.



// Dependency:

# 1 "/usr/local/include/glm/gtc/type_precision.hpp" 1 3
/// @ref gtc_type_precision
/// @file glm/gtc/type_precision.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtc_quaternion (dependence)
///
/// @defgroup gtc_type_precision GLM_GTC_type_precision
/// @ingroup gtc
///
/// @brief Defines specific C++-based precision types.
/// 
/// @ref core_precision defines types based on GLSL's precision qualifiers. This
/// extension defines types based on explicitly-sized C++ data types.
///
/// <glm/gtc/type_precision.hpp> need to be included to use these functionalities.



// Dependency:


# 1 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 1 3
/// @ref gtc_vec1
/// @file glm/gtc/vec1.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_vec1 GLM_GTC_vec1
/// @ingroup gtc
/// 
/// @brief Add vec1, ivec1, uvec1 and bvec1 types.
/// <glm/gtc/vec1.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// 1 component vector of high precision floating-point numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef highp_vec1_t			highp_vec1;

	/// 1 component vector of medium precision floating-point numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef mediump_vec1_t			mediump_vec1;

	/// 1 component vector of low precision floating-point numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef lowp_vec1_t				lowp_vec1;

	/// 1 component vector of high precision floating-point numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef highp_dvec1_t			highp_dvec1;

	/// 1 component vector of medium precision floating-point numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef mediump_dvec1_t			mediump_dvec1;

	/// 1 component vector of low precision floating-point numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef lowp_dvec1_t			lowp_dvec1;

	/// 1 component vector of high precision __signed integer numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef highp_ivec1_t			highp_ivec1;

	/// 1 component vector of medium precision __signed integer numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef mediump_ivec1_t			mediump_ivec1;

	/// 1 component vector of low precision __signed integer numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef lowp_ivec1_t			lowp_ivec1;

	/// 1 component vector of high precision unsigned integer numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef highp_uvec1_t			highp_uvec1;

	/// 1 component vector of medium precision unsigned integer numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef mediump_uvec1_t			mediump_uvec1;

	/// 1 component vector of low precision unsigned integer numbers. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef lowp_uvec1_t			lowp_uvec1;

	/// 1 component vector of high precision boolean. 
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef highp_bvec1_t			highp_bvec1;

	/// 1 component vector of medium precision boolean.
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef mediump_bvec1_t			mediump_bvec1;

	/// 1 component vector of low precision boolean.
	/// There is no guarantee on the actual precision.
	/// @see gtc_vec1 extension.
	typedef lowp_bvec1_t			lowp_bvec1;

	//////////////////////////
	// vec1 definition







      
	/// 1 component vector of boolean.
	/// @see gtc_vec1 extension.
	typedef highp_bvec1				bvec1;








      
	/// 1 component vector of floating-point numbers.
	/// @see gtc_vec1 extension.
	typedef highp_vec1				vec1;








      
	/// 1 component vector of floating-point numbers.
	/// @see gtc_vec1 extension.
	typedef highp_dvec1				dvec1;








      
	/// 1 component vector of __signed integer numbers. 
	/// @see gtc_vec1 extension.
	typedef highp_ivec1			ivec1;








      
	/// 1 component vector of unsigned integer numbers. 
	/// @see gtc_vec1 extension.
	typedef highp_uvec1			uvec1;


}// namespace glm


# 1 "/usr/local/include/glm/gtc/vec1.inl" 1 3
/// @ref gtc_vec1
/// @file glm/gtc/vec1.inl

# 164 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 2 3


# 22 "/usr/local/include/glm/gtc/type_precision.hpp" 2 3
















       

namespace glm
{
	///////////////////////////
	// Signed int vector types 

	/// @addtogroup gtc_type_precision
	/// @{

	/// Low precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 lowp_int8;
	
	/// Low precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 lowp_int16;

	/// Low precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 lowp_int32;

	/// Low precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 lowp_int64;

	/// Low precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 lowp_int8_t;
	
	/// Low precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 lowp_int16_t;

	/// Low precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 lowp_int32_t;

	/// Low precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 lowp_int64_t;

	/// Low precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 lowp_i8;
	
	/// Low precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 lowp_i16;

	/// Low precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 lowp_i32;

	/// Low precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 lowp_i64;

	/// Medium precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 mediump_int8;
	
	/// Medium precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 mediump_int16;

	/// Medium precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 mediump_int32;

	/// Medium precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 mediump_int64;

	/// Medium precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 mediump_int8_t;
	
	/// Medium precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 mediump_int16_t;

	/// Medium precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 mediump_int32_t;

	/// Medium precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 mediump_int64_t;

	/// Medium precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 mediump_i8;
	
	/// Medium precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 mediump_i16;

	/// Medium precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 mediump_i32;

	/// Medium precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 mediump_i64;

	/// High precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 highp_int8;
	
	/// High precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 highp_int16;

	/// High precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 highp_int32;

	/// High precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 highp_int64;

	/// High precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 highp_int8_t;
	
	/// High precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 highp_int16_t;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 highp_int32_t;

	/// High precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 highp_int64_t;

	/// High precision 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 highp_i8;
	
	/// High precision 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 highp_i16;

	/// High precision 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 highp_i32;

	/// High precision 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 highp_i64;
	

	/// 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 int8;
	
	/// 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 int16;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 int32;

	/// 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 int64;






      
	/// 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 int8_t;
	
	/// 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 int16_t;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 int32_t;

	/// 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 int64_t;


	/// 8 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int8 i8;
	
	/// 16 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int16 i16;

	/// 32 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int32 i32;

	/// 64 bit __signed integer type.
	/// @see gtc_type_precision
	typedef detail::int64 i64;


	/// 8 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i8, defaultp> i8vec1;
	
	/// 8 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i8, defaultp> i8vec2;

	/// 8 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i8, defaultp> i8vec3;

	/// 8 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i8, defaultp> i8vec4;


	/// 16 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i16, defaultp> i16vec1;
	
	/// 16 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i16, defaultp> i16vec2;

	/// 16 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i16, defaultp> i16vec3;

	/// 16 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i16, defaultp> i16vec4;


	/// 32 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i32, defaultp> i32vec1;
	
	/// 32 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i32, defaultp> i32vec2;

	/// 32 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i32, defaultp> i32vec3;

	/// 32 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i32, defaultp> i32vec4;


	/// 64 bit __signed integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<i64, defaultp> i64vec1;
	
	/// 64 bit __signed integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<i64, defaultp> i64vec2;

	/// 64 bit __signed integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<i64, defaultp> i64vec3;

	/// 64 bit __signed integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<i64, defaultp> i64vec4;


	/////////////////////////////
	// Unsigned int vector types

	/// Low precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 lowp_uint8;
	
	/// Low precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 lowp_uint16;

	/// Low precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 lowp_uint32;

	/// Low precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 lowp_uint64;

	/// Low precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 lowp_uint8_t;
	
	/// Low precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 lowp_uint16_t;

	/// Low precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 lowp_uint32_t;

	/// Low precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 lowp_uint64_t;

	/// Low precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 lowp_u8;
	
	/// Low precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 lowp_u16;

	/// Low precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 lowp_u32;

	/// Low precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 lowp_u64;
	
	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 mediump_uint8;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 mediump_uint16;

	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 mediump_uint32;

	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 mediump_uint64;

	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 mediump_uint8_t;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 mediump_uint16_t;

	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 mediump_uint32_t;

	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 mediump_uint64_t;

	/// Medium precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 mediump_u8;
	
	/// Medium precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 mediump_u16;

	/// Medium precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 mediump_u32;

	/// Medium precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 mediump_u64;
	
	/// High precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 highp_uint8;
	
	/// High precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 highp_uint16;

	/// High precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 highp_uint32;

	/// High precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 highp_uint64;

	/// High precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 highp_uint8_t;
	
	/// High precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 highp_uint16_t;

	/// High precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 highp_uint32_t;

	/// High precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 highp_uint64_t;

	/// High precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 highp_u8;
	
	/// High precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 highp_u16;

	/// High precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 highp_u32;

	/// High precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 highp_u64;

	/// Default precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 uint8;
	
	/// Default precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 uint16;

	/// Default precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 uint32;

	/// Default precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 uint64;






      
	/// Default precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 uint8_t;
	
	/// Default precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 uint16_t;

	/// Default precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 uint32_t;

	/// Default precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 uint64_t;


	/// Default precision 8 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint8 u8;
	
	/// Default precision 16 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint16 u16;

	/// Default precision 32 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint32 u32;

	/// Default precision 64 bit unsigned integer type.
	/// @see gtc_type_precision
	typedef detail::uint64 u64;



	/// Default precision 8 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u8, defaultp> u8vec1;
	
	/// Default precision 8 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u8, defaultp> u8vec2;

	/// Default precision 8 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u8, defaultp> u8vec3;

	/// Default precision 8 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u8, defaultp> u8vec4;


	/// Default precision 16 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u16, defaultp> u16vec1;
	
	/// Default precision 16 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u16, defaultp> u16vec2;

	/// Default precision 16 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u16, defaultp> u16vec3;

	/// Default precision 16 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u16, defaultp> u16vec4;


	/// Default precision 32 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u32, defaultp> u32vec1;
	
	/// Default precision 32 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u32, defaultp> u32vec2;

	/// Default precision 32 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u32, defaultp> u32vec3;

	/// Default precision 32 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u32, defaultp> u32vec4;


	/// Default precision 64 bit unsigned integer scalar type.
	/// @see gtc_type_precision
	typedef tvec1<u64, defaultp> u64vec1;
	
	/// Default precision 64 bit unsigned integer vector of 2 components type.
	/// @see gtc_type_precision
	typedef tvec2<u64, defaultp> u64vec2;

	/// Default precision 64 bit unsigned integer vector of 3 components type.
	/// @see gtc_type_precision
	typedef tvec3<u64, defaultp> u64vec3;

	/// Default precision 64 bit unsigned integer vector of 4 components type.
	/// @see gtc_type_precision
	typedef tvec4<u64, defaultp> u64vec4;


	//////////////////////
	// Float vector types

	/// 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 float32;

	/// 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 float64;


	/// 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float32 float32_t;

	/// 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef detail::float64 float64_t;


	/// 32 bit single-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float32 f32;

	/// 64 bit double-precision floating-point scalar.
	/// @see gtc_type_precision
	typedef float64 f64;


	/// Single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<float, defaultp> fvec1;

	/// Single-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<float, defaultp> fvec2;

	/// Single-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<float, defaultp> fvec3;

	/// Single-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<float, defaultp> fvec4;

	
	/// Single-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f32, defaultp> f32vec1;

	/// Single-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<f32, defaultp> f32vec2;

	/// Single-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<f32, defaultp> f32vec3;

	/// Single-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<f32, defaultp> f32vec4;


	/// Double-precision floating-point vector of 1 component.
	/// @see gtc_type_precision
	typedef tvec1<f64, defaultp> f64vec1;

	/// Double-precision floating-point vector of 2 components.
	/// @see gtc_type_precision
	typedef tvec2<f64, defaultp> f64vec2;

	/// Double-precision floating-point vector of 3 components.
	/// @see gtc_type_precision
	typedef tvec3<f64, defaultp> f64vec3;

	/// Double-precision floating-point vector of 4 components.
	/// @see gtc_type_precision
	typedef tvec4<f64, defaultp> f64vec4;


	//////////////////////
	// Float matrix types 

	/// Single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef detail::tmat1x1<f32> fmat1;

	/// Single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, defaultp> fmat2;

	/// Single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, defaultp> fmat3;

	/// Single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, defaultp> fmat4;


	/// Single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f32 fmat1x1;

	/// Single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, defaultp> fmat2x2;

	/// Single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, defaultp> fmat2x3;

	/// Single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, defaultp> fmat2x4;

	/// Single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, defaultp> fmat3x2;

	/// Single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, defaultp> fmat3x3;

	/// Single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, defaultp> fmat3x4;

	/// Single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, defaultp> fmat4x2;

	/// Single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, defaultp> fmat4x3;

	/// Single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, defaultp> fmat4x4;


	/// Single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef detail::tmat1x1<f32, defaultp> f32mat1;

	/// Single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, defaultp> f32mat2;

	/// Single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, defaultp> f32mat3;

	/// Single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, defaultp> f32mat4;


	/// Single-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f32 f32mat1x1;

	/// Single-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f32, defaultp> f32mat2x2;

	/// Single-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f32, defaultp> f32mat2x3;

	/// Single-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f32, defaultp> f32mat2x4;

	/// Single-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f32, defaultp> f32mat3x2;

	/// Single-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f32, defaultp> f32mat3x3;

	/// Single-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f32, defaultp> f32mat3x4;

	/// Single-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f32, defaultp> f32mat4x2;

	/// Single-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f32, defaultp> f32mat4x3;

	/// Single-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f32, defaultp> f32mat4x4;


	/// Double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef detail::tmat1x1<f64, defaultp> f64mat1;

	/// Double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f64, defaultp> f64mat2;

	/// Double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f64, defaultp> f64mat3;

	/// Double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f64, defaultp> f64mat4;


	/// Double-precision floating-point 1x1 matrix.
	/// @see gtc_type_precision
	//typedef f64 f64mat1x1;

	/// Double-precision floating-point 2x2 matrix.
	/// @see gtc_type_precision
	typedef tmat2x2<f64, defaultp> f64mat2x2;

	/// Double-precision floating-point 2x3 matrix.
	/// @see gtc_type_precision
	typedef tmat2x3<f64, defaultp> f64mat2x3;

	/// Double-precision floating-point 2x4 matrix.
	/// @see gtc_type_precision
	typedef tmat2x4<f64, defaultp> f64mat2x4;

	/// Double-precision floating-point 3x2 matrix.
	/// @see gtc_type_precision
	typedef tmat3x2<f64, defaultp> f64mat3x2;

	/// Double-precision floating-point 3x3 matrix.
	/// @see gtc_type_precision
	typedef tmat3x3<f64, defaultp> f64mat3x3;

	/// Double-precision floating-point 3x4 matrix.
	/// @see gtc_type_precision
	typedef tmat3x4<f64, defaultp> f64mat3x4;

	/// Double-precision floating-point 4x2 matrix.
	/// @see gtc_type_precision
	typedef tmat4x2<f64, defaultp> f64mat4x2;

	/// Double-precision floating-point 4x3 matrix.
	/// @see gtc_type_precision
	typedef tmat4x3<f64, defaultp> f64mat4x3;

	/// Double-precision floating-point 4x4 matrix.
	/// @see gtc_type_precision
	typedef tmat4x4<f64, defaultp> f64mat4x4;


	//////////////////////////
	// Quaternion types

	/// Single-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f32, defaultp> f32quat;

	/// Double-precision floating-point quaternion.
	/// @see gtc_type_precision
	typedef tquat<f64, defaultp> f64quat;

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/type_precision.inl" 1 3
/// @ref gtc_swizzle
/// @file glm/gtc/swizzle.inl

namespace glm
{

}

# 861 "/usr/local/include/glm/gtc/type_precision.hpp" 2 3


# 17 "/usr/local/include/glm/./gtc/packing.hpp" 2 3




       

namespace glm
{
	/// @addtogroup gtc_packing
	/// @{

	/// First, converts the normalized floating-point value v into a 8-bit integer value.
	/// Then, the results are packed into the returned 8-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packUnorm1x8:	round(clamp(c, 0, +1) * 255.0)
	///
	/// @see gtc_packing
	/// @see uint16 packUnorm2x8(vec2 __const & v)
	/// @see uint32 packUnorm4x8(vec4 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm4x8.xml">GLSL packUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint8 packUnorm1x8(float v);

	/// Convert a single 8-bit integer to a normalized floating-point value.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackUnorm4x8: f / 255.0
	/// 
	/// @see gtc_packing
	/// @see vec2 unpackUnorm2x8(uint16 p)
	/// @see vec4 unpackUnorm4x8(uint32 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm4x8.xml">GLSL unpackUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 float unpackUnorm1x8(uint8 p);

	/// First, converts each component of the normalized floating-point value v into 8-bit integer values.
	/// Then, the results are packed into the returned 16-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packUnorm2x8:	round(clamp(c, 0, +1) * 255.0)
	///
	/// The first component of the vector will be written to the least significant bits of the output;
	/// the last component will be written to the most significant bits.
	///
	/// @see gtc_packing
	/// @see uint8 packUnorm1x8(float __const & v)
	/// @see uint32 packUnorm4x8(vec4 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm4x8.xml">GLSL packUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint16 packUnorm2x8(vec2 __const & v);

	/// First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit unsigned integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned two-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackUnorm4x8: f / 255.0
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see float unpackUnorm1x8(uint8 v)
	/// @see vec4 unpackUnorm4x8(uint32 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm4x8.xml">GLSL unpackUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec2 unpackUnorm2x8(uint16 p);
	
	/// First, converts the normalized floating-point value v into 8-bit integer value.
	/// Then, the results are packed into the returned 8-bit unsigned integer.
	///
	/// The conversion to fixed point is done as follows:
	/// packSnorm1x8:	round(clamp(s, -1, +1) * 127.0)
	///
	/// @see gtc_packing
	/// @see uint16 packSnorm2x8(vec2 __const & v)
	/// @see uint32 packSnorm4x8(vec4 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm4x8.xml">GLSL packSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint8 packSnorm1x8(float s);

	/// First, unpacks a single 8-bit unsigned integer p into a single 8-bit __signed integers. 
	/// Then, the value is converted to a normalized floating-point value to generate the returned scalar.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm1x8: clamp(f / 127.0, -1, +1)
	/// 
	/// @see gtc_packing
	/// @see vec2 unpackSnorm2x8(uint16 p)
	/// @see vec4 unpackSnorm4x8(uint32 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm4x8.xml">GLSL unpackSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 float unpackSnorm1x8(uint8 p);
	
	/// First, converts each component of the normalized floating-point value v into 8-bit integer values.
	/// Then, the results are packed into the returned 16-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packSnorm2x8:	round(clamp(c, -1, +1) * 127.0)
	///
	/// The first component of the vector will be written to the least significant bits of the output;
	/// the last component will be written to the most significant bits.
	///
	/// @see gtc_packing
	/// @see uint8 packSnorm1x8(float __const & v)
	/// @see uint32 packSnorm4x8(vec4 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm4x8.xml">GLSL packSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint16 packSnorm2x8(vec2 __const & v);

	/// First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned two-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm2x8: clamp(f / 127.0, -1, +1)
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see float unpackSnorm1x8(uint8 p)
	/// @see vec4 unpackSnorm4x8(uint32 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm4x8.xml">GLSL unpackSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec2 unpackSnorm2x8(uint16 p);
	
	/// First, converts the normalized floating-point value v into a 16-bit integer value.
	/// Then, the results are packed into the returned 16-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packUnorm1x16:	round(clamp(c, 0, +1) * 65535.0)
	///
	/// @see gtc_packing
	/// @see uint16 packSnorm1x16(float __const & v)
	/// @see uint64 packSnorm4x16(vec4 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm4x8.xml">GLSL packUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint16 packUnorm1x16(float v);

	/// First, unpacks a single 16-bit unsigned integer p into a of 16-bit unsigned integers. 
	/// Then, the value is converted to a normalized floating-point value to generate the returned scalar.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackUnorm1x16: f / 65535.0 
	/// 
	/// @see gtc_packing
	/// @see vec2 unpackUnorm2x16(uint32 p)
	/// @see vec4 unpackUnorm4x16(uint64 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm2x16.xml">GLSL unpackUnorm2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 float unpackUnorm1x16(uint16 p);

	/// First, converts each component of the normalized floating-point value v into 16-bit integer values.
	/// Then, the results are packed into the returned 64-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packUnorm4x16:	round(clamp(c, 0, +1) * 65535.0)
	///
	/// The first component of the vector will be written to the least significant bits of the output;
	/// the last component will be written to the most significant bits.
	///
	/// @see gtc_packing
	/// @see uint16 packUnorm1x16(float __const & v)
	/// @see uint32 packUnorm2x16(vec2 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packUnorm4x8.xml">GLSL packUnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint64 packUnorm4x16(vec4 __const & v);

	/// First, unpacks a single 64-bit unsigned integer p into four 16-bit unsigned integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackUnormx4x16: f / 65535.0 
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see float unpackUnorm1x16(uint16 p)
	/// @see vec2 unpackUnorm2x16(uint32 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackUnorm2x16.xml">GLSL unpackUnorm2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec4 unpackUnorm4x16(uint64 p);

	/// First, converts the normalized floating-point value v into 16-bit integer value.
	/// Then, the results are packed into the returned 16-bit unsigned integer.
	///
	/// The conversion to fixed point is done as follows:
	/// packSnorm1x8:	round(clamp(s, -1, +1) * 32767.0)
	///
	/// @see gtc_packing
	/// @see uint32 packSnorm2x16(vec2 __const & v)
	/// @see uint64 packSnorm4x16(vec4 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm4x8.xml">GLSL packSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint16 packSnorm1x16(float v);

	/// First, unpacks a single 16-bit unsigned integer p into a single 16-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned scalar.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm1x16: clamp(f / 32767.0, -1, +1)
	/// 
	/// @see gtc_packing
	/// @see vec2 unpackSnorm2x16(uint32 p)
	/// @see vec4 unpackSnorm4x16(uint64 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm1x16.xml">GLSL unpackSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 float unpackSnorm1x16(uint16 p);

	/// First, converts each component of the normalized floating-point value v into 16-bit integer values.
	/// Then, the results are packed into the returned 64-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packSnorm2x8:	round(clamp(c, -1, +1) * 32767.0)
	///
	/// The first component of the vector will be written to the least significant bits of the output;
	/// the last component will be written to the most significant bits.
	///
	/// @see gtc_packing
	/// @see uint16 packSnorm1x16(float __const & v)
	/// @see uint32 packSnorm2x16(vec2 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packSnorm4x8.xml">GLSL packSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint64 packSnorm4x16(vec4 __const & v);

	/// First, unpacks a single 64-bit unsigned integer p into four 16-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm4x16: clamp(f / 32767.0, -1, +1)
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see float unpackSnorm1x16(uint16 p)
	/// @see vec2 unpackSnorm2x16(uint32 p)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackSnorm2x16.xml">GLSL unpackSnorm4x8 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec4 unpackSnorm4x16(uint64 p);
	
	/// Returns an unsigned integer obtained by converting the components of a floating-point scalar
	/// to the 16-bit floating-point representation found in the OpenGL Specification,
	/// and then packing this 16-bit value into a 16-bit unsigned integer.
	///
	/// @see gtc_packing
	/// @see uint32 packHalf2x16(vec2 __const & v)
	/// @see uint64 packHalf4x16(vec4 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packHalf2x16.xml">GLSL packHalf2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint16 packHalf1x16(float v);
	
	/// Returns a floating-point scalar with components obtained by unpacking a 16-bit unsigned integer into a 16-bit value,
	/// interpreted as a 16-bit floating-point number according to the OpenGL Specification,
	/// and converting it to 32-bit floating-point values.
	///
	/// @see gtc_packing
	/// @see vec2 unpackHalf2x16(uint32 __const & v)
	/// @see vec4 unpackHalf4x16(uint64 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackHalf2x16.xml">GLSL unpackHalf2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 float unpackHalf1x16(uint16 v);

	/// Returns an unsigned integer obtained by converting the components of a four-component floating-point vector 
	/// to the 16-bit floating-point representation found in the OpenGL Specification, 
	/// and then packing these four 16-bit values into a 64-bit unsigned integer.
	/// The first vector component specifies the 16 least-significant bits of the result; 
	/// the forth component specifies the 16 most-significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint16 packHalf1x16(float __const & v)
	/// @see uint32 packHalf2x16(vec2 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/packHalf2x16.xml">GLSL packHalf2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 uint64 packHalf4x16(vec4 __const & v);
	
	/// Returns a four-component floating-point vector with components obtained by unpacking a 64-bit unsigned integer into four 16-bit values,
	/// interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, 
	/// and converting them to 32-bit floating-point values.
	/// The first component of the vector is obtained from the 16 least-significant bits of v; 
	/// the forth component is obtained from the 16 most-significant bits of v.
	/// 
	/// @see gtc_packing
	/// @see float unpackHalf1x16(uint16 __const & v)
	/// @see vec2 unpackHalf2x16(uint32 __const & v)
	/// @see <a href="http://www.opengl.org/sdk/docs/manglsl/xhtml/unpackHalf2x16.xml">GLSL unpackHalf2x16 man page</a>
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	 vec4 unpackHalf4x16(uint64 p);

	/// Returns an unsigned integer obtained by converting the components of a four-component __signed integer vector 
	/// to the 10-10-10-2-bit __signed integer representation found in the OpenGL Specification, 
	/// and then packing these four values into a 32-bit unsigned integer.
	/// The first vector component specifies the 10 least-significant bits of the result; 
	/// the forth component specifies the 2 most-significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packI3x10_1x2(uvec4 __const & v)
	/// @see uint32 packSnorm3x10_1x2(vec4 __const & v)
	/// @see uint32 packUnorm3x10_1x2(vec4 __const & v)
	/// @see ivec4 unpackI3x10_1x2(uint32 __const & p)
	 uint32 packI3x10_1x2(ivec4 __const & v);

	/// Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit __signed integers. 
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packU3x10_1x2(uvec4 __const & v)
	/// @see vec4 unpackSnorm3x10_1x2(uint32 __const & p);
	/// @see uvec4 unpackI3x10_1x2(uint32 __const & p);
	 ivec4 unpackI3x10_1x2(uint32 p);

	/// Returns an unsigned integer obtained by converting the components of a four-component unsigned integer vector 
	/// to the 10-10-10-2-bit unsigned integer representation found in the OpenGL Specification, 
	/// and then packing these four values into a 32-bit unsigned integer.
	/// The first vector component specifies the 10 least-significant bits of the result; 
	/// the forth component specifies the 2 most-significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packI3x10_1x2(ivec4 __const & v)
	/// @see uint32 packSnorm3x10_1x2(vec4 __const & v)
	/// @see uint32 packUnorm3x10_1x2(vec4 __const & v)
	/// @see ivec4 unpackU3x10_1x2(uint32 __const & p)
	 uint32 packU3x10_1x2(uvec4 __const & v);

	/// Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit unsigned integers. 
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packU3x10_1x2(uvec4 __const & v)
	/// @see vec4 unpackSnorm3x10_1x2(uint32 __const & p);
	/// @see uvec4 unpackI3x10_1x2(uint32 __const & p);
	 uvec4 unpackU3x10_1x2(uint32 p);

	/// First, converts the first three components of the normalized floating-point value v into 10-bit __signed integer values.
	/// Then, converts the forth component of the normalized floating-point value v into 2-bit __signed integer values.
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packSnorm3x10_1x2(xyz):	round(clamp(c, -1, +1) * 511.0)
	/// packSnorm3x10_1x2(w):	round(clamp(c, -1, +1) * 1.0)
	///
	/// The first vector component specifies the 10 least-significant bits of the result; 
	/// the forth component specifies the 2 most-significant bits.
	///
	/// @see gtc_packing
	/// @see vec4 unpackSnorm3x10_1x2(uint32 __const & p)
	/// @see uint32 packUnorm3x10_1x2(vec4 __const & v)
	/// @see uint32 packU3x10_1x2(uvec4 __const & v)
	/// @see uint32 packI3x10_1x2(ivec4 __const & v)
	 uint32 packSnorm3x10_1x2(vec4 __const & v);

	/// First, unpacks a single 32-bit unsigned integer p into four 16-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm3x10_1x2(xyz): clamp(f / 511.0, -1, +1)
	/// unpackSnorm3x10_1x2(w): clamp(f / 511.0, -1, +1)
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packSnorm3x10_1x2(vec4 __const & v)
	/// @see vec4 unpackUnorm3x10_1x2(uint32 __const & p))
	/// @see uvec4 unpackI3x10_1x2(uint32 __const & p)
	/// @see uvec4 unpackU3x10_1x2(uint32 __const & p)
	 vec4 unpackSnorm3x10_1x2(uint32 p);

	/// First, converts the first three components of the normalized floating-point value v into 10-bit unsigned integer values.
	/// Then, converts the forth component of the normalized floating-point value v into 2-bit __signed uninteger values.
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	///
	/// The conversion for component c of v to fixed point is done as follows:
	/// packUnorm3x10_1x2(xyz):	round(clamp(c, 0, +1) * 1023.0)
	/// packUnorm3x10_1x2(w):	round(clamp(c, 0, +1) * 3.0)
	///
	/// The first vector component specifies the 10 least-significant bits of the result; 
	/// the forth component specifies the 2 most-significant bits.
	///
	/// @see gtc_packing
	/// @see vec4 unpackUnorm3x10_1x2(uint32 __const & p)
	/// @see uint32 packUnorm3x10_1x2(vec4 __const & v)
	/// @see uint32 packU3x10_1x2(uvec4 __const & v)
	/// @see uint32 packI3x10_1x2(ivec4 __const & v)
	 uint32 packUnorm3x10_1x2(vec4 __const & v);

	/// First, unpacks a single 32-bit unsigned integer p into four 16-bit __signed integers. 
	/// Then, each component is converted to a normalized floating-point value to generate the returned four-component vector.
	/// 
	/// The conversion for unpacked fixed-point value f to floating point is done as follows:
	/// unpackSnorm3x10_1x2(xyz): clamp(f / 1023.0, 0, +1)
	/// unpackSnorm3x10_1x2(w): clamp(f / 3.0, 0, +1)
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packSnorm3x10_1x2(vec4 __const & v)
	/// @see vec4 unpackInorm3x10_1x2(uint32 __const & p))
	/// @see uvec4 unpackI3x10_1x2(uint32 __const & p)
	/// @see uvec4 unpackU3x10_1x2(uint32 __const & p)
	 vec4 unpackUnorm3x10_1x2(uint32 p);

	/// First, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values.
	/// Then, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value.
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	///
	/// The first vector component specifies the 11 least-significant bits of the result; 
	/// the last component specifies the 10 most-significant bits.
	///
	/// @see gtc_packing
	/// @see vec3 unpackF2x11_1x10(uint32 __const & p)
	 uint32 packF2x11_1x10(vec3 __const & v);

	/// First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value . 
	/// Then, each component is converted to a normalized floating-point value to generate the returned three-component vector.
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packF2x11_1x10(vec3 __const & v)
	 vec3 unpackF2x11_1x10(uint32 p);


	/// First, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values.
	/// Then, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value.
	/// Then, the results are packed into the returned 32-bit unsigned integer.
	///
	/// The first vector component specifies the 11 least-significant bits of the result; 
	/// the last component specifies the 10 most-significant bits.
	///
	/// @see gtc_packing
	/// @see vec3 unpackF3x9_E1x5(uint32 __const & p)
	 uint32 packF3x9_E1x5(vec3 __const & v);

	/// First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value . 
	/// Then, each component is converted to a normalized floating-point value to generate the returned three-component vector.
	/// 
	/// The first component of the returned vector will be extracted from the least significant bits of the input; 
	/// the last component will be extracted from the most significant bits.
	/// 
	/// @see gtc_packing
	/// @see uint32 packF3x9_E1x5(vec3 __const & v)
	 vec3 unpackF3x9_E1x5(uint32 p);

	/// Returns an unsigned integer vector obtained by converting the components of a floating-point vector
	/// to the 16-bit floating-point representation found in the OpenGL Specification.
	/// The first vector component specifies the 16 least-significant bits of the result; 
	/// the forth component specifies the 16 most-significant bits.
	/// 
	/// @see gtc_packing
	/// @see vecType<float, P> unpackHalf(vecType<uint16, P> __const & p)
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 vecType<uint16, P> packHalf(vecType<float, P> __const & v);

	/// Returns a floating-point vector with components obtained by reinterpreting an integer vector as 16-bit floating-point numbers and converting them to 32-bit floating-point values.
	/// The first component of the vector is obtained from the 16 least-significant bits of v;
	/// the forth component is obtained from the 16 most-significant bits of v.
	/// 
	/// @see gtc_packing
	/// @see vecType<uint16, P> packHalf(vecType<float, P> __const & v)
	/// @see <a href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf">GLSL 4.20.8 specification, section 8.4 Floating-Point Pack and Unpack Functions</a>
	template <precision P, template <typename, precision> class vecType>
	 vecType<float, P> unpackHalf(vecType<uint16, P> __const & p);

	/// Convert each component of the normalized floating-point vector into unsigned integer values.
	///
	/// @see gtc_packing
	/// @see vecType<floatType, P> unpackUnorm(vecType<intType, P> __const & p);
	template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
	 vecType<uintType, P> packUnorm(vecType<floatType, P> __const & v);

	/// Convert each unsigned integer components of a vector to normalized floating-point values.
	/// 
	/// @see gtc_packing
	/// @see vecType<intType, P> packUnorm(vecType<floatType, P> __const & v)
	template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
	 vecType<floatType, P> unpackUnorm(vecType<uintType, P> __const & v);

	/// Convert each component of the normalized floating-point vector into __signed integer values.
	///
	/// @see gtc_packing
	/// @see vecType<floatType, P> unpackSnorm(vecType<intType, P> __const & p);
	template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
	 vecType<intType, P> packSnorm(vecType<floatType, P> __const & v);

	/// Convert each __signed integer components of a vector to normalized floating-point values.
	/// 
	/// @see gtc_packing
	/// @see vecType<intType, P> packSnorm(vecType<floatType, P> __const & v)
	template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
	 vecType<floatType, P> unpackSnorm(vecType<intType, P> __const & v);

	/// Convert each component of the normalized floating-point vector into unsigned integer values.
	///
	/// @see gtc_packing
	/// @see vec2 unpackUnorm2x4(uint8 p)
	 uint8 packUnorm2x4(vec2 __const & v);

	/// Convert each unsigned integer components of a vector to normalized floating-point values.
	/// 
	/// @see gtc_packing
	/// @see uint8 packUnorm2x4(vec2 __const & v)
	 vec2 unpackUnorm2x4(uint8 p);

	/// Convert each component of the normalized floating-point vector into unsigned integer values.
	///
	/// @see gtc_packing
	/// @see vec4 unpackUnorm4x4(uint16 p)
	 uint16 packUnorm4x4(vec4 __const & v);

	/// Convert each unsigned integer components of a vector to normalized floating-point values.
	/// 
	/// @see gtc_packing
	/// @see uint16 packUnorm4x4(vec4 __const & v)
	 vec4 unpackUnorm4x4(uint16 p);

	/// Convert each component of the normalized floating-point vector into unsigned integer values.
	///
	/// @see gtc_packing
	/// @see vec3 unpackUnorm1x5_1x6_1x5(uint16 p)
	 uint16 packUnorm1x5_1x6_1x5(vec3 __const & v);

	/// Convert each unsigned integer components of a vector to normalized floating-point values.
	/// 
	/// @see gtc_packing
	/// @see uint16 packUnorm1x5_1x6_1x5(vec3 __const & v)
	 vec3 unpackUnorm1x5_1x6_1x5(uint16 p);

	/// Convert each component of the normalized floating-point vector into unsigned integer values.
	///
	/// @see gtc_packing
	/// @see vec4 unpackUnorm3x5_1x1(uint16 p)
	 uint16 packUnorm3x5_1x1(vec4 __const & v);

	/// Convert each unsigned integer components of a vector to normalized floating-point values.
	/// 
	/// @see gtc_packing
	/// @see uint16 packUnorm3x5_1x1(vec4 __const & v)
	 vec4 unpackUnorm3x5_1x1(uint16 p);

	/// Convert each component of the normalized floating-point vector into unsigned integer values.
	///
	/// @see gtc_packing
	/// @see vec3 unpackUnorm2x3_1x2(uint8 p)
	 uint8 packUnorm2x3_1x2(vec3 __const & v);

	/// Convert each unsigned integer components of a vector to normalized floating-point values.
	/// 
	/// @see gtc_packing
	/// @see uint8 packUnorm2x3_1x2(vec3 __const & v)
	 vec3 unpackUnorm2x3_1x2(uint8 p);
	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/gtc/packing.inl" 1 3
/// @ref gtc_packing
/// @file glm/gtc/packing.inl









namespace glm{
namespace detail
{
	 __inline glm::uint16 float2half(glm::uint32 f)
	{
		// 10 bits    =>                         EE EEEFFFFF
		// 11 bits    =>                        EEE EEFFFFFF
		// Half bits  =>                   SEEEEEFF FFFFFFFF
		// Float bits => SEEEEEEE EFFFFFFF FFFFFFFF FFFFFFFF

		// 0x00007c00 => 00000000 00000000 01111100 00000000
		// 0x000003ff => 00000000 00000000 00000011 11111111
		// 0x38000000 => 00111000 00000000 00000000 00000000
		// 0x7f800000 => 01111111 10000000 00000000 00000000
		// 0x00008000 => 00000000 00000000 10000000 00000000
		return
			((f >> 16) & 0x8000) | // sign
			((((f & 0x7f800000) - 0x38000000) >> 13) & 0x7c00) | // exponential
			((f >> 13) & 0x03ff); // Mantissa
	}

	 __inline glm::uint32 float2packed11(glm::uint32 f)
	{
		// 10 bits    =>                         EE EEEFFFFF
		// 11 bits    =>                        EEE EEFFFFFF
		// Half bits  =>                   SEEEEEFF FFFFFFFF
		// Float bits => SEEEEEEE EFFFFFFF FFFFFFFF FFFFFFFF

		// 0x000007c0 => 00000000 00000000 00000111 11000000
		// 0x00007c00 => 00000000 00000000 01111100 00000000
		// 0x000003ff => 00000000 00000000 00000011 11111111
		// 0x38000000 => 00111000 00000000 00000000 00000000
		// 0x7f800000 => 01111111 10000000 00000000 00000000
		// 0x00008000 => 00000000 00000000 10000000 00000000
		return
			((((f & 0x7f800000) - 0x38000000) >> 17) & 0x07c0) | // exponential
			((f >> 17) & 0x003f); // Mantissa
	}

	 __inline glm::uint32 packed11ToFloat(glm::uint32 p)
	{
		// 10 bits    =>                         EE EEEFFFFF
		// 11 bits    =>                        EEE EEFFFFFF
		// Half bits  =>                   SEEEEEFF FFFFFFFF
		// Float bits => SEEEEEEE EFFFFFFF FFFFFFFF FFFFFFFF

		// 0x000007c0 => 00000000 00000000 00000111 11000000
		// 0x00007c00 => 00000000 00000000 01111100 00000000
		// 0x000003ff => 00000000 00000000 00000011 11111111
		// 0x38000000 => 00111000 00000000 00000000 00000000
		// 0x7f800000 => 01111111 10000000 00000000 00000000
		// 0x00008000 => 00000000 00000000 10000000 00000000
		return
			((((p & 0x07c0) << 17) + 0x38000000) & 0x7f800000) | // exponential
			((p & 0x003f) << 17); // Mantissa
	}

	 __inline glm::uint32 float2packed10(glm::uint32 f)
	{
		// 10 bits    =>                         EE EEEFFFFF
		// 11 bits    =>                        EEE EEFFFFFF
		// Half bits  =>                   SEEEEEFF FFFFFFFF
		// Float bits => SEEEEEEE EFFFFFFF FFFFFFFF FFFFFFFF

		// 0x0000001F => 00000000 00000000 00000000 00011111
		// 0x0000003F => 00000000 00000000 00000000 00111111
		// 0x000003E0 => 00000000 00000000 00000011 11100000
		// 0x000007C0 => 00000000 00000000 00000111 11000000
		// 0x00007C00 => 00000000 00000000 01111100 00000000
		// 0x000003FF => 00000000 00000000 00000011 11111111
		// 0x38000000 => 00111000 00000000 00000000 00000000
		// 0x7f800000 => 01111111 10000000 00000000 00000000
		// 0x00008000 => 00000000 00000000 10000000 00000000
		return
			((((f & 0x7f800000) - 0x38000000) >> 18) & 0x03E0) | // exponential
			((f >> 18) & 0x001f); // Mantissa
	}

	 __inline glm::uint32 packed10ToFloat(glm::uint32 p)
	{
		// 10 bits    =>                         EE EEEFFFFF
		// 11 bits    =>                        EEE EEFFFFFF
		// Half bits  =>                   SEEEEEFF FFFFFFFF
		// Float bits => SEEEEEEE EFFFFFFF FFFFFFFF FFFFFFFF

		// 0x0000001F => 00000000 00000000 00000000 00011111
		// 0x0000003F => 00000000 00000000 00000000 00111111
		// 0x000003E0 => 00000000 00000000 00000011 11100000
		// 0x000007C0 => 00000000 00000000 00000111 11000000
		// 0x00007C00 => 00000000 00000000 01111100 00000000
		// 0x000003FF => 00000000 00000000 00000011 11111111
		// 0x38000000 => 00111000 00000000 00000000 00000000
		// 0x7f800000 => 01111111 10000000 00000000 00000000
		// 0x00008000 => 00000000 00000000 10000000 00000000
		return
			((((p & 0x03E0) << 18) + 0x38000000) & 0x7f800000) | // exponential
			((p & 0x001f) << 18); // Mantissa
	}

	 __inline glm::uint half2float(glm::uint h)
	{
		return ((h & 0x8000) << 16) | ((( h & 0x7c00) + 0x1C000) << 13) | ((h & 0x03FF) << 13);
	}

	 __inline glm::uint floatTo11bit(float x)
	{
		if(x == 0.0f)
			return 0u;
		else if(glm::isnan(x))
			return ~0u;
		else if(glm::isinf(x))
			return 0x1Fu << 6u;

		uint Pack = 0u;
		memcpy(&Pack, &x, sizeof(Pack));
		return float2packed11(Pack);
	}

	 __inline float packed11bitToFloat(glm::uint x)
	{
		if(x == 0)
			return 0.0f;
		else if(x == ((1 << 11) - 1))
			return ~0;//NaN
		else if(x == (0x1f << 6))
			return ~0;//Inf

		uint Result = packed11ToFloat(x);

		float Temp = 0;
		memcpy(&Temp, &Result, sizeof(Temp));
		return Temp;
	}

	 __inline glm::uint floatTo10bit(float x)
	{
		if(x == 0.0f)
			return 0u;
		else if(glm::isnan(x))
			return ~0u;
		else if(glm::isinf(x))
			return 0x1Fu << 5u;

		uint Pack = 0;
		memcpy(&Pack, &x, sizeof(Pack));
		return float2packed10(Pack);
	}

	 __inline float packed10bitToFloat(glm::uint x)
	{
		if(x == 0)
			return 0.0f;
		else if(x == ((1 << 10) - 1))
			return ~0;//NaN
		else if(x == (0x1f << 5))
			return ~0;//Inf

		uint Result = packed10ToFloat(x);

		float Temp = 0;
		memcpy(&Temp, &Result, sizeof(Temp));
		return Temp;
	}

//	 __inline glm::uint f11_f11_f10(float x, float y, float z)
//	{
//		return ((floatTo11bit(x) & ((1 << 11) - 1)) << 0) |  ((floatTo11bit(y) & ((1 << 11) - 1)) << 11) | ((floatTo10bit(z) & ((1 << 10) - 1)) << 22);
//	}

	union u3u3u2
	{
		struct
		{
			uint x : 3;
			uint y : 3;
			uint z : 2;
		} data;
		uint8 pack;
	};

	union u4u4
	{
		struct
		{
			uint x : 4;
			uint y : 4;
		} data;
		uint8 pack;
	};

	union u4u4u4u4
	{
		struct
		{
			uint x : 4;
			uint y : 4;
			uint z : 4;
			uint w : 4;
		} data;
		uint16 pack;
	};

	union u5u6u5
	{
		struct
		{
			uint x : 5;
			uint y : 6;
			uint z : 5;
		} data;
		uint16 pack;
	};

	union u5u5u5u1
	{
		struct
		{
			uint x : 5;
			uint y : 5;
			uint z : 5;
			uint w : 1;
		} data;
		uint16 pack;
	};

	union u10u10u10u2
	{
		struct
		{
			uint x : 10;
			uint y : 10;
			uint z : 10;
			uint w : 2;
		} data;
		uint32 pack;
	};

	union i10i10i10i2
	{
		struct
		{
			int x : 10;
			int y : 10;
			int z : 10;
			int w : 2;
		} data;
		uint32 pack;
	};

	union u9u9u9e5
	{
		struct
		{
			uint x : 9;
			uint y : 9;
			uint z : 9;
			uint w : 5;
		} data;
		uint32 pack;
	};

	template <precision P, template <typename, precision> class vecType>
	struct compute_half
	{};

	template <precision P>
	struct compute_half<P, tvec1>
	{
		 __inline static tvec1<uint16, P> pack(tvec1<float, P> __const & v)
		{
			int16 __const Unpack(detail::toFloat16(v.x));
			u16vec1 Packed(uninitialize);
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		 __inline static tvec1<float, P> unpack(tvec1<uint16, P> __const & v)
		{
			i16vec1 Unpack(uninitialize);
			memcpy(&Unpack, &v, sizeof(Unpack));
			return tvec1<float, P>(detail::toFloat32(v.x));
		}
	};

	template <precision P>
	struct compute_half<P, tvec2>
	{
		 __inline static tvec2<uint16, P> pack(tvec2<float, P> __const & v)
		{
			tvec2<int16, P> __const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y));
			u16vec2 Packed(uninitialize);
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		 __inline static tvec2<float, P> unpack(tvec2<uint16, P> __const & v)
		{
			i16vec2 Unpack(uninitialize);
			memcpy(&Unpack, &v, sizeof(Unpack));
			return tvec2<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y));
		}
	};

	template <precision P>
	struct compute_half<P, tvec3>
	{
		 __inline static tvec3<uint16, P> pack(tvec3<float, P> __const & v)
		{
			tvec3<int16, P> __const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z));
			u16vec3 Packed(uninitialize);
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		 __inline static tvec3<float, P> unpack(tvec3<uint16, P> __const & v)
		{
			i16vec3 Unpack(uninitialize);
			memcpy(&Unpack, &v, sizeof(Unpack));
			return tvec3<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z));
		}
	};

	template <precision P>
	struct compute_half<P, tvec4>
	{
		 __inline static tvec4<uint16, P> pack(tvec4<float, P> __const & v)
		{
			tvec4<int16, P> __const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z), detail::toFloat16(v.w));
			u16vec4 Packed(uninitialize);
			memcpy(&Packed, &Unpack, sizeof(Packed));
			return Packed;
		}

		 __inline static tvec4<float, P> unpack(tvec4<uint16, P> __const & v)
		{
			i16vec4 Unpack(uninitialize);
			memcpy(&Unpack, &v, sizeof(Unpack));
			return tvec4<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z), detail::toFloat32(v.w));
		}
	};
}//namespace detail

	 __inline uint8 packUnorm1x8(float v)
	{
		return static_cast<uint8>(round(clamp(v, 0.0f, 1.0f) * 255.0f));
	}
	
	 __inline float unpackUnorm1x8(uint8 p)
	{
		float __const Unpack(p);
		return Unpack * static_cast<float>(0.0039215686274509803921568627451); // 1 / 255
	}
	
	 __inline uint16 packUnorm2x8(vec2 __const & v)
	{
		u8vec2 __const Topack(round(clamp(v, 0.0f, 1.0f) * 255.0f));

		uint16 Unpack = 0;
		memcpy(&Unpack, &Topack, sizeof(Unpack));
		return Unpack;
	}
	
	 __inline vec2 unpackUnorm2x8(uint16 p)
	{
		u8vec2 Unpack(uninitialize);
		memcpy(&Unpack, &p, sizeof(Unpack));
		return vec2(Unpack) * float(0.0039215686274509803921568627451); // 1 / 255
	}

	 __inline uint8 packSnorm1x8(float v)
	{
		int8 __const Topack(static_cast<int8>(round(clamp(v ,-1.0f, 1.0f) * 127.0f)));
		uint8 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}
	
	 __inline float unpackSnorm1x8(uint8 p)
	{
		int8 Unpack = 0;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			static_cast<float>(Unpack) * 0.00787401574803149606299212598425f, // 1.0f / 127.0f
			-1.0f, 1.0f);
	}
	
	 __inline uint16 packSnorm2x8(vec2 __const & v)
	{
		i8vec2 __const Topack(round(clamp(v, -1.0f, 1.0f) * 127.0f));
		uint16 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}
	
	 __inline vec2 unpackSnorm2x8(uint16 p)
	{
		i8vec2 Unpack(uninitialize);
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			vec2(Unpack) * 0.00787401574803149606299212598425f, // 1.0f / 127.0f
			-1.0f, 1.0f);
	}

	 __inline uint16 packUnorm1x16(float s)
	{
		return static_cast<uint16>(round(clamp(s, 0.0f, 1.0f) * 65535.0f));
	}

	 __inline float unpackUnorm1x16(uint16 p)
	{
		float __const Unpack(p);
		return Unpack * 1.5259021896696421759365224689097e-5f; // 1.0 / 65535.0
	}

	 __inline uint64 packUnorm4x16(vec4 __const & v)
	{
		u16vec4 __const Topack(round(clamp(v , 0.0f, 1.0f) * 65535.0f));
		uint64 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	 __inline vec4 unpackUnorm4x16(uint64 p)
	{
		u16vec4 Unpack(uninitialize);
		memcpy(&Unpack, &p, sizeof(Unpack));
		return vec4(Unpack) * 1.5259021896696421759365224689097e-5f; // 1.0 / 65535.0
	}

	 __inline uint16 packSnorm1x16(float v)
	{
		int16 __const Topack = static_cast<int16>(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
		uint16 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	 __inline float unpackSnorm1x16(uint16 p)
	{
		int16 Unpack = 0;
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			static_cast<float>(Unpack) * 3.0518509475997192297128208258309e-5f, //1.0f / 32767.0f, 
			-1.0f, 1.0f);
	}

	 __inline uint64 packSnorm4x16(vec4 __const & v)
	{
		i16vec4 __const Topack(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
		uint64 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	 __inline vec4 unpackSnorm4x16(uint64 p)
	{
		i16vec4 Unpack(uninitialize);
		memcpy(&Unpack, &p, sizeof(Unpack));
		return clamp(
			vec4(Unpack) * 3.0518509475997192297128208258309e-5f, //1.0f / 32767.0f,
			-1.0f, 1.0f);
	}

	 __inline uint16 packHalf1x16(float v)
	{
		int16 __const Topack(detail::toFloat16(v));
		uint16 Packed = 0;
		memcpy(&Packed, &Topack, sizeof(Packed));
		return Packed;
	}

	 __inline float unpackHalf1x16(uint16 v)
	{
		int16 Unpack = 0;
		memcpy(&Unpack, &v, sizeof(Unpack));
		return detail::toFloat32(Unpack);
	}

	 __inline uint64 packHalf4x16(glm::vec4 __const & v)
	{
		i16vec4 __const Unpack(
			detail::toFloat16(v.x),
			detail::toFloat16(v.y),
			detail::toFloat16(v.z),
			detail::toFloat16(v.w));
		uint64 Packed = 0;
		memcpy(&Packed, &Unpack, sizeof(Packed));
		return Packed;
	}

	 __inline glm::vec4 unpackHalf4x16(uint64 v)
	{
		i16vec4 Unpack(uninitialize);
		memcpy(&Unpack, &v, sizeof(Unpack));
		return vec4(
			detail::toFloat32(Unpack.x),
			detail::toFloat32(Unpack.y),
			detail::toFloat32(Unpack.z),
			detail::toFloat32(Unpack.w));
	}

	 __inline uint32 packI3x10_1x2(ivec4 __const & v)
	{
		detail::i10i10i10i2 Result;
		Result.data.x = v.x;
		Result.data.y = v.y;
		Result.data.z = v.z;
		Result.data.w = v.w;
		return Result.pack; 
	}

	 __inline ivec4 unpackI3x10_1x2(uint32 v)
	{
		detail::i10i10i10i2 Unpack;
		Unpack.pack = v;
		return ivec4(
			Unpack.data.x,
			Unpack.data.y,
			Unpack.data.z,
			Unpack.data.w);
	}

	 __inline uint32 packU3x10_1x2(uvec4 __const & v)
	{
		detail::u10u10u10u2 Result;
		Result.data.x = v.x;
		Result.data.y = v.y;
		Result.data.z = v.z;
		Result.data.w = v.w;
		return Result.pack; 
	}

	 __inline uvec4 unpackU3x10_1x2(uint32 v)
	{
		detail::u10u10u10u2 Unpack;
		Unpack.pack = v;
		return uvec4(
			Unpack.data.x,
			Unpack.data.y,
			Unpack.data.z,
			Unpack.data.w);
	}

	 __inline uint32 packSnorm3x10_1x2(vec4 __const & v)
	{
		detail::i10i10i10i2 Result;
		Result.data.x = int(round(clamp(v.x,-1.0f, 1.0f) * 511.f));
		Result.data.y = int(round(clamp(v.y,-1.0f, 1.0f) * 511.f));
		Result.data.z = int(round(clamp(v.z,-1.0f, 1.0f) * 511.f));
		Result.data.w = int(round(clamp(v.w,-1.0f, 1.0f) *   1.f));
		return Result.pack;
	}

	 __inline vec4 unpackSnorm3x10_1x2(uint32 v)
	{
		detail::i10i10i10i2 Unpack;
		Unpack.pack = v;
		vec4 Result;
		Result.x = clamp(float(Unpack.data.x) / 511.f, -1.0f, 1.0f);
		Result.y = clamp(float(Unpack.data.y) / 511.f, -1.0f, 1.0f);
		Result.z = clamp(float(Unpack.data.z) / 511.f, -1.0f, 1.0f);
		Result.w = clamp(float(Unpack.data.w) /   1.f, -1.0f, 1.0f);
		return Result;
	}

	 __inline uint32 packUnorm3x10_1x2(vec4 __const & v)
	{
		uvec4 __const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(1023.f, 1023.f, 1023.f, 3.f)));

		detail::u10u10u10u2 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		Result.data.w = Unpack.w;
		return Result.pack;
	}

	 __inline vec4 unpackUnorm3x10_1x2(uint32 v)
	{
		vec4 __const ScaleFactors(1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 3.f);

		detail::u10u10u10u2 Unpack;
		Unpack.pack = v;
		return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactors;
	}

	 __inline uint32 packF2x11_1x10(vec3 __const & v)
	{
		return
			((detail::floatTo11bit(v.x) & ((1 << 11) - 1)) <<  0) |
			((detail::floatTo11bit(v.y) & ((1 << 11) - 1)) << 11) |
			((detail::floatTo10bit(v.z) & ((1 << 10) - 1)) << 22);
	}

	 __inline vec3 unpackF2x11_1x10(uint32 v)
	{
		return vec3(
			detail::packed11bitToFloat(v >> 0),
			detail::packed11bitToFloat(v >> 11),
			detail::packed10bitToFloat(v >> 22));
	}

	 __inline uint32 packF3x9_E1x5(vec3 __const & v)
	{
		float __const SharedExpMax = (pow(2.0f, 9.0f - 1.0f) / pow(2.0f, 9.0f)) * pow(2.0f, 31.f - 15.f);
		vec3 __const Color = clamp(v, 0.0f, SharedExpMax);
		float __const MaxColor = max(Color.x, max(Color.y, Color.z));

		float __const ExpSharedP = max(-15.f - 1.f, floor(log2(MaxColor))) + 1.0f + 15.f;
		float __const MaxShared = floor(MaxColor / pow(2.0f, (ExpSharedP - 16.f - 9.f)) + 0.5f);
		float __const ExpShared = MaxShared == pow(2.0f, 9.0f) ? ExpSharedP + 1.0f : ExpSharedP;

		uvec3 __const ColorComp(floor(Color / pow(2.f, (ExpShared - 15.f - 9.f)) + 0.5f));

		detail::u9u9u9e5 Unpack;
		Unpack.data.x = ColorComp.x;
		Unpack.data.y = ColorComp.y;
		Unpack.data.z = ColorComp.z;
		Unpack.data.w = uint(ExpShared);
		return Unpack.pack;
	}

	 __inline vec3 unpackF3x9_E1x5(uint32 v)
	{
		detail::u9u9u9e5 Unpack;
		Unpack.pack = v;

		return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * pow(2.0f, Unpack.data.w - 15.f - 9.f);
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline vecType<uint16, P> packHalf(vecType<float, P> __const & v)
	{
		return detail::compute_half<P, vecType>::pack(v);
	}

	template <precision P, template <typename, precision> class vecType>
	 __inline vecType<float, P> unpackHalf(vecType<uint16, P> __const & v)
	{
		return detail::compute_half<P, vecType>::unpack(v);
	}

	template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
	 __inline vecType<uintType, P> packUnorm(vecType<floatType, P> __const & v)
	{
		;
		;

		return vecType<uintType, P>(round(clamp(v, static_cast<floatType>(0), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<uintType>::max())));
	}

	template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
	 __inline vecType<floatType, P> unpackUnorm(vecType<uintType, P> __const & v)
	{
		;
		;

		return vecType<float, P>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<uintType>::max()));
	}

	template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
	 __inline vecType<intType, P> packSnorm(vecType<floatType, P> __const & v)
	{
		;
		;

		return vecType<intType, P>(round(clamp(v , static_cast<floatType>(-1), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<intType>::max())));
	}

	template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
	 __inline vecType<floatType, P> unpackSnorm(vecType<intType, P> __const & v)
	{
		;
		;

		return clamp(vecType<floatType, P>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<intType>::max())), static_cast<floatType>(-1), static_cast<floatType>(1));
	}

	 __inline uint8 packUnorm2x4(vec2 __const & v)
	{
		u32vec2 __const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
		detail::u4u4 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		return Result.pack;
	}

	 __inline vec2 unpackUnorm2x4(uint8 v)
	{
		float __const ScaleFactor(1.f / 15.f);
		detail::u4u4 Unpack;
		Unpack.pack = v;
		return vec2(Unpack.data.x, Unpack.data.y) * ScaleFactor;
	}

	 __inline uint16 packUnorm4x4(vec4 __const & v)
	{
		u32vec4 __const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
		detail::u4u4u4u4 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		Result.data.w = Unpack.w;
		return Result.pack;
	}

	 __inline vec4 unpackUnorm4x4(uint16 v)
	{
		float __const ScaleFactor(1.f / 15.f);
		detail::u4u4u4u4 Unpack;
		Unpack.pack = v;
		return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
	}

	 __inline uint16 packUnorm1x5_1x6_1x5(vec3 __const & v)
	{
		u32vec3 __const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(31.f, 63.f, 31.f)));
		detail::u5u6u5 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		return Result.pack;
	}

	 __inline vec3 unpackUnorm1x5_1x6_1x5(uint16 v)
	{
		vec3 __const ScaleFactor(1.f / 31.f, 1.f / 63.f, 1.f / 31.f);
		detail::u5u6u5 Unpack;
		Unpack.pack = v;
		return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
	}

	 __inline uint16 packUnorm3x5_1x1(vec4 __const & v)
	{
		u32vec4 __const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(31.f, 31.f, 31.f, 1.f)));
		detail::u5u5u5u1 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		Result.data.w = Unpack.w;
		return Result.pack;
	}

	 __inline vec4 unpackUnorm3x5_1x1(uint16 v)
	{
		vec4 __const ScaleFactor(1.f / 31.f, 1.f / 31.f, 1.f / 31.f, 1.f);
		detail::u5u5u5u1 Unpack;
		Unpack.pack = v;
		return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
	}

	 __inline uint8 packUnorm2x3_1x2(vec3 __const & v)
	{
		u32vec3 __const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(7.f, 7.f, 3.f)));
		detail::u3u3u2 Result;
		Result.data.x = Unpack.x;
		Result.data.y = Unpack.y;
		Result.data.z = Unpack.z;
		return Result.pack;
	}

	 __inline vec3 unpackUnorm2x3_1x2(uint8 v)
	{
		vec3 __const ScaleFactor(1.f / 7.f, 1.f / 7.f, 1.f / 3.f);
		detail::u3u3u2 Unpack;
		Unpack.pack = v;
		return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
	}
}//namespace glm


# 579 "/usr/local/include/glm/./gtc/packing.hpp" 2 3


# 48 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtc/random.hpp" 1 3
/// @ref gtc_random
/// @file glm/gtc/random.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtx_random (extended)
///
/// @defgroup gtc_random GLM_GTC_random
/// @ingroup gtc
///
/// @brief Generate random number from various distribution methods.
///
/// <glm/gtc/random.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// @addtogroup gtc_random
	/// @{
	
	/// Generate random numbers in the interval [Min, Max], according a linear distribution 
	/// 
	/// @param Min 
	/// @param Max 
	/// @tparam genType Value type. Currently supported: float or double scalars.
	/// @see gtc_random
	template <typename genTYpe>
	 genTYpe linearRand(
		genTYpe Min,
		genTYpe Max);

	/// Generate random numbers in the interval [Min, Max], according a linear distribution 
	/// 
	/// @param Min 
	/// @param Max 
	/// @tparam T Value type. Currently supported: float or double.
	/// @tparam vecType A vertor type: tvec1, tvec2, tvec3, tvec4 or compatible
	/// @see gtc_random
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> linearRand(
		vecType<T, P> __const & Min,
		vecType<T, P> __const & Max);

	/// Generate random numbers in the interval [Min, Max], according a gaussian distribution 
	/// 
	/// @param Mean
	/// @param Deviation
	/// @see gtc_random
	template <typename genType>
	 genType gaussRand(
		genType Mean,
		genType Deviation);
	
	/// Generate a random 2D vector which coordinates are regulary distributed on a circle of a given radius
	/// 
	/// @param Radius 
	/// @see gtc_random
	template <typename T>
	 tvec2<T, defaultp> circularRand(
		T Radius);
	
	/// Generate a random 3D vector which coordinates are regulary distributed on a sphere of a given radius
	/// 
	/// @param Radius
	/// @see gtc_random
	template <typename T>
	 tvec3<T, defaultp> sphericalRand(
		T Radius);
	
	/// Generate a random 2D vector which coordinates are regulary distributed within the area of a disk of a given radius
	/// 
	/// @param Radius
	/// @see gtc_random
	template <typename T>
	 tvec2<T, defaultp> diskRand(
		T Radius);
	
	/// Generate a random 3D vector which coordinates are regulary distributed within the volume of a ball of a given radius
	/// 
	/// @param Radius
	/// @see gtc_random
	template <typename T>
	 tvec3<T, defaultp> ballRand(
		T Radius);
	
	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/random.inl" 1 3
/// @ref gtc_random
/// @file glm/gtc/random.inl







namespace glm{
namespace detail
{
	template <typename T, precision P, template <class, precision> class vecType>
	struct compute_rand
	{
		 __inline static vecType<T, P> call();
	};

	template <precision P>
	struct compute_rand<uint8, P, tvec1>
	{
		 __inline static tvec1<uint8, P> call()
		{
			return tvec1<uint8, P>(
				std::rand() % std::numeric_limits<uint8>::max());
		}
	};

	template <precision P>
	struct compute_rand<uint8, P, tvec2>
	{
		 __inline static tvec2<uint8, P> call()
		{
			return tvec2<uint8, P>(
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max());
		}
	};

	template <precision P>
	struct compute_rand<uint8, P, tvec3>
	{
		 __inline static tvec3<uint8, P> call()
		{
			return tvec3<uint8, P>(
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max());
		}
	};

	template <precision P>
	struct compute_rand<uint8, P, tvec4>
	{
		 __inline static tvec4<uint8, P> call()
		{
			return tvec4<uint8, P>(
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max(),
				std::rand() % std::numeric_limits<uint8>::max());
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_rand<uint16, P, vecType>
	{
		 __inline static vecType<uint16, P> call()
		{
			return
				(vecType<uint16, P>(compute_rand<uint8, P, vecType>::call()) << static_cast<uint16>(8)) |
				(vecType<uint16, P>(compute_rand<uint8, P, vecType>::call()) << static_cast<uint16>(0));
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_rand<uint32, P, vecType>
	{
		 __inline static vecType<uint32, P> call()
		{
			return
				(vecType<uint32, P>(compute_rand<uint16, P, vecType>::call()) << static_cast<uint32>(16)) |
				(vecType<uint32, P>(compute_rand<uint16, P, vecType>::call()) << static_cast<uint32>(0));
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_rand<uint64, P, vecType>
	{
		 __inline static vecType<uint64, P> call()
		{
			return
				(vecType<uint64, P>(compute_rand<uint32, P, vecType>::call()) << static_cast<uint64>(32)) |
				(vecType<uint64, P>(compute_rand<uint32, P, vecType>::call()) << static_cast<uint64>(0));
		}
	};

	template <typename T, precision P, template <class, precision> class vecType>
	struct compute_linearRand
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & Min, vecType<T, P> __const & Max);
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<int8, P, vecType>
	{
		 __inline static vecType<int8, P> call(vecType<int8, P> __const & Min, vecType<int8, P> __const & Max)
		{
			return (vecType<int8, P>(compute_rand<uint8, P, vecType>::call() % vecType<uint8, P>(Max + static_cast<int8>(1) - Min))) + Min;
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<uint8, P, vecType>
	{
		 __inline static vecType<uint8, P> call(vecType<uint8, P> __const & Min, vecType<uint8, P> __const & Max)
		{
			return (compute_rand<uint8, P, vecType>::call() % (Max + static_cast<uint8>(1) - Min)) + Min;
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<int16, P, vecType>
	{
		 __inline static vecType<int16, P> call(vecType<int16, P> __const & Min, vecType<int16, P> __const & Max)
		{
			return (vecType<int16, P>(compute_rand<uint16, P, vecType>::call() % vecType<uint16, P>(Max + static_cast<int16>(1) - Min))) + Min;
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<uint16, P, vecType>
	{
		 __inline static vecType<uint16, P> call(vecType<uint16, P> __const & Min, vecType<uint16, P> __const & Max)
		{
			return (compute_rand<uint16, P, vecType>::call() % (Max + static_cast<uint16>(1) - Min)) + Min;
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<int32, P, vecType>
	{
		 __inline static vecType<int32, P> call(vecType<int32, P> __const & Min, vecType<int32, P> __const & Max)
		{
			return (vecType<int32, P>(compute_rand<uint32, P, vecType>::call() % vecType<uint32, P>(Max + static_cast<int32>(1) - Min))) + Min;
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<uint32, P, vecType>
	{
		 __inline static vecType<uint32, P> call(vecType<uint32, P> __const & Min, vecType<uint32, P> __const & Max)
		{
			return (compute_rand<uint32, P, vecType>::call() % (Max + static_cast<uint32>(1) - Min)) + Min;
		}
	};
 
	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<int64, P, vecType>
	{
		 __inline static vecType<int64, P> call(vecType<int64, P> __const & Min, vecType<int64, P> __const & Max)
		{
			return (vecType<int64, P>(compute_rand<uint64, P, vecType>::call() % vecType<uint64, P>(Max + static_cast<int64>(1) - Min))) + Min;
		}
	};

	template <precision P, template <class, precision> class vecType>
	struct compute_linearRand<uint64, P, vecType>
	{
		 __inline static vecType<uint64, P> call(vecType<uint64, P> __const & Min, vecType<uint64, P> __const & Max)
		{
			return (compute_rand<uint64, P, vecType>::call() % (Max + static_cast<uint64>(1) - Min)) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<float, lowp, vecType>
	{
		 __inline static vecType<float, lowp> call(vecType<float, lowp> __const & Min, vecType<float, lowp> __const & Max)
		{
			return vecType<float, lowp>(compute_rand<uint8, lowp, vecType>::call()) / static_cast<float>(std::numeric_limits<uint8>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<float, mediump, vecType>
	{
		 __inline static vecType<float, mediump> call(vecType<float, mediump> __const & Min, vecType<float, mediump> __const & Max)
		{
			return vecType<float, mediump>(compute_rand<uint16, mediump, vecType>::call()) / static_cast<float>(std::numeric_limits<uint16>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<float, highp, vecType>
	{
		 __inline static vecType<float, highp> call(vecType<float, highp> __const & Min, vecType<float, highp> __const & Max)
		{
			return vecType<float, highp>(compute_rand<uint32, highp, vecType>::call()) / static_cast<float>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<double, lowp, vecType>
	{
		 __inline static vecType<double, lowp> call(vecType<double, lowp> __const & Min, vecType<double, lowp> __const & Max)
		{
			return vecType<double, lowp>(compute_rand<uint16, lowp, vecType>::call()) / static_cast<double>(std::numeric_limits<uint16>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<double, mediump, vecType>
	{
		 __inline static vecType<double, mediump> call(vecType<double, mediump> __const & Min, vecType<double, mediump> __const & Max)
		{
			return vecType<double, mediump>(compute_rand<uint32, mediump, vecType>::call()) / static_cast<double>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<double, highp, vecType>
	{
		 __inline static vecType<double, highp> call(vecType<double, highp> __const & Min, vecType<double, highp> __const & Max)
		{
			return vecType<double, highp>(compute_rand<uint64, highp, vecType>::call()) / static_cast<double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<long double, lowp, vecType>
	{
		 __inline static vecType<long double, lowp> call(vecType<long double, lowp> __const & Min, vecType<long double, lowp> __const & Max)
		{
			return vecType<long double, lowp>(compute_rand<uint32, lowp, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<long double, mediump, vecType>
	{
		 __inline static vecType<long double, mediump> call(vecType<long double, mediump> __const & Min, vecType<long double, mediump> __const & Max)
		{
			return vecType<long double, mediump>(compute_rand<uint64, mediump, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
		}
	};

	template <template <class, precision> class vecType>
	struct compute_linearRand<long double, highp, vecType>
	{
		 __inline static vecType<long double, highp> call(vecType<long double, highp> __const & Min, vecType<long double, highp> __const & Max)
		{
			return vecType<long double, highp>(compute_rand<uint64, highp, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
		}
	};
}//namespace detail

	template <typename genType>
	 __inline genType linearRand(genType Min, genType Max)
	{
		return detail::compute_linearRand<genType, highp, tvec1>::call(
			tvec1<genType, highp>(Min),
			tvec1<genType, highp>(Max)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> linearRand(vecType<T, P> __const & Min, vecType<T, P> __const & Max)
	{
		return detail::compute_linearRand<T, P, vecType>::call(Min, Max);
	}

	template <typename genType>
	 __inline genType gaussRand(genType Mean, genType Deviation)
	{
		genType w, x1, x2;
	
		do
		{
			x1 = linearRand(genType(-1), genType(1));
			x2 = linearRand(genType(-1), genType(1));
		
			w = x1 * x1 + x2 * x2;
		} while(w > genType(1));
	
		return x2 * Deviation * Deviation * sqrt((genType(-2) * log(w)) / w) + Mean;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> gaussRand(vecType<T, P> __const & Mean, vecType<T, P> __const & Deviation)
	{
		return detail::functor2<T, P, vecType>::call(gaussRand, Mean, Deviation);
	}

	template <typename T>
	 __inline tvec2<T, defaultp> diskRand(T Radius)
	{		
		tvec2<T, defaultp> Result(T(0));
		T LenRadius(T(0));
		
		do
		{
			Result = linearRand(
				tvec2<T, defaultp>(-Radius),
				tvec2<T, defaultp>(Radius));
			LenRadius = length(Result);
		}
		while(LenRadius > Radius);
		
		return Result;
	}
	
	template <typename T>
	 __inline tvec3<T, defaultp> ballRand(T Radius)
	{		
		tvec3<T, defaultp> Result(T(0));
		T LenRadius(T(0));
		
		do
		{
			Result = linearRand(
				tvec3<T, defaultp>(-Radius),
				tvec3<T, defaultp>(Radius));
			LenRadius = length(Result);
		}
		while(LenRadius > Radius);
		
		return Result;
	}
	
	template <typename T>
	 __inline tvec2<T, defaultp> circularRand(T Radius)
	{
		T a = linearRand(T(0), T(6.283185307179586476925286766559f));
		return tvec2<T, defaultp>(cos(a), sin(a)) * Radius;		
	}
	
	template <typename T>
	 __inline tvec3<T, defaultp> sphericalRand(T Radius)
	{
		T z = linearRand(T(-1), T(1));
		T a = linearRand(T(0), T(6.283185307179586476925286766559f));
	
		T r = sqrt(T(1) - z * z);
	
		T x = r * cos(a);
		T y = r * sin(a);
	
		return tvec3<T, defaultp>(x, y, z) * Radius;	
	}
}//namespace glm

# 98 "/usr/local/include/glm/./gtc/random.hpp" 2 3


# 50 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/reciprocal.hpp" 1 3
/// @ref gtc_reciprocal
/// @file glm/gtc/reciprocal.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_reciprocal GLM_GTC_reciprocal
/// @ingroup gtc
///
/// @brief Define secant, cosecant and cotangent functions.
///
/// <glm/gtc/reciprocal.hpp> need to be included to use these features.



// Dependencies




       

namespace glm
{
	/// @addtogroup gtc_reciprocal
	/// @{

	/// Secant function.
	/// hypotenuse / adjacent or 1 / cos(x)
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType sec(genType angle);

	/// Cosecant function.
	/// hypotenuse / opposite or 1 / sin(x)
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType> 
	 genType csc(genType angle);
		
	/// Cotangent function.
	/// adjacent / opposite or 1 / tan(x)
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType cot(genType angle);

	/// Inverse secant function.
	/// 
	/// @return Return an angle expressed in radians.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType asec(genType x);

	/// Inverse cosecant function.
	/// 
	/// @return Return an angle expressed in radians.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType acsc(genType x);
		
	/// Inverse cotangent function.
	/// 
	/// @return Return an angle expressed in radians.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType acot(genType x);

	/// Secant hyperbolic function.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType sech(genType angle);

	/// Cosecant hyperbolic function.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType csch(genType angle);
		
	/// Cotangent hyperbolic function.
	/// 
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType coth(genType angle);

	/// Inverse secant hyperbolic function.
	/// 
	/// @return Return an angle expressed in radians.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType asech(genType x);

	/// Inverse cosecant hyperbolic function.
	/// 
	/// @return Return an angle expressed in radians.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType acsch(genType x);
		
	/// Inverse cotangent hyperbolic function.
	/// 
	/// @return Return an angle expressed in radians.
	/// @tparam genType Floating-point scalar or vector types.
	/// 
	/// @see gtc_reciprocal
	template <typename genType>
	 genType acoth(genType x);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/gtc/reciprocal.inl" 1 3
/// @ref gtc_reciprocal
/// @file glm/gtc/reciprocal.inl




namespace glm
{
	// sec
	template <typename genType>
	 __inline genType sec(genType angle)
	{
		;
		return genType(1) / glm::cos(angle);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> sec(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(sec, x);
	}

	// csc
	template <typename genType>
	 __inline genType csc(genType angle)
	{
		;
		return genType(1) / glm::sin(angle);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> csc(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(csc, x);
	}

	// cot
	template <typename genType>
	 __inline genType cot(genType angle)
	{
		;
	
		genType __const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
		return glm::tan(pi_over_2 - angle);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> cot(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(cot, x);
	}

	// asec
	template <typename genType>
	 __inline genType asec(genType x)
	{
		;
		return acos(genType(1) / x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> asec(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(asec, x);
	}

	// acsc
	template <typename genType>
	 __inline genType acsc(genType x)
	{
		;
		return asin(genType(1) / x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> acsc(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(acsc, x);
	}

	// acot
	template <typename genType>
	 __inline genType acot(genType x)
	{
		;

		genType __const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
		return pi_over_2 - atan(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> acot(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(acot, x);
	}

	// sech
	template <typename genType>
	 __inline genType sech(genType angle)
	{
		;
		return genType(1) / glm::cosh(angle);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> sech(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(sech, x);
	}

	// csch
	template <typename genType>
	 __inline genType csch(genType angle)
	{
		;
		return genType(1) / glm::sinh(angle);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> csch(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(csch, x);
	}

	// coth
	template <typename genType>
	 __inline genType coth(genType angle)
	{
		;
		return glm::cosh(angle) / glm::sinh(angle);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> coth(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(coth, x);
	}

	// asech
	template <typename genType>
	 __inline genType asech(genType x)
	{
		;
		return acosh(genType(1) / x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> asech(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(asech, x);
	}

	// acsch
	template <typename genType>
	 __inline genType acsch(genType x)
	{
		;
		return acsch(genType(1) / x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> acsch(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(acsch, x);
	}

	// acoth
	template <typename genType>
	 __inline genType acoth(genType x)
	{
		;
		return atanh(genType(1) / x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> acoth(vecType<T, P> __const & x)
	{
		;
		return detail::functor1<T, T, P, vecType>::call(acoth, x);
	}
}//namespace glm

# 135 "/usr/local/include/glm/./gtc/reciprocal.hpp" 2 3


# 51 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/round.hpp" 1 3
/// @ref gtc_round
/// @file glm/gtc/round.hpp
///
/// @see core (dependence)
/// @see gtc_round (dependence)
///
/// @defgroup gtc_round GLM_GTC_round
/// @ingroup gtc
///
/// @brief rounding value to specific boundings
///
/// <glm/gtc/round.hpp> need to be included to use these functionalities.



// Dependencies









       

namespace glm
{
	/// @addtogroup gtc_round
	/// @{

	/// Return true if the value is a power of two number.
	///
	/// @see gtc_round
	template <typename genIUType>
	 bool isPowerOfTwo(genIUType Value);

	/// Return true if the value is a power of two number.
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isPowerOfTwo(vecType<T, P> __const & value);

	/// Return the power of two number which value is just higher the input value,
	/// round up to a power of two.
	///
	/// @see gtc_round
	template <typename genIUType>
	 genIUType ceilPowerOfTwo(genIUType Value);

	/// Return the power of two number which value is just higher the input value,
	/// round up to a power of two.
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> ceilPowerOfTwo(vecType<T, P> __const & value);

	/// Return the power of two number which value is just lower the input value,
	/// round down to a power of two.
	///
	/// @see gtc_round
	template <typename genIUType>
	 genIUType floorPowerOfTwo(genIUType Value);

	/// Return the power of two number which value is just lower the input value,
	/// round down to a power of two.
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> floorPowerOfTwo(vecType<T, P> __const & value);

	/// Return the power of two number which value is the closet to the input value.
	///
	/// @see gtc_round
	template <typename genIUType>
	 genIUType roundPowerOfTwo(genIUType Value);

	/// Return the power of two number which value is the closet to the input value.
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> roundPowerOfTwo(vecType<T, P> __const & value);

	/// Return true if the 'Value' is a multiple of 'Multiple'.
	///
	/// @see gtc_round
	template <typename genIUType>
	 bool isMultiple(genIUType Value, genIUType Multiple);

	/// Return true if the 'Value' is a multiple of 'Multiple'.
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isMultiple(vecType<T, P> __const & Value, T Multiple);

	/// Return true if the 'Value' is a multiple of 'Multiple'.
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isMultiple(vecType<T, P> __const & Value, vecType<T, P> __const & Multiple);

	/// Higher multiple number of Source.
	///
	/// @tparam genType Floating-point or integer scalar or vector types.
	/// @param Source 
	/// @param Multiple Must be a null or positive value
	///
	/// @see gtc_round
	template <typename genType>
	 genType ceilMultiple(genType Source, genType Multiple);

	/// Higher multiple number of Source.
	///
	/// @tparam genType Floating-point or integer scalar or vector types.
	/// @param Source 
	/// @param Multiple Must be a null or positive value
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> ceilMultiple(vecType<T, P> __const & Source, vecType<T, P> __const & Multiple);

	/// Lower multiple number of Source.
	///
	/// @tparam genType Floating-point or integer scalar or vector types.
	/// @param Source 
	/// @param Multiple Must be a null or positive value
	///
	/// @see gtc_round
	template <typename genType>
	 genType floorMultiple(
		genType Source,
		genType Multiple);

	/// Lower multiple number of Source.
	///
	/// @tparam genType Floating-point or integer scalar or vector types.
	/// @param Source 
	/// @param Multiple Must be a null or positive value
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> floorMultiple(
		vecType<T, P> __const & Source,
		vecType<T, P> __const & Multiple);

	/// Lower multiple number of Source.
	///
	/// @tparam genType Floating-point or integer scalar or vector types.
	/// @param Source 
	/// @param Multiple Must be a null or positive value
	///
	/// @see gtc_round
	template <typename genType>
	 genType roundMultiple(
		genType Source,
		genType Multiple);

	/// Lower multiple number of Source.
	///
	/// @tparam genType Floating-point or integer scalar or vector types.
	/// @param Source 
	/// @param Multiple Must be a null or positive value
	///
	/// @see gtc_round
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> roundMultiple(
		vecType<T, P> __const & Source,
		vecType<T, P> __const & Multiple);

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/gtc/round.inl" 1 3
/// @ref gtc_round
/// @file glm/gtc/round.inl



namespace glm{
namespace detail
{
	template <typename T, precision P, template <typename, precision> class vecType, bool compute = false>
	struct compute_ceilShift
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & v, T)
		{
			return v;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct compute_ceilShift<T, P, vecType, true>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & v, T Shift)
		{
			return v | (v >> Shift);
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType, bool isSigned = true>
	struct compute_ceilPowerOfTwo
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			;

			vecType<T, P> __const Sign(sign(x));

			vecType<T, P> v(abs(x));

			v = v - static_cast<T>(1);
			v = v | (v >> static_cast<T>(1));
			v = v | (v >> static_cast<T>(2));
			v = v | (v >> static_cast<T>(4));
			v = compute_ceilShift<T, P, vecType, sizeof(T) >= 2>::call(v, 8);
			v = compute_ceilShift<T, P, vecType, sizeof(T) >= 4>::call(v, 16);
			v = compute_ceilShift<T, P, vecType, sizeof(T) >= 8>::call(v, 32);
			return (v + static_cast<T>(1)) * Sign;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct compute_ceilPowerOfTwo<T, P, vecType, false>
	{
		 __inline static vecType<T, P> call(vecType<T, P> __const & x)
		{
			;

			vecType<T, P> v(x);

			v = v - static_cast<T>(1);
			v = v | (v >> static_cast<T>(1));
			v = v | (v >> static_cast<T>(2));
			v = v | (v >> static_cast<T>(4));
			v = compute_ceilShift<T, P, vecType, sizeof(T) >= 2>::call(v, 8);
			v = compute_ceilShift<T, P, vecType, sizeof(T) >= 4>::call(v, 16);
			v = compute_ceilShift<T, P, vecType, sizeof(T) >= 8>::call(v, 32);
			return v + static_cast<T>(1);
		}
	};

	template <bool is_float, bool is_signed>
	struct compute_ceilMultiple{};

	template <>
	struct compute_ceilMultiple<true, true>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source > genType(0))
				return Source + (Multiple - std::fmod(Source, Multiple));
			else
				return Source + std::fmod(-Source, Multiple);
		}
	};

	template <>
	struct compute_ceilMultiple<false, false>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			genType Tmp = Source - genType(1);
			return Tmp + (Multiple - (Tmp % Multiple));
		}
	};

	template <>
	struct compute_ceilMultiple<false, true>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source > genType(0))
			{
				genType Tmp = Source - genType(1);
				return Tmp + (Multiple - (Tmp % Multiple));
			}
			else
				return Source + (-Source % Multiple);
		}
	};

	template <bool is_float, bool is_signed>
	struct compute_floorMultiple{};

	template <>
	struct compute_floorMultiple<true, true>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - std::fmod(Source, Multiple);
			else
				return Source - std::fmod(Source, Multiple) - Multiple;
		}
	};

	template <>
	struct compute_floorMultiple<false, false>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};

	template <>
	struct compute_floorMultiple<false, true>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};

	template <bool is_float, bool is_signed>
	struct compute_roundMultiple{};

	template <>
	struct compute_roundMultiple<true, true>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - std::fmod(Source, Multiple);
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - std::fmod(Tmp, Multiple) - Multiple;
			}
		}
	};

	template <>
	struct compute_roundMultiple<false, false>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};

	template <>
	struct compute_roundMultiple<false, true>
	{
		template <typename genType>
		 __inline static genType call(genType Source, genType Multiple)
		{
			if(Source >= genType(0))
				return Source - Source % Multiple;
			else
			{
				genType Tmp = Source + genType(1);
				return Tmp - Tmp % Multiple - Multiple;
			}
		}
	};
}//namespace detail

	////////////////
	// isPowerOfTwo

	template <typename genType>
	 __inline bool isPowerOfTwo(genType Value)
	{
		genType __const Result = glm::abs(Value);
		return !(Result & (Result - 1));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> isPowerOfTwo(vecType<T, P> __const & Value)
	{
		vecType<T, P> __const Result(abs(Value));
		return equal(Result & (Result - 1), vecType<T, P>(0));
	}

	//////////////////
	// ceilPowerOfTwo

	template <typename genType>
	 __inline genType ceilPowerOfTwo(genType value)
	{
		return detail::compute_ceilPowerOfTwo<genType, defaultp, tvec1, std::numeric_limits<genType>::is_signed>::call(tvec1<genType, defaultp>(value)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> ceilPowerOfTwo(vecType<T, P> __const & v)
	{
		return detail::compute_ceilPowerOfTwo<T, P, vecType, std::numeric_limits<T>::is_signed>::call(v);
	}

	///////////////////
	// floorPowerOfTwo

	template <typename genType>
	 __inline genType floorPowerOfTwo(genType value)
	{
		return isPowerOfTwo(value) ? value : static_cast<genType>(1) << findMSB(value);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> floorPowerOfTwo(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(floorPowerOfTwo, v);
	}

	///////////////////
	// roundPowerOfTwo

	template <typename genIUType>
	 __inline genIUType roundPowerOfTwo(genIUType value)
	{
		if(isPowerOfTwo(value))
			return value;

		genIUType __const prev = static_cast<genIUType>(1) << findMSB(value);
		genIUType __const next = prev << static_cast<genIUType>(1);
		return (next - value) < (value - prev) ? next : prev;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> roundPowerOfTwo(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(roundPowerOfTwo, v);
	}

	////////////////
	// isMultiple

	template <typename genType>
	 __inline bool isMultiple(genType Value, genType Multiple)
	{
		return isMultiple(tvec1<genType>(Value), tvec1<genType>(Multiple)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> isMultiple(vecType<T, P> __const & Value, T Multiple)
	{
		return (Value % Multiple) == vecType<T, P>(0);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> isMultiple(vecType<T, P> __const & Value, vecType<T, P> __const & Multiple)
	{
		return (Value % Multiple) == vecType<T, P>(0);
	}

	//////////////////////
	// ceilMultiple

	template <typename genType>
	 __inline genType ceilMultiple(genType Source, genType Multiple)
	{
		return detail::compute_ceilMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> ceilMultiple(vecType<T, P> __const & Source, vecType<T, P> __const & Multiple)
	{
		return detail::functor2<T, P, vecType>::call(ceilMultiple, Source, Multiple);
	}

	//////////////////////
	// floorMultiple

	template <typename genType>
	 __inline genType floorMultiple(genType Source, genType Multiple)
	{
		return detail::compute_floorMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> floorMultiple(vecType<T, P> __const & Source, vecType<T, P> __const & Multiple)
	{
		return detail::functor2<T, P, vecType>::call(floorMultiple, Source, Multiple);
	}

	//////////////////////
	// roundMultiple

	template <typename genType>
	 __inline genType roundMultiple(genType Source, genType Multiple)
	{
		return detail::compute_roundMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> roundMultiple(vecType<T, P> __const & Source, vecType<T, P> __const & Multiple)
	{
		return detail::functor2<T, P, vecType>::call(roundMultiple, Source, Multiple);
	}
}//namespace glm

# 174 "/usr/local/include/glm/./gtc/round.hpp" 2 3


# 52 "/usr/local/include/glm/ext.hpp" 2 3

//#include "./gtc/type_aligned.hpp"



# 1 "/usr/local/include/glm/./gtc/ulp.hpp" 1 3
/// @ref gtc_ulp
/// @file glm/gtc/ulp.hpp
///
/// @see core (dependence)
///
/// @defgroup gtc_ulp GLM_GTC_ulp
/// @ingroup gtc
///
/// @brief Allow the measurement of the accuracy of a function against a reference 
/// implementation. This extension works on floating-point data and provide results 
/// in ULP.
/// <glm/gtc/ulp.hpp> need to be included to use these features.



// Dependencies






       

namespace glm
{
	/// @addtogroup gtc_ulp
	/// @{

	/// Return the next ULP value(s) after the input value(s).
	/// @see gtc_ulp
	template <typename genType>
	 genType next_float(genType __const & x);

	/// Return the previous ULP value(s) before the input value(s).
	/// @see gtc_ulp
	template <typename genType>
	 genType prev_float(genType __const & x);

	/// Return the value(s) ULP distance after the input value(s).
	/// @see gtc_ulp
	template <typename genType>
	 genType next_float(genType __const & x, uint __const & Distance);

	/// Return the value(s) ULP distance before the input value(s).
	/// @see gtc_ulp
	template <typename genType>
	 genType prev_float(genType __const & x, uint __const & Distance);
	
	/// Return the distance in the number of ULP between 2 scalars.
	/// @see gtc_ulp
	template <typename T>
	 uint float_distance(T __const & x, T __const & y);

	/// Return the distance in the number of ULP between 2 vectors.
	/// @see gtc_ulp
	template<typename T, template<typename> class vecType>
	 vecType<uint> float_distance(vecType<T> __const & x, vecType<T> __const & y);
	
	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/gtc/ulp.inl" 1 3
/// @ref gtc_ulp
/// @file glm/gtc/ulp.inl
///
/// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
///
/// Developed at SunPro, a Sun Microsystems, Inc. business.
/// Permission to use, copy, modify, and distribute this
/// software is freely granted, provided that this notice
/// is preserved.









       

typedef union
{
	float value;
	
	unsigned int word;
} ieee_float_shape_type;

typedef union
{
	double value;
	struct
	{
		glm::detail::int32 lsw;
		glm::detail::int32 msw;
	} parts;
} ieee_double_shape_type;







             






             






             







             

namespace glm{
namespace detail
{
	 __inline float nextafterf(float x, float y)
	{
		__volatile float t;
		glm::detail::int32 hx, hy, ix, iy;

		do { ieee_float_shape_type gf_u; gf_u.value = ( x); (hx) = gf_u.word; } while (0);
		do { ieee_float_shape_type gf_u; gf_u.value = ( y); (hy) = gf_u.word; } while (0);
		ix = hx&0x7fffffff;		// |x|
		iy = hy&0x7fffffff;		// |y|

		if((ix>0x7f800000) ||	// x is nan 
			(iy>0x7f800000))	// y is nan 
			return x+y;
		if(x==y) return y;		// x=y, return y
		if(ix==0) {				// x == 0
			do { ieee_float_shape_type sf_u; sf_u.word = ((hy&0x80000000)|1); (x) = sf_u.value; } while (0);// return +-minsubnormal
			t = x*x;
			if(t==x) return t; else return x;	// raise underflow flag
		}
		if(hx>=0) {				// x > 0 
			if(hx>hy) {			// x > y, x -= ulp
				hx -= 1;
			} else {			// x < y, x += ulp
				hx += 1;
			}
		} else {				// x < 0
			if(hy>=0||hx>hy){	// x < y, x -= ulp
				hx -= 1;
			} else {			// x > y, x += ulp
				hx += 1;
			}
		}
		hy = hx&0x7f800000;
		if(hy>=0x7f800000) return x+x;  // overflow
		if(hy<0x00800000) {             // underflow
			t = x*x;
			if(t!=x) {          // raise underflow flag
				do { ieee_float_shape_type sf_u; sf_u.word = (hx); (y) = sf_u.value; } while (0);
				return y;
			}
		}
		do { ieee_float_shape_type sf_u; sf_u.word = (hx); (x) = sf_u.value; } while (0);
		return x;
	}

	 __inline double nextafter(double x, double y)
	{
		__volatile double t;
		glm::detail::int32 hx, hy, ix, iy;
		glm::detail::uint32 lx, ly;

		do { ieee_double_shape_type ew_u; ew_u.value = ( x); (hx) = ew_u.parts.msw; ( lx) = ew_u.parts.lsw; } while (0);
		do { ieee_double_shape_type ew_u; ew_u.value = ( y); (hy) = ew_u.parts.msw; ( ly) = ew_u.parts.lsw; } while (0);
		ix = hx & 0x7fffffff;             // |x| 
		iy = hy & 0x7fffffff;             // |y| 

		if(((ix>=0x7ff00000)&&((ix-0x7ff00000)|lx)!=0) ||   // x is nan
			((iy>=0x7ff00000)&&((iy-0x7ff00000)|ly)!=0))     // y is nan
			return x+y;
		if(x==y) return y;              // x=y, return y
		if((ix|lx)==0) {                        // x == 0 
			do { ieee_double_shape_type iw_u; iw_u.parts.msw = ( hy & 0x80000000); iw_u.parts.lsw = ( 1); (x) = iw_u.value; } while (0);    // return +-minsubnormal
			t = x*x;
			if(t==x) return t; else return x;   // raise underflow flag 
		}
		if(hx>=0) {                             // x > 0 
			if(hx>hy||((hx==hy)&&(lx>ly))) {    // x > y, x -= ulp 
				if(lx==0) hx -= 1;
				lx -= 1;
			} else {                            // x < y, x += ulp
				lx += 1;
				if(lx==0) hx += 1;
			}
		} else {                                // x < 0 
			if(hy>=0||hx>hy||((hx==hy)&&(lx>ly))){// x < y, x -= ulp
				if(lx==0) hx -= 1;
				lx -= 1;
			} else {                            // x > y, x += ulp
				lx += 1;
				if(lx==0) hx += 1;
			}
		}
		hy = hx&0x7ff00000;
		if(hy>=0x7ff00000) return x+x;  // overflow
		if(hy<0x00100000) {             // underflow
			t = x*x;
			if(t!=x) {          // raise underflow flag
				do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (y) = iw_u.value; } while (0);
				return y;
			}
		}
		do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (x) = iw_u.value; } while (0);
		return x;
	}
}//namespace detail
}//namespace glm



       

namespace glm
{
	template <>
	 __inline float next_float(float __const & x)
	{






        
			return nextafterf(x, FLT_MAX);

	}

	template <>
	 __inline double next_float(double __const & x)
	{






        
			return nextafter(x, DBL_MAX);

	}

	template<typename T, precision P, template<typename, precision> class vecType>
	 __inline vecType<T, P> next_float(vecType<T, P> __const & x)
	{
		vecType<T, P> Result(uninitialize);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = next_float(x[i]);
		return Result;
	}

	 __inline float prev_float(float __const & x)
	{






        
			return nextafterf(x, FLT_MIN);

	}

	 __inline double prev_float(double __const & x)
	{






        
			return nextafter(x, DBL_MIN);

	}

	template<typename T, precision P, template<typename, precision> class vecType>
	 __inline vecType<T, P> prev_float(vecType<T, P> __const & x)
	{
		vecType<T, P> Result(uninitialize);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prev_float(x[i]);
		return Result;
	}

	template <typename T>
	 __inline T next_float(T __const & x, uint __const & ulps)
	{
		T temp = x;
		for(uint i = 0; i < ulps; ++i)
			temp = next_float(temp);
		return temp;
	}

	template<typename T, precision P, template<typename, precision> class vecType>
	 __inline vecType<T, P> next_float(vecType<T, P> __const & x, vecType<uint, P> __const & ulps)
	{
		vecType<T, P> Result(uninitialize);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = next_float(x[i], ulps[i]);
		return Result;
	}

	template <typename T>
	 __inline T prev_float(T __const & x, uint __const & ulps)
	{
		T temp = x;
		for(uint i = 0; i < ulps; ++i)
			temp = prev_float(temp);
		return temp;
	}

	template<typename T, precision P, template<typename, precision> class vecType>
	 __inline vecType<T, P> prev_float(vecType<T, P> __const & x, vecType<uint, P> __const & ulps)
	{
		vecType<T, P> Result(uninitialize);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = prev_float(x[i], ulps[i]);
		return Result;
	}

	template <typename T>
	 __inline uint float_distance(T __const & x, T __const & y)
	{
		uint ulp = 0;

		if(x < y)
		{
			T temp = x;
			while(temp != y)// && ulp < std::numeric_limits<std::size_t>::max())
			{
				++ulp;
				temp = next_float(temp);
			}
		}
		else if(y < x)
		{
			T temp = y;
			while(temp != x)// && ulp < std::numeric_limits<std::size_t>::max())
			{
				++ulp;
				temp = next_float(temp);
			}
		}
		else // ==
		{

		}

		return ulp;
	}

	template<typename T, precision P, template<typename, precision> class vecType>
	 __inline vecType<uint, P> float_distance(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		vecType<uint, P> Result(uninitialize);
		for(length_t i = 0, n = Result.length(); i < n; ++i)
			Result[i] = float_distance(x[i], y[i]);
		return Result;
	}
}//namespace glm

# 63 "/usr/local/include/glm/./gtc/ulp.hpp" 2 3


# 56 "/usr/local/include/glm/ext.hpp" 2 3




       


# 1 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 1 3
/// @ref gtx_associated_min_max
/// @file glm/gtx/associated_min_max.hpp
///
/// @see core (dependence)
/// @see gtx_extented_min_max (dependence)
///
/// @defgroup gtx_associated_min_max GLM_GTX_associated_min_max
/// @ingroup gtx
/// 
/// @brief Min and max functions that return associated values not the compared onces.
/// <glm/gtx/associated_min_max.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_associated_min_max
	/// @{

	/// Minimum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P>
	 U associatedMin(T x, U a, T y, U b);

	/// Minimum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 tvec2<U, P> associatedMin(
		vecType<T, P> __const & x, vecType<U, P> __const & a,
		vecType<T, P> __const & y, vecType<U, P> __const & b);

	/// Minimum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMin(
		T x, __const vecType<U, P>& a,
		T y, __const vecType<U, P>& b);

	/// Minimum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMin(
		vecType<T, P> __const & x, U a,
		vecType<T, P> __const & y, U b);

	/// Minimum comparison between 3 variables and returns 3 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U>
	 U associatedMin(
		T x, U a,
		T y, U b,
		T z, U c);

	/// Minimum comparison between 3 variables and returns 3 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMin(
		vecType<T, P> __const & x, vecType<U, P> __const & a,
		vecType<T, P> __const & y, vecType<U, P> __const & b,
		vecType<T, P> __const & z, vecType<U, P> __const & c);

	/// Minimum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U>
	 U associatedMin(
		T x, U a,
		T y, U b,
		T z, U c,
		T w, U d);

	/// Minimum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMin(
		vecType<T, P> __const & x, vecType<U, P> __const & a,
		vecType<T, P> __const & y, vecType<U, P> __const & b,
		vecType<T, P> __const & z, vecType<U, P> __const & c,
		vecType<T, P> __const & w, vecType<U, P> __const & d);

	/// Minimum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMin(
		T x, vecType<U, P> __const & a,
		T y, vecType<U, P> __const & b,
		T z, vecType<U, P> __const & c,
		T w, vecType<U, P> __const & d);

	/// Minimum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMin(
		vecType<T, P> __const & x, U a,
		vecType<T, P> __const & y, U b,
		vecType<T, P> __const & z, U c,
		vecType<T, P> __const & w, U d);

	/// Maximum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U>
	 U associatedMax(T x, U a, T y, U b);

	/// Maximum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 tvec2<U, P> associatedMax(
		vecType<T, P> __const & x, vecType<U, P> __const & a,
		vecType<T, P> __const & y, vecType<U, P> __const & b);

	/// Maximum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> associatedMax(
		T x, vecType<U, P> __const & a,
		T y, vecType<U, P> __const & b);

	/// Maximum comparison between 2 variables and returns 2 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMax(
		vecType<T, P> __const & x, U a,
		vecType<T, P> __const & y, U b);

	/// Maximum comparison between 3 variables and returns 3 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U>
	 U associatedMax(
		T x, U a,
		T y, U b,
		T z, U c);

	/// Maximum comparison between 3 variables and returns 3 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMax(
		vecType<T, P> __const & x, vecType<U, P> __const & a,
		vecType<T, P> __const & y, vecType<U, P> __const & b,
		vecType<T, P> __const & z, vecType<U, P> __const & c);

	/// Maximum comparison between 3 variables and returns 3 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> associatedMax(
		T x, vecType<U, P> __const & a,
		T y, vecType<U, P> __const & b,
		T z, vecType<U, P> __const & c);

	/// Maximum comparison between 3 variables and returns 3 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMax(
		vecType<T, P> __const & x, U a,
		vecType<T, P> __const & y, U b,
		vecType<T, P> __const & z, U c);

	/// Maximum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U>
	 U associatedMax(
		T x, U a,
		T y, U b,
		T z, U c,
		T w, U d);

	/// Maximum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMax(
		vecType<T, P> __const & x, vecType<U, P> __const & a,
		vecType<T, P> __const & y, vecType<U, P> __const & b,
		vecType<T, P> __const & z, vecType<U, P> __const & c,
		vecType<T, P> __const & w, vecType<U, P> __const & d);

	/// Maximum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMax(
		T x, vecType<U, P> __const & a,
		T y, vecType<U, P> __const & b,
		T z, vecType<U, P> __const & c,
		T w, vecType<U, P> __const & d);

	/// Maximum comparison between 4 variables and returns 4 associated variable values
	/// @see gtx_associated_min_max
	template<typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<U, P> associatedMax(
		vecType<T, P> __const & x, U a,
		vecType<T, P> __const & y, U b,
		vecType<T, P> __const & z, U c,
		vecType<T, P> __const & w, U d);

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/./gtx/associated_min_max.inl" 1 3
/// @ref gtx_associated_min_max
/// @file glm/gtx/associated_min_max.inl

namespace glm{

// Min comparison between 2 variables
template<typename T, typename U, precision P>
 __inline U associatedMin(T x, U a, T y, U b)
{
	return x < y ? a : b;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline tvec2<U, P> associatedMin
(
	vecType<T, P> __const & x, vecType<U, P> __const & a,
	vecType<T, P> __const & y, vecType<U, P> __const & b
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x[i] < y[i] ? a[i] : b[i];
	return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMin
(
	T x, __const vecType<U, P>& a,
	T y, __const vecType<U, P>& b
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x < y ? a[i] : b[i];
	return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMin
(
	vecType<T, P> __const & x, U a,
	vecType<T, P> __const & y, U b
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x[i] < y[i] ? a : b;
	return Result;
}

// Min comparison between 3 variables
template<typename T, typename U>
 __inline U associatedMin
(
	T x, U a,
	T y, U b,
	T z, U c
)
{
	U Result = x < y ? (x < z ? a : c) : (y < z ? b : c);
	return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMin
(
	vecType<T, P> __const & x, vecType<U, P> __const & a,
	vecType<T, P> __const & y, vecType<U, P> __const & b,
	vecType<T, P> __const & z, vecType<U, P> __const & c
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x[i] < y[i] ? (x[i] < z[i] ? a[i] : c[i]) : (y[i] < z[i] ? b[i] : c[i]);
	return Result;
}

// Min comparison between 4 variables
template<typename T, typename U>
 __inline U associatedMin
(
	T x, U a,
	T y, U b,
	T z, U c,
	T w, U d
)
{
	T Test1 = min(x, y);
	T Test2 = min(z, w);;
	U Result1 = x < y ? a : b;
	U Result2 = z < w ? c : d;
	U Result = Test1 < Test2 ? Result1 : Result2;
	return Result;
}

// Min comparison between 4 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMin
(
	vecType<T, P> __const & x, vecType<U, P> __const & a,
	vecType<T, P> __const & y, vecType<U, P> __const & b,
	vecType<T, P> __const & z, vecType<U, P> __const & c,
	vecType<T, P> __const & w, vecType<U, P> __const & d
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
	{
		T Test1 = min(x[i], y[i]);
		T Test2 = min(z[i], w[i]);
		U Result1 = x[i] < y[i] ? a[i] : b[i];
		U Result2 = z[i] < w[i] ? c[i] : d[i];
		Result[i] = Test1 < Test2 ? Result1 : Result2;
	}
	return Result;
}

// Min comparison between 4 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMin
(
	T x, vecType<U, P> __const & a,
	T y, vecType<U, P> __const & b,
	T z, vecType<U, P> __const & c,
	T w, vecType<U, P> __const & d
)
{
	T Test1 = min(x, y);
	T Test2 = min(z, w);

	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
	{
		U Result1 = x < y ? a[i] : b[i];
		U Result2 = z < w ? c[i] : d[i];
		Result[i] = Test1 < Test2 ? Result1 : Result2;
	}
	return Result;
}

// Min comparison between 4 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMin
(
	vecType<T, P> __const & x, U a,
	vecType<T, P> __const & y, U b,
	vecType<T, P> __const & z, U c,
	vecType<T, P> __const & w, U d
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
	{
		T Test1 = min(x[i], y[i]);
		T Test2 = min(z[i], w[i]);;
		U Result1 = x[i] < y[i] ? a : b;
		U Result2 = z[i] < w[i] ? c : d;
		Result[i] = Test1 < Test2 ? Result1 : Result2;
	}
	return Result;
}

// Max comparison between 2 variables
template<typename T, typename U>
 __inline U associatedMax(T x, U a, T y, U b)
{
	return x > y ? a : b;
}

// Max comparison between 2 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline tvec2<U, P> associatedMax
(
	vecType<T, P> __const & x, vecType<U, P> __const & a,
	vecType<T, P> __const & y, vecType<U, P> __const & b
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x[i] > y[i] ? a[i] : b[i];
	return Result;
}

// Max comparison between 2 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<T, P> associatedMax
(
	T x, vecType<U, P> __const & a,
	T y, vecType<U, P> __const & b
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x > y ? a[i] : b[i];
	return Result;
}

// Max comparison between 2 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMax
(
	vecType<T, P> __const & x, U a,
	vecType<T, P> __const & y, U b
)
{
	vecType<T, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x[i] > y[i] ? a : b;
	return Result;
}

// Max comparison between 3 variables
template<typename T, typename U>
 __inline U associatedMax
(
	T x, U a,
	T y, U b,
	T z, U c
)
{
	U Result = x > y ? (x > z ? a : c) : (y > z ? b : c);
	return Result;
}

// Max comparison between 3 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMax
(
	vecType<T, P> __const & x, vecType<U, P> __const & a,
	vecType<T, P> __const & y, vecType<U, P> __const & b,
	vecType<T, P> __const & z, vecType<U, P> __const & c
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x[i] > y[i] ? (x[i] > z[i] ? a[i] : c[i]) : (y[i] > z[i] ? b[i] : c[i]);
	return Result;
}

// Max comparison between 3 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<T, P> associatedMax
(
	T x, vecType<U, P> __const & a,
	T y, vecType<U, P> __const & b,
	T z, vecType<U, P> __const & c
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x > y ? (x > z ? a[i] : c[i]) : (y > z ? b[i] : c[i]);
	return Result;
}

// Max comparison between 3 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMax
(
	vecType<T, P> __const & x, U a,
	vecType<T, P> __const & y, U b,
	vecType<T, P> __const & z, U c
)
{
	vecType<T, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
		Result[i] = x[i] > y[i] ? (x[i] > z[i] ? a : c) : (y[i] > z[i] ? b : c);
	return Result;
}

// Max comparison between 4 variables
template<typename T, typename U>
 __inline U associatedMax
(
	T x, U a,
	T y, U b,
	T z, U c,
	T w, U d
)
{
	T Test1 = max(x, y);
	T Test2 = max(z, w);;
	U Result1 = x > y ? a : b;
	U Result2 = z > w ? c : d;
	U Result = Test1 > Test2 ? Result1 : Result2;
	return Result;
}

// Max comparison between 4 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMax
(
	vecType<T, P> __const & x, vecType<U, P> __const & a,
	vecType<T, P> __const & y, vecType<U, P> __const & b,
	vecType<T, P> __const & z, vecType<U, P> __const & c,
	vecType<T, P> __const & w, vecType<U, P> __const & d
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
	{
		T Test1 = max(x[i], y[i]);
		T Test2 = max(z[i], w[i]);
		U Result1 = x[i] > y[i] ? a[i] : b[i];
		U Result2 = z[i] > w[i] ? c[i] : d[i];
		Result[i] = Test1 > Test2 ? Result1 : Result2;
	}
	return Result;
}

// Max comparison between 4 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMax
(
	T x, vecType<U, P> __const & a,
	T y, vecType<U, P> __const & b,
	T z, vecType<U, P> __const & c,
	T w, vecType<U, P> __const & d
)
{
	T Test1 = max(x, y);
	T Test2 = max(z, w);

	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
	{
		U Result1 = x > y ? a[i] : b[i];
		U Result2 = z > w ? c[i] : d[i];
		Result[i] = Test1 > Test2 ? Result1 : Result2;
	}
	return Result;
}

// Max comparison between 4 variables
template<typename T, typename U, precision P, template <typename, precision> class vecType>
 __inline vecType<U, P> associatedMax
(
	vecType<T, P> __const & x, U a,
	vecType<T, P> __const & y, U b,
	vecType<T, P> __const & z, U c,
	vecType<T, P> __const & w, U d
)
{
	vecType<U, P> Result(uninitialize);
	for(length_t i = 0, n = Result.length(); i < n; ++i)
	{
		T Test1 = max(x[i], y[i]);
		T Test2 = max(z[i], w[i]);;
		U Result1 = x[i] > y[i] ? a : b;
		U Result2 = z[i] > w[i] ? c : d;
		Result[i] = Test1 > Test2 ? Result1 : Result2;
	}
	return Result;
}
}//namespace glm

# 202 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 2 3


# 62 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/bit.hpp" 1 3
/// @ref gtx_bit
/// @file glm/gtx/bit.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
///
/// @defgroup gtx_bit GLM_GTX_bit
/// @ingroup gtx
/// 
/// @brief Allow to perform bit operations on integer values
/// 
/// <glm/gtx/bit.hpp> need to be included to use these functionalities.



// Dependencies




       

namespace glm
{
	/// @addtogroup gtx_bit
	/// @{

	/// @see gtx_bit
	template <typename genIUType>
	 genIUType highestBitValue(genIUType Value);

	/// @see gtx_bit
	template <typename genIUType>
	 genIUType lowestBitValue(genIUType Value);

	/// Find the highest bit set to 1 in a integer variable and return its value.
	///
	/// @see gtx_bit
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> highestBitValue(vecType<T, P> __const & value);

	/// Return the power of two number which value is just higher the input value.
	/// Deprecated, use ceilPowerOfTwo from GTC_round instead
	///
	/// @see gtc_round
	/// @see gtx_bit
	template <typename genIUType>
	__attribute__((__deprecated__))  genIUType powerOfTwoAbove(genIUType Value);

	/// Return the power of two number which value is just higher the input value.
	/// Deprecated, use ceilPowerOfTwo from GTC_round instead
	///
	/// @see gtc_round
	/// @see gtx_bit
	template <typename T, precision P, template <typename, precision> class vecType>
	__attribute__((__deprecated__))  vecType<T, P> powerOfTwoAbove(vecType<T, P> __const & value);

	/// Return the power of two number which value is just lower the input value.
	/// Deprecated, use floorPowerOfTwo from GTC_round instead
	///
	/// @see gtc_round
	/// @see gtx_bit
	template <typename genIUType>
	__attribute__((__deprecated__))  genIUType powerOfTwoBelow(genIUType Value);

	/// Return the power of two number which value is just lower the input value.
	/// Deprecated, use floorPowerOfTwo from GTC_round instead
	///
	/// @see gtc_round
	/// @see gtx_bit
	template <typename T, precision P, template <typename, precision> class vecType>
	__attribute__((__deprecated__))  vecType<T, P> powerOfTwoBelow(vecType<T, P> __const & value);

	/// Return the power of two number which value is the closet to the input value.
	/// Deprecated, use roundPowerOfTwo from GTC_round instead
	///
	/// @see gtc_round
	/// @see gtx_bit
	template <typename genIUType>
	__attribute__((__deprecated__))  genIUType powerOfTwoNearest(genIUType Value);

	/// Return the power of two number which value is the closet to the input value.
	/// Deprecated, use roundPowerOfTwo from GTC_round instead
	///
	/// @see gtc_round
	/// @see gtx_bit
	template <typename T, precision P, template <typename, precision> class vecType>
	__attribute__((__deprecated__))  vecType<T, P> powerOfTwoNearest(vecType<T, P> __const & value);

	/// @}
} //namespace glm



# 1 "/usr/local/include/glm/./gtx/bit.inl" 1 3
/// @ref gtx_bit
/// @file glm/gtx/bit.inl

namespace glm
{
	///////////////////
	// highestBitValue

	template <typename genIUType>
	 __inline genIUType highestBitValue(genIUType Value)
	{
		genIUType tmp = Value;
		genIUType result = genIUType(0);
		while(tmp)
		{
			result = (tmp & (~tmp + 1)); // grab lowest bit
			tmp &= ~result; // clear lowest bit
		}
		return result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> highestBitValue(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(highestBitValue, v);
	}

	///////////////////
	// lowestBitValue

	template <typename genIUType>
	 __inline genIUType lowestBitValue(genIUType Value)
	{
		return (Value & (~Value + 1));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> lowestBitValue(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(lowestBitValue, v);
	}

	///////////////////
	// powerOfTwoAbove

	template <typename genType>
	 __inline genType powerOfTwoAbove(genType value)
	{
		return isPowerOfTwo(value) ? value : highestBitValue(value) << 1;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> powerOfTwoAbove(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(powerOfTwoAbove, v);
	}

	///////////////////
	// powerOfTwoBelow

	template <typename genType>
	 __inline genType powerOfTwoBelow(genType value)
	{
		return isPowerOfTwo(value) ? value : highestBitValue(value);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> powerOfTwoBelow(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(powerOfTwoBelow, v);
	}

	/////////////////////
	// powerOfTwoNearest

	template <typename genType>
	 __inline genType powerOfTwoNearest(genType value)
	{
		if(isPowerOfTwo(value))
			return value;

		genType __const prev = highestBitValue(value);
		genType __const next = prev << 1;
		return (next - value) < (value - prev) ? next : prev;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> powerOfTwoNearest(vecType<T, P> __const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(powerOfTwoNearest, v);
	}

}//namespace glm

# 94 "/usr/local/include/glm/./gtx/bit.hpp" 2 3



# 63 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/closest_point.hpp" 1 3
/// @ref gtx_closest_point
/// @file glm/gtx/closest_point.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_closest_point GLM_GTX_closest_point
/// @ingroup gtx
///
/// @brief Find the point on a straight line which is the closet of a point.
///
/// <glm/gtx/closest_point.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_closest_point
	/// @{

	/// Find the point on a straight line which is the closet of a point. 
	/// @see gtx_closest_point
	template <typename T, precision P>
	 tvec3<T, P> closestPointOnLine(
		tvec3<T, P> __const & point,
		tvec3<T, P> __const & a, 
		tvec3<T, P> __const & b);
	
	/// 2d lines work as well	
	template <typename T, precision P>
	 tvec2<T, P> closestPointOnLine(
		tvec2<T, P> __const & point,
		tvec2<T, P> __const & a, 
		tvec2<T, P> __const & b);	

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/closest_point.inl" 1 3
/// @ref gtx_closest_point
/// @file glm/gtx/closest_point.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tvec3<T, P> closestPointOnLine
	(
		tvec3<T, P> __const & point,
		tvec3<T, P> __const & a,
		tvec3<T, P> __const & b
	)
	{
		T LineLength = distance(a, b);
		tvec3<T, P> Vector = point - a;
		tvec3<T, P> LineDirection = (b - a) / LineLength;

		// Project Vector to LineDirection to get the distance of point from a
		T Distance = dot(Vector, LineDirection);

		if(Distance <= T(0)) return a;
		if(Distance >= LineLength) return b;
		return a + LineDirection * Distance;
	}
	
	template <typename T, precision P>
	 __inline tvec2<T, P> closestPointOnLine
	(
		tvec2<T, P> __const & point,
		tvec2<T, P> __const & a,
		tvec2<T, P> __const & b
	)
	{
		T LineLength = distance(a, b);
		tvec2<T, P> Vector = point - a;
		tvec2<T, P> LineDirection = (b - a) / LineLength;

		// Project Vector to LineDirection to get the distance of point from a
		T Distance = dot(Vector, LineDirection);

		if(Distance <= T(0)) return a;
		if(Distance >= LineLength) return b;
		return a + LineDirection * Distance;
	}
	
}//namespace glm

# 45 "/usr/local/include/glm/./gtx/closest_point.hpp" 2 3


# 64 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/color_space.hpp" 1 3
/// @ref gtx_color_space
/// @file glm/gtx/color_space.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_color_space GLM_GTX_color_space
/// @ingroup gtx
///
/// @brief Related to RGB to HSV conversions and operations.
///
/// <glm/gtx/color_space.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_color_space
	/// @{

	/// Converts a color from HSV color space to its color in RGB color space.
	/// @see gtx_color_space
	template <typename T, precision P>
	 tvec3<T, P> rgbColor(
		tvec3<T, P> __const & hsvValue);

	/// Converts a color from RGB color space to its color in HSV color space.
	/// @see gtx_color_space
	template <typename T, precision P>
	 tvec3<T, P> hsvColor(
		tvec3<T, P> __const & rgbValue);
		
	/// Build a saturation matrix.
	/// @see gtx_color_space
	template <typename T>
	 tmat4x4<T, defaultp> saturation(
		T __const s);

	/// Modify the saturation of a color.
	/// @see gtx_color_space
	template <typename T, precision P>
	 tvec3<T, P> saturation(
		T __const s,
		tvec3<T, P> __const & color);
		
	/// Modify the saturation of a color.
	/// @see gtx_color_space
	template <typename T, precision P>
	 tvec4<T, P> saturation(
		T __const s,
		tvec4<T, P> __const & color);
		
	/// Compute color luminosity associating ratios (0.33, 0.59, 0.11) to RGB canals.
	/// @see gtx_color_space
	template <typename T, precision P>
	 T luminosity(
		tvec3<T, P> __const & color);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/color_space.inl" 1 3
/// @ref gtx_color_space
/// @file glm/gtx/color_space.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tvec3<T, P> rgbColor(__const tvec3<T, P>& hsvColor)
	{
		tvec3<T, P> hsv = hsvColor;
		tvec3<T, P> rgbColor;

		if(hsv.y == static_cast<T>(0))
			// achromatic (grey)
			rgbColor = tvec3<T, P>(hsv.z);
		else
		{
			T sector = floor(hsv.x / T(60));
			T frac = (hsv.x / T(60)) - sector;
			// factorial part of h
			T o = hsv.z * (T(1) - hsv.y);
			T p = hsv.z * (T(1) - hsv.y * frac);
			T q = hsv.z * (T(1) - hsv.y * (T(1) - frac));

			switch(int(sector))
			{
			default:
			case 0:
				rgbColor.r = hsv.z;
				rgbColor.g = q;
				rgbColor.b = o;
				break;
			case 1:
				rgbColor.r = p;
				rgbColor.g = hsv.z;
				rgbColor.b = o;
				break;
			case 2:
				rgbColor.r = o;
				rgbColor.g = hsv.z;
				rgbColor.b = q;
				break;
			case 3:
				rgbColor.r = o;
				rgbColor.g = p;
				rgbColor.b = hsv.z;
				break;
			case 4:
				rgbColor.r = q; 
				rgbColor.g = o; 
				rgbColor.b = hsv.z;
				break;
			case 5:
				rgbColor.r = hsv.z; 
				rgbColor.g = o; 
				rgbColor.b = p;
				break;
			}
		}

		return rgbColor;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> hsvColor(__const tvec3<T, P>& rgbColor)
	{
		tvec3<T, P> hsv = rgbColor;
		float Min   = min(min(rgbColor.r, rgbColor.g), rgbColor.b);
		float Max   = max(max(rgbColor.r, rgbColor.g), rgbColor.b);
		float Delta = Max - Min;

		hsv.z = Max;                               

		if(Max != static_cast<T>(0))
		{
			hsv.y = Delta / hsv.z;    
			T h = static_cast<T>(0);

			if(rgbColor.r == Max)
				// between yellow & magenta
				h = static_cast<T>(0) + T(60) * (rgbColor.g - rgbColor.b) / Delta;
			else if(rgbColor.g == Max)
				// between cyan & yellow
				h = static_cast<T>(120) + T(60) * (rgbColor.b - rgbColor.r) / Delta;
			else
				// between magenta & cyan
				h = static_cast<T>(240) + T(60) * (rgbColor.r - rgbColor.g) / Delta;

			if(h < T(0)) 
				hsv.x = h + T(360);
			else
				hsv.x = h;
		}
		else
		{
			// If r = g = b = 0 then s = 0, h is undefined
			hsv.y = static_cast<T>(0);
			hsv.x = static_cast<T>(0);
		}

		return hsv;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> saturation(T __const s)
	{
		tvec3<T, defaultp> rgbw = tvec3<T, defaultp>(T(0.2126), T(0.7152), T(0.0722));

		tvec3<T, defaultp> __const col((T(1) - s) * rgbw);

		tmat4x4<T, defaultp> result(T(1));
		result[0][0] = col.x + s;
		result[0][1] = col.x;
		result[0][2] = col.x;
		result[1][0] = col.y;
		result[1][1] = col.y + s;
		result[1][2] = col.y;
		result[2][0] = col.z;
		result[2][1] = col.z;
		result[2][2] = col.z + s;
		return result;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> saturation(__const T s, __const tvec3<T, P>& color)
	{
		return tvec3<T, P>(saturation(s) * tvec4<T, P>(color, T(0)));
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> saturation(__const T s, __const tvec4<T, P>& color)
	{
		return saturation(s) * color;
	}

	template <typename T, precision P> 
	 __inline T luminosity(__const tvec3<T, P>& color)
	{
		__const tvec3<T, P> tmp = tvec3<T, P>(0.33, 0.59, 0.11);
		return dot(color, tmp);
	}
}//namespace glm

# 68 "/usr/local/include/glm/./gtx/color_space.hpp" 2 3


# 65 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 1 3
/// @ref gtx_color_space_YCoCg
/// @file glm/gtx/color_space_YCoCg.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_color_space_YCoCg GLM_GTX_color_space_YCoCg
/// @ingroup gtx
///
/// @brief RGB to YCoCg conversions and operations
///
/// <glm/gtx/color_space_YCoCg.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_color_space_YCoCg
	/// @{

	/// Convert a color from RGB color space to YCoCg color space.
	/// @see gtx_color_space_YCoCg
	template <typename T, precision P>
	 tvec3<T, P> rgb2YCoCg(
		tvec3<T, P> __const & rgbColor);

	/// Convert a color from YCoCg color space to RGB color space.
	/// @see gtx_color_space_YCoCg
	template <typename T, precision P>
	 tvec3<T, P> YCoCg2rgb(
		tvec3<T, P> __const & YCoCgColor);

	/// Convert a color from RGB color space to YCoCgR color space.
	/// @see "YCoCg-R: A Color Space with RGB Reversibility and Low Dynamic Range"
	/// @see gtx_color_space_YCoCg
	template <typename T, precision P>
	 tvec3<T, P> rgb2YCoCgR(
		tvec3<T, P> __const & rgbColor);

	/// Convert a color from YCoCgR color space to RGB color space.
	/// @see "YCoCg-R: A Color Space with RGB Reversibility and Low Dynamic Range"
	/// @see gtx_color_space_YCoCg
	template <typename T, precision P>
	 tvec3<T, P> YCoCgR2rgb(
		tvec3<T, P> __const & YCoCgColor);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/color_space_YCoCg.inl" 1 3
/// @ref gtx_color_space_YCoCg
/// @file glm/gtx/color_space_YCoCg.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tvec3<T, P> rgb2YCoCg
	(
		tvec3<T, P> __const & rgbColor
	)
	{
		tvec3<T, P> result;
		result.x =   rgbColor.r / T(4) + rgbColor.g / T(2) + rgbColor.b / T(4);
		result.y =   rgbColor.r / T(2) + rgbColor.g * T(0) - rgbColor.b / T(2);
		result.z = - rgbColor.r / T(4) + rgbColor.g / T(2) - rgbColor.b / T(4);
		return result;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> YCoCg2rgb
	(
		tvec3<T, P> __const & YCoCgColor
	)
	{
		tvec3<T, P> result;
		result.r = YCoCgColor.x + YCoCgColor.y - YCoCgColor.z;
		result.g = YCoCgColor.x				   + YCoCgColor.z;
		result.b = YCoCgColor.x - YCoCgColor.y - YCoCgColor.z;
		return result;
	}

	template <typename T, precision P, bool isInteger>
	class compute_YCoCgR {
	public:
		static  __inline tvec3<T, P> rgb2YCoCgR
		(
			tvec3<T, P> __const & rgbColor
		)
		{
			tvec3<T, P> result;
			result.x = rgbColor.g / T(2) + (rgbColor.r + rgbColor.b) / T(4);
			result.y = rgbColor.r - rgbColor.b;
			result.z = rgbColor.g - (rgbColor.r + rgbColor.b) / T(2);
			return result;
		}

		static  __inline tvec3<T, P> YCoCgR2rgb
		(
			tvec3<T, P> __const & YCoCgRColor
		)
		{
			tvec3<T, P> result;
			T tmp = YCoCgRColor.x - (YCoCgRColor.z / T(2));
			result.g = YCoCgRColor.z + tmp;
			result.b = tmp - (YCoCgRColor.y / T(2));
			result.r = result.b + YCoCgRColor.y;
			return result;
		}
	};

	template <typename T, precision P>
	class compute_YCoCgR<T, P, true> {
	public:
		static  __inline tvec3<T, P> rgb2YCoCgR
		(
			tvec3<T, P> __const & rgbColor
		)
		{
			tvec3<T, P> result;
			result.y = rgbColor.r - rgbColor.b;
			T tmp = rgbColor.b + (result.y >> 1);
			result.z = rgbColor.g - tmp;
			result.x = tmp + (result.z >> 1);
			return result;
		}

		static  __inline tvec3<T, P> YCoCgR2rgb
		(
			tvec3<T, P> __const & YCoCgRColor
		)
		{
			tvec3<T, P> result;
			T tmp = YCoCgRColor.x - (YCoCgRColor.z >> 1);
			result.g = YCoCgRColor.z + tmp;
			result.b = tmp - (YCoCgRColor.y >> 1);
			result.r = result.b + YCoCgRColor.y;
			return result;
		}
	};

	template <typename T, precision P>
	 __inline tvec3<T, P> rgb2YCoCgR
	(
		tvec3<T, P> __const & rgbColor
	)
	{
		return compute_YCoCgR<T, P, std::numeric_limits<T>::is_integer>::rgb2YCoCgR(rgbColor);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> YCoCgR2rgb
	(
		tvec3<T, P> __const & YCoCgRColor
	)
	{
		return compute_YCoCgR<T, P, std::numeric_limits<T>::is_integer>::YCoCgR2rgb(YCoCgRColor);
	}
}//namespace glm

# 56 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 2 3


# 66 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/compatibility.hpp" 1 3
/// @ref gtx_compatibility
/// @file glm/gtx/compatibility.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
///
/// @defgroup gtx_compatibility GLM_GTX_compatibility
/// @ingroup gtx
///
/// @brief Provide functions to increase the compatibility with Cg and HLSL languages
///
/// <glm/gtx/compatibility.hpp> need to be included to use these functionalities.



// Dependency:





       








                     

namespace glm
{
	/// @addtogroup gtx_compatibility
	/// @{

	template <typename T>  __inline T lerp(T x, T y, T a){return mix(x, y, a);}																					//!< \brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec2<T, P> lerp(__const tvec2<T, P>& x, __const tvec2<T, P>& y, T a){return mix(x, y, a);}							//!< \brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)

	template <typename T, precision P>  __inline tvec3<T, P> lerp(__const tvec3<T, P>& x, __const tvec3<T, P>& y, T a){return mix(x, y, a);}							//!< \brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec4<T, P> lerp(__const tvec4<T, P>& x, __const tvec4<T, P>& y, T a){return mix(x, y, a);}							//!< \brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec2<T, P> lerp(__const tvec2<T, P>& x, __const tvec2<T, P>& y, __const tvec2<T, P>& a){return mix(x, y, a);}	//!< \brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec3<T, P> lerp(__const tvec3<T, P>& x, __const tvec3<T, P>& y, __const tvec3<T, P>& a){return mix(x, y, a);}	//!< \brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec4<T, P> lerp(__const tvec4<T, P>& x, __const tvec4<T, P>& y, __const tvec4<T, P>& a){return mix(x, y, a);}	//!< \brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)

	template <typename T, precision P>  __inline T saturate(T x){return clamp(x, T(0), T(1));}														//!< \brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec2<T, P> saturate(__const tvec2<T, P>& x){return clamp(x, T(0), T(1));}					//!< \brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec3<T, P> saturate(__const tvec3<T, P>& x){return clamp(x, T(0), T(1));}					//!< \brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec4<T, P> saturate(__const tvec4<T, P>& x){return clamp(x, T(0), T(1));}					//!< \brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)

	template <typename T, precision P>  __inline T atan2(T x, T y){return atan(x, y);}																//!< \brief Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec2<T, P> atan2(__const tvec2<T, P>& x, __const tvec2<T, P>& y){return atan(x, y);}	//!< \brief Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec3<T, P> atan2(__const tvec3<T, P>& x, __const tvec3<T, P>& y){return atan(x, y);}	//!< \brief Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)
	template <typename T, precision P>  __inline tvec4<T, P> atan2(__const tvec4<T, P>& x, __const tvec4<T, P>& y){return atan(x, y);}	//!< \brief Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)

	template <typename genType>  bool isfinite(genType __const & x);											//!< \brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)
	template <typename T, precision P>  tvec1<bool, P> isfinite(__const tvec1<T, P>& x);				//!< \brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)
	template <typename T, precision P>  tvec2<bool, P> isfinite(__const tvec2<T, P>& x);				//!< \brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)
	template <typename T, precision P>  tvec3<bool, P> isfinite(__const tvec3<T, P>& x);				//!< \brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)
	template <typename T, precision P>  tvec4<bool, P> isfinite(__const tvec4<T, P>& x);				//!< \brief Test whether or not a scalar or each vector component is a finite value. (From GLM_GTX_compatibility)

	typedef bool						bool1;			//!< \brief boolean type with 1 component. (From GLM_GTX_compatibility extension)
	typedef tvec2<bool, highp>			bool2;			//!< \brief boolean type with 2 components. (From GLM_GTX_compatibility extension)
	typedef tvec3<bool, highp>			bool3;			//!< \brief boolean type with 3 components. (From GLM_GTX_compatibility extension)
	typedef tvec4<bool, highp>			bool4;			//!< \brief boolean type with 4 components. (From GLM_GTX_compatibility extension)

	typedef bool						bool1x1;		//!< \brief boolean matrix with 1 x 1 component. (From GLM_GTX_compatibility extension)
	typedef tmat2x2<bool, highp>		bool2x2;		//!< \brief boolean matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x3<bool, highp>		bool2x3;		//!< \brief boolean matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x4<bool, highp>		bool2x4;		//!< \brief boolean matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x2<bool, highp>		bool3x2;		//!< \brief boolean matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x3<bool, highp>		bool3x3;		//!< \brief boolean matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x4<bool, highp>		bool3x4;		//!< \brief boolean matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x2<bool, highp>		bool4x2;		//!< \brief boolean matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x3<bool, highp>		bool4x3;		//!< \brief boolean matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x4<bool, highp>		bool4x4;		//!< \brief boolean matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)

	typedef int							int1;			//!< \brief integer vector with 1 component. (From GLM_GTX_compatibility extension)
	typedef tvec2<int, highp>			int2;			//!< \brief integer vector with 2 components. (From GLM_GTX_compatibility extension)
	typedef tvec3<int, highp>			int3;			//!< \brief integer vector with 3 components. (From GLM_GTX_compatibility extension)
	typedef tvec4<int, highp>			int4;			//!< \brief integer vector with 4 components. (From GLM_GTX_compatibility extension)

	typedef int							int1x1;			//!< \brief integer matrix with 1 component. (From GLM_GTX_compatibility extension)
	typedef tmat2x2<int, highp>		int2x2;			//!< \brief integer matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x3<int, highp>		int2x3;			//!< \brief integer matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x4<int, highp>		int2x4;			//!< \brief integer matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x2<int, highp>		int3x2;			//!< \brief integer matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x3<int, highp>		int3x3;			//!< \brief integer matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x4<int, highp>		int3x4;			//!< \brief integer matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x2<int, highp>		int4x2;			//!< \brief integer matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x3<int, highp>		int4x3;			//!< \brief integer matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x4<int, highp>		int4x4;			//!< \brief integer matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)

	typedef float						float1;			//!< \brief single-precision floating-point vector with 1 component. (From GLM_GTX_compatibility extension)
	typedef tvec2<float, highp>		float2;			//!< \brief single-precision floating-point vector with 2 components. (From GLM_GTX_compatibility extension)
	typedef tvec3<float, highp>		float3;			//!< \brief single-precision floating-point vector with 3 components. (From GLM_GTX_compatibility extension)
	typedef tvec4<float, highp>		float4;			//!< \brief single-precision floating-point vector with 4 components. (From GLM_GTX_compatibility extension)

	typedef float						float1x1;		//!< \brief single-precision floating-point matrix with 1 component. (From GLM_GTX_compatibility extension)
	typedef tmat2x2<float, highp>		float2x2;		//!< \brief single-precision floating-point matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x3<float, highp>		float2x3;		//!< \brief single-precision floating-point matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x4<float, highp>		float2x4;		//!< \brief single-precision floating-point matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x2<float, highp>		float3x2;		//!< \brief single-precision floating-point matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x3<float, highp>		float3x3;		//!< \brief single-precision floating-point matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x4<float, highp>		float3x4;		//!< \brief single-precision floating-point matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x2<float, highp>		float4x2;		//!< \brief single-precision floating-point matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x3<float, highp>		float4x3;		//!< \brief single-precision floating-point matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x4<float, highp>		float4x4;		//!< \brief single-precision floating-point matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)

	typedef double						double1;		//!< \brief double-precision floating-point vector with 1 component. (From GLM_GTX_compatibility extension)
	typedef tvec2<double, highp>		double2;		//!< \brief double-precision floating-point vector with 2 components. (From GLM_GTX_compatibility extension)
	typedef tvec3<double, highp>		double3;		//!< \brief double-precision floating-point vector with 3 components. (From GLM_GTX_compatibility extension)
	typedef tvec4<double, highp>		double4;		//!< \brief double-precision floating-point vector with 4 components. (From GLM_GTX_compatibility extension)

	typedef double						double1x1;		//!< \brief double-precision floating-point matrix with 1 component. (From GLM_GTX_compatibility extension)
	typedef tmat2x2<double, highp>		double2x2;		//!< \brief double-precision floating-point matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x3<double, highp>		double2x3;		//!< \brief double-precision floating-point matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat2x4<double, highp>		double2x4;		//!< \brief double-precision floating-point matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x2<double, highp>		double3x2;		//!< \brief double-precision floating-point matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x3<double, highp>		double3x3;		//!< \brief double-precision floating-point matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat3x4<double, highp>		double3x4;		//!< \brief double-precision floating-point matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x2<double, highp>		double4x2;		//!< \brief double-precision floating-point matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x3<double, highp>		double4x3;		//!< \brief double-precision floating-point matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)
	typedef tmat4x4<double, highp>		double4x4;		//!< \brief double-precision floating-point matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/compatibility.inl" 1 3
/// @ref gtx_compatibility
/// @file glm/gtx/compatibility.inl



namespace glm
{
	// isfinite
	template <typename genType>
	 __inline bool isfinite(
		genType __const & x)
	{






        
			if (std::numeric_limits<genType>::is_integer || std::denorm_absent == std::numeric_limits<genType>::has_denorm)
				return std::numeric_limits<genType>::min() <= x && std::numeric_limits<genType>::max() >= x;
			else
				return -std::numeric_limits<genType>::max() <= x && std::numeric_limits<genType>::max() >= x;

	}

	template <typename T, precision P>
	 __inline tvec1<bool, P> isfinite(
		tvec1<T, P> __const & x)
	{
		return tvec1<bool, P>(
			isfinite(x.x));
	}

	template <typename T, precision P>
	 __inline tvec2<bool, P> isfinite(
		tvec2<T, P> __const & x)
	{
		return tvec2<bool, P>(
			isfinite(x.x),
			isfinite(x.y));
	}

	template <typename T, precision P>
	 __inline tvec3<bool, P> isfinite(
		tvec3<T, P> __const & x)
	{
		return tvec3<bool, P>(
			isfinite(x.x),
			isfinite(x.y),
			isfinite(x.z));
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> isfinite(
		tvec4<T, P> __const & x)
	{
		return tvec4<bool, P>(
			isfinite(x.x),
			isfinite(x.y),
			isfinite(x.z),
			isfinite(x.w));
	}

}//namespace glm

# 130 "/usr/local/include/glm/./gtx/compatibility.hpp" 2 3


# 67 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/component_wise.hpp" 1 3
/// @ref gtx_component_wise
/// @file glm/gtx/component_wise.hpp
/// @date 2007-05-21 / 2011-06-07
/// @author Christophe Riccio
/// 
/// @see core (dependence)
///
/// @defgroup gtx_component_wise GLM_GTX_component_wise
/// @ingroup gtx
///
/// @brief Operations between components of a type
///
/// <glm/gtx/component_wise.hpp> need to be included to use these functionalities.



// Dependencies





       

namespace glm
{
	/// @addtogroup gtx_component_wise
	/// @{

	/// Convert an integer vector to a normalized float vector.
	/// If the parameter value type is already a floating precision type, the value is passed through.
	/// @see gtx_component_wise
	template <typename floatType, typename T, precision P, template <typename, precision> class vecType>
	 vecType<floatType, P> compNormalize(vecType<T, P> __const & v);

	/// Convert a normalized float vector to an integer vector.
	/// If the parameter value type is already a floating precision type, the value is passed through.
	/// @see gtx_component_wise
	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	 vecType<T, P> compScale(vecType<floatType, P> __const & v);

	/// Add all vector components together. 
	/// @see gtx_component_wise
	template <typename genType> 
	 typename genType::value_type compAdd(genType __const & v);

	/// Multiply all vector components together. 
	/// @see gtx_component_wise
	template <typename genType> 
	 typename genType::value_type compMul(genType __const & v);

	/// Find the minimum value between single vector components.
	/// @see gtx_component_wise
	template <typename genType> 
	 typename genType::value_type compMin(genType __const & v);

	/// Find the maximum value between single vector components.
	/// @see gtx_component_wise
	template <typename genType> 
	 typename genType::value_type compMax(genType __const & v);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/component_wise.inl" 1 3
/// @ref gtx_component_wise
/// @file glm/gtx/component_wise.inl



namespace glm{
namespace detail
{
	template <typename T, typename floatType, precision P, template <typename, precision> class vecType, bool isInteger, bool signedType>
	struct compute_compNormalize
	{};

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	struct compute_compNormalize<T, floatType, P, vecType, true, true>
	{
		 __inline static vecType<floatType, P> call(vecType<T, P> __const & v)
		{
			floatType __const Min = static_cast<floatType>(std::numeric_limits<T>::min());
			floatType __const Max = static_cast<floatType>(std::numeric_limits<T>::max());
			return (vecType<floatType, P>(v) - Min) / (Max - Min) * static_cast<floatType>(2) - static_cast<floatType>(1);
		}
	};

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	struct compute_compNormalize<T, floatType, P, vecType, true, false>
	{
		 __inline static vecType<floatType, P> call(vecType<T, P> __const & v)
		{
			return vecType<floatType, P>(v) / static_cast<floatType>(std::numeric_limits<T>::max());
		}
	};

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	struct compute_compNormalize<T, floatType, P, vecType, false, true>
	{
		 __inline static vecType<floatType, P> call(vecType<T, P> __const & v)
		{
			return v;
		}
	};

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType, bool isInteger, bool signedType>
	struct compute_compScale
	{};

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	struct compute_compScale<T, floatType, P, vecType, true, true>
	{
		 __inline static vecType<T, P> call(vecType<floatType, P> __const & v)
		{
			floatType __const Max = static_cast<floatType>(std::numeric_limits<T>::max()) + static_cast<floatType>(0.5);
			vecType<floatType, P> __const Scaled(v * Max);
			vecType<T, P> __const Result(Scaled - static_cast<floatType>(0.5));
			return Result;
		}
	};

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	struct compute_compScale<T, floatType, P, vecType, true, false>
	{
		 __inline static vecType<T, P> call(vecType<floatType, P> __const & v)
		{
			return vecType<T, P>(vecType<floatType, P>(v) * static_cast<floatType>(std::numeric_limits<T>::max()));
		}
	};

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	struct compute_compScale<T, floatType, P, vecType, false, true>
	{
		 __inline static vecType<T, P> call(vecType<floatType, P> __const & v)
		{
			return v;
		}
	};
}//namespace detail

	template <typename floatType, typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<floatType, P> compNormalize(vecType<T, P> __const & v)
	{
		;

		return detail::compute_compNormalize<T, floatType, P, vecType, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
	}

	template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> compScale(vecType<floatType, P> __const & v)
	{
		;

		return detail::compute_compScale<T, floatType, P, vecType, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T compAdd(vecType<T, P> __const & v)
	{
		T Result(0);
		for(length_t i = 0, n = v.length(); i < n; ++i)
			Result += v[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T compMul(vecType<T, P> __const & v)
	{
		T Result(1);
		for(length_t i = 0, n = v.length(); i < n; ++i)
			Result *= v[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T compMin(vecType<T, P> __const & v)
	{
		T Result(v[0]);
		for(length_t i = 1, n = v.length(); i < n; ++i)
			Result = min(Result, v[i]);
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T compMax(vecType<T, P> __const & v)
	{
		T Result(v[0]);
		for(length_t i = 1, n = v.length(); i < n; ++i)
			Result = max(Result, v[i]);
		return Result;
	}
}//namespace glm

# 65 "/usr/local/include/glm/./gtx/component_wise.hpp" 2 3


# 68 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 1 3
/// @ref gtx_dual_quaternion
/// @file glm/gtx/dual_quaternion.hpp
/// @author Maksim Vorobiev (msomeone@gmail.com)
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtc_constants (dependence)
/// @see gtc_quaternion (dependence)
///
/// @defgroup gtx_dual_quaternion GLM_GTX_dual_quaternion
/// @ingroup gtx
///
/// @brief Defines a templated dual-quaternion type and several dual-quaternion operations.
///
/// <glm/gtx/dual_quaternion.hpp> need to be included to use these functionalities.



// Dependency:






       

namespace glm
{
	/// @addtogroup gtx_dual_quaternion
	/// @{

	template <typename T, precision P = defaultp>
	struct tdualquat
	{
		// -- Implementation detail --

		typedef T value_type;
		typedef glm::tquat<T, P> part_type;

		// -- Data --

		glm::tquat<T, P> real, dual;

		// -- Component accesses --

		typedef length_t length_type;
		/// Return the count of components of a dual quaternion
		 static length_type length(){return 2;}

		 part_type & operator[](length_type i);
		 part_type __const & operator[](length_type i) __const;

		// -- Implicit basic constructors --

		  tdualquat() ;
		  tdualquat(tdualquat<T, P> __const & d) ;
		template <precision Q>
		  tdualquat(tdualquat<T, Q> __const & d);

		// -- Explicit basic constructors --

		  explicit tdualquat(ctor);
		  tdualquat(tquat<T, P> __const & real);
		  tdualquat(tquat<T, P> __const & orientation, tvec3<T, P> __const & translation);
		  tdualquat(tquat<T, P> __const & real, tquat<T, P> __const & dual);

		// -- Conversion constructors --

		template <typename U, precision Q>
		   tdualquat(tdualquat<U, Q> __const & q);

		  tdualquat(tmat2x4<T, P> __const & holder_mat);
		  tdualquat(tmat3x4<T, P> __const & aug_mat);

		// -- Unary arithmetic operators --

		 tdualquat<T, P> & operator=(tdualquat<T, P> __const & m) ;

		template <typename U>
		 tdualquat<T, P> & operator=(tdualquat<U, P> __const & m);
		template <typename U>
		 tdualquat<T, P> & operator*=(U s);
		template <typename U>
		 tdualquat<T, P> & operator/=(U s);
	};

	// -- Unary bit operators --

	template <typename T, precision P>
	 tdualquat<T, P> operator+(tdualquat<T, P> __const & q);

	template <typename T, precision P>
	 tdualquat<T, P> operator-(tdualquat<T, P> __const & q);

	// -- Binary operators --

	template <typename T, precision P>
	 tdualquat<T, P> operator+(tdualquat<T, P> __const & q, tdualquat<T, P> __const & p);

	template <typename T, precision P>
	 tdualquat<T, P> operator*(tdualquat<T, P> __const & q, tdualquat<T, P> __const & p);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tdualquat<T, P> __const & q, tvec3<T, P> __const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> __const & v, tdualquat<T, P> __const & q);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tdualquat<T, P> __const & q, tvec4<T, P> __const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> __const & v, tdualquat<T, P> __const & q);

	template <typename T, precision P>
	 tdualquat<T, P> operator*(tdualquat<T, P> __const & q, T __const & s);

	template <typename T, precision P>
	 tdualquat<T, P> operator*(T __const & s, tdualquat<T, P> __const & q);

	template <typename T, precision P>
	 tdualquat<T, P> operator/(tdualquat<T, P> __const & q, T __const & s);

	// -- Boolean operators --

	template <typename T, precision P>
	 bool operator==(tdualquat<T, P> __const & q1, tdualquat<T, P> __const & q2);

	template <typename T, precision P>
	 bool operator!=(tdualquat<T, P> __const & q1, tdualquat<T, P> __const & q2);

	/// Returns the normalized quaternion.
	///
	/// @see gtx_dual_quaternion
	template <typename T, precision P>
	 tdualquat<T, P> normalize(tdualquat<T, P> __const & q);

	/// Returns the linear interpolation of two dual quaternion.
	///
	/// @see gtc_dual_quaternion
	template <typename T, precision P>
	 tdualquat<T, P> lerp(tdualquat<T, P> __const & x, tdualquat<T, P> __const & y, T __const & a);

	/// Returns the q inverse.
	///
	/// @see gtx_dual_quaternion
	template <typename T, precision P>
	 tdualquat<T, P> inverse(tdualquat<T, P> __const & q);

	/// Converts a quaternion to a 2 * 4 matrix.
	///
	/// @see gtx_dual_quaternion
	template <typename T, precision P>
	 tmat2x4<T, P> mat2x4_cast(tdualquat<T, P> __const & x);

	/// Converts a quaternion to a 3 * 4 matrix.
	///
	/// @see gtx_dual_quaternion
	template <typename T, precision P>
	 tmat3x4<T, P> mat3x4_cast(tdualquat<T, P> __const & x);

	/// Converts a 2 * 4 matrix (matrix which holds real and dual parts) to a quaternion.
	///
	/// @see gtx_dual_quaternion
	template <typename T, precision P>
	 tdualquat<T, P> dualquat_cast(tmat2x4<T, P> __const & x);

	/// Converts a 3 * 4 matrix (augmented matrix rotation + translation) to a quaternion.
	///
	/// @see gtx_dual_quaternion
	template <typename T, precision P>
	 tdualquat<T, P> dualquat_cast(tmat3x4<T, P> __const & x);


	/// Dual-quaternion of low single-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<float, lowp>		lowp_dualquat;

	/// Dual-quaternion of medium single-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<float, mediump>	mediump_dualquat;

	/// Dual-quaternion of high single-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<float, highp>		highp_dualquat;


	/// Dual-quaternion of low single-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<float, lowp>		lowp_fdualquat;

	/// Dual-quaternion of medium single-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<float, mediump>	mediump_fdualquat;

	/// Dual-quaternion of high single-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<float, highp>		highp_fdualquat;


	/// Dual-quaternion of low double-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<double, lowp>		lowp_ddualquat;

	/// Dual-quaternion of medium double-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<double, mediump>	mediump_ddualquat;

	/// Dual-quaternion of high double-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef tdualquat<double, highp>	highp_ddualquat;



	/// Dual-quaternion of floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef highp_fdualquat			dualquat;

	/// Dual-quaternion of single-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef highp_fdualquat			fdualquat;

# 245 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 3
       



	/// Dual-quaternion of default double-precision floating-point numbers.
	///
	/// @see gtx_dual_quaternion
	typedef highp_ddualquat			ddualquat;








       

	/// @}
} //namespace glm


# 1 "/usr/local/include/glm/./gtx/dual_quaternion.inl" 1 3
/// @ref gtx_dual_quaternion
/// @file glm/gtx/dual_quaternion.inl




namespace glm
{
	// -- Component accesses --

	template <typename T, precision P>
	 __inline typename tdualquat<T, P>::part_type & tdualquat<T, P>::operator[](typename tdualquat<T, P>::length_type i)
	{
		assert(i >= 0 && i < this->length());
		return (&real)[i];
	}

	template <typename T, precision P>
	 __inline typename tdualquat<T, P>::part_type __const & tdualquat<T, P>::operator[](typename tdualquat<T, P>::length_type i) __const
	{
		assert(i >= 0 && i < this->length());
		return (&real)[i];
	}

	// -- Implicit basic constructors --


		template <typename T, precision P>
		 __inline  tdualquat<T, P>::tdualquat()

				: real(tquat<T, P>())
				, dual(tquat<T, P>(0, 0, 0, 0))

		{}



		template <typename T, precision P>
		 __inline  tdualquat<T, P>::tdualquat(tdualquat<T, P> __const & d)
			: real(d.real)
			, dual(d.dual)
		{}


	template <typename T, precision P>
	template <precision Q>
	 __inline  tdualquat<T, P>::tdualquat(tdualquat<T, Q> __const & d)
		: real(d.real)
		, dual(d.dual)
	{}

	// -- Explicit basic constructors --

	template <typename T, precision P>
	 __inline  tdualquat<T, P>::tdualquat(ctor)
	{}

	template <typename T, precision P>
	 __inline  tdualquat<T, P>::tdualquat(tquat<T, P> __const & r)
		: real(r), dual(tquat<T, P>(0, 0, 0, 0))
	{}

	template <typename T, precision P>
	 __inline  tdualquat<T, P>::tdualquat(tquat<T, P> __const & q, tvec3<T, P> __const& p)
		: real(q), dual(
			T(-0.5) * ( p.x*q.x + p.y*q.y + p.z*q.z),
			T(+0.5) * ( p.x*q.w + p.y*q.z - p.z*q.y),
			T(+0.5) * (-p.x*q.z + p.y*q.w + p.z*q.x),
			T(+0.5) * ( p.x*q.y - p.y*q.x + p.z*q.w))
	{}

	template <typename T, precision P>
	 __inline  tdualquat<T, P>::tdualquat(tquat<T, P> __const & r, tquat<T, P> __const & d)
		: real(r), dual(d)
	{}

	// -- Conversion constructors --

	template <typename T, precision P>
	template <typename U, precision Q>
	 __inline  tdualquat<T, P>::tdualquat(tdualquat<U, Q> __const & q)
		: real(q.real)
		, dual(q.dual)
	{}

	template <typename T, precision P>
	 __inline tdualquat<T, P>::tdualquat(tmat2x4<T, P> __const & m)
	{
		*this = dualquat_cast(m);
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P>::tdualquat(tmat3x4<T, P> __const & m)
	{
		*this = dualquat_cast(m);
	}

	// -- Unary arithmetic operators --


		template <typename T, precision P>
		 __inline tdualquat<T, P> & tdualquat<T, P>::operator=(tdualquat<T, P> __const & q)
		{
			this->real = q.real;
			this->dual = q.dual;
			return *this;
		}


	template <typename T, precision P>
	template <typename U>
	 __inline tdualquat<T, P> & tdualquat<T, P>::operator=(tdualquat<U, P> __const & q)
	{
		this->real = q.real;
		this->dual = q.dual;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tdualquat<T, P> & tdualquat<T, P>::operator*=(U s)
	{
		this->real *= static_cast<T>(s);
		this->dual *= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 __inline tdualquat<T, P> & tdualquat<T, P>::operator/=(U s)
	{
		this->real /= static_cast<T>(s);
		this->dual /= static_cast<T>(s);
		return *this;
	}

	// -- Unary bit operators --

	template <typename T, precision P>
	 __inline tdualquat<T, P> operator+(tdualquat<T, P> __const & q)
	{
		return q;
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> operator-(tdualquat<T, P> __const & q)
	{
		return tdualquat<T, P>(-q.real, -q.dual);
	}

	// -- Binary operators --

	template <typename T, precision P>
	 __inline tdualquat<T, P> operator+(tdualquat<T, P> __const & q, tdualquat<T, P> __const & p)
	{
		return tdualquat<T, P>(q.real + p.real,q.dual + p.dual);
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> operator*(tdualquat<T, P> __const & p, tdualquat<T, P> __const & o)
	{
		return tdualquat<T, P>(p.real * o.real,p.real * o.dual + p.dual * o.real);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tdualquat<T, P> __const & q, tvec3<T, P> __const & v)
	{
		tvec3<T, P> __const real_v3(q.real.x,q.real.y,q.real.z);
		tvec3<T, P> __const dual_v3(q.dual.x,q.dual.y,q.dual.z);
		return (cross(real_v3, cross(real_v3,v) + v * q.real.w + dual_v3) + dual_v3 * q.real.w - real_v3 * q.dual.w) * T(2) + v;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> operator*(tvec3<T, P> __const & v,	tdualquat<T, P> __const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tdualquat<T, P> __const & q, tvec4<T, P> __const & v)
	{
		return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> operator*(tvec4<T, P> __const & v,	tdualquat<T, P> __const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> operator*(tdualquat<T, P> __const & q, T __const & s)
	{
		return tdualquat<T, P>(q.real * s, q.dual * s);
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> operator*(T __const & s, tdualquat<T, P> __const & q)
	{
		return q * s;
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> operator/(tdualquat<T, P> __const & q,	T __const & s)
	{
		return tdualquat<T, P>(q.real / s, q.dual / s);
	}

	// -- Boolean operators --

	template <typename T, precision P>
	 __inline bool operator==(tdualquat<T, P> __const & q1, tdualquat<T, P> __const & q2)
	{
		return (q1.real == q2.real) && (q1.dual == q2.dual);
	}

	template <typename T, precision P>
	 __inline bool operator!=(tdualquat<T, P> __const & q1, tdualquat<T, P> __const & q2)
	{
		return (q1.real != q2.dual) || (q1.real != q2.dual);
	}

	// -- Operations --

	template <typename T, precision P>
	 __inline tdualquat<T, P> normalize(tdualquat<T, P> __const & q)
	{
		return q / length(q.real);
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> lerp(tdualquat<T, P> __const & x, tdualquat<T, P> __const & y, T __const & a)
	{
		// Dual Quaternion Linear blend aka DLB:
		// Lerp is only defined in [0, 1]
		assert(a >= static_cast<T>(0));
		assert(a <= static_cast<T>(1));
		T __const k = dot(x.real,y.real) < static_cast<T>(0) ? -a : a;
		T __const one(1);
		return tdualquat<T, P>(x * (one - a) + y * k);
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> inverse(tdualquat<T, P> __const & q)
	{
		__const glm::tquat<T, P> real = conjugate(q.real);
		__const glm::tquat<T, P> dual = conjugate(q.dual);
		return tdualquat<T, P>(real, dual + (real * (-2.0f * dot(real,dual))));
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> mat2x4_cast(tdualquat<T, P> __const & x)
	{
		return tmat2x4<T, P>( x[0].x, x[0].y, x[0].z, x[0].w, x[1].x, x[1].y, x[1].z, x[1].w );
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> mat3x4_cast(tdualquat<T, P> __const & x)
	{
		tquat<T, P> r = x.real / length2(x.real);
		
		tquat<T, P> __const rr(r.w * x.real.w, r.x * x.real.x, r.y * x.real.y, r.z * x.real.z);
		r *= static_cast<T>(2);
		
		T __const xy = r.x * x.real.y;
		T __const xz = r.x * x.real.z;
		T __const yz = r.y * x.real.z;
		T __const wx = r.w * x.real.x;
		T __const wy = r.w * x.real.y;
		T __const wz = r.w * x.real.z;
		
		tvec4<T, P> __const a(
			rr.w + rr.x - rr.y - rr.z,
			xy - wz,
			xz + wy,
			-(x.dual.w * r.x - x.dual.x * r.w + x.dual.y * r.z - x.dual.z * r.y));
		
		tvec4<T, P> __const b(
			xy + wz,
			rr.w + rr.y - rr.x - rr.z,
			yz - wx,
			-(x.dual.w * r.y - x.dual.x * r.z - x.dual.y * r.w + x.dual.z * r.x));
		
		tvec4<T, P> __const c(
			xz - wy,
			yz + wx,
			rr.w + rr.z - rr.x - rr.y,
			-(x.dual.w * r.z + x.dual.x * r.y - x.dual.y * r.x - x.dual.z * r.w));
		
		return tmat3x4<T, P>(a, b, c);
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> dualquat_cast(tmat2x4<T, P> __const & x)
	{
		return tdualquat<T, P>(
			tquat<T, P>( x[0].w, x[0].x, x[0].y, x[0].z ),
			tquat<T, P>( x[1].w, x[1].x, x[1].y, x[1].z ));
	}

	template <typename T, precision P>
	 __inline tdualquat<T, P> dualquat_cast(tmat3x4<T, P> __const & x)
	{
		tquat<T, P> real(uninitialize);
		
		T __const trace = x[0].x + x[1].y + x[2].z;
		if(trace > static_cast<T>(0))
		{
			T __const r = sqrt(T(1) + trace);
			T __const invr = static_cast<T>(0.5) / r;
			real.w = static_cast<T>(0.5) * r;
			real.x = (x[2].y - x[1].z) * invr;
			real.y = (x[0].z - x[2].x) * invr;
			real.z = (x[1].x - x[0].y) * invr;
		}
		else if(x[0].x > x[1].y && x[0].x > x[2].z)
		{
			T __const r = sqrt(T(1) + x[0].x - x[1].y - x[2].z);
			T __const invr = static_cast<T>(0.5) / r;
			real.x = static_cast<T>(0.5)*r;
			real.y = (x[1].x + x[0].y) * invr;
			real.z = (x[0].z + x[2].x) * invr;
			real.w = (x[2].y - x[1].z) * invr;
		}
		else if(x[1].y > x[2].z)
		{
			T __const r = sqrt(T(1) + x[1].y - x[0].x - x[2].z);
			T __const invr = static_cast<T>(0.5) / r;
			real.x = (x[1].x + x[0].y) * invr;
			real.y = static_cast<T>(0.5) * r;
			real.z = (x[2].y + x[1].z) * invr;
			real.w = (x[0].z - x[2].x) * invr;
		}
		else
		{
			T __const r = sqrt(T(1) + x[2].z - x[0].x - x[1].y);
			T __const invr = static_cast<T>(0.5) / r;
			real.x = (x[0].z + x[2].x) * invr;
			real.y = (x[2].y + x[1].z) * invr;
			real.z = static_cast<T>(0.5) * r;
			real.w = (x[1].x - x[0].y) * invr;
		}
		
		tquat<T, P> dual(uninitialize);
		dual.x =  static_cast<T>(0.5) * ( x[0].w * real.w + x[1].w * real.z - x[2].w * real.y);
		dual.y =  static_cast<T>(0.5) * (-x[0].w * real.z + x[1].w * real.w + x[2].w * real.x);
		dual.z =  static_cast<T>(0.5) * ( x[0].w * real.y - x[1].w * real.x + x[2].w * real.w);
		dual.w = -static_cast<T>(0.5) * ( x[0].w * real.x + x[1].w * real.y + x[2].w * real.z);
		return tdualquat<T, P>(real, dual);
	}
}//namespace glm

# 266 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 2 3


# 69 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/euler_angles.hpp" 1 3
/// @ref gtx_euler_angles
/// @file glm/gtx/euler_angles.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
///
/// @defgroup gtx_euler_angles GLM_GTX_euler_angles
/// @ingroup gtx
///
/// @brief Build matrices from Euler angles.
///
/// <glm/gtx/euler_angles.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_euler_angles
	/// @{

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from an euler angle X.
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleX(
		T __const & angleX);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from an euler angle Y.
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleY(
		T __const & angleY);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from an euler angle Z.
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleZ(
		T __const & angleZ);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Y).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleXY(
		T __const & angleX,
		T __const & angleY);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleYX(
		T __const & angleY,
		T __const & angleX);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Z).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleXZ(
		T __const & angleX,
		T __const & angleZ);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * X).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleZX(
		T __const & angle,
		T __const & angleX);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * Z).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleYZ(
		T __const & angleY,
		T __const & angleZ);

	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Z * Y).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleZY(
		T __const & angleZ,
		T __const & angleY);

    /// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (X * Y * Z).
    /// @see gtx_euler_angles
    template <typename T>
     tmat4x4<T, defaultp> eulerAngleXYZ(
        T __const & t1,
        T __const & t2,
        T __const & t3);
    
	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X * Z).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> eulerAngleYXZ(
		T __const & yaw,
		T __const & pitch,
		T __const & roll);
    
	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X * Z).
	/// @see gtx_euler_angles
	template <typename T>
	 tmat4x4<T, defaultp> yawPitchRoll(
		T __const & yaw,
		T __const & pitch,
		T __const & roll);

	/// Creates a 2D 2 * 2 rotation matrix from an euler angle.
	/// @see gtx_euler_angles
	template <typename T>
	 tmat2x2<T, defaultp> orientate2(T __const & angle);

	/// Creates a 2D 4 * 4 homogeneous rotation matrix from an euler angle.
	/// @see gtx_euler_angles
	template <typename T>
	 tmat3x3<T, defaultp> orientate3(T __const & angle);

	/// Creates a 3D 3 * 3 rotation matrix from euler angles (Y * X * Z). 
	/// @see gtx_euler_angles
	template <typename T, precision P>
	 tmat3x3<T, P> orientate3(tvec3<T, P> __const & angles);
		
	/// Creates a 3D 4 * 4 homogeneous rotation matrix from euler angles (Y * X * Z).
	/// @see gtx_euler_angles
	template <typename T, precision P>
	 tmat4x4<T, P> orientate4(tvec3<T, P> __const & angles);

    /// Extracts the (X * Y * Z) Euler angles from the rotation matrix M
    /// @see gtx_euler_angles
    template <typename T>
     void extractEulerAngleXYZ(tmat4x4<T, defaultp> __const & M,
                                            T & t1,
                                            T & t2,
                                            T & t3);
    
	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/euler_angles.inl" 1 3
/// @ref gtx_euler_angles
/// @file glm/gtx/euler_angles.inl



namespace glm
{
	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleX
	(
		T __const & angleX
	)
	{
		T cosX = glm::cos(angleX);
		T sinX = glm::sin(angleX);
	
		return tmat4x4<T, defaultp>(
			T(1), T(0), T(0), T(0),
			T(0), cosX, sinX, T(0),
			T(0),-sinX, cosX, T(0),
			T(0), T(0), T(0), T(1));
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleY
	(
		T __const & angleY
	)
	{
		T cosY = glm::cos(angleY);
		T sinY = glm::sin(angleY);

		return tmat4x4<T, defaultp>(
			cosY,	T(0),	-sinY,	T(0),
			T(0),	T(1),	T(0),	T(0),
			sinY,	T(0),	cosY,	T(0),
			T(0),	T(0),	T(0),	T(1));
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleZ
	(
		T __const & angleZ
	)
	{
		T cosZ = glm::cos(angleZ);
		T sinZ = glm::sin(angleZ);

		return tmat4x4<T, defaultp>(
			cosZ,	sinZ,	T(0), T(0),
			-sinZ,	cosZ,	T(0), T(0),
			T(0),	T(0),	T(1), T(0),
			T(0),	T(0),	T(0), T(1));
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleXY
	(
		T __const & angleX,
		T __const & angleY
	)
	{
		T cosX = glm::cos(angleX);
		T sinX = glm::sin(angleX);
		T cosY = glm::cos(angleY);
		T sinY = glm::sin(angleY);

		return tmat4x4<T, defaultp>(
			cosY,   -sinX * -sinY,  cosX * -sinY,   T(0),
			T(0),   cosX,           sinX,           T(0),
			sinY,   -sinX * cosY,   cosX * cosY,    T(0),
			T(0),   T(0),           T(0),           T(1));
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleYX
	(
		T __const & angleY,
		T __const & angleX
	)
	{
		T cosX = glm::cos(angleX);
		T sinX = glm::sin(angleX);
		T cosY = glm::cos(angleY);
		T sinY = glm::sin(angleY);

		return tmat4x4<T, defaultp>(
			cosY,          0,      -sinY,    T(0),
			sinY * sinX,  cosX, cosY * sinX, T(0),
			sinY * cosX, -sinX, cosY * cosX, T(0),
			T(0),         T(0),     T(0),    T(1));
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleXZ
	(
		T __const & angleX,
		T __const & angleZ
	)
	{
		return eulerAngleX(angleX) * eulerAngleZ(angleZ);
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleZX
	(
		T __const & angleZ,
		T __const & angleX
	)
	{
		return eulerAngleZ(angleZ) * eulerAngleX(angleX);
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleYZ
	(
		T __const & angleY,
		T __const & angleZ
	)
	{
		return eulerAngleY(angleY) * eulerAngleZ(angleZ);
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleZY
	(
		T __const & angleZ,
		T __const & angleY
	)
	{
		return eulerAngleZ(angleZ) * eulerAngleY(angleY);
	}
    
    template <typename T>
     __inline tmat4x4<T, defaultp> eulerAngleXYZ
    (
     T __const & t1,
     T __const & t2,
     T __const & t3
     )
    {
        T c1 = glm::cos(-t1);
        T c2 = glm::cos(-t2);
        T c3 = glm::cos(-t3);
        T s1 = glm::sin(-t1);
        T s2 = glm::sin(-t2);
        T s3 = glm::sin(-t3);
        
        tmat4x4<T, defaultp> Result;
        Result[0][0] = c2 * c3;
        Result[0][1] =-c1 * s3 + s1 * s2 * c3;
        Result[0][2] = s1 * s3 + c1 * s2 * c3;
        Result[0][3] = static_cast<T>(0);
        Result[1][0] = c2 * s3;
        Result[1][1] = c1 * c3 + s1 * s2 * s3;
        Result[1][2] =-s1 * c3 + c1 * s2 * s3;
        Result[1][3] = static_cast<T>(0);
        Result[2][0] =-s2;
        Result[2][1] = s1 * c2;
        Result[2][2] = c1 * c2;
        Result[2][3] = static_cast<T>(0);
        Result[3][0] = static_cast<T>(0);
        Result[3][1] = static_cast<T>(0);
        Result[3][2] = static_cast<T>(0);
        Result[3][3] = static_cast<T>(1);
        return Result;
    }
    
	template <typename T>
	 __inline tmat4x4<T, defaultp> eulerAngleYXZ
	(
		T __const & yaw,
		T __const & pitch,
		T __const & roll
	)
	{
		T tmp_ch = glm::cos(yaw);
		T tmp_sh = glm::sin(yaw);
		T tmp_cp = glm::cos(pitch);
		T tmp_sp = glm::sin(pitch);
		T tmp_cb = glm::cos(roll);
		T tmp_sb = glm::sin(roll);

		tmat4x4<T, defaultp> Result;
		Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
		Result[0][1] = tmp_sb * tmp_cp;
		Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
		Result[0][3] = static_cast<T>(0);
		Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
		Result[1][1] = tmp_cb * tmp_cp;
		Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
		Result[1][3] = static_cast<T>(0);
		Result[2][0] = tmp_sh * tmp_cp;
		Result[2][1] = -tmp_sp;
		Result[2][2] = tmp_ch * tmp_cp;
		Result[2][3] = static_cast<T>(0);
		Result[3][0] = static_cast<T>(0);
		Result[3][1] = static_cast<T>(0);
		Result[3][2] = static_cast<T>(0);
		Result[3][3] = static_cast<T>(1);
		return Result;
	}

	template <typename T>
	 __inline tmat4x4<T, defaultp> yawPitchRoll
	(
		T __const & yaw,
		T __const & pitch,
		T __const & roll
	)
	{
		T tmp_ch = glm::cos(yaw);
		T tmp_sh = glm::sin(yaw);
		T tmp_cp = glm::cos(pitch);
		T tmp_sp = glm::sin(pitch);
		T tmp_cb = glm::cos(roll);
		T tmp_sb = glm::sin(roll);

		tmat4x4<T, defaultp> Result;
		Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
		Result[0][1] = tmp_sb * tmp_cp;
		Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
		Result[0][3] = static_cast<T>(0);
		Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
		Result[1][1] = tmp_cb * tmp_cp;
		Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
		Result[1][3] = static_cast<T>(0);
		Result[2][0] = tmp_sh * tmp_cp;
		Result[2][1] = -tmp_sp;
		Result[2][2] = tmp_ch * tmp_cp;
		Result[2][3] = static_cast<T>(0);
		Result[3][0] = static_cast<T>(0);
		Result[3][1] = static_cast<T>(0);
		Result[3][2] = static_cast<T>(0);
		Result[3][3] = static_cast<T>(1);
		return Result;
	}

	template <typename T>
	 __inline tmat2x2<T, defaultp> orientate2
	(
		T __const & angle
	)
	{
		T c = glm::cos(angle);
		T s = glm::sin(angle);

		tmat2x2<T, defaultp> Result;
		Result[0][0] = c;
		Result[0][1] = s;
		Result[1][0] = -s;
		Result[1][1] = c;
		return Result;
	}

	template <typename T>
	 __inline tmat3x3<T, defaultp> orientate3
	(
		T __const & angle
	)
	{
		T c = glm::cos(angle);
		T s = glm::sin(angle);

		tmat3x3<T, defaultp> Result;
		Result[0][0] = c;
		Result[0][1] = s;
		Result[0][2] = 0.0f;
		Result[1][0] = -s;
		Result[1][1] = c;
		Result[1][2] = 0.0f;
		Result[2][0] = 0.0f;
		Result[2][1] = 0.0f;
		Result[2][2] = 1.0f;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> orientate3
	(
		tvec3<T, P> __const & angles
	)
	{
		return tmat3x3<T, P>(yawPitchRoll(angles.z, angles.x, angles.y));
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> orientate4
	(
		tvec3<T, P> __const & angles
	)
	{
		return yawPitchRoll(angles.z, angles.x, angles.y);
	}
    
    template <typename T>
     void extractEulerAngleXYZ(tmat4x4<T, defaultp> __const & M,
                                            T & t1,
                                            T & t2,
                                            T & t3)
    {
        float T1 = glm::atan2<T, defaultp>(M[2][1], M[2][2]);
        float C2 = glm::sqrt(M[0][0]*M[0][0] + M[1][0]*M[1][0]);
        float T2 = glm::atan2<T, defaultp>(-M[2][0], C2);
        float S1 = glm::sin(T1);
        float C1 = glm::cos(T1);
        float T3 = glm::atan2<T, defaultp>(S1*M[0][2] - C1*M[0][1], C1*M[1][1] - S1*M[1][2  ]);
        t1 = -T1;
        t2 = -T2;
        t3 = -T3;
    }
}//namespace glm

# 143 "/usr/local/include/glm/./gtx/euler_angles.hpp" 2 3


# 70 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/extend.hpp" 1 3
/// @ref gtx_extend
/// @file glm/gtx/extend.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_extend GLM_GTX_extend
/// @ingroup gtx
///
/// @brief Extend a position from a source to a position at a defined length.
///
/// <glm/gtx/extend.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_extend
	/// @{

	/// Extends of Length the Origin position using the (Source - Origin) direction.
	/// @see gtx_extend
	template <typename genType> 
	 genType extend(
		genType __const & Origin, 
		genType __const & Source, 
		typename genType::value_type __const Length);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/extend.inl" 1 3
/// @ref gtx_extend
/// @file glm/gtx/extend.inl

namespace glm
{
	template <typename genType>
	 __inline genType extend
	(
		genType __const & Origin, 
		genType __const & Source, 
		genType __const & Distance
	)
	{
		return Origin + (Source - Origin) * Distance;
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> extend
	(
		tvec2<T, P> __const & Origin,
		tvec2<T, P> __const & Source,
		T __const & Distance
	)
	{
		return Origin + (Source - Origin) * Distance;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> extend
	(
		tvec3<T, P> __const & Origin,
		tvec3<T, P> __const & Source,
		T __const & Distance
	)
	{
		return Origin + (Source - Origin) * Distance;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> extend
	(
		tvec4<T, P> __const & Origin,
		tvec4<T, P> __const & Source,
		T __const & Distance
	)
	{
		return Origin + (Source - Origin) * Distance;
	}
}//namespace glm

# 38 "/usr/local/include/glm/./gtx/extend.hpp" 2 3


# 71 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 1 3
/// @ref gtx_extended_min_max
/// @file glm/gtx/extended_min_max.hpp
///
/// @see core (dependence)
/// @see gtx_half_float (dependence)
///
/// @defgroup gtx_extented_min_max GLM_GTX_extented_min_max
/// @ingroup gtx
///
/// Min and max functions for 3 to 4 parameters.
///
/// <glm/gtx/extented_min_max.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_extented_min_max
	/// @{

	/// Return the minimum component-wise values of 3 inputs 
	/// @see gtx_extented_min_max
	template <typename T>
	 T min(
		T __const & x, 
		T __const & y, 
		T __const & z);

	/// Return the minimum component-wise values of 3 inputs
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> min(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z);

	/// Return the minimum component-wise values of 3 inputs 
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> min(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z);

	/// Return the minimum component-wise values of 4 inputs 
	/// @see gtx_extented_min_max
	template <typename T>
	 T min(
		T __const & x, 
		T __const & y, 
		T __const & z, 
		T __const & w);

	/// Return the minimum component-wise values of 4 inputs 
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> min(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z, 
		typename C<T>::T __const & w);

	/// Return the minimum component-wise values of 4 inputs
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> min(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z,
		C<T> __const & w);

	/// Return the maximum component-wise values of 3 inputs 
	/// @see gtx_extented_min_max
	template <typename T>
	 T max(
		T __const & x, 
		T __const & y, 
		T __const & z);

	/// Return the maximum component-wise values of 3 inputs
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> max(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z);

	/// Return the maximum component-wise values of 3 inputs 
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> max(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z);

	/// Return the maximum component-wise values of 4 inputs
	/// @see gtx_extented_min_max
	template <typename T>
	 T max(
		T __const & x, 
		T __const & y, 
		T __const & z, 
		T __const & w);

	/// Return the maximum component-wise values of 4 inputs 
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> max(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z, 
		typename C<T>::T __const & w);

	/// Return the maximum component-wise values of 4 inputs 
	/// @see gtx_extented_min_max
	template <typename T, template <typename> class C>
	 C<T> max(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z, 
		C<T> __const & w);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/extended_min_max.inl" 1 3
/// @ref gtx_extended_min_max
/// @file glm/gtx/extended_min_max.inl

namespace glm
{
	template <typename T>
	 __inline T min(
		T __const & x, 
		T __const & y, 
		T __const & z)
	{
		return glm::min(glm::min(x, y), z);
	}

	template <typename T, template <typename> class C>
	 __inline C<T> min
	(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z
	)
	{
		return glm::min(glm::min(x, y), z);
	}

	template <typename T, template <typename> class C>
	 __inline C<T> min
	(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z
	)
	{
		return glm::min(glm::min(x, y), z);
	}

	template <typename T>
	 __inline T min
	(
		T __const & x, 
		T __const & y, 
		T __const & z, 
		T __const & w
	)
	{
		return glm::min(glm::min(x, y), glm::min(z, w));
	}

	template <typename T, template <typename> class C>
	 __inline C<T> min
	(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z, 
		typename C<T>::T __const & w
	)
	{
		return glm::min(glm::min(x, y), glm::min(z, w));
	}

	template <typename T, template <typename> class C>
	 __inline C<T> min
	(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z, 
		C<T> __const & w
	)
	{
		return glm::min(glm::min(x, y), glm::min(z, w));
	}

	template <typename T>
	 __inline T max(
		T __const & x, 
		T __const & y, 
		T __const & z)
	{
		return glm::max(glm::max(x, y), z);
	}

	template <typename T, template <typename> class C>
	 __inline C<T> max
	(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z
	)
	{
		return glm::max(glm::max(x, y), z);
	}

	template <typename T, template <typename> class C>
	 __inline C<T> max
	(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z
	)
	{
		return glm::max(glm::max(x, y), z);
	}

	template <typename T>
	 __inline T max
	(
		T __const & x, 
		T __const & y, 
		T __const & z, 
		T __const & w
	)
	{
		return glm::max(glm::max(x, y), glm::max(z, w));
	}

	template <typename T, template <typename> class C>
	 __inline C<T> max
	(
		C<T> __const & x, 
		typename C<T>::T __const & y, 
		typename C<T>::T __const & z, 
		typename C<T>::T __const & w
	)
	{
		return glm::max(glm::max(x, y), glm::max(z, w));
	}

	template <typename T, template <typename> class C>
	 __inline C<T> max
	(
		C<T> __const & x, 
		C<T> __const & y, 
		C<T> __const & z, 
		C<T> __const & w
	)
	{
		return glm::max(glm::max(x, y), glm::max(z, w));
	}

}//namespace glm

# 133 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 2 3


# 72 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 1 3
/// @ref gtx_fast_exponential
/// @file glm/gtx/fast_exponential.hpp
///
/// @see core (dependence)
/// @see gtx_half_float (dependence)
///
/// @defgroup gtx_fast_exponential GLM_GTX_fast_exponential
/// @ingroup gtx
///
/// @brief Fast but less accurate implementations of exponential based functions.
///
/// <glm/gtx/fast_exponential.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_fast_exponential
	/// @{

	/// Faster than the common pow function but less accurate.
	/// @see gtx_fast_exponential
	template <typename genType>
	 genType fastPow(genType x, genType y);

	/// Faster than the common pow function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastPow(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Faster than the common pow function but less accurate.
	/// @see gtx_fast_exponential
	template <typename genTypeT, typename genTypeU>
	 genTypeT fastPow(genTypeT x, genTypeU y);

	/// Faster than the common pow function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastPow(vecType<T, P> __const & x);

	/// Faster than the common exp function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T>
	 T fastExp(T x);

	/// Faster than the common exp function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastExp(vecType<T, P> __const & x);

	/// Faster than the common log function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T>
	 T fastLog(T x);

	/// Faster than the common exp2 function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastLog(vecType<T, P> __const & x);

	/// Faster than the common exp2 function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T>
	 T fastExp2(T x);

	/// Faster than the common exp2 function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastExp2(vecType<T, P> __const & x);

	/// Faster than the common log2 function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T>
	 T fastLog2(T x);

	/// Faster than the common log2 function but less accurate.
	/// @see gtx_fast_exponential
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastLog2(vecType<T, P> __const & x);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/fast_exponential.inl" 1 3
/// @ref gtx_fast_exponential
/// @file glm/gtx/fast_exponential.inl

namespace glm
{
	// fastPow:
	template <typename genType>
	 __inline genType fastPow(genType x, genType y)
	{
		return exp(y * log(x));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastPow(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		return exp(y * log(x));
	}

	template <typename T>
	 __inline T fastPow(T x, int y)
	{
		T f = static_cast<T>(1);
		for(int i = 0; i < y; ++i)
			f *= x;
		return f;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastPow(vecType<T, P> __const & x, vecType<int, P> __const & y)
	{
		vecType<T, P> Result(uninitialize);
		for(length_t i = 0, n = x.length(); i < n; ++i)
			Result[i] = fastPow(x[i], y[i]);
		return Result;
	}

	// fastExp
	// Note: This function provides accurate results only for value between -1 and 1, else avoid it.
	template <typename T>
	 __inline T fastExp(T x)
	{
		// This has a better looking and same performance in release mode than the following code. However, in debug mode it's slower.
		// return 1.0f + x * (1.0f + x * 0.5f * (1.0f + x * 0.3333333333f * (1.0f + x * 0.25 * (1.0f + x * 0.2f))));
		T x2 = x * x;
		T x3 = x2 * x;
		T x4 = x3 * x;
		T x5 = x4 * x;
		return T(1) + x + (x2 * T(0.5)) + (x3 * T(0.1666666667)) + (x4 * T(0.041666667)) + (x5 * T(0.008333333333));
	}
	
# 82 "/usr/local/include/glm/./gtx/fast_exponential.inl" 3


	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastExp(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastExp, x);
	}

	// fastLog
	template <typename genType>
	 __inline genType fastLog(genType x)
	{
		return std::log(x);
	}

	








	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastLog(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastLog, x);
	}

	//fastExp2, ln2 = 0.69314718055994530941723212145818f
	template <typename genType>
	 __inline genType fastExp2(genType x)
	{
		return fastExp(0.69314718055994530941723212145818f * x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastExp2(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastExp2, x);
	}

	// fastLog2, ln2 = 0.69314718055994530941723212145818f
	template <typename genType>
	 __inline genType fastLog2(genType x)
	{
		return fastLog(x) / 0.69314718055994530941723212145818f;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastLog2(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastLog2, x);
	}
}//namespace glm

# 91 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 2 3


# 73 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 1 3
/// @ref gtx_fast_square_root
/// @file glm/gtx/fast_square_root.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_fast_square_root GLM_GTX_fast_square_root
/// @ingroup gtx
///
/// @brief Fast but less accurate implementations of square root based functions.
/// - Sqrt optimisation based on Newton's method, 
/// www.gamedev.net/community/forums/topic.asp?topic id=139956
///
/// <glm/gtx/fast_square_root.hpp> need to be included to use these functionalities.



// Dependency:






       

namespace glm
{
	/// @addtogroup gtx_fast_square_root
	/// @{

	/// Faster than the common sqrt function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename genType> 
	 genType fastSqrt(genType x);

	/// Faster than the common sqrt function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastSqrt(vecType<T, P> __const & x);

	/// Faster than the common inversesqrt function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename genType> 
	 genType fastInverseSqrt(genType x);

	/// Faster than the common inversesqrt function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fastInverseSqrt(vecType<T, P> __const & x);

	/// Faster than the common length function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename genType>
	 genType fastLength(genType x);

	/// Faster than the common length function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 T fastLength(vecType<T, P> __const & x);

	/// Faster than the common distance function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename genType>
	 genType fastDistance(genType x, genType y);

	/// Faster than the common distance function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 T fastDistance(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Faster than the common normalize function but less accurate.
	///
	/// @see gtx_fast_square_root extension.
	template <typename genType> 
	 genType fastNormalize(genType __const & x);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/fast_square_root.inl" 1 3
/// @ref gtx_fast_square_root
/// @file glm/gtx/fast_square_root.inl

namespace glm
{
	// fastSqrt
	template <typename genType>
	 __inline genType fastSqrt(genType x)
	{
		;

		return genType(1) / fastInverseSqrt(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastSqrt(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastSqrt, x);
	}

	// fastInversesqrt
	template <typename genType>
	 __inline genType fastInverseSqrt(genType x)
	{



        
			return detail::compute_inversesqrt<tvec1, genType, highp, detail::is_aligned<highp>::value>::call(tvec1<genType, lowp>(x)).x;

	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastInverseSqrt(vecType<T, P> __const & x)
	{
		return detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
	}

	// fastLength
	template <typename genType>
	 __inline genType fastLength(genType x)
	{
		;

		return abs(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T fastLength(vecType<T, P> __const & x)
	{
		;

		return fastSqrt(dot(x, x));
	}

	// fastDistance
	template <typename genType>
	 __inline genType fastDistance(genType x, genType y)
	{
		return fastLength(y - x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T fastDistance(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		return fastLength(y - x);
	}

	// fastNormalize
	template <typename genType>
	 __inline genType fastNormalize(genType x)
	{
		return x > genType(0) ? genType(1) : -genType(1);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastNormalize(vecType<T, P> __const & x)
	{
		return x * fastInverseSqrt(dot(x, x));
	}
}//namespace glm

# 88 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 2 3


# 74 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 1 3
/// @ref gtx_fast_trigonometry
/// @file glm/gtx/fast_trigonometry.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_fast_trigonometry GLM_GTX_fast_trigonometry
/// @ingroup gtx
///
/// @brief Fast but less accurate implementations of trigonometric functions.
///
/// <glm/gtx/fast_trigonometry.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_fast_trigonometry
	/// @{

	/// Wrap an angle to [0 2pi[
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T> 
	 T wrapAngle(T angle);

	/// Faster than the common sin function but less accurate.
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T>
	 T fastSin(T angle);

	/// Faster than the common cos function but less accurate.
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T> 
	 T fastCos(T angle);

	/// Faster than the common tan function but less accurate. 
	/// Defined between -2pi and 2pi. 
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T> 
	 T fastTan(T angle);

	/// Faster than the common asin function but less accurate. 
	/// Defined between -2pi and 2pi.
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T> 
	 T fastAsin(T angle);

	/// Faster than the common acos function but less accurate. 
	/// Defined between -2pi and 2pi. 
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T> 
	 T fastAcos(T angle);

	/// Faster than the common atan function but less accurate.
	/// Defined between -2pi and 2pi. 
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T> 
	 T fastAtan(T y, T x);

	/// Faster than the common atan function but less accurate. 
	/// Defined between -2pi and 2pi.
	/// From GLM_GTX_fast_trigonometry extension.
	template <typename T> 
	 T fastAtan(T angle);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/fast_trigonometry.inl" 1 3
/// @ref gtx_fast_trigonometry
/// @file glm/gtx/fast_trigonometry.inl

namespace glm{
namespace detail
{
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> taylorCos(vecType<T, P> __const & x)
	{
		return static_cast<T>(1)
			- (x * x) / 2.f
			+ (x * x * x * x) / 24.f
			- (x * x * x * x * x * x) / 720.f
			+ (x * x * x * x * x * x * x * x) / 40320.f;
	}

	template <typename T>
	 __inline T cos_52s(T x)
	{
		T __const xx(x * x);
		return (T(0.9999932946) + xx * (T(-0.4999124376) + xx * (T(0.0414877472) + xx * T(-0.0012712095))));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> cos_52s(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(cos_52s, x);
	}
}//namespace detail

	// wrapAngle
	template <typename T>
	 __inline T wrapAngle(T angle)
	{
		return abs<T>(mod<T>(angle, two_pi<T>()));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> wrapAngle(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(wrapAngle, x);
	}

	// cos
	template <typename T> 
	 __inline T fastCos(T x)
	{
		T __const angle(wrapAngle<T>(x));

		if(angle < half_pi<T>())
			return detail::cos_52s(angle);
		if(angle < pi<T>())
			return -detail::cos_52s(pi<T>() - angle);
		if(angle < (T(3) * half_pi<T>()))
			return -detail::cos_52s(angle - pi<T>());

		return detail::cos_52s(two_pi<T>() - angle);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastCos(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastCos, x);
	}

	// sin
	template <typename T> 
	 __inline T fastSin(T x)
	{
		return fastCos<T>(half_pi<T>() - x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastSin(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastSin, x);
	}

	// tan
	template <typename T> 
	 __inline T fastTan(T x)
	{
		return x + (x * x * x * T(0.3333333333)) + (x * x * x * x * x * T(0.1333333333333)) + (x * x * x * x * x * x * x * T(0.0539682539));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastTan(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastTan, x);
	}

	// asin
	template <typename T> 
	 __inline T fastAsin(T x)
	{
		return x + (x * x * x * T(0.166666667)) + (x * x * x * x * x * T(0.075)) + (x * x * x * x * x * x * x * T(0.0446428571)) + (x * x * x * x * x * x * x * x * x * T(0.0303819444));// + (x * x * x * x * x * x * x * x * x * x * x * T(0.022372159));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastAsin(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastAsin, x);
	}

	// acos
	template <typename T> 
	 __inline T fastAcos(T x)
	{
		return T(1.5707963267948966192313216916398) - fastAsin(x); //(PI / 2)
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastAcos(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastAcos, x);
	}

	// atan
	template <typename T> 
	 __inline T fastAtan(T y, T x)
	{
		T sgn = sign(y) * sign(x);
		return abs(fastAtan(y / x)) * sgn;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastAtan(vecType<T, P> __const & y, vecType<T, P> __const & x)
	{
		return detail::functor2<T, P, vecType>::call(fastAtan, y, x);
	}

	template <typename T> 
	 __inline T fastAtan(T x)
	{
		return x - (x * x * x * T(0.333333333333)) + (x * x * x * x * x * T(0.2)) - (x * x * x * x * x * x * x * T(0.1428571429)) + (x * x * x * x * x * x * x * x * x * T(0.111111111111)) - (x * x * x * x * x * x * x * x * x * x * x * T(0.0909090909));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> fastAtan(vecType<T, P> __const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(fastAtan, x);
	}
}//namespace glm

# 75 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 2 3


# 75 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 1 3
/// @ref gtx_gradient_paint
/// @file glm/gtx/gradient_paint.hpp
///
/// @see core (dependence)
/// @see gtx_optimum_pow (dependence)
///
/// @defgroup gtx_gradient_paint GLM_GTX_gradient_paint
/// @ingroup gtx
///
/// @brief Functions that return the color of procedural gradient for specific coordinates.
/// <glm/gtx/gradient_paint.hpp> need to be included to use these functionalities.



// Dependency:


# 1 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 1 3
/// @ref gtx_optimum_pow
/// @file glm/gtx/optimum_pow.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_optimum_pow GLM_GTX_optimum_pow
/// @ingroup gtx
///
/// @brief Integer exponentiation of power functions.
///
/// <glm/gtx/optimum_pow.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm{
namespace gtx
{
	/// @addtogroup gtx_optimum_pow
	/// @{

	/// Returns x raised to the power of 2.
	///
	/// @see gtx_optimum_pow
	template <typename genType>
	 genType pow2(genType __const & x);

	/// Returns x raised to the power of 3.
	///
	/// @see gtx_optimum_pow
	template <typename genType>
	 genType pow3(genType __const & x);

	/// Returns x raised to the power of 4.
	///
	/// @see gtx_optimum_pow
	template <typename genType>
	 genType pow4(genType __const & x);

	/// @}
}//namespace gtx
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/optimum_pow.inl" 1 3
/// @ref gtx_optimum_pow
/// @file glm/gtx/optimum_pow.inl

namespace glm
{
	template <typename genType>
	 __inline genType pow2(genType __const & x)
	{
		return x * x;
	}

	template <typename genType>
	 __inline genType pow3(genType __const & x)
	{
		return x * x * x;
	}

	template <typename genType>
	 __inline genType pow4(genType __const & x)
	{
		return (x * x) * (x * x);
	}
}//namespace glm

# 50 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 2 3


# 17 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 2 3




       

namespace glm
{
	/// @addtogroup gtx_gradient_paint
	/// @{

	/// Return a color from a radial gradient.
	/// @see - gtx_gradient_paint
	template <typename T, precision P>
	 T radialGradient(
		tvec2<T, P> __const & Center,
		T __const & Radius,
		tvec2<T, P> __const & Focal,
		tvec2<T, P> __const & Position);

	/// Return a color from a linear gradient.
	/// @see - gtx_gradient_paint
	template <typename T, precision P>
	 T linearGradient(
		tvec2<T, P> __const & Point0,
		tvec2<T, P> __const & Point1,
		tvec2<T, P> __const & Position);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/gradient_paint.inl" 1 3
/// @ref gtx_gradient_paint
/// @file glm/gtx/gradient_paint.inl

namespace glm
{
	template <typename T, precision P>
	 __inline T radialGradient
	(
		tvec2<T, P> __const & Center,
		T __const & Radius,
		tvec2<T, P> __const & Focal,
		tvec2<T, P> __const & Position
	)
	{
		tvec2<T, P> F = Focal - Center;
		tvec2<T, P> D = Position - Focal;
		T Radius2 = pow2(Radius);
		T Fx2 = pow2(F.x);
		T Fy2 = pow2(F.y);

		T Numerator = (D.x * F.x + D.y * F.y) + sqrt(Radius2 * (pow2(D.x) + pow2(D.y)) - pow2(D.x * F.y - D.y * F.x));
		T Denominator = Radius2 - (Fx2 + Fy2);
		return Numerator / Denominator;
	}

	template <typename T, precision P>
	 __inline T linearGradient
	(
		tvec2<T, P> __const & Point0,
		tvec2<T, P> __const & Point1,
		tvec2<T, P> __const & Position
	)
	{
		tvec2<T, P> Dist = Point1 - Point0;
		return (Dist.x * (Position.x - Point0.x) + Dist.y * (Position.y - Point0.y)) / glm::dot(Dist, Dist);
	}
}//namespace glm

# 48 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 2 3


# 76 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 1 3
/// @ref gtx_handed_coordinate_space
/// @file glm/gtx/handed_coordinate_space.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_handed_coordinate_space GLM_GTX_handed_coordinate_space
/// @ingroup gtx
///
/// @brief To know if a set of three basis vectors defines a right or left-handed coordinate system.
///
/// <glm/gtx/handed_coordinate_system.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_handed_coordinate_space
	/// @{

	//! Return if a trihedron right handed or not.
	//! From GLM_GTX_handed_coordinate_space extension.
	template <typename T, precision P>
	 bool rightHanded(
		tvec3<T, P> __const & tangent,
		tvec3<T, P> __const & binormal,
		tvec3<T, P> __const & normal);

	//! Return if a trihedron left handed or not.
	//! From GLM_GTX_handed_coordinate_space extension.
	template <typename T, precision P>
	 bool leftHanded(
		tvec3<T, P> __const & tangent,
		tvec3<T, P> __const & binormal,
		tvec3<T, P> __const & normal);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/handed_coordinate_space.inl" 1 3
/// @ref gtx_handed_coordinate_space
/// @file glm/gtx/handed_coordinate_space.inl

namespace glm
{
	template <typename T, precision P>
	 __inline bool rightHanded
	(
		tvec3<T, P> __const & tangent,
		tvec3<T, P> __const & binormal,
		tvec3<T, P> __const & normal
	)
	{
		return dot(cross(normal, tangent), binormal) > T(0);
	}

	template <typename T, precision P>
	 __inline bool leftHanded
	(
		tvec3<T, P> __const & tangent,
		tvec3<T, P> __const & binormal,
		tvec3<T, P> __const & normal
	)
	{
		return dot(cross(normal, tangent), binormal) < T(0);
	}
}//namespace glm

# 46 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 2 3


# 77 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/integer.hpp" 1 3
/// @ref gtx_integer
/// @file glm/gtx/integer.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_integer GLM_GTX_integer
/// @ingroup gtx
///
/// @brief Add support for integer for core functions
///
/// <glm/gtx/integer.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// @addtogroup gtx_integer
	/// @{

	//! Returns x raised to the y power. 
	//! From GLM_GTX_integer extension.
	 int pow(int x, int y);

	//! Returns the positive square root of x.
	//! From GLM_GTX_integer extension.
	 int sqrt(int x);

	//! Returns the floor log2 of x.
	//! From GLM_GTX_integer extension.
	 unsigned int floor_log2(unsigned int x);

	//! Modulus. Returns x - y * floor(x / y) for each component in x using the floating point value y.
	//! From GLM_GTX_integer extension.
	 int mod(int x, int y);

	//! Return the factorial value of a number (!12 max, integer only)
	//! From GLM_GTX_integer extension.
	template <typename genType> 
	 genType factorial(genType __const & x);

	//! 32bit __signed integer. 
	//! From GLM_GTX_integer extension.
	typedef __signed int					sint;

	//! Returns x raised to the y power.
	//! From GLM_GTX_integer extension.
	 uint pow(uint x, uint y);

	//! Returns the positive square root of x. 
	//! From GLM_GTX_integer extension.
	 uint sqrt(uint x);

	//! Modulus. Returns x - y * floor(x / y) for each component in x using the floating point value y.
	//! From GLM_GTX_integer extension.
	 uint mod(uint x, uint y);

	//! Returns the number of leading zeros.
	//! From GLM_GTX_integer extension.
	 uint nlz(uint x);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/integer.inl" 1 3
/// @ref gtx_integer
/// @file glm/gtx/integer.inl

namespace glm
{
	// pow
	 __inline int pow(int x, int y)
	{
		if(y == 0)
			return 1;
		int result = x;
		for(int i = 1; i < y; ++i)
			result *= x;
		return result;
	}

	// sqrt: From Christopher J. Musial, An integer square root, Graphics Gems, 1990, page 387
	 __inline int sqrt(int x)
	{
		if(x <= 1) return x;

		int NextTrial = x >> 1;
		int CurrentAnswer;

		do
		{
			CurrentAnswer = NextTrial;
			NextTrial = (NextTrial + x / NextTrial) >> 1;
		} while(NextTrial < CurrentAnswer);

		return CurrentAnswer;
	}

// Henry Gordon Dietz: http://aggregate.org/MAGIC/
namespace detail
{
	 __inline unsigned int ones32(unsigned int x)
	{
		



		x -= ((x >> 1) & 0x55555555);
		x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
		x = (((x >> 4) + x) & 0x0f0f0f0f);
		x += (x >> 8);
		x += (x >> 16);
		return(x & 0x0000003f);
	}
}//namespace detail

	// Henry Gordon Dietz: http://aggregate.org/MAGIC/

# 64 "/usr/local/include/glm/./gtx/integer.inl" 3

	// mod
	 __inline int mod(int x, int y)
	{
		return x - y * (x / y);
	}

	// factorial (!12 max, integer only)
	template <typename genType>
	 __inline genType factorial(genType __const & x)
	{
		genType Temp = x;
		genType Result;
		for(Result = 1; Temp > 1; --Temp)
			Result *= Temp;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> factorial(
		tvec2<T, P> __const & x)
	{
		return tvec2<T, P>(
			factorial(x.x),
			factorial(x.y));
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> factorial(
		tvec3<T, P> __const & x)
	{
		return tvec3<T, P>(
			factorial(x.x),
			factorial(x.y),
			factorial(x.z));
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> factorial(
		tvec4<T, P> __const & x)
	{
		return tvec4<T, P>(
			factorial(x.x),
			factorial(x.y),
			factorial(x.z),
			factorial(x.w));
	}

	 __inline uint pow(uint x, uint y)
	{
		uint result = x;
		for(uint i = 1; i < y; ++i)
			result *= x;
		return result;
	}

	 __inline uint sqrt(uint x)
	{
		if(x <= 1) return x;

		uint NextTrial = x >> 1;
		uint CurrentAnswer;

		do
		{
			CurrentAnswer = NextTrial;
			NextTrial = (NextTrial + x / NextTrial) >> 1;
		} while(NextTrial < CurrentAnswer);

		return CurrentAnswer;
	}

	 __inline uint mod(uint x, uint y)
	{
		return x - y * (x / y);
	}








      

	// Hackers Delight: http://www.hackersdelight.org/HDcode/nlz.c.txt
	 __inline unsigned int nlz(unsigned int x) 
	{
		int y, m, n;

		y = -int(x >> 16);      // If left half of x is 0,
		m = (y >> 16) & 16;  // set n = 16.  If left half
		n = 16 - m;          // is nonzero, set n = 0 and
		x = x >> m;          // shift x right 16.
							// Now x is of the form 0000xxxx.
		y = x - 0x100;       // If positions 8-15 are 0,
		m = (y >> 16) & 8;   // add 8 to n and shift x left 8.
		n = n + m;
		x = x << m;

		y = x - 0x1000;      // If positions 12-15 are 0,
		m = (y >> 16) & 4;   // add 4 to n and shift x left 4.
		n = n + m;
		x = x << m;

		y = x - 0x4000;      // If positions 14-15 are 0,
		m = (y >> 16) & 2;   // add 2 to n and shift x left 2.
		n = n + m;
		x = x << m;

		y = x >> 14;         // Set y = 0, 1, 2, or 3.
		m = y & ~(y >> 1);   // Set m = 0, 1, 2, or 2 resp.
		return unsigned(n + 2 - m);
	}



}//namespace glm

# 72 "/usr/local/include/glm/./gtx/integer.hpp" 2 3


# 78 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/intersect.hpp" 1 3
/// @ref gtx_intersect
/// @file glm/gtx/intersect.hpp
///
/// @see core (dependence)
/// @see gtx_closest_point (dependence)
///
/// @defgroup gtx_intersect GLM_GTX_intersect
/// @ingroup gtx
///
/// @brief Add intersection functions
///
/// <glm/gtx/intersect.hpp> need to be included to use these functionalities.



// Dependency:






# 1 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 1 3
/// @ref gtx_vector_query
/// @file glm/gtx/vector_query.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_vector_query GLM_GTX_vector_query
/// @ingroup gtx
///
/// @brief Query informations of vector types
///
/// <glm/gtx/vector_query.hpp> need to be included to use these functionalities.



// Dependency:






       

namespace glm
{
	/// @addtogroup gtx_vector_query
	/// @{

	//! Check whether two vectors are collinears.
	/// @see gtx_vector_query extensions.
	template <typename T, precision P, template <typename, precision> class vecType>
	 bool areCollinear(vecType<T, P> __const & v0, vecType<T, P> __const & v1, T __const & epsilon);
		
	//! Check whether two vectors are orthogonals.
	/// @see gtx_vector_query extensions.
	template <typename T, precision P, template <typename, precision> class vecType>
	 bool areOrthogonal(vecType<T, P> __const & v0, vecType<T, P> __const & v1, T __const & epsilon);

	//! Check whether a vector is normalized.
	/// @see gtx_vector_query extensions.
	template <typename T, precision P, template <typename, precision> class vecType>
	 bool isNormalized(vecType<T, P> __const & v, T __const & epsilon);
		
	//! Check whether a vector is null.
	/// @see gtx_vector_query extensions.
	template <typename T, precision P, template <typename, precision> class vecType>
	 bool isNull(vecType<T, P> __const & v, T __const & epsilon);

	//! Check whether a each component of a vector is null.
	/// @see gtx_vector_query extensions.
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isCompNull(vecType<T, P> __const & v, T __const & epsilon);

	//! Check whether two vectors are orthonormal.
	/// @see gtx_vector_query extensions.
	template <typename T, precision P, template <typename, precision> class vecType>
	 bool areOrthonormal(vecType<T, P> __const & v0, vecType<T, P> __const & v1, T __const & epsilon);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/vector_query.inl" 1 3
/// @ref gtx_vector_query
/// @file glm/gtx/vector_query.inl



namespace glm{
namespace detail
{
	template <typename T, precision P, template <typename, precision> class vecType>
	struct compute_areCollinear{};

	template <typename T, precision P>
	struct compute_areCollinear<T, P, tvec2>
	{
		 __inline static bool call(tvec2<T, P> __const & v0, tvec2<T, P> __const & v1, T __const & epsilon)
		{
			return length(cross(tvec3<T, P>(v0, static_cast<T>(0)), tvec3<T, P>(v1, static_cast<T>(0)))) < epsilon;
		}
	};

	template <typename T, precision P>
	struct compute_areCollinear<T, P, tvec3>
	{
		 __inline static bool call(tvec3<T, P> __const & v0, tvec3<T, P> __const & v1, T __const & epsilon)
		{
			return length(cross(v0, v1)) < epsilon;
		}
	};

	template <typename T, precision P>
	struct compute_areCollinear<T, P, tvec4>
	{
		 __inline static bool call(tvec4<T, P> __const & v0, tvec4<T, P> __const & v1, T __const & epsilon)
		{
			return length(cross(tvec3<T, P>(v0), tvec3<T, P>(v1))) < epsilon;
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct compute_isCompNull{};

	template <typename T, precision P>
	struct compute_isCompNull<T, P, tvec2>
	{
		 __inline static tvec2<bool, P> call(tvec2<T, P> __const & v, T __const & epsilon)
		{
			return tvec2<bool, P>(
				(abs(v.x) < epsilon),
				(abs(v.y) < epsilon));
		}
	};

	template <typename T, precision P>
	struct compute_isCompNull<T, P, tvec3>
	{
		 __inline static tvec3<bool, P> call(tvec3<T, P> __const & v, T __const & epsilon)
		{
			return tvec3<bool, P>(
				(abs(v.x) < epsilon),
				(abs(v.y) < epsilon),
				(abs(v.z) < epsilon));
		}
	};

	template <typename T, precision P>
	struct compute_isCompNull<T, P, tvec4>
	{
		 __inline static tvec4<bool, P> call(tvec4<T, P> __const & v, T __const & epsilon)
		{
			return tvec4<bool, P>(
				(abs(v.x) < epsilon),
				(abs(v.y) < epsilon),
				(abs(v.z) < epsilon),
				(abs(v.w) < epsilon));
		}
	};

}//namespace detail

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline bool areCollinear
	(
		vecType<T, P> __const & v0,
		vecType<T, P> __const & v1,
		T __const & epsilon
	)
	{
		;

		return detail::compute_areCollinear<T, P, vecType>::call(v0, v1, epsilon);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline bool areOrthogonal
	(
		vecType<T, P> __const & v0,
		vecType<T, P> __const & v1,
		T __const & epsilon
	)
	{
		;

		return abs(dot(v0, v1)) <= max(
			static_cast<T>(1),
			length(v0)) * max(static_cast<T>(1), length(v1)) * epsilon;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline bool isNormalized
	(
		vecType<T, P> __const & v,
		T __const & epsilon
	)
	{
		;

		return abs(length(v) - static_cast<T>(1)) <= static_cast<T>(2) * epsilon;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline bool isNull
	(
		vecType<T, P> __const & v,
		T __const & epsilon
	)
	{
		;

		return length(v) <= epsilon;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<bool, P> isCompNull
	(
		vecType<T, P> __const & v,
		T __const & epsilon
	)
	{
		;

		return detail::compute_isCompNull<T, P, vecType>::call(v, epsilon);
	}

	template <typename T, precision P>
	 __inline tvec2<bool, P> isCompNull
	(
		tvec2<T, P> __const & v,
		T __const & epsilon)
	{
		return tvec2<bool, P>(
			abs(v.x) < epsilon,
			abs(v.y) < epsilon);
	}

	template <typename T, precision P>
	 __inline tvec3<bool, P> isCompNull
	(
		tvec3<T, P> __const & v,
		T __const & epsilon
	)
	{
		return tvec3<bool, P>(
			abs(v.x) < epsilon,
			abs(v.y) < epsilon,
			abs(v.z) < epsilon);
	}

	template <typename T, precision P>
	 __inline tvec4<bool, P> isCompNull
	(
		tvec4<T, P> __const & v,
		T __const & epsilon
	)
	{
		return tvec4<bool, P>(
			abs(v.x) < epsilon,
			abs(v.y) < epsilon,
			abs(v.z) < epsilon,
			abs(v.w) < epsilon);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline bool areOrthonormal
	(
		vecType<T, P> __const & v0,
		vecType<T, P> __const & v1,
		T __const & epsilon
	)
	{
		return isNormalized(v0, epsilon) && isNormalized(v1, epsilon) && (abs(dot(v0, v1)) <= epsilon);
	}

}//namespace glm

# 62 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 2 3


# 22 "/usr/local/include/glm/./gtx/intersect.hpp" 2 3




       

namespace glm
{
	/// @addtogroup gtx_intersect
	/// @{

	//! Compute the intersection of a ray and a plane.
	//! Ray direction and plane normal must be unit length.
	//! From GLM_GTX_intersect extension.
	template <typename genType>
	 bool intersectRayPlane(
		genType __const & orig, genType __const & dir,
		genType __const & planeOrig, genType __const & planeNormal,
		typename genType::value_type & intersectionDistance);

	//! Compute the intersection of a ray and a triangle.
	//! From GLM_GTX_intersect extension.
	template <typename genType>
	 bool intersectRayTriangle(
		genType __const & orig, genType __const & dir,
		genType __const & vert0, genType __const & vert1, genType __const & vert2,
		genType & baryPosition);

	//! Compute the intersection of a line and a triangle.
	//! From GLM_GTX_intersect extension.
	template <typename genType>
	 bool intersectLineTriangle(
		genType __const & orig, genType __const & dir,
		genType __const & vert0, genType __const & vert1, genType __const & vert2,
		genType & position);

	//! Compute the intersection distance of a ray and a sphere. 
	//! The ray direction vector is unit length.
	//! From GLM_GTX_intersect extension.
	template <typename genType>
	 bool intersectRaySphere(
		genType __const & rayStarting, genType __const & rayNormalizedDirection,
		genType __const & sphereCenter, typename genType::value_type __const sphereRadiusSquered,
		typename genType::value_type & intersectionDistance);

	//! Compute the intersection of a ray and a sphere.
	//! From GLM_GTX_intersect extension.
	template <typename genType>
	 bool intersectRaySphere(
		genType __const & rayStarting, genType __const & rayNormalizedDirection,
		genType __const & sphereCenter, __const typename genType::value_type sphereRadius,
		genType & intersectionPosition, genType & intersectionNormal);

	//! Compute the intersection of a line and a sphere.
	//! From GLM_GTX_intersect extension
	template <typename genType>
	 bool intersectLineSphere(
		genType __const & point0, genType __const & point1,
		genType __const & sphereCenter, typename genType::value_type sphereRadius,
		genType & intersectionPosition1, genType & intersectionNormal1, 
		genType & intersectionPosition2 = genType(), genType & intersectionNormal2 = genType());

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/intersect.inl" 1 3
/// @ref gtx_intersect
/// @file glm/gtx/intersect.inl

namespace glm
{
	template <typename genType>
	 __inline bool intersectRayPlane
	(
		genType __const & orig, genType __const & dir,
		genType __const & planeOrig, genType __const & planeNormal,
		typename genType::value_type & intersectionDistance
	)
	{
		typename genType::value_type d = glm::dot(dir, planeNormal);
		typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();

		if(d < -Epsilon)
		{
			intersectionDistance = glm::dot(planeOrig - orig, planeNormal) / d;
			return true;
		}

		return false;
	}

	template <typename genType>
	 __inline bool intersectRayTriangle
	(
		genType __const & orig, genType __const & dir,
		genType __const & v0, genType __const & v1, genType __const & v2,
		genType & baryPosition
	)
	{
		genType e1 = v1 - v0;
		genType e2 = v2 - v0;

		genType p = glm::cross(dir, e2);

		typename genType::value_type a = glm::dot(e1, p);

		typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
		if(a < Epsilon && a > -Epsilon)
			return false;

		typename genType::value_type f = typename genType::value_type(1.0f) / a;

		genType s = orig - v0;
		baryPosition.x = f * glm::dot(s, p);
		if(baryPosition.x < typename genType::value_type(0.0f))
			return false;
		if(baryPosition.x > typename genType::value_type(1.0f))
			return false;

		genType q = glm::cross(s, e1);
		baryPosition.y = f * glm::dot(dir, q);
		if(baryPosition.y < typename genType::value_type(0.0f))
			return false;
		if(baryPosition.y + baryPosition.x > typename genType::value_type(1.0f))
			return false;

		baryPosition.z = f * glm::dot(e2, q);

		return baryPosition.z >= typename genType::value_type(0.0f);
	}

	template <typename genType>
	 __inline bool intersectLineTriangle
	(
		genType __const & orig, genType __const & dir,
		genType __const & vert0, genType __const & vert1, genType __const & vert2,
		genType & position
	)
	{
		typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();

		genType edge1 = vert1 - vert0;
		genType edge2 = vert2 - vert0;

		genType pvec = cross(dir, edge2);

		float det = dot(edge1, pvec);

		if (det > -Epsilon && det < Epsilon)
			return false;
		float inv_det = typename genType::value_type(1) / det;

		genType tvec = orig - vert0;

		position.y = dot(tvec, pvec) * inv_det;
		if (position.y < typename genType::value_type(0) || position.y > typename genType::value_type(1))
			return false;

		genType qvec = cross(tvec, edge1);

		position.z = dot(dir, qvec) * inv_det;
		if (position.z < typename genType::value_type(0) || position.y + position.z > typename genType::value_type(1))
			return false;

		position.x = dot(edge2, qvec) * inv_det;

		return true;
	}

	template <typename genType>
	 __inline bool intersectRaySphere
	(
		genType __const & rayStarting, genType __const & rayNormalizedDirection,
		genType __const & sphereCenter, __const typename genType::value_type sphereRadiusSquered,
		typename genType::value_type & intersectionDistance
	)
	{
		typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
		genType diff = sphereCenter - rayStarting;
		typename genType::value_type t0 = dot(diff, rayNormalizedDirection);
		typename genType::value_type dSquared = dot(diff, diff) - t0 * t0;
		if( dSquared > sphereRadiusSquered )
		{
			return false;
		}
		typename genType::value_type t1 = sqrt( sphereRadiusSquered - dSquared );
		intersectionDistance = t0 > t1 + Epsilon ? t0 - t1 : t0 + t1;
		return intersectionDistance > Epsilon;
	}

	template <typename genType>
	 __inline bool intersectRaySphere
	(
		genType __const & rayStarting, genType __const & rayNormalizedDirection,
		genType __const & sphereCenter, __const typename genType::value_type sphereRadius,
		genType & intersectionPosition, genType & intersectionNormal
	)
	{
		typename genType::value_type distance;
		if( intersectRaySphere( rayStarting, rayNormalizedDirection, sphereCenter, sphereRadius * sphereRadius, distance ) )
		{
			intersectionPosition = rayStarting + rayNormalizedDirection * distance;
			intersectionNormal = (intersectionPosition - sphereCenter) / sphereRadius;
			return true;
		}
		return false;
	}

	template <typename genType>
	 __inline bool intersectLineSphere
	(
		genType __const & point0, genType __const & point1,
		genType __const & sphereCenter, typename genType::value_type sphereRadius,
		genType & intersectionPoint1, genType & intersectionNormal1, 
		genType & intersectionPoint2, genType & intersectionNormal2
	)
	{
		typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
		genType dir = normalize(point1 - point0);
		genType diff = sphereCenter - point0;
		typename genType::value_type t0 = dot(diff, dir);
		typename genType::value_type dSquared = dot(diff, diff) - t0 * t0;
		if( dSquared > sphereRadius * sphereRadius )
		{
			return false;
		}
		typename genType::value_type t1 = sqrt( sphereRadius * sphereRadius - dSquared );
		if( t0 < t1 + Epsilon )
			t1 = -t1;
		intersectionPoint1 = point0 + dir * (t0 - t1);
		intersectionNormal1 = (intersectionPoint1 - sphereCenter) / sphereRadius;
		intersectionPoint2 = point0 + dir * (t0 + t1);
		intersectionNormal2 = (intersectionPoint2 - sphereCenter) / sphereRadius;
		return true;
	}
}//namespace glm

# 87 "/usr/local/include/glm/./gtx/intersect.hpp" 2 3


# 79 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/log_base.hpp" 1 3
/// @ref gtx_log_base
/// @file glm/gtx/log_base.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_log_base GLM_GTX_log_base
/// @ingroup gtx
///
/// @brief Logarithm for any base. base can be a vector or a scalar.
///
/// <glm/gtx/log_base.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_log_base
	/// @{

	/// Logarithm for any base.
	/// From GLM_GTX_log_base.
	template <typename genType>
	 genType log(
		genType __const & x,
		genType __const & base);

	/// Logarithm for any base.
	/// From GLM_GTX_log_base.
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sign(
		vecType<T, P> __const & x,
		vecType<T, P> __const & base);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/log_base.inl" 1 3
/// @ref gtx_log_base
/// @file glm/gtx/log_base.inl

namespace glm
{
	template <typename genType> 
	 __inline genType log(genType __const & x, genType __const & base)
	{
		assert(x != genType(0));
		return glm::log(x) / glm::log(base);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> log(vecType<T, P> __const & x, vecType<T, P> __const & base)
	{
		return glm::log(x) / glm::log(base);
	}
}//namespace glm

# 44 "/usr/local/include/glm/./gtx/log_base.hpp" 2 3


# 80 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 1 3
/// @ref gtx_matrix_cross_product
/// @file glm/gtx/matrix_cross_product.hpp
///
/// @see core (dependence)
/// @see gtx_extented_min_max (dependence)
///
/// @defgroup gtx_matrix_cross_product GLM_GTX_matrix_cross_product
/// @ingroup gtx
///
/// @brief Build cross product matrices
///
/// <glm/gtx/matrix_cross_product.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_matrix_cross_product
	/// @{

	//! Build a cross product matrix.
	//! From GLM_GTX_matrix_cross_product extension.
	template <typename T, precision P>
	 tmat3x3<T, P> matrixCross3(
		tvec3<T, P> __const & x);
		
	//! Build a cross product matrix.
	//! From GLM_GTX_matrix_cross_product extension.
	template <typename T, precision P>
	 tmat4x4<T, P> matrixCross4(
		tvec3<T, P> __const & x);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/matrix_cross_product.inl" 1 3
/// @ref gtx_matrix_cross_product
/// @file glm/gtx/matrix_cross_product.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tmat3x3<T, P> matrixCross3
	(
		tvec3<T, P> __const & x
	)
	{
		tmat3x3<T, P> Result(T(0));
		Result[0][1] = x.z;
		Result[1][0] = -x.z;
		Result[0][2] = -x.y;
		Result[2][0] = x.y;
		Result[1][2] = x.x;
		Result[2][1] = -x.x;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> matrixCross4
	(
		tvec3<T, P> __const & x
	)
	{
		tmat4x4<T, P> Result(T(0));
		Result[0][1] = x.z;
		Result[1][0] = -x.z;
		Result[0][2] = -x.y;
		Result[2][0] = x.y;
		Result[1][2] = x.x;
		Result[2][1] = -x.x;
		return Result;
	}

}//namespace glm

# 43 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 2 3


# 81 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 1 3
/// @ref gtx_matrix_interpolation
/// @file glm/gtx/matrix_interpolation.hpp
/// @author Ghenadii Ursachi (the.asteroth@gmail.com)
///
/// @see core (dependence)
///
/// @defgroup gtx_matrix_interpolation GLM_GTX_matrix_interpolation
/// @ingroup gtx
///
/// @brief Allows to directly interpolate two exiciting matrices.
///
/// <glm/gtx/matrix_interpolation.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_matrix_interpolation
	/// @{

	/// Get the axis and angle of the rotation from a matrix.
	/// From GLM_GTX_matrix_interpolation extension.
	template <typename T, precision P>
	 void axisAngle(
		tmat4x4<T, P> __const & mat,
		tvec3<T, P> & axis,
		T & angle);

	/// Build a matrix from axis and angle.
	/// From GLM_GTX_matrix_interpolation extension.
	template <typename T, precision P>
	 tmat4x4<T, P> axisAngleMatrix(
		tvec3<T, P> __const & axis,
		T __const angle);

	/// Extracts the rotation part of a matrix.
	/// From GLM_GTX_matrix_interpolation extension.
	template <typename T, precision P>
	 tmat4x4<T, P> extractMatrixRotation(
		tmat4x4<T, P> __const & mat);

	/// Build a interpolation of 4 * 4 matrixes.
	/// From GLM_GTX_matrix_interpolation extension.
	/// Warning! works only with rotation and/or translation matrixes, scale will generate unexpected results.
	template <typename T, precision P>
	 tmat4x4<T, P> interpolate(
		tmat4x4<T, P> __const & m1,
		tmat4x4<T, P> __const & m2,
		T __const delta);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/matrix_interpolation.inl" 1 3
/// @ref gtx_matrix_interpolation
/// @file glm/gtx/matrix_interpolation.hpp

namespace glm
{
	template <typename T, precision P>
	 __inline void axisAngle
	(
		tmat4x4<T, P> __const & mat,
		tvec3<T, P> & axis,
		T & angle
	)
	{
		T epsilon = (T)0.01;
		T epsilon2 = (T)0.1;

		if((abs(mat[1][0] - mat[0][1]) < epsilon) && (abs(mat[2][0] - mat[0][2]) < epsilon) && (abs(mat[2][1] - mat[1][2]) < epsilon))
		{
			if ((abs(mat[1][0] + mat[0][1]) < epsilon2) && (abs(mat[2][0] + mat[0][2]) < epsilon2) && (abs(mat[2][1] + mat[1][2]) < epsilon2) && (abs(mat[0][0] + mat[1][1] + mat[2][2] - (T)3.0) < epsilon2))
			{
				angle = (T)0.0;
				axis.x = (T)1.0;
				axis.y = (T)0.0;
				axis.z = (T)0.0;
				return;
			}
			angle = static_cast<T>(3.1415926535897932384626433832795);
			T xx = (mat[0][0] + (T)1.0) / (T)2.0;
			T yy = (mat[1][1] + (T)1.0) / (T)2.0;
			T zz = (mat[2][2] + (T)1.0) / (T)2.0;
			T xy = (mat[1][0] + mat[0][1]) / (T)4.0;
			T xz = (mat[2][0] + mat[0][2]) / (T)4.0;
			T yz = (mat[2][1] + mat[1][2]) / (T)4.0;
			if((xx > yy) && (xx > zz))
			{
				if (xx < epsilon) {
					axis.x = (T)0.0;
					axis.y = (T)0.7071;
					axis.z = (T)0.7071;
				} else {
					axis.x = sqrt(xx);
					axis.y = xy / axis.x;
					axis.z = xz / axis.x;
				}
			}
			else if (yy > zz)
			{
				if (yy < epsilon) {
					axis.x = (T)0.7071;
					axis.y = (T)0.0;
					axis.z = (T)0.7071;
				} else {
					axis.y = sqrt(yy);
					axis.x = xy / axis.y;
					axis.z = yz / axis.y;
				}
			}
			else
			{
				if (zz < epsilon) {
					axis.x = (T)0.7071;
					axis.y = (T)0.7071;
					axis.z = (T)0.0;
				} else {
					axis.z = sqrt(zz);
					axis.x = xz / axis.z;
					axis.y = yz / axis.z;
				}
			}
			return;
		}
		T s = sqrt((mat[2][1] - mat[1][2]) * (mat[2][1] - mat[1][2]) + (mat[2][0] - mat[0][2]) * (mat[2][0] - mat[0][2]) + (mat[1][0] - mat[0][1]) * (mat[1][0] - mat[0][1]));
		if (glm::abs(s) < T(0.001))
			s = (T)1.0;
		angle = acos((mat[0][0] + mat[1][1] + mat[2][2] - (T)1.0) / (T)2.0);
		axis.x = (mat[1][2] - mat[2][1]) / s;
		axis.y = (mat[2][0] - mat[0][2]) / s;
		axis.z = (mat[0][1] - mat[1][0]) / s;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> axisAngleMatrix
	(
		tvec3<T, P> __const & axis,
		T __const angle
	)
	{
		T c = cos(angle);
		T s = sin(angle);
		T t = static_cast<T>(1) - c;
		tvec3<T, P> n = normalize(axis);

		return tmat4x4<T, P>(
			t * n.x * n.x + c,          t * n.x * n.y + n.z * s,    t * n.x * n.z - n.y * s,    T(0),
			t * n.x * n.y - n.z * s,    t * n.y * n.y + c,          t * n.y * n.z + n.x * s,    T(0),
			t * n.x * n.z + n.y * s,    t * n.y * n.z - n.x * s,    t * n.z * n.z + c,          T(0),
			T(0),                        T(0),                        T(0),                     T(1)
		);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> extractMatrixRotation
	(
		tmat4x4<T, P> __const & mat
	)
	{
		return tmat4x4<T, P>(
			mat[0][0], mat[0][1], mat[0][2], 0.0,
			mat[1][0], mat[1][1], mat[1][2], 0.0,
			mat[2][0], mat[2][1], mat[2][2], 0.0,
			0.0,       0.0,       0.0,       1.0
		);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> interpolate
	(
		tmat4x4<T, P> __const & m1,
		tmat4x4<T, P> __const & m2,
		T __const delta
	)
	{
		tmat4x4<T, P> m1rot = extractMatrixRotation(m1);
		tmat4x4<T, P> dltRotation = m2 * transpose(m1rot);
		tvec3<T, P> dltAxis;
		T dltAngle;
		axisAngle(dltRotation, dltAxis, dltAngle);
		tmat4x4<T, P> out = axisAngleMatrix(dltAxis, dltAngle * delta) * m1rot;
		out[3][0] = m1[3][0] + delta * (m2[3][0] - m1[3][0]);
		out[3][1] = m1[3][1] + delta * (m2[3][1] - m1[3][1]);
		out[3][2] = m1[3][2] + delta * (m2[3][2] - m1[3][2]);
		return out;
	}
}//namespace glm

# 61 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 2 3


# 82 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 1 3
/// @ref gtx_matrix_major_storage
/// @file glm/gtx/matrix_major_storage.hpp
///
/// @see core (dependence)
/// @see gtx_extented_min_max (dependence)
///
/// @defgroup gtx_matrix_major_storage GLM_GTX_matrix_major_storage
/// @ingroup gtx
///
/// @brief Build matrices with specific matrix order, row or column
///
/// <glm/gtx/matrix_major_storage.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_matrix_major_storage
	/// @{

	//! Build a row major matrix from row vectors.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat2x2<T, P> rowMajor2(
		tvec2<T, P> __const & v1, 
		tvec2<T, P> __const & v2);
		
	//! Build a row major matrix from other matrix.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat2x2<T, P> rowMajor2(
		tmat2x2<T, P> __const & m);

	//! Build a row major matrix from row vectors.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat3x3<T, P> rowMajor3(
		tvec3<T, P> __const & v1, 
		tvec3<T, P> __const & v2, 
		tvec3<T, P> __const & v3);

	//! Build a row major matrix from other matrix.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat3x3<T, P> rowMajor3(
		tmat3x3<T, P> __const & m);

	//! Build a row major matrix from row vectors.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat4x4<T, P> rowMajor4(
		tvec4<T, P> __const & v1, 
		tvec4<T, P> __const & v2,
		tvec4<T, P> __const & v3, 
		tvec4<T, P> __const & v4);

	//! Build a row major matrix from other matrix.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat4x4<T, P> rowMajor4(
		tmat4x4<T, P> __const & m);

	//! Build a column major matrix from column vectors.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat2x2<T, P> colMajor2(
		tvec2<T, P> __const & v1, 
		tvec2<T, P> __const & v2);
		
	//! Build a column major matrix from other matrix.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat2x2<T, P> colMajor2(
		tmat2x2<T, P> __const & m);

	//! Build a column major matrix from column vectors.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat3x3<T, P> colMajor3(
		tvec3<T, P> __const & v1, 
		tvec3<T, P> __const & v2, 
		tvec3<T, P> __const & v3);
		
	//! Build a column major matrix from other matrix.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat3x3<T, P> colMajor3(
		tmat3x3<T, P> __const & m);
		
	//! Build a column major matrix from column vectors.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P>
	 tmat4x4<T, P> colMajor4(
		tvec4<T, P> __const & v1, 
		tvec4<T, P> __const & v2, 
		tvec4<T, P> __const & v3, 
		tvec4<T, P> __const & v4);
				
	//! Build a column major matrix from other matrix.
	//! From GLM_GTX_matrix_major_storage extension.
	template <typename T, precision P> 
	 tmat4x4<T, P> colMajor4(
		tmat4x4<T, P> __const & m);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/matrix_major_storage.inl" 1 3
/// @ref gtx_matrix_major_storage
/// @file glm/gtx/matrix_major_storage.hpp

namespace glm
{
	template <typename T, precision P> 
	 __inline tmat2x2<T, P> rowMajor2
	(
		tvec2<T, P> __const & v1, 
		tvec2<T, P> __const & v2
	)
	{
		tmat2x2<T, P> Result;
		Result[0][0] = v1.x;
		Result[1][0] = v1.y;
		Result[0][1] = v2.x;
		Result[1][1] = v2.y;
		return Result;
	}

	template <typename T, precision P> 
	 __inline tmat2x2<T, P> rowMajor2(
		__const tmat2x2<T, P>& m)
	{
		tmat2x2<T, P> Result;
		Result[0][0] = m[0][0];
		Result[0][1] = m[1][0];
		Result[1][0] = m[0][1];
		Result[1][1] = m[1][1];
		return Result;
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> rowMajor3(
		__const tvec3<T, P>& v1, 
		__const tvec3<T, P>& v2, 
		__const tvec3<T, P>& v3)
	{
		tmat3x3<T, P> Result;
		Result[0][0] = v1.x;
		Result[1][0] = v1.y;
		Result[2][0] = v1.z;
		Result[0][1] = v2.x;
		Result[1][1] = v2.y;
		Result[2][1] = v2.z;
		Result[0][2] = v3.x;
		Result[1][2] = v3.y;
		Result[2][2] = v3.z;
		return Result;
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> rowMajor3(
		__const tmat3x3<T, P>& m)
	{
		tmat3x3<T, P> Result;
		Result[0][0] = m[0][0];
		Result[0][1] = m[1][0];
		Result[0][2] = m[2][0];
		Result[1][0] = m[0][1];
		Result[1][1] = m[1][1];
		Result[1][2] = m[2][1];
		Result[2][0] = m[0][2];
		Result[2][1] = m[1][2];
		Result[2][2] = m[2][2];
		return Result;
	}

	template <typename T, precision P> 
	 __inline tmat4x4<T, P> rowMajor4(
		__const tvec4<T, P>& v1, 
		__const tvec4<T, P>& v2, 
		__const tvec4<T, P>& v3, 
		__const tvec4<T, P>& v4)
	{
		tmat4x4<T, P> Result;
		Result[0][0] = v1.x;
		Result[1][0] = v1.y;
		Result[2][0] = v1.z;
		Result[3][0] = v1.w;
		Result[0][1] = v2.x;
		Result[1][1] = v2.y;
		Result[2][1] = v2.z;
		Result[3][1] = v2.w;
		Result[0][2] = v3.x;
		Result[1][2] = v3.y;
		Result[2][2] = v3.z;
		Result[3][2] = v3.w;
		Result[0][3] = v4.x;
		Result[1][3] = v4.y;
		Result[2][3] = v4.z;
		Result[3][3] = v4.w;
		return Result;
	}

	template <typename T, precision P> 
	 __inline tmat4x4<T, P> rowMajor4(
		__const tmat4x4<T, P>& m)
	{
		tmat4x4<T, P> Result;
		Result[0][0] = m[0][0];
		Result[0][1] = m[1][0];
		Result[0][2] = m[2][0];
		Result[0][3] = m[3][0];
		Result[1][0] = m[0][1];
		Result[1][1] = m[1][1];
		Result[1][2] = m[2][1];
		Result[1][3] = m[3][1];
		Result[2][0] = m[0][2];
		Result[2][1] = m[1][2];
		Result[2][2] = m[2][2];
		Result[2][3] = m[3][2];
		Result[3][0] = m[0][3];
		Result[3][1] = m[1][3];
		Result[3][2] = m[2][3];
		Result[3][3] = m[3][3];
		return Result;
	}

	template <typename T, precision P> 
	 __inline tmat2x2<T, P> colMajor2(
		__const tvec2<T, P>& v1, 
		__const tvec2<T, P>& v2)
	{
		return tmat2x2<T, P>(v1, v2);
	}

	template <typename T, precision P> 
	 __inline tmat2x2<T, P> colMajor2(
		__const tmat2x2<T, P>& m)
	{
		return tmat2x2<T, P>(m);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> colMajor3(
		__const tvec3<T, P>& v1, 
		__const tvec3<T, P>& v2, 
		__const tvec3<T, P>& v3)
	{
		return tmat3x3<T, P>(v1, v2, v3);
	}

	template <typename T, precision P> 
	 __inline tmat3x3<T, P> colMajor3(
		__const tmat3x3<T, P>& m)
	{
		return tmat3x3<T, P>(m);
	}

	template <typename T, precision P> 
	 __inline tmat4x4<T, P> colMajor4(
		__const tvec4<T, P>& v1, 
		__const tvec4<T, P>& v2, 
		__const tvec4<T, P>& v3, 
		__const tvec4<T, P>& v4)
	{
		return tmat4x4<T, P>(v1, v2, v3, v4);
	}

	template <typename T, precision P> 
	 __inline tmat4x4<T, P> colMajor4(
		__const tmat4x4<T, P>& m)
	{
		return tmat4x4<T, P>(m);
	}
}//namespace glm

# 115 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 2 3


# 83 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 1 3
/// @ref gtx_matrix_operation
/// @file glm/gtx/matrix_operation.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_matrix_operation GLM_GTX_matrix_operation
/// @ingroup gtx
///
/// @brief Build diagonal matrices from vectors.
///
/// <glm/gtx/matrix_operation.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_matrix_operation
	/// @{

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat2x2<T, P> diagonal2x2(
		tvec2<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat2x3<T, P> diagonal2x3(
		tvec2<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat2x4<T, P> diagonal2x4(
		tvec2<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat3x2<T, P> diagonal3x2(
		tvec2<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat3x3<T, P> diagonal3x3(
		tvec3<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat3x4<T, P> diagonal3x4(
		tvec3<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat4x2<T, P> diagonal4x2(
		tvec2<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat4x3<T, P> diagonal4x3(
		tvec3<T, P> __const & v);

	//! Build a diagonal matrix.
	//! From GLM_GTX_matrix_operation extension.
	template <typename T, precision P>
	 tmat4x4<T, P> diagonal4x4(
		tvec4<T, P> __const & v);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/matrix_operation.inl" 1 3
/// @ref gtx_matrix_operation
/// @file glm/gtx/matrix_operation.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tmat2x2<T, P> diagonal2x2
	(
		tvec2<T, P> __const & v
	)
	{
		tmat2x2<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x3<T, P> diagonal2x3
	(
		tvec2<T, P> __const & v
	)
	{
		tmat2x3<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat2x4<T, P> diagonal2x4
	(
		tvec2<T, P> __const & v
	)
	{
		tmat2x4<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x2<T, P> diagonal3x2
	(
		tvec2<T, P> __const & v
	)
	{
		tmat3x2<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> diagonal3x3
	(
		tvec3<T, P> __const & v
	)
	{
		tmat3x3<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		Result[2][2] = v[2];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat3x4<T, P> diagonal3x4
	(
		tvec3<T, P> __const & v
	)
	{
		tmat3x4<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		Result[2][2] = v[2];
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> diagonal4x4
	(
		tvec4<T, P> __const & v
	)
	{
		tmat4x4<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		Result[2][2] = v[2];
		Result[3][3] = v[3];
		return Result;		
	}

	template <typename T, precision P>
	 __inline tmat4x3<T, P> diagonal4x3
	(
		tvec3<T, P> __const & v
	)
	{
		tmat4x3<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		Result[2][2] = v[2];
		return Result;		
	}

	template <typename T, precision P>
	 __inline tmat4x2<T, P> diagonal4x2
	(
		tvec2<T, P> __const & v
	)
	{
		tmat4x2<T, P> Result(static_cast<T>(1));
		Result[0][0] = v[0];
		Result[1][1] = v[1];
		return Result;		
	}
}//namespace glm

# 84 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 2 3


# 84 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/matrix_query.hpp" 1 3
/// @ref gtx_matrix_query
/// @file glm/gtx/matrix_query.hpp
///
/// @see core (dependence)
/// @see gtx_vector_query (dependence)
///
/// @defgroup gtx_matrix_query GLM_GTX_matrix_query
/// @ingroup gtx
///
/// @brief Query to evaluate matrix properties
///
/// <glm/gtx/matrix_query.hpp> need to be included to use these functionalities.



// Dependency:






       

namespace glm
{
	/// @addtogroup gtx_matrix_query
	/// @{

	/// Return whether a matrix a null matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P>
	 bool isNull(tmat2x2<T, P> __const & m, T __const & epsilon);
		
	/// Return whether a matrix a null matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P>
	 bool isNull(tmat3x3<T, P> __const & m, T __const & epsilon);
		
	/// Return whether a matrix is a null matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P>
	 bool isNull(tmat4x4<T, P> __const & m, T __const & epsilon);
			
	/// Return whether a matrix is an identity matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P, template <typename, precision> class matType>
	 bool isIdentity(matType<T, P> __const & m, T __const & epsilon);

	/// Return whether a matrix is a normalized matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P>
	 bool isNormalized(tmat2x2<T, P> __const & m, T __const & epsilon);

	/// Return whether a matrix is a normalized matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P>
	 bool isNormalized(tmat3x3<T, P> __const & m, T __const & epsilon);

	/// Return whether a matrix is a normalized matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P>
	 bool isNormalized(tmat4x4<T, P> __const & m, T __const & epsilon);

	/// Return whether a matrix is an orthonormalized matrix.
	/// From GLM_GTX_matrix_query extension.
	template<typename T, precision P, template <typename, precision> class matType>
	 bool isOrthogonal(matType<T, P> __const & m, T __const & epsilon);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/matrix_query.inl" 1 3
/// @ref gtx_matrix_query
/// @file glm/gtx/matrix_query.inl

namespace glm
{
	template<typename T, precision P>
	 __inline bool isNull(tmat2x2<T, P> __const & m, T __const & epsilon)
	{
		bool result = true;
		for(length_t i = 0; result && i < m.length() ; ++i)
			result = isNull(m[i], epsilon);
		return result;
	}

	template<typename T, precision P>
	 __inline bool isNull(tmat3x3<T, P> __const & m, T __const & epsilon)
	{
		bool result = true;
		for(length_t i = 0; result && i < m.length() ; ++i)
			result = isNull(m[i], epsilon);
		return result;
	}

	template<typename T, precision P>
	 __inline bool isNull(tmat4x4<T, P> __const & m, T __const & epsilon)
	{
		bool result = true;
		for(length_t i = 0; result && i < m.length() ; ++i)
			result = isNull(m[i], epsilon);
		return result;
	}

	template<typename T, precision P, template <typename, precision> class matType>
	 __inline bool isIdentity(matType<T, P> __const & m, T __const & epsilon)
	{
		bool result = true;
		for(length_t i = 0; result && i < m[0].length() ; ++i)
		{
			for(length_t j = 0; result && j < i ; ++j)
				result = abs(m[i][j]) <= epsilon;
			if(result)
				result = abs(m[i][i] - 1) <= epsilon;
			for(length_t j = i + 1; result && j < m.length(); ++j)
				result = abs(m[i][j]) <= epsilon;
		}
		return result;
	}

	template<typename T, precision P>
	 __inline bool isNormalized(tmat2x2<T, P> __const & m, T __const & epsilon)
	{
		bool result(true);
		for(length_t i = 0; result && i < m.length(); ++i)
			result = isNormalized(m[i], epsilon);
		for(length_t i = 0; result && i < m.length(); ++i)
		{
			typename tmat2x2<T, P>::col_type v;
			for(length_t j = 0; j < m.length(); ++j)
				v[j] = m[j][i];
			result = isNormalized(v, epsilon);
		}
		return result;
	}

	template<typename T, precision P>
	 __inline bool isNormalized(tmat3x3<T, P> __const & m, T __const & epsilon)
	{
		bool result(true);
		for(length_t i = 0; result && i < m.length(); ++i)
			result = isNormalized(m[i], epsilon);
		for(length_t i = 0; result && i < m.length(); ++i)
		{
			typename tmat3x3<T, P>::col_type v;
			for(length_t j = 0; j < m.length(); ++j)
				v[j] = m[j][i];
			result = isNormalized(v, epsilon);
		}
		return result;
	}

	template<typename T, precision P>
	 __inline bool isNormalized(tmat4x4<T, P> __const & m, T __const & epsilon)
	{
		bool result(true);
		for(length_t i = 0; result && i < m.length(); ++i)
			result = isNormalized(m[i], epsilon);
		for(length_t i = 0; result && i < m.length(); ++i)
		{
			typename tmat4x4<T, P>::col_type v;
			for(length_t j = 0; j < m.length(); ++j)
				v[j] = m[j][i];
			result = isNormalized(v, epsilon);
		}
		return result;
	}

	template<typename T, precision P, template <typename, precision> class matType>
	 __inline bool isOrthogonal(matType<T, P> __const & m, T __const & epsilon)
	{
		bool result(true);
		for(length_t i(0); result && i < m.length() - 1; ++i)
		for(length_t j(i + 1); result && j < m.length(); ++j)
			result = areOrthogonal(m[i], m[j], epsilon);

		if(result)
		{
			matType<T, P> tmp = transpose(m);
			for(length_t i(0); result && i < m.length() - 1 ; ++i)
			for(length_t j(i + 1); result && j < m.length(); ++j)
				result = areOrthogonal(tmp[i], tmp[j], epsilon);
		}
		return result;
	}
}//namespace glm

# 73 "/usr/local/include/glm/./gtx/matrix_query.hpp" 2 3


# 85 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/mixed_product.hpp" 1 3
/// @ref gtx_mixed_product
/// @file glm/gtx/mixed_product.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_mixed_product GLM_GTX_mixed_producte
/// @ingroup gtx
///
/// @brief Mixed product of 3 vectors.
///
/// <glm/gtx/mixed_product.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_mixed_product
	/// @{

	/// @brief Mixed product of 3 vectors (from GLM_GTX_mixed_product extension)
	template <typename T, precision P> 
	 T mixedProduct(
		tvec3<T, P> __const & v1, 
		tvec3<T, P> __const & v2, 
		tvec3<T, P> __const & v3);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/mixed_product.inl" 1 3
/// @ref gtx_mixed_product
/// @file glm/gtx/mixed_product.inl

namespace glm
{
	template <typename T, precision P>
	 __inline T mixedProduct
	(
		tvec3<T, P> __const & v1,
		tvec3<T, P> __const & v2,
		tvec3<T, P> __const & v3
	)
	{
		return dot(cross(v1, v2), v3);
	}
}//namespace glm

# 37 "/usr/local/include/glm/./gtx/mixed_product.hpp" 2 3


# 86 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/norm.hpp" 1 3
/// @ref gtx_norm
/// @file glm/gtx/norm.hpp
///
/// @see core (dependence)
/// @see gtx_quaternion (dependence)
///
/// @defgroup gtx_norm GLM_GTX_norm
/// @ingroup gtx
///
/// @brief Various ways to compute vector norms.
/// 
/// <glm/gtx/norm.hpp> need to be included to use these functionalities.



// Dependency:


# 1 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 1 3
/// @ref gtx_quaternion
/// @file glm/gtx/quaternion.hpp
///
/// @see core (dependence)
/// @see gtx_extented_min_max (dependence)
///
/// @defgroup gtx_quaternion GLM_GTX_quaternion
/// @ingroup gtx
///
/// @brief Extented quaternion types and functions
///
/// <glm/gtx/quaternion.hpp> need to be included to use these functionalities.



// Dependency:







       

namespace glm
{
	/// @addtogroup gtx_quaternion
	/// @{

	/// Compute a cross product between a quaternion and a vector.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tvec3<T, P> cross(
		tquat<T, P> __const & q,
		tvec3<T, P> __const & v);

	//! Compute a cross product between a vector and a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tvec3<T, P> cross(
		tvec3<T, P> __const & v,
		tquat<T, P> __const & q);

	//! Compute a point on a path according squad equation. 
	//! q1 and q2 are control points; s1 and s2 are intermediate control points.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> squad(
		tquat<T, P> __const & q1,
		tquat<T, P> __const & q2,
		tquat<T, P> __const & s1,
		tquat<T, P> __const & s2,
		T __const & h);

	//! Returns an intermediate control point for squad interpolation.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> intermediate(
		tquat<T, P> __const & prev,
		tquat<T, P> __const & curr,
		tquat<T, P> __const & next);

	//! Returns a exp of a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> exp(
		tquat<T, P> __const & q);

	//! Returns a log of a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> log(
		tquat<T, P> __const & q);

	/// Returns x raised to the y power.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> pow(
		tquat<T, P> __const & x,
		T __const & y);

	//! Returns quarternion square root.
	///
	/// @see gtx_quaternion
	//template<typename T, precision P>
	//tquat<T, P> sqrt(
	//	tquat<T, P> __const & q);

	//! Rotates a 3 components vector by a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tvec3<T, P> rotate(
		tquat<T, P> __const & q,
		tvec3<T, P> __const & v);

	/// Rotates a 4 components vector by a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tvec4<T, P> rotate(
		tquat<T, P> __const & q,
		tvec4<T, P> __const & v);

	/// Extract the real component of a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 T extractRealComponent(
		tquat<T, P> __const & q);

	/// Converts a quaternion to a 3 * 3 matrix.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tmat3x3<T, P> toMat3(
		tquat<T, P> __const & x){return mat3_cast(x);}

	/// Converts a quaternion to a 4 * 4 matrix.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tmat4x4<T, P> toMat4(
		tquat<T, P> __const & x){return mat4_cast(x);}

	/// Converts a 3 * 3 matrix to a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> toQuat(
		tmat3x3<T, P> __const & x){return quat_cast(x);}

	/// Converts a 4 * 4 matrix to a quaternion.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> toQuat(
		tmat4x4<T, P> __const & x){return quat_cast(x);}

	/// Quaternion interpolation using the rotation short path.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> shortMix(
		tquat<T, P> __const & x,
		tquat<T, P> __const & y,
		T __const & a);

	/// Quaternion normalized linear interpolation.
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> fastMix(
		tquat<T, P> __const & x,
		tquat<T, P> __const & y,
		T __const & a);

	/// Compute the rotation between two vectors.
	/// param orig vector, needs to be normalized
	/// param dest vector, needs to be normalized
	///
	/// @see gtx_quaternion
	template<typename T, precision P>
	 tquat<T, P> rotation(
		tvec3<T, P> __const & orig, 
		tvec3<T, P> __const & dest);

	/// Returns the squared length of x.
	/// 
	/// @see gtx_quaternion
	template<typename T, precision P>
	 T length2(tquat<T, P> __const & q);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/quaternion.inl" 1 3
/// @ref gtx_quaternion
/// @file glm/gtx/quaternion.inl




namespace glm
{
	template <typename T, precision P>
	 __inline tvec3<T, P> cross(tvec3<T, P> __const& v, tquat<T, P> __const& q)
	{
		return inverse(q) * v;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> cross(tquat<T, P> __const& q, tvec3<T, P> __const& v)
	{
		return q * v;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> squad
	(
		tquat<T, P> __const & q1,
		tquat<T, P> __const & q2,
		tquat<T, P> __const & s1,
		tquat<T, P> __const & s2,
		T __const & h)
	{
		return mix(mix(q1, q2, h), mix(s1, s2, h), static_cast<T>(2) * (static_cast<T>(1) - h) * h);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> intermediate
	(
		tquat<T, P> __const & prev,
		tquat<T, P> __const & curr,
		tquat<T, P> __const & next
	)
	{
		tquat<T, P> invQuat = inverse(curr);
		return exp((log(next + invQuat) + log(prev + invQuat)) / static_cast<T>(-4)) * curr;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> exp(tquat<T, P> __const& q)
	{
		tvec3<T, P> u(q.x, q.y, q.z);
		T __const Angle = glm::length(u);
		if (Angle < epsilon<T>())
			return tquat<T, P>();

		tvec3<T, P> __const v(u / Angle);
		return tquat<T, P>(cos(Angle), sin(Angle) * v);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> log(tquat<T, P> __const& q)
	{
		tvec3<T, P> u(q.x, q.y, q.z);
		T Vec3Len = length(u);

		if (Vec3Len < epsilon<T>())
		{
			if(q.w > static_cast<T>(0))
				return tquat<T, P>(log(q.w), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
			else if(q.w < static_cast<T>(0))
				return tquat<T, P>(log(-q.w), pi<T>(), static_cast<T>(0), static_cast<T>(0));
			else
				return tquat<T, P>(std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity());
		}
		else
		{
			T t = atan(Vec3Len, T(q.w)) / Vec3Len;
			T QuatLen2 = Vec3Len * Vec3Len + q.w * q.w;
			return tquat<T, P>(static_cast<T>(0.5) * log(QuatLen2), t * q.x, t * q.y, t * q.z);
		}
	}

	template <typename T, precision P>
	 __inline tquat<T, P> pow(tquat<T, P> __const & x, T __const & y)
	{
		//Raising to the power of 0 should yield 1
		//Needed to prevent a division by 0 error later on
		if(y > -epsilon<T>() && y < epsilon<T>())
			return tquat<T, P>(1,0,0,0);

		//To deal with non-unit quaternions
		T magnitude = sqrt(x.x * x.x + x.y * x.y + x.z * x.z + x.w *x.w);

		//Equivalent to raising a real number to a power
		//Needed to prevent a division by 0 error later on
		if(abs(x.w / magnitude) > static_cast<T>(1) - epsilon<T>() && abs(x.w / magnitude) < static_cast<T>(1) + epsilon<T>())
			return tquat<T, P>(pow(x.w, y),0,0,0);

		T Angle = acos(x.w / magnitude);
		T NewAngle = Angle * y;
		T Div = sin(NewAngle) / sin(Angle);
		T Mag = pow(magnitude, y - static_cast<T>(1));

		return tquat<T, P>(cos(NewAngle) * magnitude * Mag, x.x * Div * Mag, x.y * Div * Mag, x.z * Div * Mag);
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> rotate(tquat<T, P> __const& q, tvec3<T, P> __const& v)
	{
		return q * v;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> rotate(tquat<T, P> __const& q, tvec4<T, P> __const& v)
	{
		return q * v;
	}

	template <typename T, precision P>
	 __inline T extractRealComponent(tquat<T, P> __const& q)
	{
		T w = static_cast<T>(1) - q.x * q.x - q.y * q.y - q.z * q.z;
		if(w < T(0))
			return T(0);
		else
			return -sqrt(w);
	}

	template <typename T, precision P>
	 __inline T length2(tquat<T, P> __const& q)
	{
		return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
	}

	template <typename T, precision P>
	 __inline tquat<T, P> shortMix(tquat<T, P> __const& x, tquat<T, P> __const& y, T __const& a)
	{
		if(a <= static_cast<T>(0)) return x;
		if(a >= static_cast<T>(1)) return y;

		T fCos = dot(x, y);
		tquat<T, P> y2(y); //BUG!!! tquat<T> y2;
		if(fCos < static_cast<T>(0))
		{
			y2 = -y;
			fCos = -fCos;
		}

		//if(fCos > 1.0f) // problem
		T k0, k1;
		if(fCos > (static_cast<T>(1) - epsilon<T>()))
		{
			k0 = static_cast<T>(1) - a;
			k1 = static_cast<T>(0) + a; //BUG!!! 1.0f + a;
		}
		else
		{
			T fSin = sqrt(T(1) - fCos * fCos);
			T fAngle = atan(fSin, fCos);
			T fOneOverSin = static_cast<T>(1) / fSin;
			k0 = sin((static_cast<T>(1) - a) * fAngle) * fOneOverSin;
			k1 = sin((static_cast<T>(0) + a) * fAngle) * fOneOverSin;
		}

		return tquat<T, P>(
			k0 * x.w + k1 * y2.w,
			k0 * x.x + k1 * y2.x,
			k0 * x.y + k1 * y2.y,
			k0 * x.z + k1 * y2.z);
	}

	template <typename T, precision P>
	 __inline tquat<T, P> fastMix(tquat<T, P> __const& x, tquat<T, P> __const& y, T __const & a)
	{
		return glm::normalize(x * (static_cast<T>(1) - a) + (y * a));
	}

	template <typename T, precision P>
	 __inline tquat<T, P> rotation(tvec3<T, P> __const& orig, tvec3<T, P> __const& dest)
	{
		T cosTheta = dot(orig, dest);
		tvec3<T, P> rotationAxis;

		if(cosTheta >= static_cast<T>(1) - epsilon<T>())
			return quat();

		if(cosTheta < static_cast<T>(-1) + epsilon<T>())
		{
			// special case when vectors in opposite directions :
			// there is no "ideal" rotation axis
			// So guess one; any will do as long as it's perpendicular to start
			// This implementation favors a rotation around the Up axis (Y),
			// since it's often what you want to do.
			rotationAxis = cross(tvec3<T, P>(0, 0, 1), orig);
			if(length2(rotationAxis) < epsilon<T>()) // bad luck, they were parallel, try again!
				rotationAxis = cross(tvec3<T, P>(1, 0, 0), orig);

			rotationAxis = normalize(rotationAxis);
			return angleAxis(pi<T>(), rotationAxis);
		}

		// Implementation from Stan Melax's Game Programming Gems 1 article
		rotationAxis = cross(orig, dest);

		T s = sqrt((T(1) + cosTheta) * static_cast<T>(2));
		T invs = static_cast<T>(1) / s;

		return tquat<T, P>(
			s * static_cast<T>(0.5f), 
			rotationAxis.x * invs,
			rotationAxis.y * invs,
			rotationAxis.z * invs);
	}

}//namespace glm

# 185 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 2 3


# 18 "/usr/local/include/glm/./gtx/norm.hpp" 2 3




       

namespace glm
{
	/// @addtogroup gtx_norm
	/// @{

	/// Returns the squared length of x.
	/// From GLM_GTX_norm extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 T length2(
		vecType<T, P> __const & x);

	/// Returns the squared distance between p0 and p1, i.e., length2(p0 - p1).
	/// From GLM_GTX_norm extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 T distance2(
		vecType<T, P> __const & p0,
		vecType<T, P> __const & p1);

	//! Returns the L1 norm between x and y.
	//! From GLM_GTX_norm extension.
	template <typename T, precision P>
	 T l1Norm(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y);
		
	//! Returns the L1 norm of v.
	//! From GLM_GTX_norm extension.
	template <typename T, precision P>
	 T l1Norm(
		tvec3<T, P> __const & v);
		
	//! Returns the L2 norm between x and y.
	//! From GLM_GTX_norm extension.
	template <typename T, precision P>
	 T l2Norm(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y);
		
	//! Returns the L2 norm of v.
	//! From GLM_GTX_norm extension.
	template <typename T, precision P>
	 T l2Norm(
		tvec3<T, P> __const & x);
		
	//! Returns the L norm between x and y.
	//! From GLM_GTX_norm extension.
	template <typename T, precision P>
	 T lxNorm(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y,
		unsigned int Depth);

	//! Returns the L norm of v.
	//! From GLM_GTX_norm extension.
	template <typename T, precision P>
	 T lxNorm(
		tvec3<T, P> __const & x,
		unsigned int Depth);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/norm.inl" 1 3
/// @ref gtx_norm
/// @file glm/gtx/norm.inl



namespace glm{
namespace detail
{
	template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
	struct compute_length2
	{
		 __inline static T call(vecType<T, P> __const & v)
		{
			return dot(v, v);
		}
	};
}//namespace detail

	template <typename genType>
	 __inline genType length2(genType x)
	{
		;
		return x * x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T length2(vecType<T, P> __const & v)
	{
		;
		return detail::compute_length2<vecType, T, P, detail::is_aligned<P>::value>::call(v);
	}

	template <typename T>
	 __inline T distance2(T p0, T p1)
	{
		;
		return length2(p1 - p0);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T distance2(vecType<T, P> __const & p0, vecType<T, P> __const & p1)
	{
		;
		return length2(p1 - p0);
	}

	template <typename T, precision P>
	 __inline T l1Norm
	(
		tvec3<T, P> __const & a,
		tvec3<T, P> __const & b
	)
	{
		return abs(b.x - a.x) + abs(b.y - a.y) + abs(b.z - a.z);
	}

	template <typename T, precision P>
	 __inline T l1Norm
	(
		tvec3<T, P> __const & v
	)
	{
		return abs(v.x) + abs(v.y) + abs(v.z);
	}

	template <typename T, precision P>
	 __inline T l2Norm
	(
		tvec3<T, P> __const & a,
		tvec3<T, P> __const & b
	)
	{
		return length(b - a);
	}

	template <typename T, precision P>
	 __inline T l2Norm
	(
		tvec3<T, P> __const & v
	)
	{
		return length(v);
	}

	template <typename T, precision P>
	 __inline T lxNorm
	(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y,
		unsigned int Depth
	)
	{
		return pow(pow(y.x - x.x, T(Depth)) + pow(y.y - x.y, T(Depth)) + pow(y.z - x.z, T(Depth)), T(1) / T(Depth));
	}

	template <typename T, precision P>
	 __inline T lxNorm
	(
		tvec3<T, P> __const & v,
		unsigned int Depth
	)
	{
		return pow(pow(v.x, T(Depth)) + pow(v.y, T(Depth)) + pow(v.z, T(Depth)), T(1) / T(Depth));
	}

}//namespace glm

# 86 "/usr/local/include/glm/./gtx/norm.hpp" 2 3


# 87 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/normal.hpp" 1 3
/// @ref gtx_normal
/// @file glm/gtx/normal.hpp
///
/// @see core (dependence)
/// @see gtx_extented_min_max (dependence)
///
/// @defgroup gtx_normal GLM_GTX_normal
/// @ingroup gtx
///
/// @brief Compute the normal of a triangle.
///
/// <glm/gtx/normal.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_normal
	/// @{

	//! Computes triangle normal from triangle points. 
	//! From GLM_GTX_normal extension.
	template <typename T, precision P> 
	 tvec3<T, P> triangleNormal(
		tvec3<T, P> __const & p1, 
		tvec3<T, P> __const & p2, 
		tvec3<T, P> __const & p3);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/normal.inl" 1 3
/// @ref gtx_normal
/// @file glm/gtx/normal.inl

namespace glm
{
	template <typename T, precision P> 
	 __inline tvec3<T, P> triangleNormal
	(
		tvec3<T, P> __const & p1, 
		tvec3<T, P> __const & p2, 
		tvec3<T, P> __const & p3
	)
	{
		return normalize(cross(p1 - p2, p1 - p3));
	}
}//namespace glm

# 39 "/usr/local/include/glm/./gtx/normal.hpp" 2 3


# 88 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 1 3
/// @ref gtx_normalize_dot
/// @file glm/gtx/normalize_dot.hpp
///
/// @see core (dependence)
/// @see gtx_fast_square_root (dependence)
///
/// @defgroup gtx_normalize_dot GLM_GTX_normalize_dot
/// @ingroup gtx
///
/// @brief Dot product of vectors that need to be normalize with a single square root.
///
/// <glm/gtx/normalized_dot.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_normalize_dot
	/// @{

	/// Normalize parameters and returns the dot product of x and y.
	/// It's faster that dot(normalize(x), normalize(y)).
	///
	/// @see gtx_normalize_dot extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 T normalizeDot(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// Normalize parameters and returns the dot product of x and y.
	/// Faster that dot(fastNormalize(x), fastNormalize(y)).
	///
	/// @see gtx_normalize_dot extension.
	template <typename T, precision P, template <typename, precision> class vecType>
	 T fastNormalizeDot(vecType<T, P> __const & x, vecType<T, P> __const & y);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/normalize_dot.inl" 1 3
/// @ref gtx_normalize_dot
/// @file glm/gtx/normalize_dot.inl

namespace glm
{
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T normalizeDot(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		return glm::dot(x, y) * glm::inversesqrt(glm::dot(x, x) * glm::dot(y, y));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline T fastNormalizeDot(vecType<T, P> __const & x, vecType<T, P> __const & y)
	{
		return glm::dot(x, y) * glm::fastInverseSqrt(glm::dot(x, x) * glm::dot(y, y));
	}
}//namespace glm

# 45 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 2 3


# 89 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/number_precision.hpp" 1 3
/// @ref gtx_number_precision
/// @file glm/gtx/number_precision.hpp
///
/// @see core (dependence)
/// @see gtc_type_precision (dependence)
/// @see gtc_quaternion (dependence)
///
/// @defgroup gtx_number_precision GLM_GTX_number_precision
/// @ingroup gtx
///
/// @brief Defined size types.
///
/// <glm/gtx/number_precision.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm{
namespace gtx
{
	/////////////////////////////
	// Unsigned int vector types 

	/// @addtogroup gtx_number_precision
	/// @{

	typedef u8			u8vec1;		//!< \brief 8bit unsigned integer scalar. (from GLM_GTX_number_precision extension)
	typedef u16			u16vec1;    //!< \brief 16bit unsigned integer scalar. (from GLM_GTX_number_precision extension)
	typedef u32			u32vec1;    //!< \brief 32bit unsigned integer scalar. (from GLM_GTX_number_precision extension)
	typedef u64			u64vec1;    //!< \brief 64bit unsigned integer scalar. (from GLM_GTX_number_precision extension)

	//////////////////////
	// Float vector types 

	typedef f32			f32vec1;    //!< \brief Single-precision floating-point scalar. (from GLM_GTX_number_precision extension)
	typedef f64			f64vec1;    //!< \brief Single-precision floating-point scalar. (from GLM_GTX_number_precision extension)

	//////////////////////
	// Float matrix types 

	typedef f32			f32mat1;	//!< \brief Single-precision floating-point scalar. (from GLM_GTX_number_precision extension)
	typedef f32			f32mat1x1;	//!< \brief Single-precision floating-point scalar. (from GLM_GTX_number_precision extension)
	typedef f64			f64mat1;	//!< \brief Double-precision floating-point scalar. (from GLM_GTX_number_precision extension)
	typedef f64			f64mat1x1;	//!< \brief Double-precision floating-point scalar. (from GLM_GTX_number_precision extension)

	/// @}
}//namespace gtx
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/number_precision.inl" 1 3
/// @ref gtx_number_precision
/// @file glm/gtx/number_precision.inl

namespace glm
{

}

# 57 "/usr/local/include/glm/./gtx/number_precision.hpp" 2 3


# 90 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 1 3
/// @ref gtx_orthonormalize
/// @file glm/gtx/orthonormalize.hpp
///
/// @see core (dependence)
/// @see gtx_extented_min_max (dependence)
///
/// @defgroup gtx_orthonormalize GLM_GTX_orthonormalize
/// @ingroup gtx
///
/// @brief Orthonormalize matrices.
///
/// <glm/gtx/orthonormalize.hpp> need to be included to use these functionalities.



// Dependency:






       

namespace glm
{
	/// @addtogroup gtx_orthonormalize
	/// @{

	/// Returns the orthonormalized matrix of m.
	///
	/// @see gtx_orthonormalize
	template <typename T, precision P> 
	 tmat3x3<T, P> orthonormalize(tmat3x3<T, P> __const & m);
		
	/// Orthonormalizes x according y.
	///
	/// @see gtx_orthonormalize
	template <typename T, precision P> 
	 tvec3<T, P> orthonormalize(tvec3<T, P> __const & x, tvec3<T, P> __const & y);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/orthonormalize.inl" 1 3
/// @ref gtx_orthonormalize
/// @file glm/gtx/orthonormalize.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tmat3x3<T, P> orthonormalize(tmat3x3<T, P> __const & m)
	{
		tmat3x3<T, P> r = m;

		r[0] = normalize(r[0]);

		T d0 = dot(r[0], r[1]);
		r[1] -= r[0] * d0;
		r[1] = normalize(r[1]);

		T d1 = dot(r[1], r[2]);
		d0 = dot(r[0], r[2]);
		r[2] -= r[0] * d0 + r[1] * d1;
		r[2] = normalize(r[2]);

		return r;
	}

	template <typename T, precision P> 
	 __inline tvec3<T, P> orthonormalize(tvec3<T, P> __const & x, tvec3<T, P> __const & y)
	{
		return normalize(x - y * dot(y, x));
	}
}//namespace glm

# 45 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 2 3


# 92 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/perpendicular.hpp" 1 3
/// @ref gtx_perpendicular
/// @file glm/gtx/perpendicular.hpp
///
/// @see core (dependence)
/// @see gtx_projection (dependence)
///
/// @defgroup gtx_perpendicular GLM_GTX_perpendicular
/// @ingroup gtx
///
/// @brief Perpendicular of a vector from other one
///
/// <glm/gtx/perpendicular.hpp> need to be included to use these functionalities.



// Dependency:


# 1 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 1 3
/// @ref gtx_projection
/// @file glm/gtx/projection.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_projection GLM_GTX_projection
/// @ingroup gtx
///
/// @brief Projection of a vector to other one
///
/// <glm/gtx/projection.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_projection
	/// @{

	/// Projects x on Normal.
	///
	/// @see gtx_projection
	template <typename vecType>
	 vecType proj(vecType __const & x, vecType __const & Normal);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/projection.inl" 1 3
/// @ref gtx_projection
/// @file glm/gtx/projection.inl

namespace glm
{
	template <typename vecType>
	 __inline vecType proj(vecType __const & x, vecType __const & Normal)
	{
		return glm::dot(x, Normal) / glm::dot(Normal, Normal) * Normal;
	}
}//namespace glm

# 36 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 2 3


# 18 "/usr/local/include/glm/./gtx/perpendicular.hpp" 2 3




       

namespace glm
{
	/// @addtogroup gtx_perpendicular
	/// @{

	//! Projects x a perpendicular axis of Normal.
	//! From GLM_GTX_perpendicular extension.
	template <typename vecType> 
	 vecType perp(
		vecType __const & x, 
		vecType __const & Normal);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/perpendicular.inl" 1 3
/// @ref gtx_perpendicular
/// @file glm/gtx/perpendicular.inl

namespace glm
{
	template <typename vecType> 
	 __inline vecType perp
	(
		vecType __const & x, 
		vecType __const & Normal
	)
	{
		return x - proj(x, Normal);
	}
}//namespace glm

# 39 "/usr/local/include/glm/./gtx/perpendicular.hpp" 2 3


# 93 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 1 3
/// @ref gtx_polar_coordinates
/// @file glm/gtx/polar_coordinates.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_polar_coordinates GLM_GTX_polar_coordinates
/// @ingroup gtx
///
/// @brief Conversion from Euclidean space to polar space and revert.
///
/// <glm/gtx/polar_coordinates.hpp> need to be included to use these functionalities.



// Dependency:




       

namespace glm
{
	/// @addtogroup gtx_polar_coordinates
	/// @{

	/// Convert Euclidean to Polar coordinates, x is the xz distance, y, the latitude and z the longitude.
	///
	/// @see gtx_polar_coordinates
	template <typename T, precision P>
	 tvec3<T, P> polar(
		tvec3<T, P> __const & euclidean);

	/// Convert Polar to Euclidean coordinates.
	///
	/// @see gtx_polar_coordinates
	template <typename T, precision P>
	 tvec3<T, P> euclidean(
		tvec2<T, P> __const & polar);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/polar_coordinates.inl" 1 3
/// @ref gtx_polar_coordinates
/// @file glm/gtx/polar_coordinates.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tvec3<T, P> polar
	(
		tvec3<T, P> __const & euclidean
	)
	{
		T __const Length(length(euclidean));
		tvec3<T, P> __const tmp(euclidean / Length);
		T __const xz_dist(sqrt(tmp.x * tmp.x + tmp.z * tmp.z));

		return tvec3<T, P>(
			asin(tmp.y),	// latitude
			atan(tmp.x, tmp.z),		// longitude
			xz_dist);				// xz distance
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> euclidean
	(
		tvec2<T, P> __const & polar
	)
	{
		T __const latitude(polar.x);
		T __const longitude(polar.y);

		return tvec3<T, P>(
			cos(latitude) * sin(longitude),
			sin(latitude),
			cos(latitude) * cos(longitude));
	}

}//namespace glm

# 44 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 2 3


# 94 "/usr/local/include/glm/ext.hpp" 2 3




# 1 "/usr/local/include/glm/./gtx/raw_data.hpp" 1 3
/// @ref gtx_raw_data
/// @file glm/gtx/raw_data.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_raw_data GLM_GTX_raw_data
/// @ingroup gtx
///
/// @brief Projection of a vector to other one
///
/// <glm/gtx/raw_data.hpp> need to be included to use these functionalities.



// Dependencies





       

namespace glm
{
	/// @addtogroup gtx_raw_data
	/// @{

	//! Type for byte numbers. 
	//! From GLM_GTX_raw_data extension.
	typedef detail::uint8		byte;

	//! Type for word numbers. 
	//! From GLM_GTX_raw_data extension.
	typedef detail::uint16		word;

	//! Type for dword numbers. 
	//! From GLM_GTX_raw_data extension.
	typedef detail::uint32		dword;

	//! Type for qword numbers. 
	//! From GLM_GTX_raw_data extension.
	typedef detail::uint64		qword;

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/raw_data.inl" 1 3
/// @ref gtx_raw_data
/// @file glm/gtx/raw_data.inl

# 47 "/usr/local/include/glm/./gtx/raw_data.hpp" 2 3


# 97 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 1 3
/// @ref gtx_rotate_vector
/// @file glm/gtx/rotate_vector.hpp
///
/// @see core (dependence)
/// @see gtx_transform (dependence)
///
/// @defgroup gtx_rotate_vector GLM_GTX_rotate_vector
/// @ingroup gtx
///
/// @brief Function to directly rotate a vector
///
/// <glm/gtx/rotate_vector.hpp> need to be included to use these functionalities.



// Dependency:


# 1 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 1 3
/// @ref gtx_transform
/// @file glm/gtx/transform.hpp
///
/// @see core (dependence)
/// @see gtc_matrix_transform (dependence)
/// @see gtx_transform
/// @see gtx_transform2
///
/// @defgroup gtx_transform GLM_GTX_transform
/// @ingroup gtx
///
/// @brief Add transformation matrices
///
/// <glm/gtx/transform.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// @addtogroup gtx_transform
	/// @{

	/// Transforms a matrix with a translation 4 * 4 matrix created from 3 scalars.
	/// @see gtc_matrix_transform
	/// @see gtx_transform
	template <typename T, precision P>
	 tmat4x4<T, P> translate(
		tvec3<T, P> __const & v);

	/// Builds a rotation 4 * 4 matrix created from an axis of 3 scalars and an angle expressed in radians. 
	/// @see gtc_matrix_transform
	/// @see gtx_transform
	template <typename T, precision P>
	 tmat4x4<T, P> rotate(
		T angle, 
		tvec3<T, P> __const & v);

	/// Transforms a matrix with a scale 4 * 4 matrix created from a vector of 3 components.
	/// @see gtc_matrix_transform
	/// @see gtx_transform
	template <typename T, precision P>
	 tmat4x4<T, P> scale(
		tvec3<T, P> __const & v);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/transform.inl" 1 3
/// @ref gtx_transform
/// @file glm/gtx/transform.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tmat4x4<T, P> translate(tvec3<T, P> __const & v)
	{
		return translate(tmat4x4<T, P>(static_cast<T>(1)), v);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> rotate(T angle, tvec3<T, P> __const & v)
	{
		return rotate(tmat4x4<T, P>(static_cast<T>(1)), angle, v);
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> scale(tvec3<T, P> __const & v)
	{
		return scale(tmat4x4<T, P>(static_cast<T>(1)), v);
	}

}//namespace glm

# 56 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 2 3


# 18 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 2 3




       

namespace glm
{
	/// @addtogroup gtx_rotate_vector
	/// @{

	/// Returns Spherical interpolation between two vectors
	/// 
	/// @param x A first vector
	/// @param y A second vector
	/// @param a Interpolation factor. The interpolation is defined beyond the range [0, 1].
	/// 
	/// @see gtx_rotate_vector
	template <typename T, precision P>
	 tvec3<T, P> slerp(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y,
		T __const & a);

	//! Rotate a two dimensional vector.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec2<T, P> rotate(
		tvec2<T, P> __const & v,
		T __const & angle);
		
	//! Rotate a three dimensional vector around an axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec3<T, P> rotate(
		tvec3<T, P> __const & v,
		T __const & angle,
		tvec3<T, P> __const & normal);
		
	//! Rotate a four dimensional vector around an axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec4<T, P> rotate(
		tvec4<T, P> __const & v,
		T __const & angle,
		tvec3<T, P> __const & normal);
		
	//! Rotate a three dimensional vector around the X axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec3<T, P> rotateX(
		tvec3<T, P> __const & v,
		T __const & angle);

	//! Rotate a three dimensional vector around the Y axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec3<T, P> rotateY(
		tvec3<T, P> __const & v,
		T __const & angle);
		
	//! Rotate a three dimensional vector around the Z axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec3<T, P> rotateZ(
		tvec3<T, P> __const & v,
		T __const & angle);
		
	//! Rotate a four dimentionnals vector around the X axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec4<T, P> rotateX(
		tvec4<T, P> __const & v,
		T __const & angle);
		
	//! Rotate a four dimensional vector around the X axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec4<T, P> rotateY(
		tvec4<T, P> __const & v,
		T __const & angle);
		
	//! Rotate a four dimensional vector around the X axis.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tvec4<T, P> rotateZ(
		tvec4<T, P> __const & v,
		T __const & angle);
		
	//! Build a rotation matrix from a normal and a up vector.
	//! From GLM_GTX_rotate_vector extension.
	template <typename T, precision P>
	 tmat4x4<T, P> orientation(
		tvec3<T, P> __const & Normal,
		tvec3<T, P> __const & Up);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/rotate_vector.inl" 1 3
/// @ref gtx_rotate_vector
/// @file glm/gtx/rotate_vector.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tvec3<T, P> slerp
	(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y,
		T __const & a
	)
	{
		// get cosine of angle between vectors (-1 -> 1)
		T CosAlpha = dot(x, y);
		// get angle (0 -> pi)
		T Alpha = acos(CosAlpha);
		// get sine of angle between vectors (0 -> 1)
		T SinAlpha = sin(Alpha);
		// this breaks down when SinAlpha = 0, i.e. Alpha = 0 or pi
		T t1 = sin((static_cast<T>(1) - a) * Alpha) / SinAlpha;
		T t2 = sin(a * Alpha) / SinAlpha;

		// interpolate src vectors
		return x * t1 + y * t2;
	}

	template <typename T, precision P>
	 __inline tvec2<T, P> rotate
	(
		tvec2<T, P> __const & v,
		T __const & angle
	)
	{
		tvec2<T, P> Result;
		T __const Cos(cos(angle));
		T __const Sin(sin(angle));

		Result.x = v.x * Cos - v.y * Sin;
		Result.y = v.x * Sin + v.y * Cos;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> rotate
	(
		tvec3<T, P> __const & v,
		T __const & angle,
		tvec3<T, P> __const & normal
	)
	{
		return tmat3x3<T, P>(glm::rotate(angle, normal)) * v;
	}
	
# 65 "/usr/local/include/glm/./gtx/rotate_vector.inl" 3

	template <typename T, precision P>
	 __inline tvec4<T, P> rotate
	(
		tvec4<T, P> __const & v,
		T __const & angle,
		tvec3<T, P> __const & normal
	)
	{
		return rotate(angle, normal) * v;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> rotateX
	(
		tvec3<T, P> __const & v,
		T __const & angle
	)
	{
		tvec3<T, P> Result(v);
		T __const Cos(cos(angle));
		T __const Sin(sin(angle));

		Result.y = v.y * Cos - v.z * Sin;
		Result.z = v.y * Sin + v.z * Cos;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> rotateY
	(
		tvec3<T, P> __const & v,
		T __const & angle
	)
	{
		tvec3<T, P> Result = v;
		T __const Cos(cos(angle));
		T __const Sin(sin(angle));

		Result.x =  v.x * Cos + v.z * Sin;
		Result.z = -v.x * Sin + v.z * Cos;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec3<T, P> rotateZ
	(
		tvec3<T, P> __const & v,
		T __const & angle
	)
	{
		tvec3<T, P> Result = v;
		T __const Cos(cos(angle));
		T __const Sin(sin(angle));

		Result.x = v.x * Cos - v.y * Sin;
		Result.y = v.x * Sin + v.y * Cos;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> rotateX
	(
		tvec4<T, P> __const & v,
		T __const & angle
	)
	{
		tvec4<T, P> Result = v;
		T __const Cos(cos(angle));
		T __const Sin(sin(angle));

		Result.y = v.y * Cos - v.z * Sin;
		Result.z = v.y * Sin + v.z * Cos;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> rotateY
	(
		tvec4<T, P> __const & v,
		T __const & angle
	)
	{
		tvec4<T, P> Result = v;
		T __const Cos(cos(angle));
		T __const Sin(sin(angle));

		Result.x =  v.x * Cos + v.z * Sin;
		Result.z = -v.x * Sin + v.z * Cos;
		return Result;
	}

	template <typename T, precision P>
	 __inline tvec4<T, P> rotateZ
	(
		tvec4<T, P> __const & v,
		T __const & angle
	)
	{
		tvec4<T, P> Result = v;
		T __const Cos(cos(angle));
		T __const Sin(sin(angle));

		Result.x = v.x * Cos - v.y * Sin;
		Result.y = v.x * Sin + v.y * Cos;
		return Result;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> orientation
	(
		tvec3<T, P> __const & Normal,
		tvec3<T, P> __const & Up
	)
	{
		if(all(equal(Normal, Up)))
			return tmat4x4<T, P>(T(1));

		tvec3<T, P> RotationAxis = cross(Up, Normal);
		T Angle = acos(dot(Normal, Up));

		return rotate(Angle, RotationAxis);
	}
}//namespace glm

# 117 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 2 3


# 98 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/spline.hpp" 1 3
/// @ref gtx_spline
/// @file glm/gtx/spline.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_spline GLM_GTX_spline
/// @ingroup gtx
///
/// @brief Spline functions
///
/// <glm/gtx/spline.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// @addtogroup gtx_spline
	/// @{

	/// Return a point from a catmull rom curve.
	/// @see gtx_spline extension.
	template <typename genType> 
	 genType catmullRom(
		genType __const & v1, 
		genType __const & v2, 
		genType __const & v3, 
		genType __const & v4, 
		typename genType::value_type __const & s);
		
	/// Return a point from a hermite curve.
	/// @see gtx_spline extension.
	template <typename genType> 
	 genType hermite(
		genType __const & v1, 
		genType __const & t1, 
		genType __const & v2, 
		genType __const & t2, 
		typename genType::value_type __const & s);
		
	/// Return a point from a cubic curve. 
	/// @see gtx_spline extension.
	template <typename genType> 
	 genType cubic(
		genType __const & v1, 
		genType __const & v2, 
		genType __const & v3, 
		genType __const & v4, 
		typename genType::value_type __const & s);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/spline.inl" 1 3
/// @ref gtx_spline
/// @file glm/gtx/spline.inl

namespace glm
{
	template <typename genType>
	 __inline genType catmullRom
	(
		genType __const & v1, 
		genType __const & v2, 
		genType __const & v3, 
		genType __const & v4, 
		typename genType::value_type __const & s
	)
	{
		typename genType::value_type s1 = s;
		typename genType::value_type s2 = pow2(s);
		typename genType::value_type s3 = pow3(s);

		typename genType::value_type f1 = -s3 + typename genType::value_type(2) * s2 - s;
		typename genType::value_type f2 = typename genType::value_type(3) * s3 - typename genType::value_type(5) * s2 + typename genType::value_type(2);
		typename genType::value_type f3 = typename genType::value_type(-3) * s3 + typename genType::value_type(4) * s2 + s;
		typename genType::value_type f4 = s3 - s2;

		return (f1 * v1 + f2 * v2 + f3 * v3 + f4 * v4) / typename genType::value_type(2);

	}

	template <typename genType>
	 __inline genType hermite
	(
		genType __const & v1, 
		genType __const & t1, 
		genType __const & v2, 
		genType __const & t2, 
		typename genType::value_type __const & s
	)
	{
		typename genType::value_type s1 = s;
		typename genType::value_type s2 = pow2(s);
		typename genType::value_type s3 = pow3(s);

		typename genType::value_type f1 = typename genType::value_type(2) * s3 - typename genType::value_type(3) * s2 + typename genType::value_type(1);
		typename genType::value_type f2 = typename genType::value_type(-2) * s3 + typename genType::value_type(3) * s2;
		typename genType::value_type f3 = s3 - typename genType::value_type(2) * s2 + s;
		typename genType::value_type f4 = s3 - s2;

		return f1 * v1 + f2 * v2 + f3 * t1 + f4 * t2;
	}

	template <typename genType>
	 __inline genType cubic
	(
		genType __const & v1, 
		genType __const & v2, 
		genType __const & v3, 
		genType __const & v4, 
		typename genType::value_type __const & s
	)
	{
		return ((v1 * s + v2) * s + v3) * s + v4;
	}
}//namespace glm

# 61 "/usr/local/include/glm/./gtx/spline.hpp" 2 3


# 99 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/std_based_type.hpp" 1 3
/// @ref gtx_std_based_type
/// @file glm/gtx/std_based_type.hpp
///
/// @see core (dependence)
/// @see gtx_extented_min_max (dependence)
///
/// @defgroup gtx_std_based_type GLM_GTX_std_based_type
/// @ingroup gtx
///
/// @brief Adds vector types based on STL value types.
/// <glm/gtx/std_based_type.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// @addtogroup gtx_std_based_type
	/// @{

	/// Vector type based of one std::size_t component.
	/// @see GLM_GTX_std_based_type
	typedef tvec1<std::size_t, defaultp>		size1;

	/// Vector type based of two std::size_t components.
	/// @see GLM_GTX_std_based_type
	typedef tvec2<std::size_t, defaultp>		size2;

	/// Vector type based of three std::size_t components.
	/// @see GLM_GTX_std_based_type
	typedef tvec3<std::size_t, defaultp>		size3;

	/// Vector type based of four std::size_t components.
	/// @see GLM_GTX_std_based_type
	typedef tvec4<std::size_t, defaultp>		size4;

	/// Vector type based of one std::size_t component.
	/// @see GLM_GTX_std_based_type
	typedef tvec1<std::size_t, defaultp>		size1_t;

	/// Vector type based of two std::size_t components.
	/// @see GLM_GTX_std_based_type
	typedef tvec2<std::size_t, defaultp>		size2_t;

	/// Vector type based of three std::size_t components.
	/// @see GLM_GTX_std_based_type
	typedef tvec3<std::size_t, defaultp>		size3_t;

	/// Vector type based of four std::size_t components.
	/// @see GLM_GTX_std_based_type
	typedef tvec4<std::size_t, defaultp>		size4_t;

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/std_based_type.inl" 1 3
/// @ref gtx_std_based_type
/// @file glm/gtx/std_based_type.inl

namespace glm
{

}

# 63 "/usr/local/include/glm/./gtx/std_based_type.hpp" 2 3


# 100 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtx/string_cast.hpp" 1 3
/// @ref gtx_string_cast
/// @file glm/gtx/string_cast.hpp
///
/// @see core (dependence)
/// @see gtc_half_float (dependence)
/// @see gtx_integer (dependence)
/// @see gtx_quaternion (dependence)
///
/// @defgroup gtx_string_cast GLM_GTX_string_cast
/// @ingroup gtx
///
/// @brief Setup strings for GLM type values
///
/// <glm/gtx/string_cast.hpp> need to be included to use these functionalities.
/// This extension is not supported with CUDA



// Dependency:








       



       

namespace glm
{
	/// @addtogroup gtx_string_cast
	/// @{

	/// Create a string from a GLM vector or matrix typed variable.
	/// @see gtx_string_cast extension.
	template <template <typename, precision> class matType, typename T, precision P>
	 std::string to_string(matType<T, P> __const & x);

	/// @}
}//namespace glm


# 1 "/usr/local/include/glm/./gtx/string_cast.inl" 1 3
/// @ref gtx_string_cast
/// @file glm/gtx/string_cast.inl




namespace glm{
namespace detail
{
	 __inline std::string format(__const char* msg, ...)
	{
		std::size_t __const STRING_BUFFER(4096);
		char text[STRING_BUFFER];
		va_list list;

		if(msg == 0)
			return std::string();

		va_start(list, msg);


          
			vsprintf(text, msg, list);

		va_end(list);

		return std::string(text);
	}

	static __const char* LabelTrue = "true";
	static __const char* LabelFalse = "false";

	template <typename T, bool isFloat = false>
	struct literal
	{
		 __inline static char __const * value() {return "%d";};
	};

	template <typename T>
	struct literal<T, true>
	{
		 __inline static char __const * value() {return "%f";};
	};


# 57 "/usr/local/include/glm/./gtx/string_cast.inl" 3
                                                                      

	template <typename T>
	struct prefix{};

	template <>
	struct prefix<float>
	{
		 __inline static char __const * value() {return "";};
	};

	template <>
	struct prefix<double>
	{
		 __inline static char __const * value() {return "d";};
	};

	template <>
	struct prefix<bool>
	{
		 __inline static char __const * value() {return "b";};
	};

	template <>
	struct prefix<uint8_t>
	{
		 __inline static char __const * value() {return "u8";};
	};

	template <>
	struct prefix<int8_t>
	{
		 __inline static char __const * value() {return "i8";};
	};

	template <>
	struct prefix<uint16_t>
	{
		 __inline static char __const * value() {return "u16";};
	};

	template <>
	struct prefix<int16_t>
	{
		 __inline static char __const * value() {return "i16";};
	};

	template <>
	struct prefix<uint32_t>
	{
		 __inline static char __const * value() {return "u";};
	};

	template <>
	struct prefix<int32_t>
	{
		 __inline static char __const * value() {return "i";};
	};

	template <>
	struct prefix<uint64_t>
	{
		 __inline static char __const * value() {return "u64";};
	};

	template <>
	struct prefix<int64_t>
	{
		 __inline static char __const * value() {return "i64";};
	};

	template <template <typename, precision> class matType, typename T, precision P>
	struct compute_to_string
	{};

	template <precision P>
	struct compute_to_string<tvec1, bool, P>
	{
		 __inline static std::string call(tvec1<bool, P> __const & x)
		{
			return detail::format("bvec1(%s)",
				x[0] ? detail::LabelTrue : detail::LabelFalse);
		}
	};

	template <precision P>
	struct compute_to_string<tvec2, bool, P>
	{
		 __inline static std::string call(tvec2<bool, P> __const & x)
		{
			return detail::format("bvec2(%s, %s)",
				x[0] ? detail::LabelTrue : detail::LabelFalse,
				x[1] ? detail::LabelTrue : detail::LabelFalse);
		}
	};

	template <precision P>
	struct compute_to_string<tvec3, bool, P>
	{
		 __inline static std::string call(tvec3<bool, P> __const & x)
		{
			return detail::format("bvec3(%s, %s, %s)",
				x[0] ? detail::LabelTrue : detail::LabelFalse,
				x[1] ? detail::LabelTrue : detail::LabelFalse,
				x[2] ? detail::LabelTrue : detail::LabelFalse);
		}
	};

	template <precision P>
	struct compute_to_string<tvec4, bool, P>
	{
		 __inline static std::string call(tvec4<bool, P> __const & x)
		{
			return detail::format("bvec4(%s, %s, %s, %s)",
				x[0] ? detail::LabelTrue : detail::LabelFalse,
				x[1] ? detail::LabelTrue : detail::LabelFalse,
				x[2] ? detail::LabelTrue : detail::LabelFalse,
				x[3] ? detail::LabelTrue : detail::LabelFalse);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tvec1, T, P>
	{
		 __inline static std::string call(tvec1<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%svec1(%s)",
				PrefixStr,
				LiteralStr));

			return detail::format(FormatStr.c_str(), x[0]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tvec2, T, P>
	{
		 __inline static std::string call(tvec2<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%svec2(%s, %s)",
				PrefixStr,
				LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(), x[0], x[1]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tvec3, T, P>
	{
		 __inline static std::string call(tvec3<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%svec3(%s, %s, %s)",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(), x[0], x[1], x[2]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tvec4, T, P>
	{
		 __inline static std::string call(tvec4<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%svec4(%s, %s, %s, %s)",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(), x[0], x[1], x[2], x[3]);
		}
	};


	template <typename T, precision P>
	struct compute_to_string<tmat2x2, T, P>
	{
		 __inline static std::string call(tmat2x2<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat2x2((%s, %s), (%s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr,
				LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1],
				x[1][0], x[1][1]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat2x3, T, P>
	{
		 __inline static std::string call(tmat2x3<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat2x3((%s, %s, %s), (%s, %s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1], x[0][2],
				x[1][0], x[1][1], x[1][2]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat2x4, T, P>
	{
		 __inline static std::string call(tmat2x4<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat2x4((%s, %s, %s, %s), (%s, %s, %s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1], x[0][2], x[0][3],
				x[1][0], x[1][1], x[1][2], x[1][3]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat3x2, T, P>
	{
		 __inline static std::string call(tmat3x2<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat3x2((%s, %s), (%s, %s), (%s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr,
				LiteralStr, LiteralStr,
				LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1],
				x[1][0], x[1][1],
				x[2][0], x[2][1]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat3x3, T, P>
	{
		 __inline static std::string call(tmat3x3<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat3x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1], x[0][2],
				x[1][0], x[1][1], x[1][2],
				x[2][0], x[2][1], x[2][2]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat3x4, T, P>
	{
		 __inline static std::string call(tmat3x4<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat3x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1], x[0][2], x[0][3],
				x[1][0], x[1][1], x[1][2], x[1][3],
				x[2][0], x[2][1], x[2][2], x[2][3]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat4x2, T, P>
	{
		 __inline static std::string call(tmat4x2<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat4x2((%s, %s), (%s, %s), (%s, %s), (%s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr,
				LiteralStr, LiteralStr,
				LiteralStr, LiteralStr,
				LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1],
				x[1][0], x[1][1],
				x[2][0], x[2][1],
				x[3][0], x[3][1]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat4x3, T, P>
	{
		 __inline static std::string call(tmat4x3<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat4x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1], x[0][2],
				x[1][0], x[1][1], x[1][2],
				x[2][0], x[2][1], x[2][2],
				x[3][0], x[3][1], x[3][2]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tmat4x4, T, P>
	{
		 __inline static std::string call(tmat4x4<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%smat4x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(),
				x[0][0], x[0][1], x[0][2], x[0][3],
				x[1][0], x[1][1], x[1][2], x[1][3],
				x[2][0], x[2][1], x[2][2], x[2][3],
				x[3][0], x[3][1], x[3][2], x[3][3]);
		}
	};


	template <typename T, precision P>
	struct compute_to_string<tquat, T, P>
	{
		 __inline static std::string call(tquat<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%squat(%s, %s, %s, %s)",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(), x[0], x[1], x[2], x[3]);
		}
	};

	template <typename T, precision P>
	struct compute_to_string<tdualquat, T, P>
	{
		 __inline static std::string call(tdualquat<T, P> __const & x)
		{
			char __const * PrefixStr = prefix<T>::value();
			char __const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
			std::string FormatStr(detail::format("%sdualquat((%s, %s, %s, %s), (%s, %s, %s, %s))",
				PrefixStr,
				LiteralStr, LiteralStr, LiteralStr, LiteralStr));

			return detail::format(FormatStr.c_str(), x.real[0], x.real[1], x.real[2], x.real[3], x.dual[0], x.dual[1], x.dual[2], x.dual[3]);
		}
	};

}//namespace detail

template <template <typename, precision> class matType, typename T, precision P>
 __inline std::string to_string(matType<T, P> __const & x)
{
	return detail::compute_to_string<matType, T, P>::call(x);
}

}//namespace glm

# 47 "/usr/local/include/glm/./gtx/string_cast.hpp" 2 3


# 102 "/usr/local/include/glm/ext.hpp" 2 3




# 1 "/usr/local/include/glm/./gtx/transform2.hpp" 1 3
/// @ref gtx_transform2
/// @file glm/gtx/transform2.hpp
///
/// @see core (dependence)
/// @see gtx_transform (dependence)
///
/// @defgroup gtx_transform2 GLM_GTX_transform2
/// @ingroup gtx
///
/// @brief Add extra transformation matrices
///
/// <glm/gtx/transform2.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// @addtogroup gtx_transform2
	/// @{

	//! Transforms a matrix with a shearing on X axis.
	//! From GLM_GTX_transform2 extension.
	template <typename T, precision P>
	 tmat3x3<T, P> shearX2D(
		tmat3x3<T, P> __const & m, 
		T y);

	//! Transforms a matrix with a shearing on Y axis.
	//! From GLM_GTX_transform2 extension.
	template <typename T, precision P> 
	 tmat3x3<T, P> shearY2D(
		tmat3x3<T, P> __const & m, 
		T x);

	//! Transforms a matrix with a shearing on X axis
	//! From GLM_GTX_transform2 extension.
	template <typename T, precision P> 
	 tmat4x4<T, P> shearX3D(
		__const tmat4x4<T, P> & m,
		T y, 
		T z);

	//! Transforms a matrix with a shearing on Y axis.
	//! From GLM_GTX_transform2 extension.
	template <typename T, precision P> 
	 tmat4x4<T, P> shearY3D(
		__const tmat4x4<T, P> & m, 
		T x, 
		T z);

	//! Transforms a matrix with a shearing on Z axis. 
	//! From GLM_GTX_transform2 extension.
	template <typename T, precision P> 
	 tmat4x4<T, P> shearZ3D(
		__const tmat4x4<T, P> & m, 
		T x, 
		T y);

	//template <typename T>  __inline tmat4x4<T, P> shear(__const tmat4x4<T, P> & m, shearPlane, planePoint, angle)
	// Identity + tan(angle) * cross(Normal, OnPlaneVector)     0
	// - dot(PointOnPlane, normal) * OnPlaneVector              1

	// Reflect functions seem to don't work
	//template <typename T> tmat3x3<T, P> reflect2D(__const tmat3x3<T, P> & m, __const tvec3<T, P>& normal){return reflect2DGTX(m, normal);}									//!< \brief Build a reflection matrix (from GLM_GTX_transform2 extension)
	//template <typename T> tmat4x4<T, P> reflect3D(__const tmat4x4<T, P> & m, __const tvec3<T, P>& normal){return reflect3DGTX(m, normal);}									//!< \brief Build a reflection matrix (from GLM_GTX_transform2 extension)
		
	//! Build planar projection matrix along normal axis.
	//! From GLM_GTX_transform2 extension.
	template <typename T, precision P> 
	 tmat3x3<T, P> proj2D(
		__const tmat3x3<T, P> & m, 
		__const tvec3<T, P>& normal);

	//! Build planar projection matrix along normal axis.
	//! From GLM_GTX_transform2 extension.
	template <typename T, precision P> 
	 tmat4x4<T, P> proj3D(
		__const tmat4x4<T, P> & m, 
		__const tvec3<T, P>& normal);

	//! Build a scale bias matrix. 
	//! From GLM_GTX_transform2 extension.
	template <typename valType, precision P> 
	 tmat4x4<valType, P> scaleBias(
		valType scale, 
		valType bias);

	//! Build a scale bias matrix.
	//! From GLM_GTX_transform2 extension.
	template <typename valType, precision P> 
	 tmat4x4<valType, P> scaleBias(
		tmat4x4<valType, P> __const & m, 
		valType scale, 
		valType bias);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/transform2.inl" 1 3
/// @ref gtx_transform2
/// @file glm/gtx/transform2.inl

namespace glm
{
	template <typename T, precision P>
	 __inline tmat3x3<T, P> shearX2D(tmat3x3<T, P> __const& m, T s)
	{
		tmat3x3<T, P> r(1);
		r[1][0] = s;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> shearY2D(tmat3x3<T, P> __const& m, T s)
	{
		tmat3x3<T, P> r(1);
		r[0][1] = s;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> shearX3D(tmat4x4<T, P> __const& m, T s, T t)
	{
		tmat4x4<T, P> r(1);
		r[0][1] = s;
		r[0][2] = t;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> shearY3D(tmat4x4<T, P> __const& m, T s, T t)
	{
		tmat4x4<T, P> r(1);
		r[1][0] = s;
		r[1][2] = t;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> shearZ3D(tmat4x4<T, P> __const& m, T s, T t)
	{
		tmat4x4<T, P> r(1);
		r[2][0] = s;
		r[2][1] = t;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> reflect2D(tmat3x3<T, P> __const& m, tvec3<T, P> __const& normal)
	{
		tmat3x3<T, P> r(static_cast<T>(1));
		r[0][0] = static_cast<T>(1) - static_cast<T>(2) * normal.x * normal.x;
		r[0][1] = -static_cast<T>(2) * normal.x * normal.y;
		r[1][0] = -static_cast<T>(2) * normal.x * normal.y;
		r[1][1] = static_cast<T>(1) - static_cast<T>(2) * normal.y * normal.y;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> reflect3D(tmat4x4<T, P> __const& m, tvec3<T, P> __const& normal)
	{
		tmat4x4<T, P> r(static_cast<T>(1));
		r[0][0] = static_cast<T>(1) - static_cast<T>(2) * normal.x * normal.x;
		r[0][1] = -static_cast<T>(2) * normal.x * normal.y;
		r[0][2] = -static_cast<T>(2) * normal.x * normal.z;

		r[1][0] = -static_cast<T>(2) * normal.x * normal.y;
		r[1][1] = static_cast<T>(1) - static_cast<T>(2) * normal.y * normal.y;
		r[1][2] = -static_cast<T>(2) * normal.y * normal.z;

		r[2][0] = -static_cast<T>(2) * normal.x * normal.z;
		r[2][1] = -static_cast<T>(2) * normal.y * normal.z;
		r[2][2] = static_cast<T>(1) - static_cast<T>(2) * normal.z * normal.z;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat3x3<T, P> proj2D(
		__const tmat3x3<T, P>& m, 
		__const tvec3<T, P>& normal)
	{
		tmat3x3<T, P> r(static_cast<T>(1));
		r[0][0] = static_cast<T>(1) - normal.x * normal.x;
		r[0][1] = - normal.x * normal.y;
		r[1][0] = - normal.x * normal.y;
		r[1][1] = static_cast<T>(1) - normal.y * normal.y;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> proj3D(
		__const tmat4x4<T, P>& m, 
		__const tvec3<T, P>& normal)
	{
		tmat4x4<T, P> r(static_cast<T>(1));
		r[0][0] = static_cast<T>(1) - normal.x * normal.x;
		r[0][1] = - normal.x * normal.y;
		r[0][2] = - normal.x * normal.z;
		r[1][0] = - normal.x * normal.y;
		r[1][1] = static_cast<T>(1) - normal.y * normal.y;
		r[1][2] = - normal.y * normal.z;
		r[2][0] = - normal.x * normal.z;
		r[2][1] = - normal.y * normal.z;
		r[2][2] = static_cast<T>(1) - normal.z * normal.z;
		return m * r;
	}

	template <typename T, precision P>
	 __inline tmat4x4<T, P> scaleBias(T scale, T bias)
	{
		tmat4x4<T, P> result;
		result[3] = tvec4<T, P>(tvec3<T, P>(bias), static_cast<T>(1));
		result[0][0] = scale;
		result[1][1] = scale;
		result[2][2] = scale;
		return result;
	}

	template <typename T, precision P> 
	 __inline tmat4x4<T, P> scaleBias(tmat4x4<T, P> __const& m, T scale, T bias)
	{
		return m * scaleBias(scale, bias);
	}
}//namespace glm


# 107 "/usr/local/include/glm/./gtx/transform2.hpp" 2 3


# 105 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/vector_angle.hpp" 1 3
/// @ref gtx_vector_angle
/// @file glm/gtx/vector_angle.hpp
///
/// @see core (dependence)
/// @see gtx_quaternion (dependence)
/// @see gtx_epsilon (dependence)
///
/// @defgroup gtx_vector_angle GLM_GTX_vector_angle
/// @ingroup gtx
///
/// @brief Compute angle between vectors
///
/// <glm/gtx/vector_angle.hpp> need to be included to use these functionalities.



// Dependency:







       

namespace glm
{
	/// @addtogroup gtx_vector_angle
	/// @{

	//! Returns the absolute angle between two vectors.
	//! Parameters need to be normalized.
	/// @see gtx_vector_angle extension.
	template <typename vecType>
	 typename vecType::value_type angle(
		vecType __const & x, 
		vecType __const & y);

	//! Returns the oriented angle between two 2d vectors.
	//! Parameters need to be normalized.
	/// @see gtx_vector_angle extension.
	template <typename T, precision P>
	 T orientedAngle(
		tvec2<T, P> __const & x,
		tvec2<T, P> __const & y);

	//! Returns the oriented angle between two 3d vectors based from a reference axis.
	//! Parameters need to be normalized.
	/// @see gtx_vector_angle extension.
	template <typename T, precision P>
	 T orientedAngle(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y,
		tvec3<T, P> __const & ref);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/vector_angle.inl" 1 3
/// @ref gtx_vector_angle
/// @file glm/gtx/vector_angle.inl

namespace glm
{
	template <typename genType> 
	 __inline genType angle
	(
		genType __const & x,
		genType __const & y
	)
	{
		;
		return acos(clamp(dot(x, y), genType(-1), genType(1)));
	}

	template <typename T, precision P, template <typename, precision> class vecType> 
	 __inline T angle
	(
		vecType<T, P> __const & x,
		vecType<T, P> __const & y
	)
	{
		;
		return acos(clamp(dot(x, y), T(-1), T(1)));
	}

	//! \todo epsilon is hard coded to 0.01
	template <typename T, precision P>
	 __inline T orientedAngle
	(
		tvec2<T, P> __const & x,
		tvec2<T, P> __const & y
	)
	{
		;
		T __const Angle(acos(clamp(dot(x, y), T(-1), T(1))));

		if(all(epsilonEqual(y, glm::rotate(x, Angle), T(0.0001))))
			return Angle;
		else
			return -Angle;
	}

	template <typename T, precision P>
	 __inline T orientedAngle
	(
		tvec3<T, P> __const & x,
		tvec3<T, P> __const & y,
		tvec3<T, P> __const & ref
	)
	{
		;

		T __const Angle(acos(clamp(dot(x, y), T(-1), T(1))));
		return mix(Angle, -Angle, dot(ref, cross(x, y)) < T(0));
	}
}//namespace glm

# 60 "/usr/local/include/glm/./gtx/vector_angle.hpp" 2 3


# 106 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtx/wrap.hpp" 1 3
/// @ref gtx_wrap
/// @file glm/gtx/wrap.hpp
///
/// @see core (dependence)
///
/// @defgroup gtx_wrap GLM_GTX_wrap
/// @ingroup gtx
///
/// @brief Wrapping mode of texture coordinates.
///
/// <glm/gtx/wrap.hpp> need to be included to use these functionalities.



// Dependency:





       

namespace glm
{
	/// @addtogroup gtx_wrap
	/// @{

	/// Simulate GL_CLAMP OpenGL wrap mode
	/// @see gtx_wrap extension.
	template <typename genType>
	 genType clamp(genType __const& Texcoord);

	/// Simulate GL_REPEAT OpenGL wrap mode
	/// @see gtx_wrap extension.
	template <typename genType>
	 genType repeat(genType __const& Texcoord);

	/// Simulate GL_MIRRORED_REPEAT OpenGL wrap mode
	/// @see gtx_wrap extension.
	template <typename genType>
	 genType mirrorClamp(genType __const& Texcoord);

	/// Simulate GL_MIRROR_REPEAT OpenGL wrap mode
	/// @see gtx_wrap extension.
	template <typename genType>
	 genType mirrorRepeat(genType __const& Texcoord);

	/// @}
}// namespace glm


# 1 "/usr/local/include/glm/./gtx/wrap.inl" 1 3
/// @ref gtx_wrap
/// @file glm/gtx/wrap.inl

namespace glm
{
	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> clamp(vecType<T, P> __const& Texcoord)
	{
		return glm::clamp(Texcoord, vecType<T, P>(0), vecType<T, P>(1));
	}

	template <typename genType>
	 __inline genType clamp(genType __const & Texcoord)
	{
		return clamp(tvec1<genType, defaultp>(Texcoord)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> repeat(vecType<T, P> __const& Texcoord)
	{
		return glm::fract(Texcoord);
	}

	template <typename genType>
	 __inline genType repeat(genType __const & Texcoord)
	{
		return repeat(tvec1<genType, defaultp>(Texcoord)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> mirrorClamp(vecType<T, P> __const& Texcoord)
	{
		return glm::fract(glm::abs(Texcoord));
	}

	template <typename genType>
	 __inline genType mirrorClamp(genType __const & Texcoord)
	{
		return mirrorClamp(tvec1<genType, defaultp>(Texcoord)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 __inline vecType<T, P> mirrorRepeat(vecType<T, P> __const& Texcoord)
	{
		vecType<T, P> __const Abs = glm::abs(Texcoord);
		vecType<T, P> __const Clamp = glm::mod(glm::floor(Abs), vecType<T, P>(2));
		vecType<T, P> __const Floor = glm::floor(Abs);
		vecType<T, P> __const Rest = Abs - Floor;
		vecType<T, P> __const Mirror = Clamp + Rest;
		return mix(Rest, vecType<T, P>(1) - Rest, glm::greaterThanEqual(Mirror, vecType<T, P>(1)));
	}

	template <typename genType>
	 __inline genType mirrorRepeat(genType __const& Texcoord)
	{
		return mirrorRepeat(tvec1<genType, defaultp>(Texcoord)).x;
	}
}//namespace glm

# 51 "/usr/local/include/glm/./gtx/wrap.hpp" 2 3


# 108 "/usr/local/include/glm/ext.hpp" 2 3




       



       

# 15 "common_utils_cpp.h" 2








typedef char* byteptr;





# 50 "common_utils_cpp.h"
enum struct PROPERTY_TYPE {
    
    #define KIND(a, b, c, d) a##c ,
    KIND(PROP_, f_, i64, i64) KIND(PROP_, f_, u64, u64) KIND(PROP_, f_, usize, usize) KIND(PROP_, f_, f64, f64) KIND(PROP_, f_, i32, i32) KIND(PROP_, f_, u32, i32) KIND(PROP_, f_, f32, i32) KIND(PROP_, f_, i16, i16) KIND(PROP_, f_, u16, u16) KIND(PROP_, f_, i8, i8) KIND(PROP_, f_, u8, u8) KIND(PROP_, f_, bool, bool) KIND(PROP_, f_, char, char) KIND(PROP_, f_, string, std::string) // KIND(PROP_, f_, Functor) // KIND(PROP_, f_, Ptr_PropertyContainer) KIND(PROP_, f_, byteptr, char*) KIND(PROP_, f_, vec2, glm::vec2) KIND(PROP_, f_, vec3, glm::vec3) KIND(PROP_, f_, vec4, glm::vec4)
    COUNT_PROPERTY_TYPE
    
    #undef ,
    
};

union Field {
    
    #define KIND(a, b, c, d) d b##c ;
    KIND(PROP_, f_, i64, i64) KIND(PROP_, f_, u64, u64) KIND(PROP_, f_, usize, usize) KIND(PROP_, f_, f64, f64) KIND(PROP_, f_, i32, i32) KIND(PROP_, f_, u32, i32) KIND(PROP_, f_, f32, i32) KIND(PROP_, f_, i16, i16) KIND(PROP_, f_, u16, u16) KIND(PROP_, f_, i8, i8) KIND(PROP_, f_, u8, u8) KIND(PROP_, f_, bool, bool) KIND(PROP_, f_, char, char) KIND(PROP_, f_, string, std::string) // KIND(PROP_, f_, Functor) // KIND(PROP_, f_, Ptr_PropertyContainer) KIND(PROP_, f_, byteptr, char*) KIND(PROP_, f_, vec2, glm::vec2) KIND(PROP_, f_, vec3, glm::vec3) KIND(PROP_, f_, vec4, glm::vec4)
    COUNT_FIELD
    
    #undef ;
    
};





typedef std::pair<glm::vec3, glm::vec3>  vec3##_pair;
typedef std::pair<glm::vec4, glm::vec4>  vec4##_pair;

__inline f64 dist2(glm::vec3 v, glm::vec3 w);
__inline f64 dist_to_segment_squared(glm::vec3 v, glm::vec3 w, glm::vec3 p);
__inline f64 dist_to_segment(glm::vec3 v, glm::vec3 w, glm::vec3 p);

// http://alienryderflex.com/intersect/
bool line_segment_intersection(__const vec3_pair* s0, __const vec3_pair* s1, glm::vec3* out);

template<typename T>
static std::string to_binary_string(__const T& x);

template <typename T, usize N>
struct Buffer {
    T memory[N];
    usize elements_used;

    operator T*(void)
    {
        return this->memory;
    }

    __inline T& operator[](usize i)
    {
        return this->memory[i];
    }

    __inline __const T& operator[](usize i) __const 
    {
        return this->memory[i];
    }

    __inline usize byte_length(void) __const
    {
        return sizeof(T) * N;
    }

    __inline usize element_length(void) __const
    {
        return N;
    }

    __inline void push_back(T val)
    {
        assert(this->elements_used < N);
        memory[this->elements_used] = val;
        this->elements_used += 1;
    }

    __inline void push_back(T* val)
    {
        assert(this->elements_used < N);
        memory[this->elements_used] = *val;
        this->elements_used += 1;
    }

    __inline void reset()
    {
        this->elements_used = 0;
    }

    typedef T* iterator;
    typedef __const T* const_iterator;
    iterator begin(void) { return &this->memory[0]; }
    iterator end(void) { return &this->memory[N]; }
    iterator first_free(void) { return &this->memory[this->elements_used]; }
};

template <typename T>
struct DynamicBuffer {
    size_t cap;
    size_t count;
    T*  array;

    operator T*()
    {
        return this->array;
    }

    T& operator[](size_t i)
    {
        return this->array[i];
    }
     
    __const T& operator[](size_t i) __const 
    {
        return this->array[i];
    }

    __inline size_t element_count() __const
    {
        return this->count;
    }

    __inline size_t element_size() __const
    {
        return sizeof(T);
    }

    __inline size_t size() __const
    {
        return this->cap;
    }


    typedef T* iterator;
    typedef __const T* const_iterator;
    iterator begin() { return &this->array[0]; }
    iterator end() { return &this->array[this->cap]; }
};

void vec2_print(glm::vec2* v);

void vec2_pair_print(glm::vec2* a, glm::vec2* b);

void vec3_print(glm::vec3* v);

void vec3_pair_print(glm::vec3* a, glm::vec3*b);

void vec4_print(glm::vec4* v);

void vec4_pair_print(glm::vec4* a, glm::vec4* b);

template<typename T>
void print_array(T* array, __const usize N, __const usize M = 1);




static __inline f32 atan2pos_32(f64 y, f64 x);
static __inline f64 atan2pos_64(f64 y, f64 x);

bool check_file_status(__const char* file_path, struct stat* file_stat);

template <typename T>
__inline void zero_mem(T* ptr);

// }




