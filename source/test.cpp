# 1 "entity.h"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 175 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "entity.h" 2



# 1 "./common_utils.h" 1




extern "C"
{



# 1 "/usr/include/stdio.h" 1 3 4
# 64 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 484 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 485 "/usr/include/sys/cdefs.h" 2 3 4
# 550 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_posix_availability.h" 1 3 4
# 551 "/usr/include/sys/cdefs.h" 2 3 4
# 65 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/Availability.h" 1 3 4
# 148 "/usr/include/Availability.h" 3 4
# 1 "/usr/include/AvailabilityInternal.h" 1 3 4
# 149 "/usr/include/Availability.h" 2 3 4
# 66 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/_types.h" 1 3 4
# 27 "/usr/include/_types.h" 3 4
# 1 "/usr/include/sys/_types.h" 1 3 4
# 33 "/usr/include/sys/_types.h" 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
# 32 "/usr/include/machine/_types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 37 "/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4
# 58 "/usr/include/sys/_types.h" 3 4
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[1168]; };
# 94 "/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
# 28 "/usr/include/_types.h" 2 3 4
# 39 "/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 68 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/sys/_types/_va_list.h" 1 3 4
# 31 "/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 72 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/sys/_types/_size_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 73 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/sys/_types/_null.h" 1 3 4
# 74 "/usr/include/stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 86 "/usr/include/stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 120 "/usr/include/stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 228 "/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen");

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs") ;
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen") ;
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite") ;
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);


__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
# 290 "/usr/include/stdio.h" 3 4
extern "C" {



char *ctermid(char *);





FILE *fdopen(int, const char *) __asm("_" "fdopen");

int fileno(FILE *);
}
# 312 "/usr/include/stdio.h" 3 4
extern "C" {
int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen");

}
# 334 "/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 371 "/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);



__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *, const char *) __asm("_" "tempnam") ;
}
# 409 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_off_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 410 "/usr/include/stdio.h" 2 3 4

extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}



extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 434 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 435 "/usr/include/stdio.h" 2 3 4

extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((availability(macosx,introduced=10.7)));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
# 10 "./common_utils.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 65 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/sys/wait.h" 1 3 4
# 79 "/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






# 1 "/usr/include/sys/_types/_pid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/_types/_id_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/usr/include/sys/wait.h" 2 3 4
# 109 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
# 73 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/usr/include/sys/signal.h" 2 3 4







# 1 "/usr/include/machine/signal.h" 1 3 4
# 32 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/i386/signal.h" 1 3 4
# 39 "/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/usr/include/machine/signal.h" 2 3 4
# 82 "/usr/include/sys/signal.h" 2 3 4
# 145 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/usr/include/machine/_mcontext.h" 3 4
# 1 "/usr/include/i386/_mcontext.h" 1 3 4
# 33 "/usr/include/i386/_mcontext.h" 3 4
# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
# 43 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
# 402 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 454 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
# 751 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 34 "/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 76 "/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 115 "/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/usr/include/machine/_mcontext.h" 2 3 4
# 146 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 36 "/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 147 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_ucontext.h" 1 3 4
# 34 "/usr/include/sys/_types/_ucontext.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 148 "/usr/include/sys/signal.h" 2 3 4


# 1 "/usr/include/sys/_types/_pthread_attr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 151 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 152 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_types/_uid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 154 "/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 266 "/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 328 "/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 345 "/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 364 "/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 386 "/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 110 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 72 "/usr/include/sys/resource.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 1 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 18 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 19 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 20 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 21 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 22 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/usr/include/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;






# 1 "/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_intptr_t.h" 3 4
typedef __darwin_intptr_t intptr_t;
# 54 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 55 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/usr/include/stdint.h" 2 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 2 3 4
# 73 "/usr/include/sys/resource.h" 2 3 4







# 1 "/usr/include/sys/_types/_timeval.h" 1 3 4
# 30 "/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/usr/include/sys/resource.h" 2 3 4








typedef __uint64_t rlim_t;
# 151 "/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 162 "/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 190 "/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};
# 290 "/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 317 "/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
# 346 "/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit") ;
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit") ;
}
# 111 "/usr/include/sys/wait.h" 2 3 4
# 186 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
# 35 "/usr/include/machine/endian.h" 3 4
# 1 "/usr/include/i386/endian.h" 1 3 4
# 99 "/usr/include/i386/endian.h" 3 4
# 1 "/usr/include/sys/_endian.h" 1 3 4
# 124 "/usr/include/sys/_endian.h" 3 4
# 1 "/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((__uint16_t)((_data << 8) | (_data >> 8)));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 125 "/usr/include/sys/_endian.h" 2 3 4
# 100 "/usr/include/i386/endian.h" 2 3 4
# 36 "/usr/include/machine/endian.h" 2 3 4
# 187 "/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 247 "/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait") ;
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid") ;

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid") ;


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/alloca.h" 1 3 4
# 31 "/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 68 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 77 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_rune_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 78 "/usr/include/stdlib.h" 2 3 4


# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 81 "/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 117 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 127 "/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((availability(macosx,introduced=10.6)));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod") ;
float strtof(const char *, char **) __asm("_" "strtof") ;
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system") ;
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv") ;
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv") ;

void setkey(const char *) __asm("_" "setkey") ;



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv") ;







# 1 "/usr/include/machine/types.h" 1 3 4
# 35 "/usr/include/machine/types.h" 3 4
# 1 "/usr/include/i386/types.h" 1 3 4
# 81 "/usr/include/i386/types.h" 3 4
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;


typedef int64_t register_t;
# 97 "/usr/include/i386/types.h" 3 4
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;


# 1 "/usr/include/sys/_types/___offsetof.h" 1 3 4
# 114 "/usr/include/i386/types.h" 2 3 4
# 36 "/usr/include/machine/types.h" 2 3 4
# 239 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/sys/_types/_dev_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 241 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/sys/_types/_mode_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 242 "/usr/include/stdlib.h" 2 3 4

u_int32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((availability(macosx,introduced=10.7)));

int atexit_b(void (^)(void)) __attribute__((availability(macosx,introduced=10.6)));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((availability(macosx,introduced=10.0,deprecated=10.5)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 11 "./common_utils.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 53 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 3 4
typedef long unsigned int rsize_t;
# 12 "./common_utils.h" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 70 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/runetype.h" 1 3 4
# 49 "/usr/include/runetype.h" 3 4
# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/usr/include/runetype.h" 2 3 4
# 1 "/usr/include/sys/_types/_wint_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_wint_t.h" 3 4
typedef __darwin_wint_t wint_t;
# 51 "/usr/include/runetype.h" 2 3 4
# 60 "/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 71 "/usr/include/ctype.h" 2 3 4
# 128 "/usr/include/ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 147 "/usr/include/ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 187 "/usr/include/ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

inline int
tolower(int _c)
{
        return (__tolower(_c));
}

inline int
toupper(int _c)
{
        return (__toupper(_c));
}


inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 13 "./common_utils.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 14 "./common_utils.h" 2
# 1 "/usr/include/math.h" 1 3 4
# 33 "/usr/include/math.h" 3 4
extern "C" {
# 44 "/usr/include/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 111 "/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 144 "/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 188 "/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union {
        long double __ld;
        struct{ unsigned long long __m; unsigned short __sexp; } __p;
    } __u;
    __u.__ld = __x;
    return (int)(__u.__p.__sexp >> 15);
}







inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 3.36210314311209350626e-4932L;
}
# 322 "/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 565 "/usr/include/math.h" 3 4
extern float __inff(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern double __inf(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern long double __infl(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern float __nan(void) __attribute__((availability(macosx,introduced=10.0)));
# 597 "/usr/include/math.h" 3 4
extern float __exp10f(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __exp10(double) __attribute__((availability(macosx,introduced=10.9)));





inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) __attribute__((availability(macosx,introduced=10.9)));
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) __attribute__((availability(macosx,introduced=10.9)));
# 614 "/usr/include/math.h" 3 4
extern float __cospif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __cospi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __sinpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __sinpi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __tanpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __tanpi(double) __attribute__((availability(macosx,introduced=10.9)));






inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) __attribute__((availability(macosx,introduced=10.9)));
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) __attribute__((availability(macosx,introduced=10.9)));






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}






extern double j0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double j1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double jn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double y0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double y1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double yn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double scalb(double, double);
extern int signgam;
# 712 "/usr/include/math.h" 3 4
extern long int rinttol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern long int roundtol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double drem(double, double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern int finite(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double gamma(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double significand(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
# 737 "/usr/include/math.h" 3 4
}
# 15 "./common_utils.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdbool.h" 1 3 4
# 16 "./common_utils.h" 2
# 1 "/usr/include/getopt.h" 1 3 4
# 44 "/usr/include/getopt.h" 3 4
# 1 "/usr/include/unistd.h" 1 3 4
# 72 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 84 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 85 "/usr/include/sys/unistd.h" 2 3 4
# 122 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
# 123 "/usr/include/sys/unistd.h" 2 3 4
# 132 "/usr/include/sys/unistd.h" 3 4
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/usr/include/unistd.h" 2 3 4

# 1 "/usr/include/sys/_types/_gid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 75 "/usr/include/unistd.h" 2 3 4








# 1 "/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 84 "/usr/include/unistd.h" 2 3 4
# 423 "/usr/include/unistd.h" 3 4
extern "C" {
void _exit(int) __attribute__((noreturn));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close") ;

int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause") ;

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read") ;

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep") ;

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r") ;




int unlink(const char *);

ssize_t write(int, const void *, size_t) __asm("_" "write") ;
}
# 500 "/usr/include/unistd.h" 3 4
extern "C" {
size_t confstr(int, char *, size_t) __asm("_" "confstr") ;

int getopt(int, char * const [], const char *) __asm("_" "getopt") ;

extern char *optarg;
extern int optind, opterr, optopt;
}
# 525 "/usr/include/unistd.h" 3 4
 extern "C" {





__attribute__((deprecated))

void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);






void encrypt(char *, int) __asm("_" "encrypt") ;



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((const)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown") ;

int lockf(int, int, off_t) __asm("_" "lockf") ;

int nice(int) __asm("_" "nice") ;

ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread") ;

ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite") ;






__attribute__((deprecated))

void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp") ;




int setregid(gid_t, gid_t) __asm("_" "setregid") ;

int setreuid(uid_t, uid_t) __asm("_" "setreuid") ;

void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep") ;
pid_t vfork(void);


int fsync(int) __asm("_" "fsync") ;

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}
# 618 "/usr/include/unistd.h" 3 4
extern "C" {
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}








# 1 "/usr/include/sys/select.h" 1 3 4
# 75 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/_types/_fd_def.h" 1 3 4
# 45 "/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[(unsigned long)_n/(sizeof(__int32_t) * 8)] & ((__int32_t)(1<<((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}
# 76 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_timespec.h" 1 3 4
# 30 "/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 77 "/usr/include/sys/select.h" 2 3 4







# 1 "/usr/include/sys/_types/_time_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 85 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 86 "/usr/include/sys/select.h" 2 3 4
# 100 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 101 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_set.h" 1 3 4
# 102 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 103 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 104 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 105 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 108 "/usr/include/sys/select.h" 2 3 4



extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )




  __asm("_" "pselect" "$1050")




  ;



# 1 "/usr/include/sys/_select.h" 1 3 4
# 39 "/usr/include/sys/_select.h" 3 4
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )




  __asm("_" "select" "$1050")




  ;
# 130 "/usr/include/sys/select.h" 2 3 4

}
# 634 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/sys/_types/_uuid_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uuid_t.h" 3 4
typedef __darwin_uuid_t uuid_t;
# 638 "/usr/include/unistd.h" 2 3 4

extern "C" {
void _Exit(int) __attribute__((noreturn));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);





# 1 "/usr/include/gethostuuid.h" 1 3 4
# 39 "/usr/include/gethostuuid.h" 3 4
int gethostuuid(uuid_t, const struct timespec *) __attribute__((availability(macosx,introduced=10.5)));
# 654 "/usr/include/unistd.h" 2 3 4




mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkpath_np(const char *path, mode_t omode) __attribute__((availability(macosx,introduced=10.8)));
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey") ;



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode");
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((availability(macosx,introduced=10.6)));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((availability(macosx,introduced=10.6)));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist") ;
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist") ;
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
# 731 "/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((availability(macosx,introduced=10.6)));




int fsync_volume_np(int, int) __attribute__((availability(macosx,introduced=10.8)));
int sync_volume_np(const char *, int) __attribute__((availability(macosx,introduced=10.8)));

extern int optreset;

}
# 45 "/usr/include/getopt.h" 2 3 4
# 54 "/usr/include/getopt.h" 3 4
struct option {

 const char *name;




 int has_arg;

 int *flag;

 int val;
};

extern "C" {
int getopt_long(int, char * const *, const char *,
 const struct option *, int *);
int getopt_long_only(int, char * const *, const char *,
 const struct option *, int *);


int getopt(int, char * const [], const char *) __asm("_" "getopt") ;

extern char *optarg;
extern int optind, opterr, optopt;



extern int optreset;

}
# 17 "./common_utils.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 69 "/usr/include/string.h" 3 4
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror") ;
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
}
# 103 "/usr/include/string.h" 3 4
extern "C" {
char *strtok_r(char *, const char *, char **);
}
# 115 "/usr/include/string.h" 3 4
extern "C" {
int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);
}
# 129 "/usr/include/string.h" 3 4
extern "C" {
char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *, size_t) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int sig);
}






# 1 "/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 142 "/usr/include/string.h" 2 3 4
# 1 "/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 143 "/usr/include/string.h" 2 3 4

extern "C" {
errno_t memset_s(void *, rsize_t, int, rsize_t) __attribute__((availability(macosx,introduced=10.9)));
}







extern "C" {
void *memmem(const void *, size_t, const void *, size_t) __attribute__((availability(macosx,introduced=10.7)));
void memset_pattern4(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void *, const void *, size_t) __attribute__((availability(macosx,introduced=10.5)));

char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);


void swab(const void * , void * , ssize_t);
}







# 1 "/usr/include/strings.h" 1 3 4
# 67 "/usr/include/strings.h" 3 4
extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((availability(macosx,introduced=10.5)));
int ffsll(long long) __attribute__((availability(macosx,introduced=10.9)));
int fls(int) __attribute__((availability(macosx,introduced=10.5)));
int flsl(long) __attribute__((availability(macosx,introduced=10.5)));
int flsll(long long) __attribute__((availability(macosx,introduced=10.9)));
}


# 1 "/usr/include/string.h" 1 3 4
# 93 "/usr/include/strings.h" 2 3 4
# 177 "/usr/include/string.h" 2 3 4
# 18 "./common_utils.h" 2


typedef int8_t int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;

typedef uint8_t uint8;
typedef uint16_t uint16;
typedef uint32_t uint32;
typedef uint64_t uint64;

typedef float float32;
typedef double float64;

typedef int8 i8;
typedef int16 i16;
typedef int32 i32;
typedef int64 i64;

typedef uint8 u8;
typedef uint16 u16;
typedef uint32 u32;
typedef uint64 u64;

typedef float32 f32;
typedef float64 f64;

typedef u64 usize;
# 66 "./common_utils.h"
void* xmalloc(size_t num_bytes);
void* xcalloc(size_t num_elems, size_t elem_size);
void* xcalloc_1arg(size_t bytes);
void* xrealloc(void* ptr, size_t num_bytes);


void* memdup(void *src, size_t size);

char *strf(const char *fmt, ...);


char* read_file(const char *path);
bool write_file(const char *path, const char *buf, size_t len);
# 96 "./common_utils.h"
typedef struct {
    char* ptr;
    char* end;
    char** blocks;
    size_t block_count;
    size_t block_cap;
} ArenaAllocator;

void ArenaAllocator_init(ArenaAllocator* arena);
void* ArenaAllocator_allocate(ArenaAllocator* arena, size_t size);
void ArenaAllocator_grow(ArenaAllocator* arena, size_t min_size);
void ArenaAllocator_delete(ArenaAllocator* arena);
# 116 "./common_utils.h"
void debug_print(const char* const in);







typedef void* (*Fn_MemoryAllocator)(size_t bytes);


extern struct option program_args[(2) + 1];

typedef struct {
    bool verbose;
    bool hot_config;
} CommandLineArgs;

bool parse_command_line_args(CommandLineArgs* cmd, const int argc, char* argv[]);


uint64_t hash_uint64(uint64_t x);
uint64_t hash_ptr(const void* ptr);
uint64_t hash_mix(uint64_t x, uint64_t y);
uint64_t hash_bytes(const void* ptr, size_t len);

typedef struct Map {
    uint64_t* keys;
    uint64_t* vals;
    size_t len;
    size_t cap;
} Map;

uint64_t map_get_uint64_from_uint64(Map* map, uint64_t key);

void map_put_uint64_from_uint64(Map* map, uint64_t key, uint64_t val);

void map_grow(Map* map, size_t new_cap);

void map_put_uint64_from_uint64(Map* map, uint64_t key, uint64_t val);

void* map_get(Map* map, const void* key);

void map_put(Map* map, const void* key, void* val);

void* map_get_from_uint64(Map *map, uint64_t key);

void map_put_from_uint64(Map* map, uint64_t key, void* val);

uint64_t map_get_uint64(Map* map, void* key);

void map_put_uint64(Map* map, void* key, uint64_t val);



typedef struct Intern {
    size_t len;
    struct Intern* next;
    char str[];
} Intern;

extern ArenaAllocator intern_arena;
extern Map interns;

const char *str_intern_range(const char* start, const char* end);

const char *str_intern(const char* str);

bool str_islower(const char* str);



}
# 5 "entity.h" 2
# 1 "./common_utils_cpp.hpp" 1



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 1 3
# 60 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
# 226 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
typedef __char16_t char16_t;
typedef __char32_t char32_t;
# 349 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
namespace std {
  inline namespace __1 {
  }
}
# 494 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
template <bool> struct __static_assert_test;
template <> struct __static_assert_test<true> {};
template <unsigned> struct __static_assert_check {};
# 61 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 2 3
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;

using ::memchr;

using ::strchr;

using ::strcspn;

using ::strpbrk;

using ::strrchr;

using ::strspn;

using ::strstr;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strchr( char* __s, int __c) {return ::strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strpbrk( char* __s1, const char* __s2) {return ::strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strrchr( char* __s, int __c) {return ::strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* memchr( void* __s, int __c, size_t __n) {return ::memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strstr( char* __s1, const char* __s2) {return ::strstr(__s1, __s2);}


using ::strtok;
using ::memset;
using ::strerror;
using ::strlen;

} }
# 5 "./common_utils_cpp.hpp" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 1 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 3
# 1 "/usr/include/time.h" 1 3 4
# 69 "/usr/include/time.h" 3 4
# 1 "/usr/include/_structs.h" 1 3 4
# 24 "/usr/include/_structs.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 25 "/usr/include/_structs.h" 2 3 4
# 70 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/sys/_types/_clock_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 72 "/usr/include/time.h" 2 3 4



struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 98 "/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone") ;

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock") ;
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime") ;
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime") ;
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime") ;
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep") ;

}
# 49 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 2 3
# 52 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 3


namespace std {inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;
using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;
using ::strftime;

} }
# 6 "./common_utils_cpp.hpp" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 1 3
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 3
# 1 "/usr/include/signal.h" 1 3 4
# 64 "/usr/include/signal.h" 3 4
# 1 "/usr/include/sys/_types/_pthread_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 65 "/usr/include/signal.h" 2 3 4


extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];


extern "C" {
int raise(int);
}


extern "C" {
void (*bsd_signal(int, void (*)(int)))(int);
int kill(pid_t, int) __asm("_" "kill") ;
int killpg(pid_t, int) __asm("_" "killpg") ;
int pthread_kill(pthread_t, int);
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask") ;
int sigaction(int, const struct sigaction * ,
     struct sigaction * );
int sigaddset(sigset_t *, int);
int sigaltstack(const stack_t * , stack_t * ) __asm("_" "sigaltstack") ;
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(const sigset_t *, int);
int sigpause(int) __asm("_" "sigpause") ;
int sigpending(sigset_t *);
int sigprocmask(int, const sigset_t * , sigset_t * );
int sigrelse(int);
void (*sigset(int, void (*)(int)))(int);
int sigsuspend(const sigset_t *) __asm("_" "sigsuspend") ;
int sigwait(const sigset_t * , int * ) __asm("_" "sigwait") ;

void psignal(unsigned int, const char *);
int sigblock(int);
int sigsetmask(int);
int sigvec(int, struct sigvec *, struct sigvec *);

}




inline __attribute__ ((__always_inline__)) int
__sigbits(int __signo)
{
    return __signo > 32 ? 0 : (1 << (__signo - 1));
}
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 2 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/csignal" 3


namespace std {inline namespace __1 {

using ::sig_atomic_t;
using ::signal;
using ::raise;

} }
# 7 "./common_utils_cpp.hpp" 2
# 1 "/usr/include/sys/stat.h" 1 3 4
# 85 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 86 "/usr/include/sys/stat.h" 2 3 4
# 1 "/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 87 "/usr/include/sys/stat.h" 2 3 4

# 1 "/usr/include/sys/_types/_ino_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 89 "/usr/include/sys/stat.h" 2 3 4


# 1 "/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_ino64_t.h" 3 4
typedef __darwin_ino64_t ino64_t;
# 92 "/usr/include/sys/stat.h" 2 3 4



# 1 "/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 96 "/usr/include/sys/stat.h" 2 3 4
# 110 "/usr/include/sys/stat.h" 3 4
struct ostat {
 __uint16_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 __uint16_t st_uid;
 __uint16_t st_gid;
 __uint16_t st_rdev;
 __int32_t st_size;
 struct timespec st_atimespec;
 struct timespec st_mtimespec;
 struct timespec st_ctimespec;
 __int32_t st_blksize;
 __int32_t st_blocks;
 __uint32_t st_flags;
 __uint32_t st_gen;
};
# 182 "/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 221 "/usr/include/sys/stat.h" 3 4
struct stat64 { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 241 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/_types/_s_ifmt.h" 1 3 4
# 242 "/usr/include/sys/stat.h" 2 3 4
# 344 "/usr/include/sys/stat.h" 3 4
extern "C" {

int chmod(const char *, mode_t) __asm("_" "chmod") ;
int fchmod(int, mode_t) __asm("_" "fchmod") ;
int fstat(int, struct stat *) __asm("_" "fstat" "$INODE64");
int lstat(const char *, struct stat *) __asm("_" "lstat" "$INODE64");
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int stat(const char *, struct stat *) __asm("_" "stat" "$INODE64");
int mknod(const char *, mode_t, dev_t);
mode_t umask(mode_t);




# 1 "/usr/include/sys/_types/_filesec_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_filesec_t.h" 3 4
struct _filesec;
typedef struct _filesec *filesec_t;
# 359 "/usr/include/sys/stat.h" 2 3 4

int chflags(const char *, __uint32_t);
int chmodx_np(const char *, filesec_t);
int fchflags(int, __uint32_t);
int fchmodx_np(int, filesec_t);
int fstatx_np(int, struct stat *, filesec_t) __asm("_" "fstatx_np" "$INODE64");
int lchflags(const char *, __uint32_t) __attribute__((availability(macosx,introduced=10.5)));
int lchmod(const char *, mode_t) __attribute__((availability(macosx,introduced=10.5)));
int lstatx_np(const char *, struct stat *, filesec_t) __asm("_" "lstatx_np" "$INODE64");
int mkdirx_np(const char *, filesec_t);
int mkfifox_np(const char *, filesec_t);
int statx_np(const char *, struct stat *, filesec_t) __asm("_" "statx_np" "$INODE64");
int umaskx_np(filesec_t) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)));



int fstatx64_np(int, struct stat64 *, filesec_t) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int lstatx64_np(const char *, struct stat64 *, filesec_t) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int statx64_np(const char *, struct stat64 *, filesec_t) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int fstat64(int, struct stat64 *) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int lstat64(const char *, struct stat64 *) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));
int stat64(const char *, struct stat64 *) __attribute__((availability(macosx,introduced=10.5,deprecated=10.6)));



}
# 8 "./common_utils_cpp.hpp" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 23 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/sys/fcntl.h" 1 3 4
# 116 "/usr/include/sys/fcntl.h" 3 4
# 1 "/usr/include/sys/_types/_o_sync.h" 1 3 4
# 117 "/usr/include/sys/fcntl.h" 2 3 4
# 141 "/usr/include/sys/fcntl.h" 3 4
# 1 "/usr/include/sys/_types/_o_dsync.h" 1 3 4
# 142 "/usr/include/sys/fcntl.h" 2 3 4
# 279 "/usr/include/sys/fcntl.h" 3 4
# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
# 280 "/usr/include/sys/fcntl.h" 2 3 4
# 304 "/usr/include/sys/fcntl.h" 3 4
struct flock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
};
# 319 "/usr/include/sys/fcntl.h" 3 4
struct flocktimeout {
 struct flock fl;
 struct timespec timeout;
};
# 332 "/usr/include/sys/fcntl.h" 3 4
struct radvisory {
       off_t ra_offset;
       int ra_count;
};
# 344 "/usr/include/sys/fcntl.h" 3 4
typedef struct fsignatures {
 off_t fs_file_start;
 void *fs_blob_start;
 size_t fs_blob_size;
} fsignatures_t;
# 358 "/usr/include/sys/fcntl.h" 3 4
typedef struct fstore {
 unsigned int fst_flags;
 int fst_posmode;
 off_t fst_offset;
 off_t fst_length;
 off_t fst_bytesalloc;
} fstore_t;



typedef struct fbootstraptransfer {
  off_t fbt_offset;
  size_t fbt_length;
  void *fbt_buffer;
} fbootstraptransfer_t;
# 396 "/usr/include/sys/fcntl.h" 3 4
#pragma pack(4)

struct log2phys {
 unsigned int l2p_flags;
 off_t l2p_contigbytes;


 off_t l2p_devoffset;


};

#pragma pack()
# 421 "/usr/include/sys/fcntl.h" 3 4
typedef enum {
 FILESEC_OWNER = 1,
 FILESEC_GROUP = 2,
 FILESEC_UUID = 3,
 FILESEC_MODE = 4,
 FILESEC_ACL = 5,
 FILESEC_GRPUUID = 6,


 FILESEC_ACL_RAW = 100,
 FILESEC_ACL_ALLOCSIZE = 101
} filesec_property_t;





extern "C" {
int open(const char *, int, ...) __asm("_" "open") ;
int creat(const char *, mode_t) __asm("_" "creat") ;
int fcntl(int, int, ...) __asm("_" "fcntl") ;


int openx_np(const char *, int, filesec_t);

int open_dprotected_np ( const char *, int, int, int, ...);
int flock(int, int);
filesec_t filesec_init(void);
filesec_t filesec_dup(filesec_t);
void filesec_free(filesec_t);
int filesec_get_property(filesec_t, filesec_property_t, void *);
int filesec_query_property(filesec_t, filesec_property_t, int *);
int filesec_set_property(filesec_t, filesec_property_t, const void *);
int filesec_unset_property(filesec_t, filesec_property_t) __attribute__((availability(macosx,introduced=10.6)));



}
# 24 "/usr/include/fcntl.h" 2 3 4
# 9 "./common_utils_cpp.hpp" 2


# 1 "/usr/local/include/glm/glm.hpp" 1 3
# 52 "/usr/local/include/glm/glm.hpp" 3
# 1 "/usr/local/include/glm/detail/_fixes.hpp" 1 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 1 3
# 302 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 1 3
# 203 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 1 3
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 2 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 3


namespace std {inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;

typedef long double max_align_t;



struct __attribute__ ((__type_visibility__("default"))) nullptr_t
{
    void* __lx;

    struct __nat {int __for_bool_;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t() : __lx(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t(int __nat::*) : __lx(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int __nat::*() const {return 0;}

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp* () const {return 0;}

    template <class _Tp, class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp _Up::* () const {return 0;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator==(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!=(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<=(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>=(nullptr_t, nullptr_t) {return true;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t __get_nullptr_t() {return nullptr_t(0);}





} }
# 204 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 2 3
# 207 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3


namespace std {inline namespace __1 {

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};





template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};






struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
    static const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                          operator value_type() const {return value;}




};

template <class _Tp, _Tp __v>
                  const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};






template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 309 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};



template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};
# 382 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 397 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 415 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};



namespace __libcpp_is_function_imp
{
template <class _Tp> char __test(_Tp*);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source();
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};



template <class _Tp> struct __libcpp_is_member_function_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 487 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};



template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};







template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
# 579 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference {typedef _Tp& type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<_Tp&> {typedef _Tp& type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<void> {typedef void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const void> {typedef const void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<volatile void> {typedef volatile void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const volatile void> {typedef const volatile void type;};
# 612 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
typename add_lvalue_reference<_Tp>::type
declval();



struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename remove_reference<_Tp>::type* type;};







template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};



template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};



template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};







template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};







namespace __is_abstract_imp
{
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};

template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};





template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 801 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 920 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 951 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 971 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 983 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};



template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{






};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Aligner>::value)>)> __t1074;
    union type
    {
        _Aligner __align;
        unsigned char __data[_Len];
    };
};
# 1097 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[_Len]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[_Len]; };};
# 1154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef __typeof__(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote
{
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
    typedef typename __promote<_A3>::type __type3;
public:
    typedef __typeof__(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote<_A1, _A2, void, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
public:
    typedef __typeof__(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
    static const bool __does_not_throw = false;
};
# 1236 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,
    __nat
    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,
    __nat
    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};







template <class _Tp, class _Up = void, class V = void>
struct __attribute__ ((__type_visibility__("default"))) common_type
{
public:
    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, void, void>
{
public:
    typedef _Tp type;
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up, void>
{
private:




    static _Tp __t();
    static _Up __u();

public:
    typedef typename remove_reference<__typeof__(true ? __t() : __u())>::type type;
};
# 1441 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<__typeof__((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type



__is_assignable_test(_Tp, _Arg&);


template <class _Arg>
false_type



__is_assignable_test(__any, _Arg&);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public common_type
        <
            __typeof__(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        >::type {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                     const typename add_lvalue_reference<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable




    : public is_copy_assignable<_Tp> {};




template <class _Tp>
struct __destructible_test
{
    _Tp __t;
};

template <class _Tp>
__typeof__((std::__1::declval<__destructible_test<_Tp> >().~__destructible_test<_Tp>(), true_type()))



__is_destructible_test(_Tp&);


false_type
__is_destructible_test(__any);

template <class _Tp, bool = is_void<_Tp>::value || is_abstract<_Tp>::value
                                                || is_function<_Tp>::value>
struct __destructible_imp
    : public common_type
        <
            __typeof__(__is_destructible_test(declval<_Tp>()))
        >::type {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_imp<_Tp> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public false_type {};
# 1564 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
move(_Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
move(const _Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
forward(typename std::remove_reference<_Tp>::type& __t) throw()
{
    return __t;
}


template <class _Tp>
class __rv
{
    typedef typename remove_reference<_Tp>::type _Trr;
    _Trr& t_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Trr* operator->() {return &t_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __rv(_Trr& __t) : t_(__t) {}
};
# 1615 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(const _Tp& __t)
{
    return std::__1::forward<_Tp>(__t);
}



template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};
# 1722 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};



template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{


};



template <class _Callable> class result_of;



template <class _Fn, bool, bool>
class __result_of
{
};

template <class _Fn>
class __result_of<_Fn(), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()()) type;
};

template <class _Fn, class _A0>
class __result_of<_Fn(_A0), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>())) type;
};

template <class _Fn, class _A0, class _A1>
class __result_of<_Fn(_A0, _A1), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
};

template <class _Fn, class _A0, class _A1, class _A2>
class __result_of<_Fn(_A0, _A1, _A2), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
};

template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
struct __result_of_mp;



template <class _MP, class _Tp>
struct __result_of_mp<_MP, _Tp, true>
    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>
{
};



template <class _MP, class _Tp, bool>
struct __result_of_mdp;

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, false>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_Tp>()), _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, true>
{
    typedef typename __apply_cv<_Tp, _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mp<_Rp _Class::*, _Tp, false>
    : public __result_of_mdp<_Rp _Class::*, _Tp,
            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
{
};



template <class _Fn, class _Tp>
class __result_of<_Fn(_Tp), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0>
class __result_of<_Fn(_Tp, _A0), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1>
class __result_of<_Fn(_Tp, _A0, _A1), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};



template <class _Fn>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn()>
    : public __result_of<_Fn(),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0)>
    : public __result_of<_Fn(_A0),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1)>
    : public __result_of<_Fn(_A0, _A1),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1, _A2)>
    : public __result_of<_Fn(_A0, _A1, _A2),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};
# 2131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
__typeof__((_Tp(), true_type()))
__is_constructible0_test(_Tp&);

false_type
__is_constructible0_test(__any);

template <class _Tp, class _A0>
__typeof__((_Tp(std::__1::declval<_A0>()), true_type()))
__is_constructible1_test(_Tp&, _A0&);

template <class _A0>
false_type
__is_constructible1_test(__any, _A0&);

template <class _Tp, class _A0, class _A1>
__typeof__((_Tp(std::__1::declval<_A0>(), std::__1::declval<_A1>()), true_type()))
__is_constructible2_test(_Tp&, _A0&, _A1&);

template <class _A0, class _A1>
false_type
__is_constructible2_test(__any, _A0&, _A1&);

template <bool, class _Tp>
struct __is_constructible0_imp
    : public common_type
             <
                 __typeof__(__is_constructible0_test(declval<_Tp&>()))
             >::type
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_imp
    : public common_type
             <
                 __typeof__(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
             >::type
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_imp
    : public common_type
             <
                 __typeof__(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
             >::type
    {};





template <class _Tp>
struct __is_constructible0_imp<true, _Tp>
    : public is_scalar<_Tp>
    {};

template <class _Tp, class _A0>
struct __is_constructible1_imp<true, _Tp, _A0>
    : public is_convertible<_A0, _Tp>
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_imp<true, _Tp, _A0, _A1>
    : public false_type
    {};



template <bool, class _Tp>
struct __is_constructible0_void_check
    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp>
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_void_check
    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0>
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check
    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0, _A1>
    {};



template <class _Tp>
struct __is_constructible0_void_check<true, _Tp>
    : public false_type
    {};

template <class _Tp, class _A0>
struct __is_constructible1_void_check<true, _Tp, _A0>
    : public false_type
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
    : public false_type
    {};



namespace __is_construct
{

struct __nat {};

}

template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public __is_constructible2_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value
                                        || is_void<_A1>::value,
                                           _Tp, _A0, _A1>
    {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
    : public __is_constructible0_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value,
                                           _Tp>
    {};

template <class _Tp, class _A0>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, _A0, __is_construct::__nat>
    : public __is_constructible1_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value,
                                           _Tp, _A0>
    {};




template <class _Ap, size_t _Np>
struct __is_constructible0_imp<false, _Ap[_Np]>
    : public is_constructible<typename remove_all_extents<_Ap>::type>
    {};

template <class _Ap, size_t _Np, class _A0>
struct __is_constructible1_imp<false, _Ap[_Np], _A0>
    : public false_type
    {};

template <class _Ap, size_t _Np, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
    : public false_type
    {};



template <class _Ap>
struct __is_constructible0_imp<false, _Ap[]>
    : public false_type
    {};

template <class _Ap, class _A0>
struct __is_constructible1_imp<false, _Ap[], _A0>
    : public false_type
    {};

template <class _Ap, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
    : public false_type
    {};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible



    : public is_copy_constructible<_Tp>

    {};
# 2389 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : false_type
{
};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
{
};
# 2462 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible



    : public is_trivially_copy_constructible<_Tp>

    {};





template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 2522 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};
# 2644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : false_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_constructor(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible



    : public is_nothrow_copy_constructible<_Tp>

    {};
# 2745 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public false_type {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, const _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
# 2789 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};
# 2853 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_nothrow_destructor
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_reference<_Tp>::value> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 2881 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>




    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};
# 3190 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))







void

swap(_Tp& __x, _Tp& __y)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)



{
    swap(*__a, *__b);
}



namespace __detail
{

using std::__1::swap;
__nat swap(__any, __any);

template <class _Tp>
struct __swappable
{
    typedef __typeof__(swap(std::__1::declval<_Tp&>(), std::__1::declval<_Tp&>())) type;
    static const bool value = !is_same<type, __nat>::value;
};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
{
};
# 3266 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __is_nothrow_swappable
    : public false_type
{
};





template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};
# 3319 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
} }
# 303 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3
# 310 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3






template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_signbit(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_signbitf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_signbitd((double)(__x)) : __inline_signbitl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
signbit(_A1 __x) throw()
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
int
__libcpp_fpclassify(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __fpclassifyf((float)(__x)) : sizeof(__x) == sizeof(double) ? __fpclassifyd((double)(__x)) : __fpclassifyl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, int>::type
fpclassify(_A1 __x) throw()
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isfinite(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isfinitef((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isfinited((double)(__x)) : __inline_isfinitel((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isfinite(_A1 __x) throw()
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isinf(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isinff((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isinfd((double)(__x)) : __inline_isinfl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isinf(_A1 __x) throw()
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnan(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isnanf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isnand((double)(__x)) : __inline_isnanl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnan(_A1 __x) throw()
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnormal(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isnormalf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isnormald((double)(__x)) : __inline_isnormall((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnormal(_A1 __x) throw()
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__x);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreater((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreaterequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreaterequal((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isless(_A1 __x, _A2 __y) throw()
{
    return __builtin_isless((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessequal((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessgreater((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isunordered(_A1 __x, _A2 __y) throw()
{
    return __builtin_isunordered((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__x, (type)__y);
}



namespace std {inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;




inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float
abs(float __x) throw() {return fabsf(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double
abs(double __x) throw() {return fabs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double
abs(long double __x) throw() {return fabsl(__x);}






using ::acos;
using ::acosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acos(float __x) throw() {return acosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acos(long double __x) throw() {return acosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acos(_A1 __x) throw() {return acos((double)__x);}



using ::asin;
using ::asinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asin(float __x) throw() {return asinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asin(long double __x) throw() {return asinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asin(_A1 __x) throw() {return asin((double)__x);}



using ::atan;
using ::atanf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan(float __x) throw() {return atanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan(long double __x) throw() {return atanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atan(_A1 __x) throw() {return atan((double)__x);}



using ::atan2;
using ::atan2f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan2(float __y, float __x) throw() {return atan2f(__y, __x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan2(long double __y, long double __x) throw() {return atan2l(__y, __x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
atan2(_A1 __y, _A2 __x) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t740;

    return atan2((__result_type)__y, (__result_type)__x);
}



using ::ceil;
using ::ceilf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ceil(float __x) throw() {return ceilf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ceil(long double __x) throw() {return ceill(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ceil(_A1 __x) throw() {return ceil((double)__x);}



using ::cos;
using ::cosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cos(float __x) throw() {return cosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cos(long double __x) throw() {return cosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cos(_A1 __x) throw() {return cos((double)__x);}



using ::cosh;
using ::coshf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cosh(float __x) throw() {return coshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cosh(long double __x) throw() {return coshl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cosh(_A1 __x) throw() {return cosh((double)__x);}




using ::exp;
using ::expf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp(float __x) throw() {return expf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp(long double __x) throw() {return expl(__x);}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp(_A1 __x) throw() {return exp((double)__x);}



using ::fabs;
using ::fabsf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fabs(float __x) throw() {return fabsf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fabs(long double __x) throw() {return fabsl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
fabs(_A1 __x) throw() {return fabs((double)__x);}



using ::floor;
using ::floorf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float floor(float __x) throw() {return floorf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double floor(long double __x) throw() {return floorl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
floor(_A1 __x) throw() {return floor((double)__x);}




using ::fmod;
using ::fmodf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmod(float __x, float __y) throw() {return fmodf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmod(long double __x, long double __y) throw() {return fmodl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmod(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t862;

    return fmod((__result_type)__x, (__result_type)__y);
}




using ::frexp;
using ::frexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float frexp(float __x, int* __e) throw() {return frexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double frexp(long double __x, int* __e) throw() {return frexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
frexp(_A1 __x, int* __e) throw() {return frexp((double)__x, __e);}



using ::ldexp;
using ::ldexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ldexp(float __x, int __e) throw() {return ldexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ldexp(long double __x, int __e) throw() {return ldexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ldexp(_A1 __x, int __e) throw() {return ldexp((double)__x, __e);}




using ::log;
using ::logf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log(float __x) throw() {return logf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log(long double __x) throw() {return logl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log(_A1 __x) throw() {return log((double)__x);}




using ::log10;
using ::log10f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log10(float __x) throw() {return log10f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log10(long double __x) throw() {return log10l(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log10(_A1 __x) throw() {return log10((double)__x);}



using ::modf;
using ::modff;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float modf(float __x, float* __y) throw() {return modff(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double modf(long double __x, long double* __y) throw() {return modfl(__x, __y);}





using ::pow;
using ::powf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float pow(float __x, float __y) throw() {return powf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double pow(long double __x, long double __y) throw() {return powl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
pow(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t965;

    return pow((__result_type)__x, (__result_type)__y);
}



using ::sin;
using ::sinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sin(float __x) throw() {return sinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sin(long double __x) throw() {return sinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sin(_A1 __x) throw() {return sin((double)__x);}



using ::sinh;
using ::sinhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sinh(float __x) throw() {return sinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sinh(long double __x) throw() {return sinhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sinh(_A1 __x) throw() {return sinh((double)__x);}




using ::sqrt;
using ::sqrtf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sqrt(float __x) throw() {return sqrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sqrt(long double __x) throw() {return sqrtl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sqrt(_A1 __x) throw() {return sqrt((double)__x);}



using ::tan;
using ::tanf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tan(float __x) throw() {return tanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tan(long double __x) throw() {return tanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tan(_A1 __x) throw() {return tan((double)__x);}



using ::tanh;
using ::tanhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tanh(float __x) throw() {return tanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tanh(long double __x) throw() {return tanhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tanh(_A1 __x) throw() {return tanh((double)__x);}




using ::acosh;
using ::acoshf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acosh(float __x) throw() {return acoshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acosh(long double __x) throw() {return acoshl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acosh(_A1 __x) throw() {return acosh((double)__x);}





using ::asinh;
using ::asinhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asinh(float __x) throw() {return asinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asinh(long double __x) throw() {return asinhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asinh(_A1 __x) throw() {return asinh((double)__x);}





using ::atanh;
using ::atanhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atanh(float __x) throw() {return atanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atanh(long double __x) throw() {return atanhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atanh(_A1 __x) throw() {return atanh((double)__x);}





using ::cbrt;
using ::cbrtf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cbrt(float __x) throw() {return cbrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cbrt(long double __x) throw() {return cbrtl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cbrt(_A1 __x) throw() {return cbrt((double)__x);}




using ::copysign;
using ::copysignf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float copysign(float __x, float __y) throw() {return copysignf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double copysign(long double __x, long double __y) throw() {return copysignl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
copysign(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1127;

    return copysign((__result_type)__x, (__result_type)__y);
}





using ::erf;
using ::erff;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erf(float __x) throw() {return erff(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erf(long double __x) throw() {return erfl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erf(_A1 __x) throw() {return erf((double)__x);}



using ::erfc;
using ::erfcf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erfc(float __x) throw() {return erfcf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erfc(long double __x) throw() {return erfcl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erfc(_A1 __x) throw() {return erfc((double)__x);}



using ::exp2;
using ::exp2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp2(float __x) throw() {return exp2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp2(long double __x) throw() {return exp2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp2(_A1 __x) throw() {return exp2((double)__x);}



using ::expm1;
using ::expm1f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float expm1(float __x) throw() {return expm1f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double expm1(long double __x) throw() {return expm1l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
expm1(_A1 __x) throw() {return expm1((double)__x);}



using ::fdim;
using ::fdimf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fdim(float __x, float __y) throw() {return fdimf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fdim(long double __x, long double __y) throw() {return fdiml(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fdim(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1205;

    return fdim((__result_type)__x, (__result_type)__y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmaf(float __x, float __y, float __z) throw() {return (float)((double)__x*__y + __z);}




using ::fma;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fma(float __x, float __y, float __z) throw() {return fmaf(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fma(long double __x, long double __y, long double __z) throw() {return fmal(__x, __y, __z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    typename __promote<_A1, _A2, _A3>::type
>::type
fma(_A1 __x, _A2 __y, _A3 __z) throw()
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value && is_same<_A3, __result_type>::value)))>)> __t1235;


    return fma((__result_type)__x, (__result_type)__y, (__result_type)__z);
}



using ::fmax;
using ::fmaxf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmax(float __x, float __y) throw() {return fmaxf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmax(long double __x, long double __y) throw() {return fmaxl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmax(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1259;

    return fmax((__result_type)__x, (__result_type)__y);
}



using ::fmin;
using ::fminf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmin(float __x, float __y) throw() {return fminf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmin(long double __x, long double __y) throw() {return fminl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmin(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1283;

    return fmin((__result_type)__x, (__result_type)__y);
}



using ::hypot;
using ::hypotf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float hypot(float __x, float __y) throw() {return hypotf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double hypot(long double __x, long double __y) throw() {return hypotl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
hypot(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1307;

    return hypot((__result_type)__x, (__result_type)__y);
}



using ::ilogb;
using ::ilogbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(float __x) throw() {return ilogbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(long double __x) throw() {return ilogbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, int>::type
ilogb(_A1 __x) throw() {return ilogb((double)__x);}



using ::lgamma;
using ::lgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float lgamma(float __x) throw() {return lgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double lgamma(long double __x) throw() {return lgammal(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
lgamma(_A1 __x) throw() {return lgamma((double)__x);}




using ::llrint;
using ::llrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(float __x) throw() {return llrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(long double __x) throw() {return llrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llrint(_A1 __x) throw() {return llrint((double)__x);}



using ::llround;
using ::llroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(float __x) throw() {return llroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(long double __x) throw() {return llroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llround(_A1 __x) throw() {return llround((double)__x);}



using ::log1p;
using ::log1pf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log1p(float __x) throw() {return log1pf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log1p(long double __x) throw() {return log1pl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log1p(_A1 __x) throw() {return log1p((double)__x);}



using ::log2;
using ::log2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log2(float __x) throw() {return log2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log2(long double __x) throw() {return log2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log2(_A1 __x) throw() {return log2((double)__x);}



using ::logb;
using ::logbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float logb(float __x) throw() {return logbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double logb(long double __x) throw() {return logbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
logb(_A1 __x) throw() {return logb((double)__x);}



using ::lrint;
using ::lrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(float __x) throw() {return lrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(long double __x) throw() {return lrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lrint(_A1 __x) throw() {return lrint((double)__x);}



using ::lround;
using ::lroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(float __x) throw() {return lroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(long double __x) throw() {return lroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lround(_A1 __x) throw() {return lround((double)__x);}







using ::nan;
using ::nanf;







using ::nearbyint;
using ::nearbyintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nearbyint(float __x) throw() {return nearbyintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nearbyint(long double __x) throw() {return nearbyintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nearbyint(_A1 __x) throw() {return nearbyint((double)__x);}



using ::nextafter;
using ::nextafterf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nextafter(float __x, float __y) throw() {return nextafterf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nextafter(long double __x, long double __y) throw() {return nextafterl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
nextafter(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1476;

    return nextafter((__result_type)__x, (__result_type)__y);
}



using ::nexttoward;
using ::nexttowardf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nexttoward(float __x, long double __y) throw() {return nexttowardf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nexttoward(long double __x, long double __y) throw() {return nexttowardl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nexttoward(_A1 __x, long double __y) throw() {return nexttoward((double)__x, __y);}



using ::remainder;
using ::remainderf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remainder(float __x, float __y) throw() {return remainderf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remainder(long double __x, long double __y) throw() {return remainderl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remainder(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1513;

    return remainder((__result_type)__x, (__result_type)__y);
}



using ::remquo;
using ::remquof;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remquo(float __x, float __y, int* __z) throw() {return remquof(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remquo(long double __x, long double __y, int* __z) throw() {return remquol(__x, __y, __z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remquo(_A1 __x, _A2 __y, int* __z) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1537;

    return remquo((__result_type)__x, (__result_type)__y, __z);
}



using ::rint;
using ::rintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float rint(float __x) throw() {return rintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double rint(long double __x) throw() {return rintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
rint(_A1 __x) throw() {return rint((double)__x);}



using ::round;
using ::roundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float round(float __x) throw() {return roundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double round(long double __x) throw() {return roundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
round(_A1 __x) throw() {return round((double)__x);}



using ::scalbln;
using ::scalblnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbln(float __x, long __y) throw() {return scalblnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbln(long double __x, long __y) throw() {return scalblnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbln(_A1 __x, long __y) throw() {return scalbln((double)__x, __y);}



using ::scalbn;
using ::scalbnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbn(float __x, int __y) throw() {return scalbnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbn(long double __x, int __y) throw() {return scalbnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbn(_A1 __x, int __y) throw() {return scalbn((double)__x, __y);}



using ::tgamma;
using ::tgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tgamma(float __x) throw() {return tgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tgamma(long double __x) throw() {return tgammal(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tgamma(_A1 __x) throw() {return tgamma((double)__x);}



using ::trunc;
using ::truncf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float trunc(float __x) throw() {return truncf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double trunc(long double __x) throw() {return truncl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
trunc(_A1 __x) throw() {return trunc((double)__x);}



using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;






} }
# 4 "/usr/local/include/glm/detail/_fixes.hpp" 2 3
# 52 "/usr/local/include/glm/glm.hpp" 2 3





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 1 3
# 42 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 1 3 4
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 64 "/usr/include/limits.h" 3 4
# 1 "/usr/include/machine/limits.h" 1 3 4





# 1 "/usr/include/i386/limits.h" 1 3 4
# 40 "/usr/include/i386/limits.h" 3 4
# 1 "/usr/include/i386/_limits.h" 1 3 4
# 41 "/usr/include/i386/limits.h" 2 3 4
# 7 "/usr/include/machine/limits.h" 2 3 4
# 65 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
# 66 "/usr/include/limits.h" 2 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 2 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 2 3
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 57 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 1 3
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/float.h" 1 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 2 3
# 68 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 3
# 58 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 1 3
# 107 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 113 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 2 3
# 122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3
namespace std {inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return type();}

    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type();}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type();}

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int digits, bool is_signed>
struct __libcpp_compute_min
{
    static const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false>
{
    static const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static const bool is_specialized = true;

    static const bool is_signed = type(-1) < type(0);
    static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static const int digits10 = digits * 3 / 10;
    static const int max_digits10 = 0;
    static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = true;


    static const bool traps = true;



    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static const bool is_specialized = true;

    static const bool is_signed = false;
    static const int digits = 1;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const type __min = false;
    static const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 24;
    static const int digits10 = 6;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5F;}

    static const int min_exponent = (-125);
    static const int min_exponent10 = (-37);
    static const int max_exponent = 128;
    static const int max_exponent10 = 38;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 1.40129846e-45F;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-1021);
    static const int min_exponent10 = (-307);
    static const int max_exponent = 1024;
    static const int max_exponent10 = 308;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 4.9406564584124654e-324;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 64;
    static const int digits10 = 18;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 3.36210314311209350626e-4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.18973149535723176502e+4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.08420217248550443401e-19L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-16381);
    static const int min_exponent10 = (-4931);
    static const int max_exponent = 16384;
    static const int max_exponent10 = 4932;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 3.64519953188247460253e-4951L;}




    static const bool is_iec559 = true;

    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<_Tp>::radix;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<_Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 59 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 60 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/fwd.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_int.hpp" 1 3





# 1 "/usr/local/include/glm/detail/setup.hpp" 1 3
# 28 "/usr/local/include/glm/detail/setup.hpp" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 28 "/usr/local/include/glm/detail/setup.hpp" 2 3


# 1 "/usr/local/include/glm/detail/../simd/platform.h" 1 3
# 432 "/usr/local/include/glm/detail/../simd/platform.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mmintrin.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mmintrin.h" 3 4
typedef long long __m64 __attribute__((__vector_size__(8)));

typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_empty(void)
{
    __builtin_ia32_emms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mm_malloc.h" 1 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/mm_malloc.h" 3 4
extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t __size, size_t __align)
{
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{
  free(__p);
}
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return __a + __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return __a - __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return __a * __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return __a / __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_sqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rcpss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ps(__m128 __a)
{
  return __builtin_ia32_rcpps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rsqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 1),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 2),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 5),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 6),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 3);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}



static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64(__a);
}



static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si32(__m128 __a)
{
  return __a[0];
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si64(__m128 __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}

static __inline__ float __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load_ss_struct*)__p)->__u;
  return (__m128){ __u, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct*)__p)->__u;
  return (__m128){ __u, __u, __u, __u };
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ps(const float *__p)
{
  return *(__m128*)__p;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ss(float __w)
{
  return (__m128){ __w, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set1_ps(float __w)
{
  return (__m128){ __w, __w, __w, __w };
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __w, __x, __y, __z };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __z, __y, __x, __w };
}

static __inline__ __m128 __attribute__((__always_inline__))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __attribute__((__always_inline__))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storehps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storelps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_ps(float *__p, __m128 __a)
{
  __builtin_ia32_storeups(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 0, 0, 0, 0);
  _mm_storeu_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps1(float *__p, __m128 __a)
{
    return _mm_store1_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128 *)__p = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 680 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_ia32_movntps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_pi16(__m64 __a, int __n)
{
  __v4hi __b = (__v4hi)__a;
  return (unsigned short)__b[__n & 3];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_insert_pi16(__m64 __a, int __d, int __n)
{
   __v4hi __b = (__v4hi)__a;
   __b[__n & 3] = __d;
   return (__m64)__b;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}





static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_setcsr(unsigned int __i)
{
  __builtin_ia32_ldmxcsr(__i);
}
# 797 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 2, 6, 3, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 4, 1, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_move_ss(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 6, 7, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps(__a);
}
# 996 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 1 3 4
# 997 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/xmmintrin.h" 2 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 2 3 4

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return __a + __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return __a - __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return __a * __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return __a / __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd(__b);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 1);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 2);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 5);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 6);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pd(__m128 __a)
{
  return __builtin_ia32_cvtps2pd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_pd(__m128i __a)
{
  return __builtin_ia32_cvtdq2pd((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si32(__m128d __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_pd(double const *__dp)
{
  return *(__m128d*)__dp;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load1_pd(double const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load1_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __u };
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadr_pd(double const *__dp)
{
  __m128d __u = *(__m128d*)__dp;
  return __builtin_shufflevector(__u, __u, 1, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadu_pd(double const *__dp)
{
  struct __loadu_pd {
    __m128d __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_pd*)__dp)->__v;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_sd(double const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load_sd_struct*)__dp)->__u;
  return (__m128d){ __u, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadh_pd_struct*)__dp)->__u;
  return (__m128d){ __a[0], __u };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadl_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_sd(double __w)
{
  return (__m128d){ __w, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set1_pd(double __w)
{
  return (__m128d){ __w, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_pd(double __w, double __x)
{
  return (__m128d){ __x, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setr_pd(double __w, double __x)
{
  return (__m128d){ __w, __x };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_move_sd(__m128d __a, __m128d __b)
{
  return (__m128d){ __b[0], __a[1] };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_pd(double *__dp, __m128d __a)
{
  struct __mm_store1_pd_struct {
    double __u[2];
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store1_pd_struct*)__dp)->__u[0] = __a[0];
  ((struct __mm_store1_pd_struct*)__dp)->__u[1] = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  __builtin_ia32_storeupd(__dp, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector(__a, __a, 1, 0);
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a + (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a + (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a + (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a * (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a - (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a - (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a - (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return __a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return ~__a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return __a | __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return __a ^ __b;
}







static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 901 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{


  typedef signed char __v16qs __attribute__((__vector_size__(16)));
  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}


static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si64(__m128d __a)
{
  return __a[0];
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_ps(__m128i __a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si128(int __a)
{
  return (__m128i)(__v4si){ __a, 0, 0, 0 };
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si128(long long __a)
{
  return (__m128i){ __a, 0 };
}


static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_load_si128(__m128i const *__p)
{
  return *__p;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadu_si128(__m128i const *__p)
{
  struct __loadu_si128 {
    __m128i __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_si128*)__p)->__v;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadl_epi64(__m128i const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64x(long long q1, long long q0)
{
  return (__m128i){ q0, q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64(__m64 q1, __m64 q0)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi32(int i3, int i2, int i1, int i0)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi16(short w7, short w6, short w5, short w4, short w3, short w2, short w1, short w0)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi8(char b15, char b14, char b13, char b12, char b11, char b10, char b9, char b8, char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64x(long long __q)
{
  return (__m128i){ __q, __q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64(__m64 __q)
{
  return (__m128i){ (long long)__q, (long long)__q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi32(int __i)
{
  return (__m128i)(__v4si){ __i, __i, __i, __i };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi16(short __w)
{
  return (__m128i)(__v8hi){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi8(char __b)
{
  return (__m128i)(__v16qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi64(__m64 q0, __m64 q1)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi32(int i0, int i1, int i2, int i3)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi16(short w0, short w1, short w2, short w3, short w4, short w5, short w6, short w7)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi8(char b0, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8, char b9, char b10, char b11, char b12, char b13, char b14, char b15)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_si128(__m128i *__p, __m128i __b)
{
  __builtin_ia32_storedqu((char *)__p, (__v16qi)__b);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_epi64(__m128i *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_ia32_movntpd(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_ia32_movntdq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_clflush(void const *__p)
{
  __builtin_ia32_clflush(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_lfence(void)
{
  __builtin_ia32_lfence();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mfence(void)
{
  __builtin_ia32_mfence();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_epi16(__m128i __a, int __imm)
{
  __v8hi __b = (__v8hi)__a;
  return (unsigned short)__b[__imm & 7];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_insert_epi16(__m128i __a, int __b, int __imm)
{
  __v8hi __c = (__v8hi)__a;
  __c[__imm & 7] = __b;
  return (__m128i)__c;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 1314 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_movpi64_epi64(__m64 __a)
{
  return (__m128i){ (long long)__a, 0 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector(__a, (__m128i){ 0 }, 0, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd(__a);
}
# 1405 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_pause(void)
{
  __asm__ volatile ("pause");
}
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 2 3 4

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_lddqu_si128(__m128i const *__p)
{
  return (__m128i)__builtin_ia32_lddqu((char const *)__p);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_addsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_addsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_haddps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_hsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehdup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 1, 1, 3, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_moveldup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0, 2, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_addsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_addsubpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_haddpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_hsubpd(__a, __b);
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_movedup_pd(__m128d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0);
}
# 103 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_monitor(void const *__p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitor((void *)__p, __extensions, __hints);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mwait(unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_mwait(__extensions, __hints);
}
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 2 3 4

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi8(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi8(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsb128((__v16qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi16(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi16(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsw128((__v8hi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi32(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi32(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsd128((__v4si)__a);
}
# 79 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadds_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadds_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)__a, (__v2si)__b);
}
# 432 "/usr/local/include/glm/detail/../simd/platform.h" 2 3








 typedef __m128 glm_vec4;
 typedef __m128i glm_ivec4;
 typedef __m128i glm_uvec4;
# 30 "/usr/local/include/glm/detail/setup.hpp" 2 3
# 780 "/usr/local/include/glm/detail/setup.hpp" 3
namespace glm
{
 using std::size_t;



  typedef int length_t;

}
# 825 "/usr/local/include/glm/detail/setup.hpp" 3
namespace glm
{
 enum ctor{uninitialize};
}
# 6 "/usr/local/include/glm/detail/type_int.hpp" 2 3
# 15 "/usr/local/include/glm/detail/type_int.hpp" 3
namespace glm{
namespace detail
{
# 43 "/usr/local/include/glm/detail/type_int.hpp" 3
#pragma clang diagnostic ignored "-Wc++11-long-long"
 typedef signed long long sint64;
   typedef unsigned long long uint64;






  typedef signed char int8;
  typedef signed short int16;
  typedef signed int int32;
  typedef sint64 int64;

  typedef unsigned char uint8;
  typedef unsigned short uint16;
  typedef unsigned int uint32;
  typedef uint64 uint64;


 typedef signed int lowp_int_t;
 typedef signed int mediump_int_t;
 typedef signed int highp_int_t;

 typedef unsigned int lowp_uint_t;
 typedef unsigned int mediump_uint_t;
 typedef unsigned int highp_uint_t;






  template <typename genType>
  struct make_signed
  {};

  template <>
  struct make_signed<char>
  {
   typedef char type;
  };

  template <>
  struct make_signed<short>
  {
   typedef short type;
  };

  template <>
  struct make_signed<int>
  {
   typedef int type;
  };

  template <>
  struct make_signed<long>
  {
   typedef long type;
  };

  template <>
  struct make_signed<unsigned char>
  {
   typedef char type;
  };

  template <>
  struct make_signed<unsigned short>
  {
   typedef short type;
  };

  template <>
  struct make_signed<unsigned int>
  {
   typedef int type;
  };

  template <>
  struct make_signed<unsigned long>
  {
   typedef long type;
  };

  template <typename genType>
  struct make_unsigned
  {};

  template <>
  struct make_unsigned<char>
  {
   typedef unsigned char type;
  };

  template <>
  struct make_unsigned<short>
  {
   typedef unsigned short type;
  };

  template <>
  struct make_unsigned<int>
  {
   typedef unsigned int type;
  };

  template <>
  struct make_unsigned<long>
  {
   typedef unsigned long type;
  };

  template <>
  struct make_unsigned<unsigned char>
  {
   typedef unsigned char type;
  };

  template <>
  struct make_unsigned<unsigned short>
  {
   typedef unsigned short type;
  };

  template <>
  struct make_unsigned<unsigned int>
  {
   typedef unsigned int type;
  };

  template <>
  struct make_unsigned<unsigned long>
  {
   typedef unsigned long type;
  };

  template <>
  struct make_signed<long long>
  {
   typedef long long type;
  };

  template <>
  struct make_signed<unsigned long long>
  {
   typedef long long type;
  };

  template <>
  struct make_unsigned<long long>
  {
   typedef unsigned long long type;
  };

  template <>
  struct make_unsigned<unsigned long long>
  {
   typedef unsigned long long type;
  };

}

 typedef detail::int8 int8;
 typedef detail::int16 int16;
 typedef detail::int32 int32;
 typedef detail::int64 int64;

 typedef detail::uint8 uint8;
 typedef detail::uint16 uint16;
 typedef detail::uint32 uint32;
 typedef detail::uint64 uint64;
# 224 "/usr/local/include/glm/detail/type_int.hpp" 3
 typedef detail::lowp_int_t lowp_int;






 typedef detail::mediump_int_t mediump_int;






 typedef detail::highp_int_t highp_int;






 typedef detail::lowp_uint_t lowp_uint;






 typedef detail::mediump_uint_t mediump_uint;






 typedef detail::highp_uint_t highp_uint;


 typedef mediump_int int_t;
# 274 "/usr/local/include/glm/detail/type_int.hpp" 3
 typedef mediump_uint uint_t;
# 288 "/usr/local/include/glm/detail/type_int.hpp" 3
 typedef unsigned int uint;
# 306 "/usr/local/include/glm/detail/type_int.hpp" 3
}
# 6 "/usr/local/include/glm/fwd.hpp" 2 3

# 1 "/usr/local/include/glm/detail/type_float.hpp" 1 3







namespace glm{
namespace detail
{
 typedef float float32;
 typedef double float64;
}

 typedef float lowp_float_t;
 typedef float mediump_float_t;
 typedef double highp_float_t;
# 27 "/usr/local/include/glm/detail/type_float.hpp" 3
 typedef lowp_float_t lowp_float;






 typedef mediump_float_t mediump_float;






 typedef highp_float_t highp_float;


 typedef mediump_float float_t;
# 55 "/usr/local/include/glm/detail/type_float.hpp" 3
 typedef float float32;
 typedef double float64;
# 67 "/usr/local/include/glm/detail/type_float.hpp" 3
}
# 7 "/usr/local/include/glm/fwd.hpp" 2 3

# 1 "/usr/local/include/glm/detail/type_vec.hpp" 1 3





# 1 "/usr/local/include/glm/detail/precision.hpp" 1 3







namespace glm
{
 enum precision
 {
  packed_highp,
  packed_mediump,
  packed_lowp,
# 23 "/usr/local/include/glm/detail/precision.hpp" 3
  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

namespace detail
{
 template <glm::precision P>
 struct is_aligned
 {
  static const bool value = false;
 };
# 62 "/usr/local/include/glm/detail/precision.hpp" 3
}
}
# 6 "/usr/local/include/glm/detail/type_vec.hpp" 2 3



namespace glm{
namespace detail
{
 template <typename T, std::size_t size, bool aligned>
 struct storage
 {
  typedef struct type {
   uint8 data[size];
  } type;
 };
# 28 "/usr/local/include/glm/detail/type_vec.hpp" 3
 template <typename T> struct storage<T, 1, true> { struct __attribute__((aligned(1))) type { uint8 data[1]; }; };
 template <typename T> struct storage<T, 2, true> { struct __attribute__((aligned(2))) type { uint8 data[2]; }; };
 template <typename T> struct storage<T, 4, true> { struct __attribute__((aligned(4))) type { uint8 data[4]; }; };
 template <typename T> struct storage<T, 8, true> { struct __attribute__((aligned(8))) type { uint8 data[8]; }; };
 template <typename T> struct storage<T, 16, true> { struct __attribute__((aligned(16))) type { uint8 data[16]; }; };
 template <typename T> struct storage<T, 32, true> { struct __attribute__((aligned(32))) type { uint8 data[32]; }; };
 template <typename T> struct storage<T, 64, true> { struct __attribute__((aligned(64))) type { uint8 data[64]; }; };


  template <>
  struct storage<float, 16, true>
  {
   typedef glm_vec4 type;
  };

  template <>
  struct storage<int, 16, true>
  {
   typedef glm_ivec4 type;
  };

  template <>
  struct storage<unsigned int, 16, true>
  {
   typedef glm_uvec4 type;
  };
# 102 "/usr/local/include/glm/detail/type_vec.hpp" 3
}

 template <typename T, precision P> struct tvec1;
 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;

 typedef tvec1<float, highp> highp_vec1_t;
 typedef tvec1<float, mediump> mediump_vec1_t;
 typedef tvec1<float, lowp> lowp_vec1_t;
 typedef tvec1<double, highp> highp_dvec1_t;
 typedef tvec1<double, mediump> mediump_dvec1_t;
 typedef tvec1<double, lowp> lowp_dvec1_t;
 typedef tvec1<int, highp> highp_ivec1_t;
 typedef tvec1<int, mediump> mediump_ivec1_t;
 typedef tvec1<int, lowp> lowp_ivec1_t;
 typedef tvec1<uint, highp> highp_uvec1_t;
 typedef tvec1<uint, mediump> mediump_uvec1_t;
 typedef tvec1<uint, lowp> lowp_uvec1_t;
 typedef tvec1<bool, highp> highp_bvec1_t;
 typedef tvec1<bool, mediump> mediump_bvec1_t;
 typedef tvec1<bool, lowp> lowp_bvec1_t;
# 133 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef tvec2<float, highp> highp_vec2;






 typedef tvec2<float, mediump> mediump_vec2;






 typedef tvec2<float, lowp> lowp_vec2;






 typedef tvec2<double, highp> highp_dvec2;






 typedef tvec2<double, mediump> mediump_dvec2;






 typedef tvec2<double, lowp> lowp_dvec2;






 typedef tvec2<int, highp> highp_ivec2;






 typedef tvec2<int, mediump> mediump_ivec2;






 typedef tvec2<int, lowp> lowp_ivec2;






 typedef tvec2<uint, highp> highp_uvec2;






 typedef tvec2<uint, mediump> mediump_uvec2;






 typedef tvec2<uint, lowp> lowp_uvec2;






 typedef tvec2<bool, highp> highp_bvec2;






 typedef tvec2<bool, mediump> mediump_bvec2;






 typedef tvec2<bool, lowp> lowp_bvec2;
# 243 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef tvec3<float, highp> highp_vec3;






 typedef tvec3<float, mediump> mediump_vec3;






 typedef tvec3<float, lowp> lowp_vec3;






 typedef tvec3<double, highp> highp_dvec3;






 typedef tvec3<double, mediump> mediump_dvec3;






 typedef tvec3<double, lowp> lowp_dvec3;






 typedef tvec3<int, highp> highp_ivec3;






 typedef tvec3<int, mediump> mediump_ivec3;






 typedef tvec3<int, lowp> lowp_ivec3;






 typedef tvec3<uint, highp> highp_uvec3;






 typedef tvec3<uint, mediump> mediump_uvec3;






 typedef tvec3<uint, lowp> lowp_uvec3;





 typedef tvec3<bool, highp> highp_bvec3;





 typedef tvec3<bool, mediump> mediump_bvec3;





 typedef tvec3<bool, lowp> lowp_bvec3;
# 349 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef tvec4<float, highp> highp_vec4;





 typedef tvec4<float, mediump> mediump_vec4;





 typedef tvec4<float, lowp> lowp_vec4;





 typedef tvec4<double, highp> highp_dvec4;





 typedef tvec4<double, mediump> mediump_dvec4;





 typedef tvec4<double, lowp> lowp_dvec4;





 typedef tvec4<int, highp> highp_ivec4;





 typedef tvec4<int, mediump> mediump_ivec4;





 typedef tvec4<int, lowp> lowp_ivec4;





 typedef tvec4<uint, highp> highp_uvec4;





 typedef tvec4<uint, mediump> mediump_uvec4;





 typedef tvec4<uint, lowp> lowp_uvec4;





 typedef tvec4<bool, highp> highp_bvec4;





 typedef tvec4<bool, mediump> mediump_bvec4;





 typedef tvec4<bool, lowp> lowp_bvec4;
# 454 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_vec2 vec2;




 typedef highp_vec3 vec3;




 typedef highp_vec4 vec4;
# 481 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_dvec2 dvec2;




 typedef highp_dvec3 dvec3;




 typedef highp_dvec4 dvec4;
# 508 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_ivec2 ivec2;




 typedef highp_ivec3 ivec3;




 typedef highp_ivec4 ivec4;
# 535 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_uvec2 uvec2;




 typedef highp_uvec3 uvec3;




 typedef highp_uvec4 uvec4;
# 562 "/usr/local/include/glm/detail/type_vec.hpp" 3
 typedef highp_bvec2 bvec2;




 typedef highp_bvec3 bvec3;




 typedef highp_bvec4 bvec4;



}
# 8 "/usr/local/include/glm/fwd.hpp" 2 3

# 1 "/usr/local/include/glm/detail/type_mat.hpp" 1 3







namespace glm{
namespace detail
{
 template <typename T, precision P, template <class, precision> class colType, template <class, precision> class rowType>
 struct outerProduct_trait{};
}

 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;
 template <typename T, precision P> struct tmat2x2;
 template <typename T, precision P> struct tmat2x3;
 template <typename T, precision P> struct tmat2x4;
 template <typename T, precision P> struct tmat3x2;
 template <typename T, precision P> struct tmat3x3;
 template <typename T, precision P> struct tmat3x4;
 template <typename T, precision P> struct tmat4x2;
 template <typename T, precision P> struct tmat4x3;
 template <typename T, precision P> struct tmat4x4;

 template <typename T, precision P, template <typename, precision> class matType>
               matType<T, P> inverse(matType<T, P> const & m);
# 39 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x2<float, lowp> lowp_mat2;






 typedef tmat2x2<float, mediump> mediump_mat2;






 typedef tmat2x2<float, highp> highp_mat2;






 typedef tmat2x2<float, lowp> lowp_mat2x2;






 typedef tmat2x2<float, mediump> mediump_mat2x2;






 typedef tmat2x2<float, highp> highp_mat2x2;
# 86 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x3<float, lowp> lowp_mat2x3;






 typedef tmat2x3<float, mediump> mediump_mat2x3;






 typedef tmat2x3<float, highp> highp_mat2x3;
# 112 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x4<float, lowp> lowp_mat2x4;






 typedef tmat2x4<float, mediump> mediump_mat2x4;






 typedef tmat2x4<float, highp> highp_mat2x4;
# 138 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x2<float, lowp> lowp_mat3x2;






 typedef tmat3x2<float, mediump> mediump_mat3x2;






 typedef tmat3x2<float, highp> highp_mat3x2;
# 164 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x3<float, lowp> lowp_mat3;






 typedef tmat3x3<float, mediump> mediump_mat3;






 typedef tmat3x3<float, highp> highp_mat3;






 typedef tmat3x3<float, lowp> lowp_mat3x3;






 typedef tmat3x3<float, mediump> mediump_mat3x3;






 typedef tmat3x3<float, highp> highp_mat3x3;
# 211 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x4<float, lowp> lowp_mat3x4;






 typedef tmat3x4<float, mediump> mediump_mat3x4;






 typedef tmat3x4<float, highp> highp_mat3x4;
# 237 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x2<float, lowp> lowp_mat4x2;






 typedef tmat4x2<float, mediump> mediump_mat4x2;






 typedef tmat4x2<float, highp> highp_mat4x2;
# 263 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x3<float, lowp> lowp_mat4x3;






 typedef tmat4x3<float, mediump> mediump_mat4x3;






 typedef tmat4x3<float, highp> highp_mat4x3;
# 290 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x4<float, lowp> lowp_mat4;






 typedef tmat4x4<float, mediump> mediump_mat4;






 typedef tmat4x4<float, highp> highp_mat4;






 typedef tmat4x4<float, lowp> lowp_mat4x4;






 typedef tmat4x4<float, mediump> mediump_mat4x4;






 typedef tmat4x4<float, highp> highp_mat4x4;
# 359 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef highp_mat2x2 mat2x2;




 typedef highp_mat2x3 mat2x3;




 typedef highp_mat2x4 mat2x4;




 typedef highp_mat3x2 mat3x2;




 typedef highp_mat3x3 mat3x3;




 typedef highp_mat3x4 mat3x4;




 typedef highp_mat4x2 mat4x2;




 typedef highp_mat4x3 mat4x3;




 typedef highp_mat4x4 mat4x4;






 typedef mat2x2 mat2;




 typedef mat3x3 mat3;




 typedef mat4x4 mat4;
# 428 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x2<double, lowp> lowp_dmat2;





 typedef tmat2x2<double, mediump> mediump_dmat2;





 typedef tmat2x2<double, highp> highp_dmat2;





 typedef tmat2x2<double, lowp> lowp_dmat2x2;





 typedef tmat2x2<double, mediump> mediump_dmat2x2;





 typedef tmat2x2<double, highp> highp_dmat2x2;
# 469 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x3<double, lowp> lowp_dmat2x3;





 typedef tmat2x3<double, mediump> mediump_dmat2x3;





 typedef tmat2x3<double, highp> highp_dmat2x3;
# 492 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat2x4<double, lowp> lowp_dmat2x4;





 typedef tmat2x4<double, mediump> mediump_dmat2x4;





 typedef tmat2x4<double, highp> highp_dmat2x4;
# 515 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x2<double, lowp> lowp_dmat3x2;





 typedef tmat3x2<double, mediump> mediump_dmat3x2;





 typedef tmat3x2<double, highp> highp_dmat3x2;
# 538 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x3<float, lowp> lowp_dmat3;





 typedef tmat3x3<double, mediump> mediump_dmat3;





 typedef tmat3x3<double, highp> highp_dmat3;





 typedef tmat3x3<double, lowp> lowp_dmat3x3;





 typedef tmat3x3<double, mediump> mediump_dmat3x3;





 typedef tmat3x3<double, highp> highp_dmat3x3;
# 579 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat3x4<double, lowp> lowp_dmat3x4;





 typedef tmat3x4<double, mediump> mediump_dmat3x4;





 typedef tmat3x4<double, highp> highp_dmat3x4;
# 602 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x2<double, lowp> lowp_dmat4x2;





 typedef tmat4x2<double, mediump> mediump_dmat4x2;





 typedef tmat4x2<double, highp> highp_dmat4x2;
# 625 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x3<double, lowp> lowp_dmat4x3;





 typedef tmat4x3<double, mediump> mediump_dmat4x3;





 typedef tmat4x3<double, highp> highp_dmat4x3;
# 648 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef tmat4x4<double, lowp> lowp_dmat4;





 typedef tmat4x4<double, mediump> mediump_dmat4;





 typedef tmat4x4<double, highp> highp_dmat4;





 typedef tmat4x4<double, lowp> lowp_dmat4x4;





 typedef tmat4x4<double, mediump> mediump_dmat4x4;





 typedef tmat4x4<double, highp> highp_dmat4x4;
# 707 "/usr/local/include/glm/detail/type_mat.hpp" 3
 typedef highp_dmat2x2 dmat2;




 typedef highp_dmat3x3 dmat3;




 typedef highp_dmat4x4 dmat4;




 typedef highp_dmat2x2 dmat2x2;




 typedef highp_dmat2x3 dmat2x3;




 typedef highp_dmat2x4 dmat2x4;




 typedef highp_dmat3x2 dmat3x2;




 typedef highp_dmat3x3 dmat3x3;




 typedef highp_dmat3x4 dmat3x4;




 typedef highp_dmat4x2 dmat4x2;




 typedef highp_dmat4x3 dmat4x3;




 typedef highp_dmat4x4 dmat4x4;




}
# 9 "/usr/local/include/glm/fwd.hpp" 2 3




namespace glm
{
 template <typename T, precision P> struct tquat;




 typedef tquat<float, lowp> lowp_quat;




 typedef tquat<float, mediump> mediump_quat;




 typedef tquat<float, highp> highp_quat;
# 40 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_quat quat;





 typedef lowp_quat lowp_fquat;




 typedef mediump_quat mediump_fquat;




 typedef highp_quat highp_fquat;




 typedef quat fquat;





 typedef tquat<double, lowp> lowp_dquat;




 typedef tquat<double, mediump> mediump_dquat;




 typedef tquat<double, highp> highp_dquat;
# 89 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_dquat dquat;


}



namespace glm
{


 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;




 typedef detail::int8 int8;



 typedef detail::int16 int16;



 typedef detail::int32 int32;



 typedef detail::int64 int64;
# 268 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::int8 int8_t;



 typedef detail::int16 int16_t;



 typedef detail::int32 int32_t;



 typedef detail::int64 int64_t;




 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;





 typedef tvec1<i8, lowp> lowp_i8vec1;



 typedef tvec2<i8, lowp> lowp_i8vec2;



 typedef tvec3<i8, lowp> lowp_i8vec3;



 typedef tvec4<i8, lowp> lowp_i8vec4;




 typedef tvec1<i8, mediump> mediump_i8vec1;



 typedef tvec2<i8, mediump> mediump_i8vec2;



 typedef tvec3<i8, mediump> mediump_i8vec3;



 typedef tvec4<i8, mediump> mediump_i8vec4;




 typedef tvec1<i8, highp> highp_i8vec1;



 typedef tvec2<i8, highp> highp_i8vec2;



 typedef tvec3<i8, highp> highp_i8vec3;



 typedef tvec4<i8, highp> highp_i8vec4;
# 364 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i8vec1 i8vec1;



 typedef highp_i8vec2 i8vec2;



 typedef highp_i8vec3 i8vec3;



 typedef highp_i8vec4 i8vec4;





 typedef tvec1<i16, lowp> lowp_i16vec1;



 typedef tvec2<i16, lowp> lowp_i16vec2;



 typedef tvec3<i16, lowp> lowp_i16vec3;



 typedef tvec4<i16, lowp> lowp_i16vec4;




 typedef tvec1<i16, mediump> mediump_i16vec1;



 typedef tvec2<i16, mediump> mediump_i16vec2;



 typedef tvec3<i16, mediump> mediump_i16vec3;



 typedef tvec4<i16, mediump> mediump_i16vec4;




 typedef tvec1<i16, highp> highp_i16vec1;



 typedef tvec2<i16, highp> highp_i16vec2;



 typedef tvec3<i16, highp> highp_i16vec3;



 typedef tvec4<i16, highp> highp_i16vec4;
# 444 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i16vec1 i16vec1;



 typedef highp_i16vec2 i16vec2;



 typedef highp_i16vec3 i16vec3;



 typedef highp_i16vec4 i16vec4;





 typedef tvec1<i32, lowp> lowp_i32vec1;



 typedef tvec2<i32, lowp> lowp_i32vec2;



 typedef tvec3<i32, lowp> lowp_i32vec3;



 typedef tvec4<i32, lowp> lowp_i32vec4;




 typedef tvec1<i32, mediump> mediump_i32vec1;



 typedef tvec2<i32, mediump> mediump_i32vec2;



 typedef tvec3<i32, mediump> mediump_i32vec3;



 typedef tvec4<i32, mediump> mediump_i32vec4;




 typedef tvec1<i32, highp> highp_i32vec1;



 typedef tvec2<i32, highp> highp_i32vec2;



 typedef tvec3<i32, highp> highp_i32vec3;



 typedef tvec4<i32, highp> highp_i32vec4;
# 523 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;





 typedef tvec1<i32, lowp> lowp_i32vec1;



 typedef tvec2<i32, lowp> lowp_i32vec2;



 typedef tvec3<i32, lowp> lowp_i32vec3;



 typedef tvec4<i32, lowp> lowp_i32vec4;




 typedef tvec1<i32, mediump> mediump_i32vec1;



 typedef tvec2<i32, mediump> mediump_i32vec2;



 typedef tvec3<i32, mediump> mediump_i32vec3;



 typedef tvec4<i32, mediump> mediump_i32vec4;




 typedef tvec1<i32, highp> highp_i32vec1;



 typedef tvec2<i32, highp> highp_i32vec2;



 typedef tvec3<i32, highp> highp_i32vec3;



 typedef tvec4<i32, highp> highp_i32vec4;
# 602 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;






 typedef tvec1<i64, lowp> lowp_i64vec1;



 typedef tvec2<i64, lowp> lowp_i64vec2;



 typedef tvec3<i64, lowp> lowp_i64vec3;



 typedef tvec4<i64, lowp> lowp_i64vec4;




 typedef tvec1<i64, mediump> mediump_i64vec1;



 typedef tvec2<i64, mediump> mediump_i64vec2;



 typedef tvec3<i64, mediump> mediump_i64vec3;



 typedef tvec4<i64, mediump> mediump_i64vec4;




 typedef tvec1<i64, highp> highp_i64vec1;



 typedef tvec2<i64, highp> highp_i64vec2;



 typedef tvec3<i64, highp> highp_i64vec3;



 typedef tvec4<i64, highp> highp_i64vec4;
# 682 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_i64vec1 i64vec1;



 typedef highp_i64vec2 i64vec2;



 typedef highp_i64vec3 i64vec3;



 typedef highp_i64vec4 i64vec4;
# 703 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;




 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;




 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;





 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;





 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;





 typedef detail::uint8 uint8;



 typedef detail::uint16 uint16;



 typedef detail::uint32 uint32;



 typedef detail::uint64 uint64;
# 877 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::uint8 uint8_t;



 typedef detail::uint16 uint16_t;



 typedef detail::uint32 uint32_t;



 typedef detail::uint64 uint64_t;




 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;





 typedef tvec1<u8, lowp> lowp_u8vec1;



 typedef tvec2<u8, lowp> lowp_u8vec2;



 typedef tvec3<u8, lowp> lowp_u8vec3;



 typedef tvec4<u8, lowp> lowp_u8vec4;




 typedef tvec1<u8, mediump> mediump_u8vec1;



 typedef tvec2<u8, mediump> mediump_u8vec2;



 typedef tvec3<u8, mediump> mediump_u8vec3;



 typedef tvec4<u8, mediump> mediump_u8vec4;




 typedef tvec1<u8, highp> highp_u8vec1;



 typedef tvec2<u8, highp> highp_u8vec2;



 typedef tvec3<u8, highp> highp_u8vec3;



 typedef tvec4<u8, highp> highp_u8vec4;
# 973 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u8vec1 u8vec1;



 typedef highp_u8vec2 u8vec2;



 typedef highp_u8vec3 u8vec3;



 typedef highp_u8vec4 u8vec4;





 typedef tvec1<u16, lowp> lowp_u16vec1;



 typedef tvec2<u16, lowp> lowp_u16vec2;



 typedef tvec3<u16, lowp> lowp_u16vec3;



 typedef tvec4<u16, lowp> lowp_u16vec4;




 typedef tvec1<u16, mediump> mediump_u16vec1;



 typedef tvec2<u16, mediump> mediump_u16vec2;



 typedef tvec3<u16, mediump> mediump_u16vec3;



 typedef tvec4<u16, mediump> mediump_u16vec4;




 typedef tvec1<u16, highp> highp_u16vec1;



 typedef tvec2<u16, highp> highp_u16vec2;



 typedef tvec3<u16, highp> highp_u16vec3;



 typedef tvec4<u16, highp> highp_u16vec4;
# 1053 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u16vec1 u16vec1;



 typedef highp_u16vec2 u16vec2;



 typedef highp_u16vec3 u16vec3;



 typedef highp_u16vec4 u16vec4;





 typedef tvec1<u32, lowp> lowp_u32vec1;



 typedef tvec2<u32, lowp> lowp_u32vec2;



 typedef tvec3<u32, lowp> lowp_u32vec3;



 typedef tvec4<u32, lowp> lowp_u32vec4;




 typedef tvec1<u32, mediump> mediump_u32vec1;



 typedef tvec2<u32, mediump> mediump_u32vec2;



 typedef tvec3<u32, mediump> mediump_u32vec3;



 typedef tvec4<u32, mediump> mediump_u32vec4;




 typedef tvec1<u32, highp> highp_u32vec1;



 typedef tvec2<u32, highp> highp_u32vec2;



 typedef tvec3<u32, highp> highp_u32vec3;



 typedef tvec4<u32, highp> highp_u32vec4;
# 1132 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;





 typedef tvec1<u32, lowp> lowp_u32vec1;



 typedef tvec2<u32, lowp> lowp_u32vec2;



 typedef tvec3<u32, lowp> lowp_u32vec3;



 typedef tvec4<u32, lowp> lowp_u32vec4;




 typedef tvec1<u32, mediump> mediump_u32vec1;



 typedef tvec2<u32, mediump> mediump_u32vec2;



 typedef tvec3<u32, mediump> mediump_u32vec3;



 typedef tvec4<u32, mediump> mediump_u32vec4;




 typedef tvec1<u32, highp> highp_u32vec1;



 typedef tvec2<u32, highp> highp_u32vec2;



 typedef tvec3<u32, highp> highp_u32vec3;



 typedef tvec4<u32, highp> highp_u32vec4;
# 1211 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;






 typedef tvec1<u64, lowp> lowp_u64vec1;



 typedef tvec2<u64, lowp> lowp_u64vec2;



 typedef tvec3<u64, lowp> lowp_u64vec3;



 typedef tvec4<u64, lowp> lowp_u64vec4;




 typedef tvec1<u64, mediump> mediump_u64vec1;



 typedef tvec2<u64, mediump> mediump_u64vec2;



 typedef tvec3<u64, mediump> mediump_u64vec3;



 typedef tvec4<u64, mediump> mediump_u64vec4;




 typedef tvec1<u64, highp> highp_u64vec1;



 typedef tvec2<u64, highp> highp_u64vec2;



 typedef tvec3<u64, highp> highp_u64vec3;



 typedef tvec4<u64, highp> highp_u64vec4;
# 1291 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_u64vec1 u64vec1;



 typedef highp_u64vec2 u64vec2;



 typedef highp_u64vec3 u64vec3;



 typedef highp_u64vec4 u64vec4;
# 1312 "/usr/local/include/glm/fwd.hpp" 3
 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;



 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 mediump_float32;



 typedef detail::float64 mediump_float64;



 typedef detail::float32 mediump_float32_t;



 typedef detail::float64 mediump_float64_t;



 typedef float32 mediump_f32;



 typedef float64 mediump_f64;




 typedef detail::float32 highp_float32;



 typedef detail::float64 highp_float64;



 typedef detail::float32 highp_float32_t;



 typedef detail::float64 highp_float64_t;



 typedef float32 highp_f32;



 typedef float64 highp_f64;
# 1489 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_float32 float32;



 typedef highp_float64 float64;



 typedef highp_float32_t float32_t;



 typedef highp_float64_t float64_t;



 typedef highp_float32_t f32;



 typedef highp_float64_t f64;





 typedef tvec1<float, lowp> lowp_vec1;



 typedef tvec2<float, lowp> lowp_vec2;



 typedef tvec3<float, lowp> lowp_vec3;



 typedef tvec4<float, lowp> lowp_vec4;



 typedef tvec1<float, lowp> lowp_fvec1;



 typedef tvec2<float, lowp> lowp_fvec2;



 typedef tvec3<float, lowp> lowp_fvec3;



 typedef tvec4<float, lowp> lowp_fvec4;




 typedef tvec1<float, mediump> mediump_vec1;



 typedef tvec2<float, mediump> mediump_vec2;



 typedef tvec3<float, mediump> mediump_vec3;



 typedef tvec4<float, mediump> mediump_vec4;



 typedef tvec1<float, mediump> mediump_fvec1;



 typedef tvec2<float, mediump> mediump_fvec2;



 typedef tvec3<float, mediump> mediump_fvec3;



 typedef tvec4<float, mediump> mediump_fvec4;




 typedef tvec1<float, highp> highp_vec1;



 typedef tvec2<float, highp> highp_vec2;



 typedef tvec3<float, highp> highp_vec3;



 typedef tvec4<float, highp> highp_vec4;



 typedef tvec1<float, highp> highp_fvec1;



 typedef tvec2<float, highp> highp_fvec2;



 typedef tvec3<float, highp> highp_fvec3;



 typedef tvec4<float, highp> highp_fvec4;




 typedef tvec1<f32, lowp> lowp_f32vec1;



 typedef tvec2<f32, lowp> lowp_f32vec2;



 typedef tvec3<f32, lowp> lowp_f32vec3;



 typedef tvec4<f32, lowp> lowp_f32vec4;



 typedef tvec1<f32, mediump> mediump_f32vec1;



 typedef tvec2<f32, mediump> mediump_f32vec2;



 typedef tvec3<f32, mediump> mediump_f32vec3;



 typedef tvec4<f32, mediump> mediump_f32vec4;



 typedef tvec1<f32, highp> highp_f32vec1;



 typedef tvec2<f32, highp> highp_f32vec2;



 typedef tvec3<f32, highp> highp_f32vec3;



 typedef tvec4<f32, highp> highp_f32vec4;




 typedef tvec1<f64, lowp> lowp_f64vec1;



 typedef tvec2<f64, lowp> lowp_f64vec2;



 typedef tvec3<f64, lowp> lowp_f64vec3;



 typedef tvec4<f64, lowp> lowp_f64vec4;



 typedef tvec1<f64, mediump> mediump_f64vec1;



 typedef tvec2<f64, mediump> mediump_f64vec2;



 typedef tvec3<f64, mediump> mediump_f64vec3;



 typedef tvec4<f64, mediump> mediump_f64vec4;



 typedef tvec1<f64, highp> highp_f64vec1;



 typedef tvec2<f64, highp> highp_f64vec2;



 typedef tvec3<f64, highp> highp_f64vec3;



 typedef tvec4<f64, highp> highp_f64vec4;
# 1719 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, lowp> lowp_fmat2x2;



 typedef tmat2x3<f32, lowp> lowp_fmat2x3;



 typedef tmat2x4<f32, lowp> lowp_fmat2x4;



 typedef tmat3x2<f32, lowp> lowp_fmat3x2;



 typedef tmat3x3<f32, lowp> lowp_fmat3x3;



 typedef tmat3x4<f32, lowp> lowp_fmat3x4;



 typedef tmat4x2<f32, lowp> lowp_fmat4x2;



 typedef tmat4x3<f32, lowp> lowp_fmat4x3;



 typedef tmat4x4<f32, lowp> lowp_fmat4x4;







 typedef lowp_fmat2x2 lowp_fmat2;



 typedef lowp_fmat3x3 lowp_fmat3;



 typedef lowp_fmat4x4 lowp_fmat4;
# 1776 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, mediump> mediump_fmat2x2;



 typedef tmat2x3<f32, mediump> mediump_fmat2x3;



 typedef tmat2x4<f32, mediump> mediump_fmat2x4;



 typedef tmat3x2<f32, mediump> mediump_fmat3x2;



 typedef tmat3x3<f32, mediump> mediump_fmat3x3;



 typedef tmat3x4<f32, mediump> mediump_fmat3x4;



 typedef tmat4x2<f32, mediump> mediump_fmat4x2;



 typedef tmat4x3<f32, mediump> mediump_fmat4x3;



 typedef tmat4x4<f32, mediump> mediump_fmat4x4;







 typedef mediump_fmat2x2 mediump_fmat2;



 typedef mediump_fmat3x3 mediump_fmat3;



 typedef mediump_fmat4x4 mediump_fmat4;
# 1833 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, highp> highp_fmat2x2;



 typedef tmat2x3<f32, highp> highp_fmat2x3;



 typedef tmat2x4<f32, highp> highp_fmat2x4;



 typedef tmat3x2<f32, highp> highp_fmat3x2;



 typedef tmat3x3<f32, highp> highp_fmat3x3;



 typedef tmat3x4<f32, highp> highp_fmat3x4;



 typedef tmat4x2<f32, highp> highp_fmat4x2;



 typedef tmat4x3<f32, highp> highp_fmat4x3;



 typedef tmat4x4<f32, highp> highp_fmat4x4;







 typedef highp_fmat2x2 highp_fmat2;



 typedef highp_fmat3x3 highp_fmat3;



 typedef highp_fmat4x4 highp_fmat4;
# 1890 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, lowp> lowp_f32mat2x2;



 typedef tmat2x3<f32, lowp> lowp_f32mat2x3;



 typedef tmat2x4<f32, lowp> lowp_f32mat2x4;



 typedef tmat3x2<f32, lowp> lowp_f32mat3x2;



 typedef tmat3x3<f32, lowp> lowp_f32mat3x3;



 typedef tmat3x4<f32, lowp> lowp_f32mat3x4;



 typedef tmat4x2<f32, lowp> lowp_f32mat4x2;



 typedef tmat4x3<f32, lowp> lowp_f32mat4x3;



 typedef tmat4x4<f32, lowp> lowp_f32mat4x4;







 typedef lowp_f32mat2x2 lowp_f32mat2;



 typedef lowp_f32mat3x3 lowp_f32mat3;



 typedef lowp_f32mat4x4 lowp_f32mat4;
# 1947 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, mediump> mediump_f32mat2x2;



 typedef tmat2x3<f32, mediump> mediump_f32mat2x3;



 typedef tmat2x4<f32, mediump> mediump_f32mat2x4;



 typedef tmat3x2<f32, mediump> mediump_f32mat3x2;



 typedef tmat3x3<f32, mediump> mediump_f32mat3x3;



 typedef tmat3x4<f32, mediump> mediump_f32mat3x4;



 typedef tmat4x2<f32, mediump> mediump_f32mat4x2;



 typedef tmat4x3<f32, mediump> mediump_f32mat4x3;



 typedef tmat4x4<f32, mediump> mediump_f32mat4x4;







 typedef mediump_f32mat2x2 mediump_f32mat2;



 typedef mediump_f32mat3x3 mediump_f32mat3;



 typedef mediump_f32mat4x4 mediump_f32mat4;
# 2004 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f32, highp> highp_f32mat2x2;



 typedef tmat2x3<f32, highp> highp_f32mat2x3;



 typedef tmat2x4<f32, highp> highp_f32mat2x4;



 typedef tmat3x2<f32, highp> highp_f32mat3x2;



 typedef tmat3x3<f32, highp> highp_f32mat3x3;



 typedef tmat3x4<f32, highp> highp_f32mat3x4;



 typedef tmat4x2<f32, highp> highp_f32mat4x2;



 typedef tmat4x3<f32, highp> highp_f32mat4x3;



 typedef tmat4x4<f32, highp> highp_f32mat4x4;







 typedef highp_f32mat2x2 highp_f32mat2;



 typedef highp_f32mat3x3 highp_f32mat3;



 typedef highp_f32mat4x4 highp_f32mat4;
# 2061 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f64, lowp> lowp_f64mat2x2;



 typedef tmat2x3<f64, lowp> lowp_f64mat2x3;



 typedef tmat2x4<f64, lowp> lowp_f64mat2x4;



 typedef tmat3x2<f64, lowp> lowp_f64mat3x2;



 typedef tmat3x3<f64, lowp> lowp_f64mat3x3;



 typedef tmat3x4<f64, lowp> lowp_f64mat3x4;



 typedef tmat4x2<f64, lowp> lowp_f64mat4x2;



 typedef tmat4x3<f64, lowp> lowp_f64mat4x3;



 typedef tmat4x4<f64, lowp> lowp_f64mat4x4;







 typedef lowp_f64mat2x2 lowp_f64mat2;



 typedef lowp_f64mat3x3 lowp_f64mat3;



 typedef lowp_f64mat4x4 lowp_f64mat4;
# 2118 "/usr/local/include/glm/fwd.hpp" 3
 typedef tmat2x2<f64, mediump> mediump_f64mat2x2;



 typedef tmat2x3<f64, mediump> mediump_f64mat2x3;



 typedef tmat2x4<f64, mediump> mediump_f64mat2x4;



 typedef tmat3x2<f64, mediump> mediump_f64mat3x2;



 typedef tmat3x3<f64, mediump> mediump_f64mat3x3;



 typedef tmat3x4<f64, mediump> mediump_f64mat3x4;



 typedef tmat4x2<f64, mediump> mediump_f64mat4x2;



 typedef tmat4x3<f64, mediump> mediump_f64mat4x3;



 typedef tmat4x4<f64, mediump> mediump_f64mat4x4;







 typedef mediump_f64mat2x2 mediump_f64mat2;



 typedef mediump_f64mat3x3 mediump_f64mat3;



 typedef mediump_f64mat4x4 mediump_f64mat4;







 typedef tmat2x2<f64, highp> highp_f64mat2x2;



 typedef tmat2x3<f64, highp> highp_f64mat2x3;



 typedef tmat2x4<f64, highp> highp_f64mat2x4;



 typedef tmat3x2<f64, highp> highp_f64mat3x2;



 typedef tmat3x3<f64, highp> highp_f64mat3x3;



 typedef tmat3x4<f64, highp> highp_f64mat3x4;



 typedef tmat4x2<f64, highp> highp_f64mat4x2;



 typedef tmat4x3<f64, highp> highp_f64mat4x3;



 typedef tmat4x4<f64, highp> highp_f64mat4x4;







 typedef highp_f64mat2x2 highp_f64mat2;



 typedef highp_f64mat3x3 highp_f64mat3;



 typedef highp_f64mat4x4 highp_f64mat4;






 typedef tquat<f32, lowp> lowp_f32quat;



 typedef tquat<f64, lowp> lowp_f64quat;



 typedef tquat<f32, mediump> mediump_f32quat;



 typedef tquat<f64, mediump> mediump_f64quat;



 typedef tquat<f32, highp> highp_f32quat;



 typedef tquat<f64, highp> highp_f64quat;
# 2327 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_f32vec1 fvec1;



 typedef highp_f32vec2 fvec2;



 typedef highp_f32vec3 fvec3;



 typedef highp_f32vec4 fvec4;



 typedef highp_f32mat2x2 fmat2x2;



 typedef highp_f32mat2x3 fmat2x3;



 typedef highp_f32mat2x4 fmat2x4;



 typedef highp_f32mat3x2 fmat3x2;



 typedef highp_f32mat3x3 fmat3x3;



 typedef highp_f32mat3x4 fmat3x4;



 typedef highp_f32mat4x2 fmat4x2;



 typedef highp_f32mat4x3 fmat4x3;



 typedef highp_f32mat4x4 fmat4x4;



 typedef fmat2x2 fmat2;



 typedef fmat3x3 fmat3;



 typedef fmat4x4 fmat4;



 typedef highp_fquat fquat;





 typedef highp_f32vec1 f32vec1;



 typedef highp_f32vec2 f32vec2;



 typedef highp_f32vec3 f32vec3;



 typedef highp_f32vec4 f32vec4;



 typedef highp_f32mat2x2 f32mat2x2;



 typedef highp_f32mat2x3 f32mat2x3;



 typedef highp_f32mat2x4 f32mat2x4;



 typedef highp_f32mat3x2 f32mat3x2;



 typedef highp_f32mat3x3 f32mat3x3;



 typedef highp_f32mat3x4 f32mat3x4;



 typedef highp_f32mat4x2 f32mat4x2;



 typedef highp_f32mat4x3 f32mat4x3;



 typedef highp_f32mat4x4 f32mat4x4;



 typedef f32mat2x2 f32mat2;



 typedef f32mat3x3 f32mat3;



 typedef f32mat4x4 f32mat4;



 typedef highp_f32quat f32quat;
# 2503 "/usr/local/include/glm/fwd.hpp" 3
 typedef highp_f64vec1 f64vec1;



 typedef highp_f64vec2 f64vec2;



 typedef highp_f64vec3 f64vec3;



 typedef highp_f64vec4 f64vec4;



 typedef highp_f64mat2x2 f64mat2x2;



 typedef highp_f64mat2x3 f64mat2x3;



 typedef highp_f64mat2x4 f64mat2x4;



 typedef highp_f64mat3x2 f64mat3x2;



 typedef highp_f64mat3x3 f64mat3x3;



 typedef highp_f64mat3x4 f64mat3x4;



 typedef highp_f64mat4x2 f64mat4x2;



 typedef highp_f64mat4x3 f64mat4x3;



 typedef highp_f64mat4x4 f64mat4x4;



 typedef f64mat2x2 f64mat2;



 typedef f64mat3x3 f64mat3;



 typedef f64mat4x4 f64mat4;



 typedef highp_f64quat f64quat;


}
# 61 "/usr/local/include/glm/glm.hpp" 2 3







# 1 "/usr/local/include/glm/vec2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_vec2.hpp" 1 3
# 16 "/usr/local/include/glm/detail/type_vec2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec2
 {


  typedef T value_type;
  typedef tvec2<T, P> type;
  typedef tvec2<bool, P> bool_type;
# 70 "/usr/local/include/glm/detail/type_vec2.hpp" 3
   union {T x, r, s;};
   union {T y, g, t;};
# 81 "/usr/local/include/glm/detail/type_vec2.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 2;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec2() ;
                                   tvec2(tvec2<T, P> const& v) ;
  template <precision Q>
                                   tvec2(tvec2<T, Q> const& v);



                                   explicit tvec2(ctor);
                                   explicit tvec2(T scalar);
                                   tvec2(T s1, T s2);




  template <typename A, typename B>
                                   tvec2(A x, B y);
  template <typename A, typename B>
                                   tvec2(tvec1<A, P> const & v1, tvec1<B, P> const & v2);




  template <typename U, precision Q>
                                                tvec2(tvec3<U, Q> const & v);

  template <typename U, precision Q>
                                                tvec2(tvec4<U, Q> const & v);


  template <typename U, precision Q>
                                                tvec2(tvec2<U, Q> const & v);
# 132 "/usr/local/include/glm/detail/type_vec2.hpp" 3
                tvec2<T, P>& operator=(tvec2<T, P> const & v) ;

  template <typename U>
                tvec2<T, P>& operator=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator+=(U scalar);
  template <typename U>
                tvec2<T, P>& operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator+=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator-=(U scalar);
  template <typename U>
                tvec2<T, P>& operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator-=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator*=(U scalar);
  template <typename U>
                tvec2<T, P>& operator*=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator*=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator/=(U scalar);
  template <typename U>
                tvec2<T, P>& operator/=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P>& operator/=(tvec2<U, P> const & v);



                tvec2<T, P> & operator++();
                tvec2<T, P> & operator--();
                tvec2<T, P> operator++(int);
                tvec2<T, P> operator--(int);



  template <typename U>
                tvec2<T, P> & operator%=(U scalar);
  template <typename U>
                tvec2<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator%=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator&=(U scalar);
  template <typename U>
                tvec2<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator&=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator|=(U scalar);
  template <typename U>
                tvec2<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator|=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator^=(U scalar);
  template <typename U>
                tvec2<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator^=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec2<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator<<=(tvec2<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec2<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
                tvec2<T, P> & operator>>=(tvec2<U, P> const & v);
 };



 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v);



 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator+(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator-(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator*(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator/(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator%(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator&(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator|(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator^(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator<<(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec2<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator>>(T scalar, tvec2<T, P> const & v);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               tvec2<T, P> operator~(tvec2<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <precision P>
               tvec2<bool, P> operator&&(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2);

 template <precision P>
               tvec2<bool, P> operator||(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec2.inl" 1 3



namespace glm
{
# 22 "/usr/local/include/glm/detail/type_vec2.inl" 3
  template <typename T, precision P> inline
                                        tvec2<T, P>::tvec2()

    : x(0), y(0)

  {}



  template <typename T, precision P> inline
                                        tvec2<T, P>::tvec2(tvec2<T, P> const & v)
   : x(v.x), y(v.y)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec2<T, P>::tvec2(tvec2<T, Q> const & v)
  : x(v.x), y(v.y)
 {}



 template <typename T, precision P> inline
                                       tvec2<T, P>::tvec2(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec2<T, P>::tvec2(T scalar)
  : x(scalar), y(scalar)
 {}

 template <typename T, precision P> inline
                                       tvec2<T, P>::tvec2(T s1, T s2)
  : x(s1), y(s2)
 {}



 template <typename T, precision P>
 template <typename A, typename B> inline
                                       tvec2<T, P>::tvec2(A a, B b)
  : x(static_cast<T>(a))
  , y(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B> inline
                                       tvec2<T, P>::tvec2(tvec1<A, P> const & a, tvec1<B, P> const & b)
  : x(static_cast<T>(a.x))
  , y(static_cast<T>(b.x))
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec2<T, P>::tvec2(tvec2<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec2<T, P>::tvec2(tvec3<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec2<T, P>::tvec2(tvec4<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template <typename T, precision P> inline
                    T & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec2.inl", 103, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec2.inl", 110, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec2<T, P> & tvec2<T, P>::operator=(tvec2<T, P> const & v)
  {
   this->x = v.x;
   this->y = v.y;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec2<T, P> & tvec2<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> & tvec2<T, P>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> tvec2<T, P>::operator++(int)
 {
  tvec2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> tvec2<T, P>::operator--(int)
 {
  tvec2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   -v.x,
   -v.y);
 }



 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x + scalar,
   v.y + scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar + v.x,
   scalar + v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x - scalar,
   v.y - scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar - v.x,
   scalar - v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x * scalar,
   v.y * scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar * v.x,
   scalar * v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x / scalar,
   v.y / scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar / v.x,
   scalar / v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x % scalar,
   v.y % scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar % v.x,
   scalar % v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x & scalar,
   v.y & scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar & v.x,
   scalar & v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x | scalar,
   v.y | scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar | v.x,
   scalar | v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x << scalar,
   v.y << scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar << v.x,
   scalar << v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec2<T, P> const & v, T scalar)
 {
  return tvec2<T, P>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(T scalar, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> operator~(tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   ~v.x,
   ~v.y);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return (v1.x == v2.x) && (v1.y == v2.y);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return (v1.x != v2.x) || (v1.y != v2.y);
 }

 template <precision P> inline
                    tvec2<bool, P> operator&&(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)
 {
  return tvec2<bool, P>(v1.x && v2.x, v1.y && v2.y);
 }

 template <precision P> inline
                    tvec2<bool, P> operator||(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)
 {
  return tvec2<bool, P>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 387 "/usr/local/include/glm/detail/type_vec2.hpp" 2 3
# 6 "/usr/local/include/glm/vec2.hpp" 2 3
# 68 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/vec3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_vec3.hpp" 1 3
# 16 "/usr/local/include/glm/detail/type_vec3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec3
 {


  typedef T value_type;
  typedef tvec3<T, P> type;
  typedef tvec3<bool, P> bool_type;
# 69 "/usr/local/include/glm/detail/type_vec3.hpp" 3
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 81 "/usr/local/include/glm/detail/type_vec3.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 3;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec3() ;
                                   tvec3(tvec3<T, P> const & v) ;
  template <precision Q>
                                   tvec3(tvec3<T, Q> const & v);



                                   explicit tvec3(ctor);
                                   explicit tvec3(T scalar);
                                   tvec3(T a, T b, T c);




  template <typename A, typename B, typename C>
                                   tvec3(A a, B b, C c);
  template <typename A, typename B, typename C>
                                   tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c);




  template <typename A, typename B, precision Q>
                                   tvec3(tvec2<A, Q> const & a, B b);

  template <typename A, typename B, precision Q>
                                   tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec3(A a, tvec2<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b);

  template <typename U, precision Q>
                                                tvec3(tvec4<U, Q> const & v);


  template <typename U, precision Q>
                                                tvec3(tvec3<U, Q> const & v);
# 153 "/usr/local/include/glm/detail/type_vec3.hpp" 3
                tvec3<T, P> & operator=(tvec3<T, P> const & v) ;

  template <typename U>
                tvec3<T, P> & operator=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator+=(U scalar);
  template <typename U>
                tvec3<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator+=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator-=(U scalar);
  template <typename U>
                tvec3<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator-=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator*=(U scalar);
  template <typename U>
                tvec3<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator*=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator/=(U scalar);
  template <typename U>
                tvec3<T, P> & operator/=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator/=(tvec3<U, P> const & v);



                tvec3<T, P> & operator++();
                tvec3<T, P> & operator--();
                tvec3<T, P> operator++(int);
                tvec3<T, P> operator--(int);



  template <typename U>
                tvec3<T, P> & operator%=(U scalar);
  template <typename U>
                tvec3<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator%=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator&=(U scalar);
  template <typename U>
                tvec3<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator&=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator|=(U scalar);
  template <typename U>
                tvec3<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator|=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator^=(U scalar);
  template <typename U>
                tvec3<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator^=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec3<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator<<=(tvec3<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec3<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
                tvec3<T, P> & operator>>=(tvec3<U, P> const & v);
 };



 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v);



 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator+(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator%(T const & scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec3<T, P> const & v1, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec1<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               tvec3<T, P> operator~(tvec3<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <precision P>
               tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);

 template <precision P>
               tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec3.inl" 1 3



namespace glm
{
# 35 "/usr/local/include/glm/detail/type_vec3.inl" 3
  template <typename T, precision P> inline
                                        tvec3<T, P>::tvec3()

    : x(0), y(0), z(0)

  {}



  template <typename T, precision P> inline
                                        tvec3<T, P>::tvec3(tvec3<T, P> const & v)
   : x(v.x), y(v.y), z(v.z)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec3<T, P>::tvec3(tvec3<T, Q> const & v)
  : x(v.x), y(v.y), z(v.z)
 {}



 template <typename T, precision P> inline
                                       tvec3<T, P>::tvec3(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec3<T, P>::tvec3(T scalar)
  : x(scalar), y(scalar), z(scalar)
 {}

 template <typename T, precision P> inline
                                       tvec3<T, P>::tvec3(T a, T b, T c)
  : x(a), y(b), z(c)
 {}



 template <typename T, precision P>
 template <typename A, typename B, typename C> inline
                                       tvec3<T, P>::tvec3(A a, B b, C c) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C> inline
                                       tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c))
 {}



 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(A a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}



 template <typename T, precision P> inline
                    T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec3.inl", 145, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec3.inl", 152, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> const & v)
  {
   this->x = v.x;
   this->y = v.y;
   this->z = v.z;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  this->z *= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator/=(U v)
 {
  this->x /= static_cast<T>(v);
  this->y /= static_cast<T>(v);
  this->z /= static_cast<T>(v);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec3<T, P> & tvec3<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> & tvec3<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> tvec3<T, P>::operator++(int)
 {
  tvec3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> tvec3<T, P>::operator--(int)
 {
  tvec3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)
 {
  this->x %= scalar;
  this->y %= scalar;
  this->z %= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)
 {
  this->x &= scalar;
  this->y &= scalar;
  this->z &= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)
 {
  this->x |= scalar;
  this->y |= scalar;
  this->z |= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)
 {
  this->x ^= scalar;
  this->y ^= scalar;
  this->z ^= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)
 {
  this->x <<= scalar;
  this->y <<= scalar;
  this->z <<= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   -v.x,
   -v.y,
   -v.z);
 }



 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x + scalar.x,
   v.y + scalar.x,
   v.z + scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x + v.x,
   scalar.x + v.y,
   scalar.x + v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x - scalar.x,
   v.y - scalar.x,
   v.z - scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x - v.x,
   scalar.x - v.y,
   scalar.x - v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x * scalar.x,
   v.y * scalar.x,
   v.z * scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x * v.x,
   scalar.x * v.y,
   scalar.x * v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x / scalar.x,
   v.y / scalar.x,
   v.z / scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x / v.x,
   scalar.x / v.y,
   scalar.x / v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }



 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x % scalar,
   v.y % scalar,
   v.z % scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x % scalar.x,
   v.y % scalar.x,
   v.z % scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar % v.x,
   scalar % v.y,
   scalar % v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x % v.x,
   scalar.x % v.y,
   scalar.x % v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x & scalar,
   v.y & scalar,
   v.z & scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x & scalar.x,
   v.y & scalar.x,
   v.z & scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar & v.x,
   scalar & v.y,
   scalar & v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x & v.x,
   scalar.x & v.y,
   scalar.x & v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x | scalar,
   v.y | scalar,
   v.z | scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x | scalar.x,
   v.y | scalar.x,
   v.z | scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar | v.x,
   scalar | v.y,
   scalar | v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x | v.x,
   scalar.x | v.y,
   scalar.x | v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x ^ scalar,
   v.y ^ scalar,
   v.z ^ scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x ^ scalar.x,
   v.y ^ scalar.x,
   v.z ^ scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x ^ v.x,
   scalar.x ^ v.y,
   scalar.x ^ v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x << scalar.x,
   v.y << scalar.x,
   v.z << scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x << v.x,
   scalar.x << v.y,
   scalar.x << v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar)
 {
  return tvec3<T, P>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec3<T, P>(
   v.x >> scalar.x,
   v.y >> scalar.x,
   v.z >> scalar.x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec1<T, P> const & scalar, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   scalar.x >> v.x,
   scalar.x >> v.y,
   scalar.x >> v.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator~(tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   ~v.x,
   ~v.y,
   ~v.z);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
 }

 template <precision P> inline
                    tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)
 {
  return tvec3<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
 }

 template <precision P> inline
                    tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)
 {
  return tvec3<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
 }
}
# 408 "/usr/local/include/glm/detail/type_vec3.hpp" 2 3
# 6 "/usr/local/include/glm/vec3.hpp" 2 3
# 69 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/vec4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_vec4.hpp" 1 3
# 16 "/usr/local/include/glm/detail/type_vec4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec4
 {


  typedef T value_type;
  typedef tvec4<T, P> type;
  typedef tvec4<bool, P> bool_type;
# 71 "/usr/local/include/glm/detail/type_vec4.hpp" 3
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 84 "/usr/local/include/glm/detail/type_vec4.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 4;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec4() ;
                                   tvec4(tvec4<T, P> const& v) ;
  template <precision Q>
                                   tvec4(tvec4<T, Q> const& v);



                                   explicit tvec4(ctor);
                                   explicit tvec4(T scalar);
                                   tvec4(T a, T b, T c, T d);




  template <typename A, typename B, typename C, typename D>
                                   tvec4(A a, B b, C c, D d);
  template <typename A, typename B, typename C, typename D>
                                   tvec4(tvec1<A, P> const& a, tvec1<B, P> const& b, tvec1<C, P> const& c, tvec1<D, P> const& d);




  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec2<A, Q> const & a, B b, C c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(A a, tvec2<B, Q> const & b, C c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(A a, B b, tvec2<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
                                   tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec3<A, Q> const & a, B b);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec4(A a, tvec3<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b);

  template <typename A, typename B, precision Q>
                                   tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b);


  template <typename U, precision Q>
                                                tvec4(tvec4<U, Q> const& v);
# 198 "/usr/local/include/glm/detail/type_vec4.hpp" 3
                tvec4<T, P> & operator=(tvec4<T, P> const & v) ;

  template <typename U>
                tvec4<T, P> & operator=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator+=(U scalar);
  template <typename U>
                tvec4<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator+=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator-=(U scalar);
  template <typename U>
                tvec4<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator-=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator*=(U scalar);
  template <typename U>
                tvec4<T, P> & operator*=(tvec1<U, P> const& v);
  template <typename U>
                tvec4<T, P> & operator*=(tvec4<U, P> const& v);
  template <typename U>
                tvec4<T, P> & operator/=(U scalar);
  template <typename U>
                tvec4<T, P> & operator/=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator/=(tvec4<U, P> const & v);



                tvec4<T, P> & operator++();
                tvec4<T, P> & operator--();
                tvec4<T, P> operator++(int);
                tvec4<T, P> operator--(int);



  template <typename U>
                tvec4<T, P> & operator%=(U scalar);
  template <typename U>
                tvec4<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator%=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator&=(U scalar);
  template <typename U>
                tvec4<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator&=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator|=(U scalar);
  template <typename U>
                tvec4<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator|=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator^=(U scalar);
  template <typename U>
                tvec4<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator^=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec4<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator<<=(tvec4<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec4<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
                tvec4<T, P> & operator>>=(tvec4<U, P> const & v);
 };



 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v);



 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & scalar);

 template <typename T, precision P>
               tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec1<T, P> const & scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               tvec4<T, P> operator~(tvec4<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <precision P>
               tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);

 template <precision P>
               tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec4.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template <>
 struct is_int<uint32>
 {
  enum test {value = ~0};
 };

 template <>
 struct is_int<int32>
 {
  enum test {value = ~0};
 };

 template <>
 struct is_int<uint64>
 {
  enum test {value = ~0};
 };

 template <>
 struct is_int<int64>
 {
  enum test {value = ~0};
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_add
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_sub
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_mul
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_div
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_vec4_mod
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 { inline
                     static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
  {
   return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 { inline
                     static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
  {
   return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
  }
 };

 template <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const & v)
  {
   return tvec4<T, P>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}




  template <typename T, precision P> inline
                                        tvec4<T, P>::tvec4()

    : x(0), y(0), z(0), w(0)

  {}



  template <typename T, precision P> inline
                                        tvec4<T, P>::tvec4(tvec4<T, P> const & v)
   : x(v.x), y(v.y), z(v.z), w(v.w)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec4<T, P>::tvec4(tvec4<T, Q> const & v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template <typename T, precision P> inline
                                       tvec4<T, P>::tvec4(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec4<T, P>::tvec4(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, precision P> inline
                                       tvec4<T, P>::tvec4(T a, T b, T c, T d)
  : x(a), y(b), z(c), w(d)
 {}



 template <typename T, precision P>
 template <typename A, typename B, typename C, typename D> inline
                                       tvec4<T, P>::tvec4(A a, B b, C c, D d) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c)),
  w(static_cast<T>(d))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, typename D> inline
                                       tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(c.x)),
  w(static_cast<T>(d.x))
 {}



 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b)),
  w(static_cast<T>(c))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x)),
  w(static_cast<T>(c.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(v.x)),
  z(static_cast<T>(v.y)),
  w(static_cast<T>(s2))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(c.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(s2)),
  z(static_cast<T>(v.x)),
  w(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(c.x)),
  w(static_cast<T>(c.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(a.z)),
  w(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(a.z)),
  w(static_cast<T>(b.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(b.z))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(b.z))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x)),
  w(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z)),
  w(static_cast<T>(v.w))
 {}



 template <typename T, precision P> inline
                    T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec4.inl", 330, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec4.inl", 337, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec4<T, P>& tvec4<T, P>::operator=(tvec4<T, P> const & v)
  {
   this->x = v.x;
   this->y = v.y;
   this->z = v.z;
   this->w = v.w;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P>& tvec4<T, P>::operator=(tvec4<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }



 template <typename T, precision P> inline
                    tvec4<T, P> & tvec4<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> & tvec4<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> tvec4<T, P>::operator++(int)
 {
  tvec4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> tvec4<T, P>::operator--(int)
 {
  tvec4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)
 {
  return (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));
 }



 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v)
 {
  return tvec4<T, P>(0) -= v;
 }



 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) += scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) += v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(v) += scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v2) += v1;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) += v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) -= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) -= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) -= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) -= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) -= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) *= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) *= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(v) *= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v2) *= v1;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) *= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) /= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) /= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) /= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) /= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) /= v2;
 }



 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) %= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) %= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) %= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar.x) %= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) %= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) &= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar)
 {
  return tvec4<T, P>(v) &= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) &= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) &= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) &= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) |= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) |= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) |= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) |= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) |= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) ^= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) ^= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) ^= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) ^= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) ^= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) <<= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) <<= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) <<= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) <<= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) <<= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(v) >>= scalar;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec4<T, P>(v1) >>= v2.x;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(scalar) >>= v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec1<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1.x) >>= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(v1) >>= v2;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator~(tvec4<T, P> const & v)
 {
  return detail::compute_vec4_bitwise_not<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return detail::compute_vec4_equal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return detail::compute_vec4_nequal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);
 }

 template <precision P> inline
                    tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)
 {
  return tvec4<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template <precision P> inline
                    tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)
 {
  return tvec4<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}
# 453 "/usr/local/include/glm/detail/type_vec4.hpp" 2 3
# 6 "/usr/local/include/glm/vec4.hpp" 2 3
# 70 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/mat2x2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat2x2.hpp" 1 3
# 12 "/usr/local/include/glm/detail/type_mat2x2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x2<T, P> type;
  typedef tmat2x2<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


                tmat2x2() ;
                tmat2x2(tmat2x2<T, P> const & m) ;
  template <precision Q>
                tmat2x2(tmat2x2<T, Q> const & m);

                                   explicit tmat2x2(ctor);
                explicit tmat2x2(T scalar);
                tmat2x2(
   T const & x1, T const & y1,
   T const & x2, T const & y2);
                tmat2x2(
   col_type const & v1,
   col_type const & v2);



  template <typename U, typename V, typename M, typename N>
                tmat2x2(
   U const & x1, V const & y1,
   M const & x2, N const & y2);

  template <typename U, typename V>
                tmat2x2(
   tvec2<U, P> const & v1,
   tvec2<V, P> const & v2);



  template <typename U, precision Q>
                             tmat2x2(tmat2x2<U, Q> const & m);

                             tmat2x2(tmat3x3<T, P> const & x);
                             tmat2x2(tmat4x4<T, P> const & x);
                             tmat2x2(tmat2x3<T, P> const & x);
                             tmat2x2(tmat3x2<T, P> const & x);
                             tmat2x2(tmat2x4<T, P> const & x);
                             tmat2x2(tmat4x2<T, P> const & x);
                             tmat2x2(tmat3x4<T, P> const & x);
                             tmat2x2(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 2;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat2x2<T, P> & operator=(tmat2x2<T, P> const & v) ;

  template <typename U>
                tmat2x2<T, P> & operator=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator+=(U s);
  template <typename U>
                tmat2x2<T, P> & operator+=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator-=(U s);
  template <typename U>
                tmat2x2<T, P> & operator-=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator*=(U s);
  template <typename U>
                tmat2x2<T, P> & operator*=(tmat2x2<U, P> const & m);
  template <typename U>
                tmat2x2<T, P> & operator/=(U s);
  template <typename U>
                tmat2x2<T, P> & operator/=(tmat2x2<U, P> const & m);



                tmat2x2<T, P> & operator++ ();
                tmat2x2<T, P> & operator-- ();
                tmat2x2<T, P> operator++(int);
                tmat2x2<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat2x2<T, P> operator+(tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(tmat2x2<T, P> const & m);



 template <typename T, precision P>
               tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x2<T, P>::col_type operator*(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x2<T, P>::row_type operator*(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);



 template <typename T, precision P>
               bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat2x2.inl" 1 3



# 1 "/usr/local/include/glm/detail/func_matrix.hpp" 1 3
# 25 "/usr/local/include/glm/detail/func_matrix.hpp" 3
# 1 "/usr/local/include/glm/detail/../mat2x3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat2x3.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat2x3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x3<T, P> type;
  typedef tmat3x2<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


                tmat2x3() ;
                tmat2x3(tmat2x3<T, P> const & m) ;
  template <precision Q>
                tmat2x3(tmat2x3<T, Q> const & m);

                                   explicit tmat2x3(ctor);
                explicit tmat2x3(T scalar);
                tmat2x3(
   T x0, T y0, T z0,
   T x1, T y1, T z1);
                tmat2x3(
   col_type const & v0,
   col_type const & v1);



  template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
                tmat2x3(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2);

  template <typename U, typename V>
                tmat2x3(
   tvec3<U, P> const & v1,
   tvec3<V, P> const & v2);



  template <typename U, precision Q>
                             tmat2x3(tmat2x3<U, Q> const & m);

                             tmat2x3(tmat2x2<T, P> const & x);
                             tmat2x3(tmat3x3<T, P> const & x);
                             tmat2x3(tmat4x4<T, P> const & x);
                             tmat2x3(tmat2x4<T, P> const & x);
                             tmat2x3(tmat3x2<T, P> const & x);
                             tmat2x3(tmat3x4<T, P> const & x);
                             tmat2x3(tmat4x2<T, P> const & x);
                             tmat2x3(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 2;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat2x3<T, P> & operator=(tmat2x3<T, P> const & m) ;

  template <typename U>
                tmat2x3<T, P> & operator=(tmat2x3<U, P> const & m);
  template <typename U>
                tmat2x3<T, P> & operator+=(U s);
  template <typename U>
                tmat2x3<T, P> & operator+=(tmat2x3<U, P> const & m);
  template <typename U>
                tmat2x3<T, P> & operator-=(U s);
  template <typename U>
                tmat2x3<T, P> & operator-=(tmat2x3<U, P> const & m);
  template <typename U>
                tmat2x3<T, P> & operator*=(U s);
  template <typename U>
                tmat2x3<T, P> & operator/=(U s);



                tmat2x3<T, P> & operator++ ();
                tmat2x3<T, P> & operator-- ();
                tmat2x3<T, P> operator++(int);
                tmat2x3<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat2x3<T, P> operator+(tmat2x3<T, P> const & m);

 template <typename T, precision P>
               tmat2x3<T, P> operator-(tmat2x3<T, P> const & m);



 template <typename T, precision P>
               tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x3<T, P>::col_type operator*(tmat2x3<T, P> const & m, typename tmat2x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x3<T, P>::row_type operator*(typename tmat2x3<T, P>::col_type const & v, tmat2x3<T, P> const & m);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat2x3.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat2x3<T, P>::tmat2x3()
  {

    this->value[0] = col_type(1, 0, 0);
    this->value[1] = col_type(0, 1, 0);

  }



  template <typename T, precision P> inline
                     tmat2x3<T, P>::tmat2x3(tmat2x3<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P> inline
                                       tmat2x3<T, P>::tmat2x3(ctor)
 {}

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(T scalar)
 {
  this->value[0] = col_type(scalar, 0, 0);
  this->value[1] = col_type(0, scalar, 0);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2> inline
                    tmat2x3<T, P>::tmat2x3
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2> inline
                    tmat2x3<T, P>::tmat2x3(tvec3<V1, P> const & v1, tvec3<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                     tmat2x3<T, P>::tmat2x3(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P>::tmat2x3(tmat4x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }



 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::col_type & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x3.inl", 160, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::col_type const & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x3.inl", 167, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator+=(tmat2x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator-=(tmat2x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P>& tmat2x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> & tmat2x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> tmat2x3<T, P>::operator++(int)
 {
  tmat2x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> tmat2x3<T, P>::operator--(int)
 {
  tmat2x3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat2x3<T, P> operator+(tmat2x3<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator-(tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   -m[0],
   -m[1]);
 }



 template <typename T, precision P> inline
                    tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(T scalar, tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::col_type operator*
 (
  tmat2x3<T, P> const & m,
  typename tmat2x3<T, P>::row_type const & v)
 {
  return typename tmat2x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template <typename T, precision P> inline
                    typename tmat2x3<T, P>::row_type operator*
 (
  typename tmat2x3<T, P>::col_type const & v,
  tmat2x3<T, P> const & m)
 {
  return typename tmat2x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T scalar)
 {
  return tmat2x3<T, P>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator/(T scalar, tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   scalar / m[0],
   scalar / m[1]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 164 "/usr/local/include/glm/detail/type_mat2x3.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat2x3.hpp" 2 3


namespace glm
{





 typedef tmat2x3<float, lowp> lowp_mat2x3;






 typedef tmat2x3<float, mediump> mediump_mat2x3;






 typedef tmat2x3<float, highp> highp_mat2x3;

}
# 25 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat2x4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat2x4.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat2x4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x4<T, P> type;
  typedef tmat4x2<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


                tmat2x4() ;
                tmat2x4(tmat2x4<T, P> const & m) ;
  template <precision Q>
                tmat2x4(tmat2x4<T, Q> const & m);

                                   explicit tmat2x4(ctor);
                explicit tmat2x4(T scalar);
                tmat2x4(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1);
                tmat2x4(
   col_type const & v0,
   col_type const & v1);



  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
                tmat2x4(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2);

  template <typename U, typename V>
                tmat2x4(
   tvec4<U, P> const & v1,
   tvec4<V, P> const & v2);



  template <typename U, precision Q>
                             tmat2x4(tmat2x4<U, Q> const & m);

                             tmat2x4(tmat2x2<T, P> const & x);
                             tmat2x4(tmat3x3<T, P> const & x);
                             tmat2x4(tmat4x4<T, P> const & x);
                             tmat2x4(tmat2x3<T, P> const & x);
                             tmat2x4(tmat3x2<T, P> const & x);
                             tmat2x4(tmat3x4<T, P> const & x);
                             tmat2x4(tmat4x2<T, P> const & x);
                             tmat2x4(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 2;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat2x4<T, P> & operator=(tmat2x4<T, P> const & m) ;

  template <typename U>
                tmat2x4<T, P> & operator=(tmat2x4<U, P> const & m);
  template <typename U>
                tmat2x4<T, P> & operator+=(U s);
  template <typename U>
                tmat2x4<T, P> & operator+=(tmat2x4<U, P> const & m);
  template <typename U>
                tmat2x4<T, P> & operator-=(U s);
  template <typename U>
                tmat2x4<T, P> & operator-=(tmat2x4<U, P> const & m);
  template <typename U>
                tmat2x4<T, P> & operator*=(U s);
  template <typename U>
                tmat2x4<T, P> & operator/=(U s);



                tmat2x4<T, P> & operator++ ();
                tmat2x4<T, P> & operator-- ();
                tmat2x4<T, P> operator++(int);
                tmat2x4<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat2x4<T, P> operator+(tmat2x4<T, P> const & m);

 template <typename T, precision P>
               tmat2x4<T, P> operator-(tmat2x4<T, P> const & m);



 template <typename T, precision P>
               tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat2x4.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat2x4<T, P>::tmat2x4()
  {

    this->value[0] = col_type(1, 0, 0, 0);
    this->value[1] = col_type(0, 1, 0, 0);

  }



  template <typename T, precision P> inline
                     tmat2x4<T, P>::tmat2x4(tmat2x4<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P> inline
                                       tmat2x4<T, P>::tmat2x4(ctor)
 {}

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(T scalar)
 {
  value_type const Zero(0);
  this->value[0] = col_type(scalar, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, scalar, Zero, Zero);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2> inline
                    tmat2x4<T, P>::tmat2x4
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2> inline
                    tmat2x4<T, P>::tmat2x4(tvec4<V1, P> const & v1, tvec4<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x4<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat3x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>::tmat2x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }



 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::col_type & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x4.inl", 161, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::col_type const & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x4.inl", 168, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator+=(tmat2x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator-=(tmat2x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x4<T, P> & tmat2x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P>& tmat2x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> tmat2x4<T, P>::operator++(int)
 {
  tmat2x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> tmat2x4<T, P>::operator--(int)
 {
  tmat2x4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat2x4<T, P> operator+(tmat2x4<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator-(tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   -m[0],
   -m[1]);
 }



 template <typename T, precision P> inline
                    tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(T scalar, tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v)
 {
  return typename tmat2x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template <typename T, precision P> inline
                    typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m)
 {
  return typename tmat2x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  tmat4x4<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T scalar)
 {
  return tmat2x4<T, P>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator/(T scalar, tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   scalar / m[0],
   scalar / m[1]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 166 "/usr/local/include/glm/detail/type_mat2x4.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat2x4.hpp" 2 3


namespace glm
{





 typedef tmat2x4<float, lowp> lowp_mat2x4;






 typedef tmat2x4<float, mediump> mediump_mat2x4;






 typedef tmat2x4<float, highp> highp_mat2x4;

}
# 26 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat3x2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat3x2.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat3x2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x2<T, P> type;
  typedef tmat2x3<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


                tmat3x2() ;
                tmat3x2(tmat3x2<T, P> const & m) ;
  template <precision Q>
                tmat3x2(tmat3x2<T, Q> const & m);

                                   explicit tmat3x2(ctor);
                explicit tmat3x2(T scalar);
                tmat3x2(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2);
                tmat3x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
                tmat3x2(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template <typename V1, typename V2, typename V3>
                tmat3x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3);



  template <typename U, precision Q>
                             tmat3x2(tmat3x2<U, Q> const & m);

                             tmat3x2(tmat2x2<T, P> const & x);
                             tmat3x2(tmat3x3<T, P> const & x);
                             tmat3x2(tmat4x4<T, P> const & x);
                             tmat3x2(tmat2x3<T, P> const & x);
                             tmat3x2(tmat2x4<T, P> const & x);
                             tmat3x2(tmat3x4<T, P> const & x);
                             tmat3x2(tmat4x2<T, P> const & x);
                             tmat3x2(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 3;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat3x2<T, P> & operator=(tmat3x2<T, P> const & m) ;

  template <typename U>
                tmat3x2<T, P> & operator=(tmat3x2<U, P> const & m);
  template <typename U>
                tmat3x2<T, P> & operator+=(U s);
  template <typename U>
                tmat3x2<T, P> & operator+=(tmat3x2<U, P> const & m);
  template <typename U>
                tmat3x2<T, P> & operator-=(U s);
  template <typename U>
                tmat3x2<T, P> & operator-=(tmat3x2<U, P> const & m);
  template <typename U>
                tmat3x2<T, P> & operator*=(U s);
  template <typename U>
                tmat3x2<T, P> & operator/=(U s);



                tmat3x2<T, P> & operator++ ();
                tmat3x2<T, P> & operator-- ();
                tmat3x2<T, P> operator++(int);
                tmat3x2<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat3x2<T, P> operator+(tmat3x2<T, P> const & m);

 template <typename T, precision P>
               tmat3x2<T, P> operator-(tmat3x2<T, P> const & m);



 template <typename T, precision P>
               tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

}



# 1 "/usr/local/include/glm/detail/type_mat3x2.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat3x2<T, P>::tmat3x2()
  {

    this->value[0] = col_type(1, 0);
    this->value[1] = col_type(0, 1);
    this->value[2] = col_type(0, 0);

  }



  template <typename T, precision P> inline
                     tmat3x2<T, P>::tmat3x2(tmat3x2<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P> inline
                                       tmat3x2<T, P>::tmat3x2(ctor)
 {}

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(T scalar)
 {
  this->value[0] = col_type(scalar, 0);
  this->value[1] = col_type(0, scalar);
  this->value[2] = col_type(0, 0);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3> inline
                    tmat3x2<T, P>::tmat3x2
 (
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3> inline
                    tmat3x2<T, P>::tmat3x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat2x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat4x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>::tmat3x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }



 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::col_type & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x2.inl", 190, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::col_type const & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x2.inl", 197, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator+=(tmat3x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator-=(tmat3x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x2<T, P> & tmat3x2<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P>& tmat3x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> tmat3x2<T, P>::operator++(int)
 {
  tmat3x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> tmat3x2<T, P>::operator--(int)
 {
  tmat3x2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat3x2<T, P> operator+(tmat3x2<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator-(tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template <typename T, precision P> inline
                    tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(T scalar, tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v)
 {
  return typename tmat3x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template <typename T, precision P> inline
                    typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m)
 {
  return typename tmat3x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  tmat2x2<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T scalar)
 {
  return tmat3x2<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator/(T scalar, tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 172 "/usr/local/include/glm/detail/type_mat3x2.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat3x2.hpp" 2 3


namespace glm
{





 typedef tmat3x2<float, lowp> lowp_mat3x2;






 typedef tmat3x2<float, mediump> mediump_mat3x2;






 typedef tmat3x2<float, highp> highp_mat3x2;

}
# 27 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat3x3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat3x3.hpp" 1 3
# 12 "/usr/local/include/glm/detail/type_mat3x3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x3<T, P> type;
  typedef tmat3x3<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


                tmat3x3() ;
                tmat3x3(tmat3x3<T, P> const & m) ;
  template <precision Q>
                tmat3x3(tmat3x3<T, Q> const & m);

                                   explicit tmat3x3(ctor);
                explicit tmat3x3(T scalar);
                tmat3x3(
   T x0, T y0, T z0,
   T x1, T y1, T z1,
   T x2, T y2, T z2);
                tmat3x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
                tmat3x3(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2,
   X3 x3, Y3 y3, Z3 z3);

  template <typename V1, typename V2, typename V3>
                tmat3x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3);



  template <typename U, precision Q>
                             tmat3x3(tmat3x3<U, Q> const & m);

                             tmat3x3(tmat2x2<T, P> const & x);
                             tmat3x3(tmat4x4<T, P> const & x);
                             tmat3x3(tmat2x3<T, P> const & x);
                             tmat3x3(tmat3x2<T, P> const & x);
                             tmat3x3(tmat2x4<T, P> const & x);
                             tmat3x3(tmat4x2<T, P> const & x);
                             tmat3x3(tmat3x4<T, P> const & x);
                             tmat3x3(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 3;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat3x3<T, P> & operator=(tmat3x3<T, P> const & m) ;

  template <typename U>
                tmat3x3<T, P> & operator=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator+=(U s);
  template <typename U>
                tmat3x3<T, P> & operator+=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator-=(U s);
  template <typename U>
                tmat3x3<T, P> & operator-=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator*=(U s);
  template <typename U>
                tmat3x3<T, P> & operator*=(tmat3x3<U, P> const & m);
  template <typename U>
                tmat3x3<T, P> & operator/=(U s);
  template <typename U>
                tmat3x3<T, P> & operator/=(tmat3x3<U, P> const & m);



                tmat3x3<T, P> & operator++();
                tmat3x3<T, P> & operator--();
                tmat3x3<T, P> operator++(int);
                tmat3x3<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat3x3<T, P> operator+(tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(tmat3x3<T, P> const & m);



 template <typename T, precision P>
               tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator/(tmat3x3<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

 template <typename T, precision P>
               tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);



 template <typename T, precision P>
               bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat3x3.inl" 1 3





namespace glm
{



  template <typename T, precision P> inline
                     tmat3x3<T, P>::tmat3x3()
  {

    this->value[0] = col_type(1, 0, 0);
    this->value[1] = col_type(0, 1, 0);
    this->value[2] = col_type(0, 0, 1);

  }



  template <typename T, precision P> inline
                     tmat3x3<T, P>::tmat3x3(tmat3x3<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P> inline
                                       tmat3x3<T, P>::tmat3x3(ctor)
 {}

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(T scalar)
 {
  this->value[0] = col_type(scalar, 0, 0);
  this->value[1] = col_type(0, scalar, 0);
  this->value[2] = col_type(0, 0, scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1,
  T x2, T y2, T z2
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3> inline
                    tmat3x3<T, P>::tmat3x3
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2,
  X3 x3, Y3 y3, Z3 z3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3> inline
                    tmat3x3<T, P>::tmat3x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat2x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P>::tmat3x3(tmat4x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }



 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x3.inl", 192, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type const & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x3.inl", 199, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator+=(tmat3x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator-=(tmat3x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator*=(tmat3x3<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator/=(tmat3x3<U, P> const & m)
 {
  return *this *= inverse(m);
 }



 template <typename T, precision P> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> & tmat3x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> tmat3x3<T, P>::operator++(int)
 {
  tmat3x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> tmat3x3<T, P>::operator--(int)
 {
  tmat3x3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(tmat3x3<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
 {
  return typename tmat3x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
 {
  return typename tmat3x3<T, P>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator/(tmat3x3<T, P> const & m, T scalar)
 {
  return tmat3x3<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator/(T scalar, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
 {
  return inverse(m) * v;
 }

 template <typename T, precision P> inline
                    typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
 {
  return v * inverse(m);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  tmat3x3<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }



 template <typename T, precision P> inline
                    bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 189 "/usr/local/include/glm/detail/type_mat3x3.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat3x3.hpp" 2 3


namespace glm
{





 typedef tmat3x3<float, lowp> lowp_mat3;






 typedef tmat3x3<float, mediump> mediump_mat3;






 typedef tmat3x3<float, highp> highp_mat3;






 typedef tmat3x3<float, lowp> lowp_mat3x3;






 typedef tmat3x3<float, mediump> mediump_mat3x3;






 typedef tmat3x3<float, highp> highp_mat3x3;

}
# 28 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat3x4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat3x4.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat3x4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x4<T, P> type;
  typedef tmat4x3<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


                tmat3x4() ;
                tmat3x4(tmat3x4<T, P> const & m) ;
  template <precision Q>
                tmat3x4(tmat3x4<T, Q> const & m);

                                   explicit tmat3x4(ctor);
                explicit tmat3x4(T scalar);
                tmat3x4(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1,
   T x2, T y2, T z2, T w2);
                tmat3x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
                tmat3x4(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2,
   X3 x3, Y3 y3, Z3 z3, W3 w3);

  template <typename V1, typename V2, typename V3>
                tmat3x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3);



  template <typename U, precision Q>
                             tmat3x4(tmat3x4<U, Q> const & m);

                             tmat3x4(tmat2x2<T, P> const & x);
                             tmat3x4(tmat3x3<T, P> const & x);
                             tmat3x4(tmat4x4<T, P> const & x);
                             tmat3x4(tmat2x3<T, P> const & x);
                             tmat3x4(tmat3x2<T, P> const & x);
                             tmat3x4(tmat2x4<T, P> const & x);
                             tmat3x4(tmat4x2<T, P> const & x);
                             tmat3x4(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 3;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat3x4<T, P> & operator=(tmat3x4<T, P> const & m) ;

  template <typename U>
                tmat3x4<T, P> & operator=(tmat3x4<U, P> const & m);
  template <typename U>
                tmat3x4<T, P> & operator+=(U s);
  template <typename U>
                tmat3x4<T, P> & operator+=(tmat3x4<U, P> const & m);
  template <typename U>
                tmat3x4<T, P> & operator-=(U s);
  template <typename U>
                tmat3x4<T, P> & operator-=(tmat3x4<U, P> const & m);
  template <typename U>
                tmat3x4<T, P> & operator*=(U s);
  template <typename U>
                tmat3x4<T, P> & operator/=(U s);



                tmat3x4<T, P> & operator++();
                tmat3x4<T, P> & operator--();
                tmat3x4<T, P> operator++(int);
                tmat3x4<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat3x4<T, P> operator+(tmat3x4<T, P> const & m);

 template <typename T, precision P>
               tmat3x4<T, P> operator-(tmat3x4<T, P> const & m);



 template <typename T, precision P>
               tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat3x4<T, P>::col_type operator*(tmat3x4<T, P> const & m, typename tmat3x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat3x4<T, P>::row_type operator*(typename tmat3x4<T, P>::col_type const & v, tmat3x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat3x4.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat3x4<T, P>::tmat3x4()
  {

    this->value[0] = col_type(1, 0, 0, 0);
    this->value[1] = col_type(0, 1, 0, 0);
    this->value[2] = col_type(0, 0, 1, 0);

  }



  template <typename T, precision P> inline
                     tmat3x4<T, P>::tmat3x4(tmat3x4<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P> inline
                                       tmat3x4<T, P>::tmat3x4(ctor)
 {}

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(T scalar)
 {
  this->value[0] = col_type(scalar, 0, 0, 0);
  this->value[1] = col_type(0, scalar, 0, 0);
  this->value[2] = col_type(0, 0, scalar, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1,
  T x2, T y2, T z2, T w2
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3> inline
                    tmat3x4<T, P>::tmat3x4
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2,
  X3 x3, Y3 y3, Z3 z3, W3 w3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3> inline
                    tmat3x4<T, P>::tmat3x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x4<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 1, 0);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>::tmat3x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
 }



 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::col_type & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x4.inl", 190, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::col_type const & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat3x4.inl", 197, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator+=(tmat3x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator-=(tmat3x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat3x4<T, P> & tmat3x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P>& tmat3x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> tmat3x4<T, P>::operator++(int)
 {
  tmat3x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> tmat3x4<T, P>::operator--(int)
 {
  tmat3x4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat3x4<T, P> operator+(tmat3x4<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator-(tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template <typename T, precision P> inline
                    tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(T scalar, tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::col_type operator*
 (
  tmat3x4<T, P> const & m,
  typename tmat3x4<T, P>::row_type const & v
 )
 {
  return typename tmat3x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template <typename T, precision P> inline
                    typename tmat3x4<T, P>::row_type operator*
 (
  typename tmat3x4<T, P>::col_type const & v,
  tmat3x4<T, P> const & m
 )
 {
  return typename tmat3x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  tmat4x4<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T scalar)
 {
  return tmat3x4<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator/(T scalar, tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 171 "/usr/local/include/glm/detail/type_mat3x4.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat3x4.hpp" 2 3


namespace glm
{





 typedef tmat3x4<float, lowp> lowp_mat3x4;






 typedef tmat3x4<float, mediump> mediump_mat3x4;






 typedef tmat3x4<float, highp> highp_mat3x4;

}
# 29 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat4x2.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat4x2.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat4x2.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x2<T, P> type;
  typedef tmat2x4<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


                tmat4x2() ;
                tmat4x2(tmat4x2<T, P> const & m) ;
  template <precision Q>
                tmat4x2(tmat4x2<T, Q> const & m);

                                   explicit tmat4x2(ctor);
                explicit tmat4x2(T scalar);
                tmat4x2(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2,
   T x3, T y3);
                tmat4x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3,
   typename X4, typename Y4>
                tmat4x2(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3,
   X4 x4, Y4 y4);

  template <typename V1, typename V2, typename V3, typename V4>
                tmat4x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3,
   tvec2<V4, P> const & v4);



  template <typename U, precision Q>
                             tmat4x2(tmat4x2<U, Q> const & m);

                             tmat4x2(tmat2x2<T, P> const & x);
                             tmat4x2(tmat3x3<T, P> const & x);
                             tmat4x2(tmat4x4<T, P> const & x);
                             tmat4x2(tmat2x3<T, P> const & x);
                             tmat4x2(tmat3x2<T, P> const & x);
                             tmat4x2(tmat2x4<T, P> const & x);
                             tmat4x2(tmat4x3<T, P> const & x);
                             tmat4x2(tmat3x4<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 4;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat4x2<T, P> & operator=(tmat4x2<T, P> const & m) ;

  template <typename U>
                tmat4x2<T, P> & operator=(tmat4x2<U, P> const & m);
  template <typename U>
                tmat4x2<T, P> & operator+=(U s);
  template <typename U>
                tmat4x2<T, P> & operator+=(tmat4x2<U, P> const & m);
  template <typename U>
                tmat4x2<T, P> & operator-=(U s);
  template <typename U>
                tmat4x2<T, P> & operator-=(tmat4x2<U, P> const & m);
  template <typename U>
                tmat4x2<T, P> & operator*=(U s);
  template <typename U>
                tmat4x2<T, P> & operator/=(U s);



                tmat4x2<T, P> & operator++ ();
                tmat4x2<T, P> & operator-- ();
                tmat4x2<T, P> operator++(int);
                tmat4x2<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat4x2<T, P> operator+(tmat4x2<T, P> const & m);

 template <typename T, precision P>
               tmat4x2<T, P> operator-(tmat4x2<T, P> const & m);



 template <typename T, precision P>
               tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m);

 template <typename T, precision P>
               tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T scalar);

 template <typename T, precision P>
               tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat4x2.inl" 1 3



namespace glm
{
# 16 "/usr/local/include/glm/detail/type_mat4x2.inl" 3
  template <typename T, precision P> inline
                     tmat4x2<T, P>::tmat4x2()
  {

    this->value[0] = col_type(1, 0);
    this->value[1] = col_type(0, 1);
    this->value[2] = col_type(0, 0);
    this->value[3] = col_type(0, 0);

  }



  template <typename T, precision P> inline
                     tmat4x2<T, P>::tmat4x2(tmat4x2<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
   this->value[3] = m.value[3];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P> inline
                                       tmat4x2<T, P>::tmat4x2(ctor)
 {}

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(T scalar)
 {
  this->value[0] = col_type(scalar, 0);
  this->value[1] = col_type(0, scalar);
  this->value[2] = col_type(0, 0);
  this->value[3] = col_type(0, 0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2,
  T x3, T y3
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
  this->value[3] = col_type(x3, y3);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3,
  typename X4, typename Y4> inline
                    tmat4x2<T, P>::tmat4x2
 (
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3,
  X4 x4, Y4 y4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4> inline
                    tmat4x2<T, P>::tmat4x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3,
  tvec2<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P>::tmat4x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }



 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::col_type & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x2.inl", 219, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::col_type const & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x2.inl", 226, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator+=(tmat4x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator-=(tmat4x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> & tmat4x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> tmat4x2<T, P>::operator++(int)
 {
  tmat4x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> tmat4x2<T, P>::operator--(int)
 {
  tmat4x2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat4x2<T, P> operator+(tmat4x2<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator-(tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template <typename T, precision P> inline
                    tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(T scalar, tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v)
 {
  return typename tmat4x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template <typename T, precision P> inline
                    typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m)
 {
  return typename tmat4x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  tmat2x2<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T scalar)
 {
  return tmat4x2<T, P>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator/(T scalar, tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 176 "/usr/local/include/glm/detail/type_mat4x2.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat4x2.hpp" 2 3


namespace glm
{





 typedef tmat4x2<float, lowp> lowp_mat4x2;






 typedef tmat4x2<float, mediump> mediump_mat4x2;






 typedef tmat4x2<float, highp> highp_mat4x2;

}
# 30 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat4x3.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat4x3.hpp" 1 3
# 13 "/usr/local/include/glm/detail/type_mat4x3.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x3<T, P> type;
  typedef tmat3x4<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


                tmat4x3() ;
                tmat4x3(tmat4x3<T, P> const & m) ;
  template <precision Q>
                tmat4x3(tmat4x3<T, Q> const & m);

                                   explicit tmat4x3(ctor);
                explicit tmat4x3(T const & x);
                tmat4x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1,
   T const & x2, T const & y2, T const & z2,
   T const & x3, T const & y3, T const & z3);
                tmat4x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
                tmat4x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3,
   X4 const & x4, Y4 const & y4, Z4 const & z4);

  template <typename V1, typename V2, typename V3, typename V4>
                tmat4x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3,
   tvec3<V4, P> const & v4);



  template <typename U, precision Q>
                             tmat4x3(tmat4x3<U, Q> const & m);

                             tmat4x3(tmat2x2<T, P> const & x);
                             tmat4x3(tmat3x3<T, P> const & x);
                             tmat4x3(tmat4x4<T, P> const & x);
                             tmat4x3(tmat2x3<T, P> const & x);
                             tmat4x3(tmat3x2<T, P> const & x);
                             tmat4x3(tmat2x4<T, P> const & x);
                             tmat4x3(tmat4x2<T, P> const & x);
                             tmat4x3(tmat3x4<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 4;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat4x3<T, P> & operator=(tmat4x3<T, P> const & m) ;

  template <typename U>
                tmat4x3<T, P> & operator=(tmat4x3<U, P> const & m);
  template <typename U>
                tmat4x3<T, P> & operator+=(U s);
  template <typename U>
                tmat4x3<T, P> & operator+=(tmat4x3<U, P> const & m);
  template <typename U>
                tmat4x3<T, P> & operator-=(U s);
  template <typename U>
                tmat4x3<T, P> & operator-=(tmat4x3<U, P> const & m);
  template <typename U>
                tmat4x3<T, P> & operator*=(U s);
  template <typename U>
                tmat4x3<T, P> & operator/=(U s);



                tmat4x3<T, P> & operator++();
                tmat4x3<T, P> & operator--();
                tmat4x3<T, P> operator++(int);
                tmat4x3<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat4x3<T, P> operator+(tmat4x3<T, P> const & m);

 template <typename T, precision P>
               tmat4x3<T, P> operator-(tmat4x3<T, P> const & m);



 template <typename T, precision P>
               tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x3<T, P>::col_type operator*(tmat4x3<T, P> const & m, typename tmat4x3<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x3<T, P>::row_type operator*(typename tmat4x3<T, P>::col_type const & v, tmat4x3<T, P> const & m);

 template <typename T, precision P>
               tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m);



 template <typename T, precision P>
               bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat4x3.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                     tmat4x3<T, P>::tmat4x3()
  {

    this->value[0] = col_type(1, 0, 0);
    this->value[1] = col_type(0, 1, 0);
    this->value[2] = col_type(0, 0, 1);
    this->value[3] = col_type(0, 0, 0);

  }



  template <typename T, precision P> inline
                     tmat4x3<T, P>::tmat4x3(tmat4x3<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
   this->value[2] = m.value[2];
   this->value[3] = m.value[3];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P> inline
                                       tmat4x3<T, P>::tmat4x3(ctor)
 {}

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(T const & s)
 {
  this->value[0] = col_type(s, 0, 0);
  this->value[1] = col_type(0, s, 0);
  this->value[2] = col_type(0, 0, s);
  this->value[3] = col_type(0, 0, 0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1,
  T const & x2, T const & y2, T const & z2,
  T const & x3, T const & y3, T const & z3
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
  this->value[3] = col_type(x3, y3, z3);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3,
  typename X4, typename Y4, typename Z4> inline
                    tmat4x3<T, P>::tmat4x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3,
  X4 const & x4, Y4 const & y4, Z4 const & z4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4> inline
                    tmat4x3<T, P>::tmat4x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3,
  tvec3<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
  this->value[3] = col_type(m[3], 0);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P>::tmat4x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }



 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::col_type & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x3.inl", 212, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::col_type const & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x3.inl", 219, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator+=(tmat4x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator-=(tmat4x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template <typename T, precision P> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> & tmat4x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> tmat4x3<T, P>::operator++(int)
 {
  tmat4x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> tmat4x3<T, P>::operator--(int)
 {
  tmat4x3<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat4x3<T, P> operator+(tmat4x3<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator-(tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template <typename T, precision P> inline
                    tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::col_type operator*
 (
  tmat4x3<T, P> const & m,
  typename tmat4x3<T, P>::row_type const & v)
 {
  return typename tmat4x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template <typename T, precision P> inline
                    typename tmat4x3<T, P>::row_type operator*
 (
  typename tmat4x3<T, P>::col_type const & v,
  tmat4x3<T, P> const & m)
 {
  return typename tmat4x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }



 template <typename T, precision P> inline
                    bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 176 "/usr/local/include/glm/detail/type_mat4x3.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat4x3.hpp" 2 3


namespace glm
{





 typedef tmat4x3<float, lowp> lowp_mat4x3;






 typedef tmat4x3<float, mediump> mediump_mat4x3;






 typedef tmat4x3<float, highp> highp_mat4x3;

}
# 31 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3

# 1 "/usr/local/include/glm/detail/../mat4x4.hpp" 1 3





# 1 "/usr/local/include/glm/detail/type_mat4x4.hpp" 1 3
# 12 "/usr/local/include/glm/detail/type_mat4x4.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x4<T, P> type;
  typedef tmat4x4<T, P> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


                tmat4x4() ;
                tmat4x4(tmat4x4<T, P> const & m) ;
  template <precision Q>
                tmat4x4(tmat4x4<T, Q> const & m);

                explicit tmat4x4(ctor);
                explicit tmat4x4(T const & x);
                tmat4x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1,
   T const & x2, T const & y2, T const & z2, T const & w2,
   T const & x3, T const & y3, T const & z3, T const & w3);
                tmat4x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
                tmat4x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
   X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
   X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

  template <typename V1, typename V2, typename V3, typename V4>
                tmat4x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3,
   tvec4<V4, P> const & v4);



  template <typename U, precision Q>
                             tmat4x4(tmat4x4<U, Q> const & m);

                             tmat4x4(tmat2x2<T, P> const & x);
                             tmat4x4(tmat3x3<T, P> const & x);
                             tmat4x4(tmat2x3<T, P> const & x);
                             tmat4x4(tmat3x2<T, P> const & x);
                             tmat4x4(tmat2x4<T, P> const & x);
                             tmat4x4(tmat4x2<T, P> const & x);
                             tmat4x4(tmat3x4<T, P> const & x);
                             tmat4x4(tmat4x3<T, P> const & x);



  typedef length_t length_type;
                static length_type length(){return 4;}

                col_type & operator[](length_type i);
                col_type const & operator[](length_type i) const;



                tmat4x4<T, P> & operator=(tmat4x4<T, P> const & m) ;

  template <typename U>
                tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator+=(U s);
  template <typename U>
                tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator-=(U s);
  template <typename U>
                tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator*=(U s);
  template <typename U>
                tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);
  template <typename U>
                tmat4x4<T, P> & operator/=(U s);
  template <typename U>
                tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);



                tmat4x4<T, P> & operator++();
                tmat4x4<T, P> & operator--();
                tmat4x4<T, P> operator++(int);
                tmat4x4<T, P> operator--(int);
 };



 template <typename T, precision P>
               tmat4x4<T, P> operator+(tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(tmat4x4<T, P> const & m);



 template <typename T, precision P>
               tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
               tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
               tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
               typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

 template <typename T, precision P>
               tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);



 template <typename T, precision P>
               bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
               bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);
}



# 1 "/usr/local/include/glm/detail/type_mat4x4.inl" 1 3





namespace glm
{



  template <typename T, precision P> inline
                     tmat4x4<T, P>::tmat4x4()
  {

    this->value[0] = col_type(1, 0, 0, 0);
    this->value[1] = col_type(0, 1, 0, 0);
    this->value[2] = col_type(0, 0, 1, 0);
    this->value[3] = col_type(0, 0, 0, 1);

  }



  template <typename T, precision P> inline
                     tmat4x4<T, P>::tmat4x4(tmat4x4<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(ctor)
 {}

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(T const & s)
 {
  this->value[0] = col_type(s, 0, 0, 0);
  this->value[1] = col_type(0, s, 0, 0);
  this->value[2] = col_type(0, 0, s, 0);
  this->value[3] = col_type(0, 0, 0, s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1,
  T const & x2, T const & y2, T const & z2, T const & w2,
  T const & x3, T const & y3, T const & z3, T const & w3
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
  this->value[3] = col_type(x3, y3, z3, w3);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }

 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat4x4<T, P>::tmat4x4
 (
  tmat4x4<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4> inline
                    tmat4x4<T, P>::tmat4x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
  X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
 )
 {
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;

                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;

                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;

                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;
                                                                                                                                                                                                                  ;

  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4> inline
                    tmat4x4<T, P>::tmat4x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3,
  tvec4<V4, P> const & v4
 )
 {
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;
                                                                                                                                                                                                                 ;

  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
  this->value[3] = col_type(m[3], 1);
 }



 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x4.inl", 242, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat4x4.inl", 249, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<T, P> const & m)
  {


   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)
 {
  return *this *= inverse(m);
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> & tmat4x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> tmat4x4<T, P>::operator++(int)
 {
  tmat4x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> tmat4x4<T, P>::operator--(int)
 {
  tmat4x4<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(tmat4x4<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   s - m[0],
   s - m[1],
   s - m[2],
   s - m[3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type operator*
 (
  tmat4x4<T, P> const & m,
  typename tmat4x4<T, P>::row_type const & v
 )
 {
# 526 "/usr/local/include/glm/detail/type_mat4x4.inl" 3
  typename tmat4x4<T, P>::col_type const Mov0(v[0]);
  typename tmat4x4<T, P>::col_type const Mov1(v[1]);
  typename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;
  typename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;
  typename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;
  typename tmat4x4<T, P>::col_type const Mov2(v[2]);
  typename tmat4x4<T, P>::col_type const Mov3(v[3]);
  typename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;
  typename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;
  typename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;
  typename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 546 "/usr/local/include/glm/detail/type_mat4x4.inl" 3
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::row_type operator*
 (
  typename tmat4x4<T, P>::col_type const & v,
  tmat4x4<T, P> const & m
 )
 {
  return typename tmat4x4<T, P>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  typename tmat4x4<T, P>::col_type const SrcA0 = m1[0];
  typename tmat4x4<T, P>::col_type const SrcA1 = m1[1];
  typename tmat4x4<T, P>::col_type const SrcA2 = m1[2];
  typename tmat4x4<T, P>::col_type const SrcA3 = m1[3];

  typename tmat4x4<T, P>::col_type const SrcB0 = m2[0];
  typename tmat4x4<T, P>::col_type const SrcB1 = m2[1];
  typename tmat4x4<T, P>::col_type const SrcB2 = m2[2];
  typename tmat4x4<T, P>::col_type const SrcB3 = m2[3];

  tmat4x4<T, P> Result(uninitialize);
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)
 {
  return inverse(m) * v;
 }

 template <typename T, precision P> inline
                    typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)
 {
  return v * inverse(m);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  tmat4x4<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }



 template <typename T, precision P> inline
                    bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}



# 1 "/usr/local/include/glm/detail/type_mat4x4_simd.inl" 1 3



namespace glm
{

}
# 670 "/usr/local/include/glm/detail/type_mat4x4.inl" 2 3
# 194 "/usr/local/include/glm/detail/type_mat4x4.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../mat4x4.hpp" 2 3


namespace glm
{





 typedef tmat4x4<float, lowp> lowp_mat4;






 typedef tmat4x4<float, mediump> mediump_mat4;






 typedef tmat4x4<float, highp> highp_mat4;






 typedef tmat4x4<float, lowp> lowp_mat4x4;






 typedef tmat4x4<float, mediump> mediump_mat4x4;






 typedef tmat4x4<float, highp> highp_mat4x4;

}
# 32 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3


namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec2>
 {
  typedef tmat2x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec3>
 {
  typedef tmat3x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec4>
 {
  typedef tmat4x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec2>
 {
  typedef tmat2x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec3>
 {
  typedef tmat3x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec4>
 {
  typedef tmat4x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec2>
 {
  typedef tmat2x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec3>
 {
  typedef tmat3x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec4>
 {
  typedef tmat4x4<T, P> type;
 };

}
# 103 "/usr/local/include/glm/detail/func_matrix.hpp" 3
 template <typename T, precision P, template <typename, precision> class matType>
               matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y);
# 114 "/usr/local/include/glm/detail/func_matrix.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
               typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r);
# 134 "/usr/local/include/glm/detail/func_matrix.hpp" 3
 template <typename T, precision P, template <typename, precision> class matType>
               T determinant(matType<T, P> const & m);







 template <typename T, precision P, template <typename, precision> class matType>
               matType<T, P> inverse(matType<T, P> const & m);


}


# 1 "/usr/local/include/glm/detail/func_matrix.inl" 1 3



# 1 "/usr/local/include/glm/detail/../geometric.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_geometric.hpp" 1 3
# 15 "/usr/local/include/glm/detail/func_geometric.hpp" 3
namespace glm
{
# 26 "/usr/local/include/glm/detail/func_geometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               T length(
  vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               T distance(
  vecType<T, P> const & p0,
  vecType<T, P> const & p1);







 template <typename T, precision P, template <typename, precision> class vecType>
               T dot(
  vecType<T, P> const & x,
  vecType<T, P> const & y);







 template <typename T, precision P>
               tvec3<T, P> cross(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y);






 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> normalize(
  vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> faceforward(
  vecType<T, P> const & N,
  vecType<T, P> const & I,
  vecType<T, P> const & Nref);
# 91 "/usr/local/include/glm/detail/func_geometric.hpp" 3
 template <typename genType>
               genType reflect(
  genType const & I,
  genType const & N);
# 104 "/usr/local/include/glm/detail/func_geometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> refract(
  vecType<T, P> const & I,
  vecType<T, P> const & N,
  T eta);


}


# 1 "/usr/local/include/glm/detail/func_geometric.inl" 1 3



# 1 "/usr/local/include/glm/detail/func_exponential.hpp" 1 3
# 13 "/usr/local/include/glm/detail/func_exponential.hpp" 3
# 1 "/usr/local/include/glm/detail/type_vec1.hpp" 1 3
# 17 "/usr/local/include/glm/detail/type_vec1.hpp" 3
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec1
 {


  typedef T value_type;
  typedef tvec1<T, P> type;
  typedef tvec1<bool, P> bool_type;
# 70 "/usr/local/include/glm/detail/type_vec1.hpp" 3
   union {T x, r, s;};
# 80 "/usr/local/include/glm/detail/type_vec1.hpp" 3
  typedef length_t length_type;
                static length_type length(){return 1;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                                   tvec1() ;
                                   tvec1(tvec1<T, P> const & v) ;
  template <precision Q>
                                   tvec1(tvec1<T, Q> const & v);



                                   explicit tvec1(ctor);
                                   explicit tvec1(T scalar);




  template <typename U, precision Q>
                                                tvec1(tvec2<U, Q> const & v);

  template <typename U, precision Q>
                                                tvec1(tvec3<U, Q> const & v);

  template <typename U, precision Q>
                                                tvec1(tvec4<U, Q> const & v);


  template <typename U, precision Q>
                                                tvec1(tvec1<U, Q> const & v);
# 126 "/usr/local/include/glm/detail/type_vec1.hpp" 3
                tvec1<T, P> & operator=(tvec1<T, P> const & v) ;

  template <typename U>
                tvec1<T, P> & operator=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator+=(U scalar);
  template <typename U>
                tvec1<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator-=(U scalar);
  template <typename U>
                tvec1<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator*=(U scalar);
  template <typename U>
                tvec1<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator/=(U scalar);
  template <typename U>
                tvec1<T, P> & operator/=(tvec1<U, P> const & v);



                tvec1<T, P> & operator++();
                tvec1<T, P> & operator--();
                tvec1<T, P> operator++(int);
                tvec1<T, P> operator--(int);



  template <typename U>
                tvec1<T, P> & operator%=(U scalar);
  template <typename U>
                tvec1<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator&=(U scalar);
  template <typename U>
                tvec1<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator|=(U scalar);
  template <typename U>
                tvec1<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator^=(U scalar);
  template <typename U>
                tvec1<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator<<=(U scalar);
  template <typename U>
                tvec1<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
                tvec1<T, P> & operator>>=(U scalar);
  template <typename U>
                tvec1<T, P> & operator>>=(tvec1<U, P> const & v);
 };



 template <typename T, precision P>
               tvec1<T, P> operator+(tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator-(tvec1<T, P> const & v);



 template <typename T, precision P>
               tvec1<T, P> operator+(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator+(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator-(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator-(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator- (tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator*(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator*(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator/(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator/(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator%(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator%(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator&(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator&(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator|(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator|(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator^(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator^(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator<<(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator<<(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator>>(tvec1<T, P> const & v, T scalar);

 template <typename T, precision P>
               tvec1<T, P> operator>>(T scalar, tvec1<T, P> const & v);

 template <typename T, precision P>
               tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               tvec1<T, P> operator~(tvec1<T, P> const & v);



 template <typename T, precision P>
               bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
               bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <precision P>
               tvec1<bool, P> operator&&(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2);

 template <precision P>
               tvec1<bool, P> operator||(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2);
}



# 1 "/usr/local/include/glm/detail/type_vec1.inl" 1 3



namespace glm
{



  template <typename T, precision P> inline
                                        tvec1<T, P>::tvec1()

    : x(0)

  {}



  template <typename T, precision P> inline
                                        tvec1<T, P>::tvec1(tvec1<T, P> const & v)
   : x(v.x)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                       tvec1<T, P>::tvec1(tvec1<T, Q> const & v)
  : x(v.x)
 {}



 template <typename T, precision P> inline
                                       tvec1<T, P>::tvec1(ctor)
 {}

 template <typename T, precision P> inline
                                       tvec1<T, P>::tvec1(T scalar)
  : x(scalar)
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec1<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec2<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec3<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q> inline
                                       tvec1<T, P>::tvec1(tvec4<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}



 template <typename T, precision P> inline
                    T & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec1.inl", 72, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_vec1.inl", 79, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                     tvec1<T, P> & tvec1<T, P>::operator=(tvec1<T, P> const & v)
  {
   this->x = v.x;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator=(tvec1<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec1<T, P> & tvec1<T, P>::operator++()
 {
  ++this->x;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> & tvec1<T, P>::operator--()
 {
  --this->x;
  return *this;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> tvec1<T, P>::operator++(int)
 {
  tvec1<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> tvec1<T, P>::operator--(int)
 {
  tvec1<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= U(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tvec1<T, P> & tvec1<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }



 template <typename T, precision P> inline
                    tvec1<T, P> operator+(tvec1<T, P> const & v)
 {
  return v;
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator-(tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   -v.x);
 }



 template <typename T, precision P> inline
                    tvec1<T, P> operator+(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x + scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator+(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar + v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x + v2.x);
 }


 template <typename T, precision P> inline
                    tvec1<T, P> operator-(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x - scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator-(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar - v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator-(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x - v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator*(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x * scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator*(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar * v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x * v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator/(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x / scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator/(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar / v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x / v2.x);
 }



 template <typename T, precision P> inline
                    tvec1<T, P> operator%(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x % scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator%(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar % v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x % v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator&(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x & scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator&(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar & v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x & v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator|(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x | scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator|(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar | v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x | v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator^(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x ^ scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator^(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar ^ v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x ^ v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator<<(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x << scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator<<(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar << v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x << v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator>>(tvec1<T, P> const & v, T scalar)
 {
  return tvec1<T, P>(
   v.x >> scalar);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator>>(T scalar, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   scalar >> v.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x >> v2.x);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> operator~(tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   ~v.x);
 }



 template <typename T, precision P> inline
                    bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return (v1.x == v2.x);
 }

 template <typename T, precision P> inline
                    bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return (v1.x != v2.x);
 }

 template <precision P> inline
                    tvec1<bool, P> operator&&(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2)
 {
  return tvec1<bool, P>(v1.x && v2.x);
 }

 template <precision P> inline
                    tvec1<bool, P> operator||(tvec1<bool, P> const & v1, tvec1<bool, P> const & v2)
 {
  return tvec1<bool, P>(v1.x || v2.x);
 }
}
# 301 "/usr/local/include/glm/detail/type_vec1.hpp" 2 3
# 13 "/usr/local/include/glm/detail/func_exponential.hpp" 2 3






namespace glm
{
# 32 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent);
# 42 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> exp(vecType<T, P> const & v);
# 54 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> log(vecType<T, P> const & v);
# 64 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> exp2(vecType<T, P> const & v);
# 75 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> log2(vecType<T, P> const & v);
# 87 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sqrt(vecType<T, P> const & v);
# 97 "/usr/local/include/glm/detail/func_exponential.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> inversesqrt(vecType<T, P> const & v);


}


# 1 "/usr/local/include/glm/detail/func_exponential.inl" 1 3



# 1 "/usr/local/include/glm/detail/func_vector_relational.hpp" 1 3
# 21 "/usr/local/include/glm/detail/func_vector_relational.hpp" 3
namespace glm
{
# 32 "/usr/local/include/glm/detail/func_vector_relational.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <precision P, template <typename, precision> class vecType>
               bool any(vecType<bool, P> const & v);







 template <precision P, template <typename, precision> class vecType>
               bool all(vecType<bool, P> const & v);
# 105 "/usr/local/include/glm/detail/func_vector_relational.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<bool, P> not_(vecType<bool, P> const & v);


}


# 1 "/usr/local/include/glm/detail/func_vector_relational.inl" 1 3





namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 11, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];

  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 23, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 34, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 45, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 56, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/func_vector_relational.inl", 67, "x.length() == y.length()") : (void)0);

  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType> inline
                    bool any(vecType<bool, P> const & v)
 {
  bool Result = false;
  for(length_t i = 0; i < v.length(); ++i)
   Result = Result || v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType> inline
                    bool all(vecType<bool, P> const & v)
 {
  bool Result = true;
  for(length_t i = 0; i < v.length(); ++i)
   Result = Result && v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> not_(vecType<bool, P> const & v)
 {
  vecType<bool, P> Result(uninitialize);
  for(length_t i = 0; i < v.length(); ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 111 "/usr/local/include/glm/detail/func_vector_relational.hpp" 2 3
# 4 "/usr/local/include/glm/detail/func_exponential.inl" 2 3

# 1 "/usr/local/include/glm/detail/_vectorize.hpp" 1 3
# 11 "/usr/local/include/glm/detail/_vectorize.hpp" 3
namespace glm{
namespace detail
{
 template <typename R, typename T, precision P, template <typename, precision> class vecType>
 struct functor1{};

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec1>
 { inline
                     static tvec1<R, P> call(R (*Func) (T x), tvec1<T, P> const & v)
  {
   return tvec1<R, P>(Func(v.x));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec2>
 { inline
                     static tvec2<R, P> call(R (*Func) (T x), tvec2<T, P> const & v)
  {
   return tvec2<R, P>(Func(v.x), Func(v.y));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec3>
 { inline
                     static tvec3<R, P> call(R (*Func) (T x), tvec3<T, P> const & v)
  {
   return tvec3<R, P>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec4>
 { inline
                     static tvec4<R, P> call(R (*Func) (T x), tvec4<T, P> const & v)
  {
   return tvec4<R, P>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct functor2{};

 template <typename T, precision P>
 struct functor2<T, P, tvec1>
 { inline
                     static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, tvec1<T, P> const & b)
  {
   return tvec1<T, P>(Func(a.x, b.x));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec2>
 { inline
                     static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, tvec2<T, P> const & b)
  {
   return tvec2<T, P>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec3>
 { inline
                     static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, tvec3<T, P> const & b)
  {
   return tvec3<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct functor2_vec_sca{};

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec1>
 { inline
                     static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, T b)
  {
   return tvec1<T, P>(Func(a.x, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec2>
 { inline
                     static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, T b)
  {
   return tvec2<T, P>(Func(a.x, b), Func(a.y, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec3>
 { inline
                     static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, T b)
  {
   return tvec3<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, T b)
  {
   return tvec4<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };
}
}
# 5 "/usr/local/include/glm/detail/func_exponential.inl" 2 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 8 "/usr/local/include/glm/detail/func_exponential.inl" 2 3


namespace glm{
namespace detail
{



  template <typename genType>
  genType log2(genType Value)
  {
   return std::log(Value) * static_cast<genType>(1.4426950408889634073599246810019);
  }


 template <typename T, precision P, template <class, precision> class vecType, bool isFloat, bool Aligned>
 struct compute_log2
 { inline
                     static vecType<T, P> call(vecType<T, P> const & vec)
  {
   return detail::functor1<T, T, P, vecType>::call(log2, vec);
  }
 };

 template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_sqrt
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(std::sqrt, x);
  }
 };

 template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_inversesqrt
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template <template <class, precision> class vecType, bool Aligned>
 struct compute_inversesqrt<vecType, float, lowp, Aligned>
 { inline
                     static vecType<float, lowp> call(vecType<float, lowp> const & x)
  {
   vecType<float, lowp> tmp(x);
   vecType<float, lowp> xhalf(tmp * 0.5f);
   vecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));
   vecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));
   vecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent)
 {
  return detail::functor2<T, P, vecType>::call(pow, base, exponent);
 }


 using std::exp;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> exp(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(exp, x);
 }


 using std::log;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> log(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(log, x);
 }


 template <typename genType> inline
                    genType exp2(genType x)
 {
                                                                                                        ;

  return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> exp2(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(exp2, x);
 }


 template <typename genType> inline
                    genType log2(genType x)
 {
  return log2(tvec1<genType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> log2(vecType<T, P> const & x)
 {
  return detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
 }


 using std::sqrt;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sqrt(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::compute_sqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> inversesqrt(vecType<T, P> const & x)
 {
                                                                                                         ;
  return detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
 }
}
# 103 "/usr/local/include/glm/detail/func_exponential.hpp" 2 3
# 4 "/usr/local/include/glm/detail/func_geometric.inl" 2 3

# 1 "/usr/local/include/glm/detail/func_common.hpp" 1 3
# 16 "/usr/local/include/glm/detail/func_common.hpp" 3
# 1 "/usr/local/include/glm/detail/_fixes.hpp" 1 3
# 16 "/usr/local/include/glm/detail/func_common.hpp" 2 3


namespace glm
{
# 29 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType abs(genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> abs(vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sign(vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> floor(vecType<T, P> const & x);
# 60 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> trunc(vecType<T, P> const & x);
# 73 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> round(vecType<T, P> const & x);
# 85 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> roundEven(vecType<T, P> const & x);
# 95 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> ceil(vecType<T, P> const & x);







 template <typename genType>
               genType fract(genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fract(vecType<T, P> const & x);
# 117 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType mod(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y);
# 135 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType modf(genType x, genType & i);







 template <typename genType>
               genType min(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> min(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> min(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename genType>
               genType max(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> max(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> max(vecType<T, P> const & x, vecType<T, P> const & y);
# 175 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType clamp(genType x, genType minVal, genType maxVal);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal);
# 226 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a);

 template <typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a);

 template <typename genTypeT, typename genTypeU>
               genTypeT mix(genTypeT x, genTypeT y, genTypeU a);





 template <typename genType>
               genType step(genType edge, genType x);





 template <template <typename, precision> class vecType, typename T, precision P>
               vecType<T, P> step(T edge, vecType<T, P> const & x);





 template <template <typename, precision> class vecType, typename T, precision P>
               vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x);
# 270 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType>
               genType smoothstep(genType edge0, genType edge1, genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x);

 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x);
# 291 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isnan(vecType<T, P> const & x);
# 304 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isinf(vecType<T, P> const & x);







               int floatBitsToInt(float const & v);







 template <template <typename, precision> class vecType, precision P>
               vecType<int, P> floatBitsToInt(vecType<float, P> const & v);







               uint floatBitsToUint(float const & v);







 template <template <typename, precision> class vecType, precision P>
               vecType<uint, P> floatBitsToUint(vecType<float, P> const & v);
# 349 "/usr/local/include/glm/detail/func_common.hpp" 3
               float intBitsToFloat(int const & v);
# 359 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <template <typename, precision> class vecType, precision P>
               vecType<float, P> intBitsToFloat(vecType<int, P> const & v);
# 370 "/usr/local/include/glm/detail/func_common.hpp" 3
               float uintBitsToFloat(uint const & v);
# 380 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <template <typename, precision> class vecType, precision P>
               vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v);







 template <typename genType>
               genType fma(genType const & a, genType const & b, genType const & c);
# 406 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType, typename genIType>
               genType frexp(genType const & x, genIType & exp);
# 420 "/usr/local/include/glm/detail/func_common.hpp" 3
 template <typename genType, typename genIType>
               genType ldexp(genType const & x, genIType const & exp);


}


# 1 "/usr/local/include/glm/detail/func_common.inl" 1 3
# 11 "/usr/local/include/glm/detail/func_common.inl" 3
namespace glm
{

 template <typename genType> inline
                    genType min(genType x, genType y)
 {
                                                                                                                                                                                          ;
  return x < y ? x : y;
 }


 template <typename genType> inline
                    genType max(genType x, genType y)
 {
                                                                                                                                                                                          ;

  return x > y ? x : y;
 }


 template <> inline
                    int32 abs(int32 x)
 {
  int32 const y = x >> 31;
  return (x ^ y) - y;
 }





  template <typename genType> inline
                     genType round(genType x)
  {
                                                                                                          ;

   return x < static_cast<genType>(0) ? static_cast<genType>(int(x - static_cast<genType>(0.5))) : static_cast<genType>(int(x + static_cast<genType>(0.5)));
  }






  template <typename genType> inline
                     genType trunc(genType x)
  {
                                                                                                          ;

   return x < static_cast<genType>(0) ? -std::floor(-x) : std::floor(x);
  }


}

namespace glm{
namespace detail
{
 template <typename genFIType, bool >
 struct compute_abs
 {};

 template <typename genFIType>
 struct compute_abs<genFIType, true>
 { inline
                     static genFIType call(genFIType x)
  {


                                                                           ;

   return x >= genFIType(0) ? x : -x;

  }
 };
# 98 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename genFIType>
 struct compute_abs<genFIType, false>
 { inline
                     static genFIType call(genFIType x)
  {


                                                                           ;
   return x;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_abs_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(abs, x);
  }
 };

 template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
  {
                                                                                                                                                     ;

   return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_vector<T, bool, P, vecType, Aligned>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<bool, P> const & a)
  {
   vecType<T, P> Result(uninitialize);
   for(length_t i = 0; i < x.length(); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template <typename T, typename U, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_scalar
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, U const & a)
  {
                                                                                                                                                     ;

   return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mix_scalar<T, bool, P, vecType, Aligned>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, bool const & a)
  {
   return a ? y : x;
  }
 };

 template <typename T, typename U>
 struct compute_mix
 { inline
                     static T call(T const & x, T const & y, U const & a)
  {
                                                                                                                                                     ;

   return static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));
  }
 };

 template <typename T>
 struct compute_mix<T, bool>
 { inline
                     static T call(T const & x, T const & y, bool const & a)
  {
   return a ? y : x;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool isFloat, bool Aligned>
 struct compute_sign
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return vecType<T, P>(glm::lessThan(vecType<T, P>(0), x)) - vecType<T, P>(glm::lessThan(x, vecType<T, P>(0)));
  }
 };
# 205 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_floor
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(std::floor, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_ceil
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(std::ceil, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_fract
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return x - floor(x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_trunc
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(trunc, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_round
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
   return detail::functor1<T, T, P, vecType>::call(round, x);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_mod
 { inline
                     static vecType<T, P> call(vecType<T, P> const & a, vecType<T, P> const & b)
  {
                                                                                                                                                     ;
   return a - b * floor(a / b);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_min_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y)
  {
   return detail::functor2<T, P, vecType>::call(min, x, y);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_max_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y)
  {
   return detail::functor2<T, P, vecType>::call(max, x, y);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_clamp_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
  {
   return min(max(x, minVal), maxVal);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_step_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & edge, vecType<T, P> const & x)
  {
   return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, edge));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_smoothstep_vector
 { inline
                     static vecType<T, P> call(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
  {
                                                                                                                               ;
   vecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
   return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
  }
 };
}

 template <typename genFIType> inline
                    genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> abs(vecType<T, P> const & x)
 {
  return detail::compute_abs_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }



 template <typename genFIType> inline
                    genFIType sign(genFIType x)
 {


                                      ;

  return detail::compute_sign<genFIType, defaultp, tvec1, std::numeric_limits<genFIType>::is_iec559, highp>::call(tvec1<genFIType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sign(vecType<T, P> const & x)
 {


                                      ;

  return detail::compute_sign<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);
 }


 using ::std::floor;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> floor(vecType<T, P> const & x)
 {
                                                                                                    ;
  return detail::compute_floor<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> trunc(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::compute_trunc<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> round(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::compute_round<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }
# 377 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename genType> inline
                    genType roundEven(genType x)
 {
                                                                                                             ;

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> roundEven(vecType<T, P> const & x)
 {
                                                                                                       ;
  return detail::functor1<T, T, P, vecType>::call(roundEven, x);
 }


 using ::std::ceil;
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> ceil(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::compute_ceil<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType fract(genType x)
 {
  return fract(tvec1<genType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fract(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::compute_fract<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType mod(genType x, genType y)
 {





   return mod(tvec1<genType, defaultp>(x), y).x;

 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mod(vecType<T, P> const & x, T y)
 {
  return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(y));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return detail::compute_mod<T, P, vecType, detail::is_aligned<P>::value>::call(x, y);
 }


 template <typename genType> inline
                    genType modf(genType x, genType & i)
 {
                                                                                                        ;
  return std::modf(x, &i);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> modf(tvec1<T, P> const & x, tvec1<T, P> & i)
 {
  return tvec1<T, P>(
   modf(x.x, i.x));
 }

 template <typename T, precision P> inline
                    tvec2<T, P> modf(tvec2<T, P> const & x, tvec2<T, P> & i)
 {
  return tvec2<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> modf(tvec3<T, P> const & x, tvec3<T, P> & i)
 {
  return tvec3<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> modf(tvec4<T, P> const & x, tvec4<T, P> & i)
 {
  return tvec4<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 514 "/usr/local/include/glm/detail/func_common.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> min(vecType<T, P> const & a, T b)
 {
                                                                                                                                                    ;
  return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> min(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::compute_min_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
 }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> max(vecType<T, P> const & a, T b)
 {
                                                                                                                                                    ;
  return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, vecType<T, P>(b));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> max(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::compute_max_vector<T, P, vecType, detail::is_aligned<P>::value>::call(a, b);
 }


 template <typename genType> inline
                    genType clamp(genType x, genType minVal, genType maxVal)
 {
                                                                                                                                                                                            ;
  return min(max(x, minVal), maxVal);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal)
 {
                                                                                                                                                                                ;
  return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, vecType<T, P>(minVal), vecType<T, P>(maxVal));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
 {
                                                                                                                                                                                ;
  return detail::compute_clamp_vector<T, P, vecType, detail::is_aligned<P>::value>::call(x, minVal, maxVal);
 }

 template <typename genTypeT, typename genTypeU> inline
                    genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template <typename T, typename U, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a)
 {
  return detail::compute_mix_scalar<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
 }

 template <typename T, typename U, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
 {
  return detail::compute_mix_vector<T, U, P, vecType, detail::is_aligned<P>::value>::call(x, y, a);
 }


 template <typename genType> inline
                    genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), glm::lessThan(x, edge));
 }

 template <template <typename, precision> class vecType, typename T, precision P> inline
                    vecType<T, P> step(T edge, vecType<T, P> const & x)
 {
  return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge), x);
 }

 template <template <typename, precision> class vecType, typename T, precision P> inline
                    vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x)
 {
  return detail::compute_step_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge, x);
 }


 template <typename genType> inline
                    genType smoothstep(genType edge0, genType edge1, genType x)
 {
                                                                                                                                          ;

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x)
 {
  return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(vecType<T, P>(edge0), vecType<T, P>(edge1), x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
 {
  return detail::compute_smoothstep_vector<T, P, vecType, detail::is_aligned<P>::value>::call(edge0, edge1, x);
 }




  template <typename genType> inline
                     bool isnan(genType x)
  {
                                                                                                          ;
# 645 "/usr/local/include/glm/detail/func_common.inl" 3
    return std::isnan(x);

  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isnan(vecType<T, P> const & x)
 {
                                                                                                   ;

  return detail::functor1<bool, T, P, vecType>::call(isnan, x);
 }




  template <typename genType> inline
                     bool isinf(genType x)
  {
                                                                                                          ;
# 678 "/usr/local/include/glm/detail/func_common.inl" 3
     return std::isinf(x);







 }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isinf(vecType<T, P> const & x)
 {
                                                                                                   ;

  return detail::functor1<bool, T, P, vecType>::call(isinf, x);
 } inline

                    int floatBitsToInt(float const & v)
 {
  return reinterpret_cast<int&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<int, P> floatBitsToInt(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));
 } inline

                    uint floatBitsToUint(float const & v)
 {
  return reinterpret_cast<uint&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<uint, P> floatBitsToUint(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));
 } inline

                    float intBitsToFloat(int const & v)
 {
  return reinterpret_cast<float&>(const_cast<int&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<float, P> intBitsToFloat(vecType<int, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));
 } inline

                    float uintBitsToFloat(uint const & v)
 {
  return reinterpret_cast<float&>(const_cast<uint&>(v));
 }

 template <template <typename, precision> class vecType, precision P> inline
                    vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));
 }

 template <typename genType> inline
                    genType fma(genType const & a, genType const & b, genType const & c)
 {
  return a * b + c;
 }

 template <typename genType> inline
                    genType frexp(genType x, int & exp)
 {
                                                                                                                                     ;

  return std::frexp(x, &exp);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> frexp(tvec1<T, P> const & x, tvec1<int, P> & exp)
 {
                                                                                                                               ;

  return tvec1<T, P>(std::frexp(x.x, &exp.x));
 }

 template <typename T, precision P> inline
                    tvec2<T, P> frexp(tvec2<T, P> const & x, tvec2<int, P> & exp)
 {
                                                                                                                               ;

  return tvec2<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> frexp(tvec3<T, P> const & x, tvec3<int, P> & exp)
 {
                                                                                                                               ;

  return tvec3<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> frexp(tvec4<T, P> const & x, tvec4<int, P> & exp)
 {
                                                                                                                               ;

  return tvec4<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z),
   frexp(x.w, exp.w));
 }

 template <typename genType> inline
                    genType ldexp(genType const & x, int const & exp)
 {
                                                                                                                                     ;

  return std::ldexp(x, exp);
 }

 template <typename T, precision P> inline
                    tvec1<T, P> ldexp(tvec1<T, P> const & x, tvec1<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec1<T, P>(
   ldexp(x.x, exp.x));
 }

 template <typename T, precision P> inline
                    tvec2<T, P> ldexp(tvec2<T, P> const & x, tvec2<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec2<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> ldexp(tvec3<T, P> const & x, tvec3<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec3<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> ldexp(tvec4<T, P> const & x, tvec4<int, P> const & exp)
 {
                                                                                                                               ;

  return tvec4<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z),
   ldexp(x.w, exp.w));
 }
}
# 426 "/usr/local/include/glm/detail/func_common.hpp" 2 3
# 5 "/usr/local/include/glm/detail/func_geometric.inl" 2 3





namespace glm{
namespace detail
{
 template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_length
 { inline
                     static T call(vecType<T, P> const & v)
  {
   return sqrt(dot(v, v));
  }
 };

 template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_distance
 { inline
                     static T call(vecType<T, P> const & p0, vecType<T, P> const & p1)
  {
   return length(p1 - p0);
  }
 };

 template <template <class, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_dot{};

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec1, T, P, Aligned>
 { inline
                     static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)
  {
   return a.x * b.x;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec2, T, P, Aligned>
 { inline
                     static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)
  {
   tvec2<T, P> tmp(x * y);
   return tmp.x + tmp.y;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec3, T, P, Aligned>
 { inline
                     static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)
  {
   tvec3<T, P> tmp(x * y);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_dot<tvec4, T, P, Aligned>
 { inline
                     static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)
  {
   tvec4<T, P> tmp(x * y);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_cross
 { inline
                     static tvec3<T, P> call(tvec3<T, P> const & x, tvec3<T, P> const & y)
  {
                                                                                                     ;

   return tvec3<T, P>(
    x.y * y.z - y.y * x.z,
    x.z * y.x - y.z * x.x,
    x.x * y.y - y.x * x.y);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_normalize
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v)
  {
                                                                                                         ;

   return v * inversesqrt(dot(v, v));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_faceforward
 { inline
                     static vecType<T, P> call(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)
  {
                                                                                                         ;

   return dot(Nref, I) < static_cast<T>(0) ? N : -N;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_reflect
 { inline
                     static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N)
  {
   return I - N * dot(N, I) * static_cast<T>(2);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_refract
 { inline
                     static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
  {
   T const dotValue(dot(N, I));
   T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
   return (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));
  }
 };
}


 template <typename genType> inline
                    genType length(genType x)
 {
                                                                                                           ;

  return abs(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T length(vecType<T, P> const & v)
 {
                                                                                                     ;

  return detail::compute_length<vecType, T, P, detail::is_aligned<P>::value>::call(v);
 }


 template <typename genType> inline
                    genType distance(genType const & p0, genType const & p1)
 {
                                                                                                             ;

  return length(p1 - p0);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)
 {
  return detail::compute_distance<vecType, T, P, detail::is_aligned<P>::value>::call(p0, p1);
 }


 template <typename T> inline
                    T dot(T x, T y)
 {
                                                                                                  ;
  return x * y;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T dot(vecType<T, P> const & x, vecType<T, P> const & y)
 {
                                                                                                  ;
  return detail::compute_dot<vecType, T, P, detail::is_aligned<P>::value>::call(x, y);
 }


 template <typename T, precision P> inline
                    tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)
 {
  return detail::compute_cross<T, P, detail::is_aligned<P>::value>::call(x, y);
 }


 template <typename genType> inline
                    genType normalize(genType const & x)
 {
                                                                                                              ;

  return x < genType(0) ? genType(-1) : genType(1);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> normalize(vecType<T, P> const & x)
 {
                                                                                                        ;

  return detail::compute_normalize<T, P, vecType, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType faceforward(genType const & N, genType const & I, genType const & Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> faceforward(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)
 {
  return detail::compute_faceforward<T, P, vecType, detail::is_aligned<P>::value>::call(N, I, Nref);
 }


 template <typename genType> inline
                    genType reflect(genType const & I, genType const & N)
 {
  return I - N * dot(N, I) * genType(2);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> reflect(vecType<T, P> const & I, vecType<T, P> const & N)
 {
  return detail::compute_reflect<T, P, vecType, detail::is_aligned<P>::value>::call(I, N);
 }


 template <typename genType> inline
                    genType refract(genType const & I, genType const & N, genType eta)
 {
                                                                                                            ;
  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
 {
                                                                                                      ;
  return detail::compute_refract<T, P, vecType, detail::is_aligned<P>::value>::call(I, N, eta);
 }
}
# 113 "/usr/local/include/glm/detail/func_geometric.hpp" 2 3
# 6 "/usr/local/include/glm/detail/../geometric.hpp" 2 3
# 4 "/usr/local/include/glm/detail/func_matrix.inl" 2 3



namespace glm{
namespace detail
{
 template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_matrixCompMult
 { inline
                     static matType<T, P> call(matType<T, P> const& x, matType<T, P> const& y)
  {
   matType<T, P> result(uninitialize);
   for(length_t i = 0; i < result.length(); ++i)
    result[i] = x[i] * y[i];
   return result;
  }
 };

 template <template <class, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_transpose{};

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat2x2, T, P, Aligned>
 { inline
                     static tmat2x2<T, P> call(tmat2x2<T, P> const & m)
  {
   tmat2x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat2x3, T, P, Aligned>
 { inline
                     static tmat3x2<T, P> call(tmat2x3<T, P> const & m)
  {
   tmat3x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat2x4, T, P, Aligned>
 { inline
                     static tmat4x2<T, P> call(tmat2x4<T, P> const & m)
  {
   tmat4x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat3x2, T, P, Aligned>
 { inline
                     static tmat2x3<T, P> call(tmat3x2<T, P> const & m)
  {
   tmat2x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat3x3, T, P, Aligned>
 { inline
                     static tmat3x3<T, P> call(tmat3x3<T, P> const & m)
  {
   tmat3x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat3x4, T, P, Aligned>
 { inline
                     static tmat4x3<T, P> call(tmat3x4<T, P> const & m)
  {
   tmat4x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat4x2, T, P, Aligned>
 { inline
                     static tmat2x4<T, P> call(tmat4x2<T, P> const & m)
  {
   tmat2x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat4x3, T, P, Aligned>
 { inline
                     static tmat3x4<T, P> call(tmat4x3<T, P> const & m)
  {
   tmat3x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];
   return result;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_transpose<tmat4x4, T, P, Aligned>
 { inline
                     static tmat4x4<T, P> call(tmat4x4<T, P> const & m)
  {
   tmat4x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];

   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   result[3][3] = m[3][3];
   return result;
  }
 };

 template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_determinant{};

 template <typename T, precision P, bool Aligned>
 struct compute_determinant<tmat2x2, T, P, Aligned>
 { inline
                     static T call(tmat2x2<T, P> const & m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_determinant<tmat3x3, T, P, Aligned>
 { inline
                     static T call(tmat3x3<T, P> const & m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_determinant<tmat4x4, T, P, Aligned>
 { inline
                     static T call(tmat4x4<T, P> const & m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   tvec4<T, P> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };

 template <template <typename, precision> class matType, typename T, precision P, bool Aligned>
 struct compute_inverse{};

 template <typename T, precision P, bool Aligned>
 struct compute_inverse<tmat2x2, T, P, Aligned>
 { inline
                     static tmat2x2<T, P> call(tmat2x2<T, P> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   tmat2x2<T, P> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_inverse<tmat3x3, T, P, Aligned>
 { inline
                     static tmat3x3<T, P> call(tmat3x3<T, P> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   tmat3x3<T, P> Inverse(uninitialize);
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_inverse<tmat4x4, T, P, Aligned>
 { inline
                     static tmat4x4<T, P> call(tmat4x4<T, P> const& m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   tvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);
   tvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);
   tvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);
   tvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);
   tvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);
   tvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);

   tvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   tvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   tvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   tvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   tvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   tvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   tvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   tvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   tvec4<T, P> SignA(+1, -1, +1, -1);
   tvec4<T, P> SignB(-1, +1, -1, +1);
   tmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   tvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   tvec4<T, P> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };
}

 template <typename T, precision P, template <typename, precision> class matType> inline
                    matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y)
 {
                                                                                                                                        ;
  return detail::compute_matrixCompMult<matType, T, P, detail::is_aligned<P>::value>::call(x, y);
 }

 template<typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB> inline
                    typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r)
 {
                                                                                                                                      ;

  typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type m(uninitialize);
  for(length_t i = 0; i < m.length(); ++i)
   m[i] = c * r[i];
  return m;
 }

 template <typename T, precision P, template <typename, precision> class matType> inline
                    typename matType<T, P>::transpose_type transpose(matType<T, P> const & m)
 {
                                                                                                                                   ;
  return detail::compute_transpose<matType, T, P, detail::is_aligned<P>::value>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType> inline
                    T determinant(matType<T, P> const & m)
 {
                                                                                                                                     ;
  return detail::compute_determinant<matType, T, P, detail::is_aligned<P>::value>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType> inline
                    matType<T, P> inverse(matType<T, P> const & m)
 {
                                                                                                                                 ;
  return detail::compute_inverse<matType, T, P, detail::is_aligned<P>::value>::call(m);
 }
}
# 149 "/usr/local/include/glm/detail/func_matrix.hpp" 2 3
# 4 "/usr/local/include/glm/detail/type_mat2x2.inl" 2 3


namespace glm
{



  template <typename T, precision P> inline
                     tmat2x2<T, P>::tmat2x2()
  {

    this->value[0] = col_type(1, 0);
    this->value[1] = col_type(0, 1);

  }



  template <typename T, precision P> inline
                     tmat2x2<T, P>::tmat2x2(tmat2x2<T, P> const & m)
  {
   this->value[0] = m.value[0];
   this->value[1] = m.value[1];
  }


 template <typename T, precision P>
 template <precision Q> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P> inline
                                       tmat2x2<T, P>::tmat2x2(ctor)
 {}

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(T scalar)
 {
  this->value[0] = col_type(scalar, 0);
  this->value[1] = col_type(0, scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <typename X1, typename Y1, typename X2, typename Y2> inline
                    tmat2x2<T, P>::tmat2x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2> inline
                    tmat2x2<T, P>::tmat2x2(tvec2<V1, P> const & v1, tvec2<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }



 template <typename T, precision P>
 template <typename U, precision Q> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat3x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat4x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>::tmat2x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }



 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i)
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x2.inl", 160, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type const & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/detail/type_mat2x2.inl", 167, "i < this->length()") : (void)0);
  return this->value[i];
 }




  template <typename T, precision P> inline
                     tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<T, P> const & m)
  {
   this->value[0] = m[0];
   this->value[1] = m[1];
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator+=(U scalar)
 {
  this->value[0] += scalar;
  this->value[1] += scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator+=(tmat2x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator-=(U scalar)
 {
  this->value[0] -= scalar;
  this->value[1] -= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator-=(tmat2x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator*=(U scalar)
 {
  this->value[0] *= scalar;
  this->value[1] *= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator*=(tmat2x2<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator/=(U scalar)
 {
  this->value[0] /= scalar;
  this->value[1] /= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator/=(tmat2x2<U, P> const & m)
 {
  return *this *= inverse(m);
 }



 template <typename T, precision P> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P>& tmat2x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> tmat2x2<T, P>::operator++(int)
 {
  tmat2x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> tmat2x2<T, P>::operator--(int)
 {
  tmat2x2<T, P> Result(*this);
  --*this;
  return Result;
 }



 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(tmat2x2<T, P> const & m)
 {
  return m;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   -m[0],
   -m[1]);
 }



 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   scalar - m[0],
   scalar - m[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type operator*
 (
  tmat2x2<T, P> const & m,
  typename tmat2x2<T, P>::row_type const & v
 )
 {
  return tvec2<T, P>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::row_type operator*
 (
  typename tmat2x2<T, P>::col_type const & v,
  tmat2x2<T, P> const & m
 )
 {
  return tvec2<T, P>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T scalar)
 {
  return tmat2x2<T, P>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator/(T scalar, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   scalar / m[0],
   scalar / m[1]);
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v)
 {
  return inverse(m) * v;
 }

 template <typename T, precision P> inline
                    typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m)
 {
  return v * inverse(m);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  tmat2x2<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }



 template <typename T, precision P> inline
                    bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P> inline
                    bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 182 "/usr/local/include/glm/detail/type_mat2x2.hpp" 2 3
# 6 "/usr/local/include/glm/mat2x2.hpp" 2 3


namespace glm
{





 typedef tmat2x2<float, lowp> lowp_mat2;






 typedef tmat2x2<float, mediump> mediump_mat2;






 typedef tmat2x2<float, highp> highp_mat2;






 typedef tmat2x2<float, lowp> lowp_mat2x2;






 typedef tmat2x2<float, mediump> mediump_mat2x2;






 typedef tmat2x2<float, highp> highp_mat2x2;

}
# 71 "/usr/local/include/glm/glm.hpp" 2 3
# 81 "/usr/local/include/glm/glm.hpp" 3
# 1 "/usr/local/include/glm/trigonometric.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_trigonometric.hpp" 1 3
# 20 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
namespace glm
{
# 31 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
                             vecType<T, P> radians(vecType<T, P> const & degrees);







 template <typename T, precision P, template <typename, precision> class vecType>
                             vecType<T, P> degrees(vecType<T, P> const & radians);
# 50 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sin(vecType<T, P> const & angle);
# 60 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> cos(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> tan(vecType<T, P> const & angle);
# 80 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> asin(vecType<T, P> const & x);
# 91 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> acos(vecType<T, P> const & x);
# 104 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> atan(vecType<T, P> const & y, vecType<T, P> const & x);
# 114 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> atan(vecType<T, P> const & y_over_x);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sinh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> cosh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> tanh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> asinh(vecType<T, P> const & x);
# 160 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> acosh(vecType<T, P> const & x);
# 170 "/usr/local/include/glm/detail/func_trigonometric.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> atanh(vecType<T, P> const & x);


}


# 1 "/usr/local/include/glm/detail/func_trigonometric.inl" 1 3







namespace glm
{

 template <typename genType> inline
                                  genType radians(genType degrees)
 {
                                                                                                          ;

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                                  vecType<T, P> radians(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(radians, v);
 }


 template <typename genType> inline
                                  genType degrees(genType radians)
 {
                                                                                                          ;

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                                  vecType<T, P> degrees(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(degrees, v);
 }


 using ::std::sin;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sin(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(sin, v);
 }


 using std::cos;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cos(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(cos, v);
 }


 using std::tan;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> tan(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(tan, v);
 }


 using std::asin;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asin(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(asin, v);
 }


 using std::acos;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acos(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(acos, v);
 }


 template <typename genType> inline
                    genType atan(genType y, genType x)
 {
                                                                                                       ;

  return ::std::atan2(y, x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> atan(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::functor2<T, P, vecType>::call(::std::atan2, a, b);
 }

 using std::atan;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> atan(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(atan, v);
 }


 using std::sinh;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sinh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(sinh, v);
 }


 using std::cosh;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cosh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(cosh, v);
 }


 using std::tanh;

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> tanh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(tanh, v);
 }





  template <typename genType> inline
                     genType asinh(genType x)
  {
                                                                                                         ;

   return (x < static_cast<genType>(0) ? static_cast<genType>(-1) : (x > static_cast<genType>(0) ? static_cast<genType>(1) : static_cast<genType>(0))) * log(std::abs(x) + sqrt(static_cast<genType>(1) + x * x));
  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asinh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(asinh, v);
 }





  template <typename genType> inline
                     genType acosh(genType x)
  {
                                                                                                         ;

   if(x < static_cast<genType>(1))
    return static_cast<genType>(0);
   return log(x + sqrt(x * x - static_cast<genType>(1)));
  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acosh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(acosh, v);
 }





  template <typename genType> inline
                     genType atanh(genType x)
  {
                                                                                                         ;

   if(std::abs(x) >= static_cast<genType>(1))
    return 0;
   return static_cast<genType>(0.5) * log((static_cast<genType>(1) + x) / (static_cast<genType>(1) - x));
  }


 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> atanh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(atanh, v);
 }
}
# 176 "/usr/local/include/glm/detail/func_trigonometric.hpp" 2 3
# 6 "/usr/local/include/glm/trigonometric.hpp" 2 3
# 81 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/exponential.hpp" 1 3
# 82 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/common.hpp" 1 3
# 83 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/packing.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_packing.hpp" 1 3
# 17 "/usr/local/include/glm/detail/func_packing.hpp" 3
namespace glm
{
# 33 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packUnorm2x16(vec2 const & v);
# 46 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packSnorm2x16(vec2 const & v);
# 59 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packUnorm4x8(vec4 const & v);
# 72 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packSnorm4x8(vec4 const & v);
# 85 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec2 unpackUnorm2x16(uint p);
# 98 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec2 unpackSnorm2x16(uint p);
# 111 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec4 unpackUnorm4x8(uint p);
# 124 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec4 unpackSnorm4x8(uint p);
# 134 "/usr/local/include/glm/detail/func_packing.hpp" 3
               double packDouble2x32(uvec2 const & v);
# 143 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uvec2 unpackDouble2x32(double v);
# 153 "/usr/local/include/glm/detail/func_packing.hpp" 3
               uint packHalf2x16(vec2 const & v);
# 163 "/usr/local/include/glm/detail/func_packing.hpp" 3
               vec2 unpackHalf2x16(uint v);


}


# 1 "/usr/local/include/glm/detail/func_packing.inl" 1 3




# 1 "/usr/local/include/glm/detail/type_half.hpp" 1 3







namespace glm{
namespace detail
{
 typedef short hdata;

               float toFloat32(hdata value);
               hdata toFloat16(float const & value);

}
}


# 1 "/usr/local/include/glm/detail/type_half.inl" 1 3



namespace glm{
namespace detail
{ inline
                    float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f *= f;
  return f;
 }

 union uif32
 { inline
                     uif32() :
   i(0)
  {} inline

                     uif32(float f_) :
   f(f_)
  {} inline

                     uif32(uint32 i_) :
   i(i_)
  {}

  float f;
  uint32 i;
 }; inline

                    float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = (unsigned int)(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = (unsigned int)((s << 31) | (e << 23) | m);
  return Result.f;
 } inline

                    hdata toFloat16(float const & f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = (int)Entry.i;
# 124 "/usr/local/include/glm/detail/type_half.inl" 3
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 144 "/usr/local/include/glm/detail/type_half.inl" 3
    return hdata(s);
   }
# 154 "/usr/local/include/glm/detail/type_half.inl" 3
   m = (m | 0x00800000) >> (1 - e);
# 165 "/usr/local/include/glm/detail/type_half.inl" 3
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 196 "/usr/local/include/glm/detail/type_half.inl" 3
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 212 "/usr/local/include/glm/detail/type_half.inl" 3
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 19 "/usr/local/include/glm/detail/type_half.hpp" 2 3
# 5 "/usr/local/include/glm/detail/func_packing.inl" 2 3



namespace glm
{ inline
                    uint packUnorm2x16(vec2 const & v)
 {
  union
  {
   u16 in[2];
   uint out;
  } u;

  u16vec2 result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 } inline

                    vec2 unpackUnorm2x16(uint p)
 {
  union
  {
   uint in;
   u16 out[2];
  } u;

  u.in = p;

  return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
 } inline

                    uint packSnorm2x16(vec2 const & v)
 {
  union
  {
   i16 in[2];
   uint out;
  } u;

  i16vec2 result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 } inline

                    vec2 unpackSnorm2x16(uint p)
 {
  union
  {
   uint in;
   i16 out[2];
  } u;

  u.in = p;

  return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
 } inline

                    uint packUnorm4x8(vec4 const & v)
 {
  union
  {
   u8 in[4];
   uint out;
  } u;

  u8vec4 result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 } inline

                    vec4 unpackUnorm4x8(uint p)
 {
  union
  {
   uint in;
   u8 out[4];
  } u;

  u.in = p;

  return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
 } inline

                    uint packSnorm4x8(vec4 const & v)
 {
  union
  {
   i8 in[4];
   uint out;
  } u;

  i8vec4 result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 } inline

                    glm::vec4 unpackSnorm4x8(uint p)
 {
  union
  {
   uint in;
   i8 out[4];
  } u;

  u.in = p;

  return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
 } inline

                    double packDouble2x32(uvec2 const & v)
 {
  union
  {
   uint in[2];
   double out;
  } u;

  u.in[0] = v[0];
  u.in[1] = v[1];

  return u.out;
 } inline

                    uvec2 unpackDouble2x32(double v)
 {
  union
  {
   double in;
   uint out[2];
  } u;

  u.in = v;

  return uvec2(u.out[0], u.out[1]);
 } inline

                    uint packHalf2x16(vec2 const & v)
 {
  union
  {
   i16 in[2];
   uint out;
  } u;

  u.in[0] = detail::toFloat16(v.x);
  u.in[1] = detail::toFloat16(v.y);

  return u.out;
 } inline

                    vec2 unpackHalf2x16(uint v)
 {
  union
  {
   uint in;
   i16 out[2];
  } u;

  u.in = v;

  return vec2(
   detail::toFloat32(u.out[0]),
   detail::toFloat32(u.out[1]));
 }
}
# 168 "/usr/local/include/glm/detail/func_packing.hpp" 2 3
# 6 "/usr/local/include/glm/packing.hpp" 2 3
# 84 "/usr/local/include/glm/glm.hpp" 2 3


# 1 "/usr/local/include/glm/matrix.hpp" 1 3
# 86 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/vector_relational.hpp" 1 3
# 87 "/usr/local/include/glm/glm.hpp" 2 3

# 1 "/usr/local/include/glm/integer.hpp" 1 3





# 1 "/usr/local/include/glm/detail/func_integer.hpp" 1 3
# 20 "/usr/local/include/glm/detail/func_integer.hpp" 3
namespace glm
{
# 33 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<uint, P> uaddCarry(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & carry);
# 47 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<uint, P> usubBorrow(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & borrow);
# 61 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               void umulExtended(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & msb,
  vecType<uint, P> & lsb);
# 76 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               void imulExtended(
  vecType<int, P> const & x,
  vecType<int, P> const & y,
  vecType<int, P> & msb,
  vecType<int, P> & lsb);
# 98 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldExtract(
  vecType<T, P> const & Value,
  int Offset,
  int Bits);
# 118 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldInsert(
  vecType<T, P> const & Base,
  vecType<T, P> const & Insert,
  int Offset,
  int Bits);
# 133 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldReverse(vecType<T, P> const & v);







 template <typename genType>
               int bitCount(genType v);







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> bitCount(vecType<T, P> const & v);
# 162 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename genIUType>
               int findLSB(genIUType x);
# 173 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> findLSB(vecType<T, P> const & v);
# 185 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename genIUType>
               int findMSB(genIUType x);
# 197 "/usr/local/include/glm/detail/func_integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> findMSB(vecType<T, P> const & v);


}


# 1 "/usr/local/include/glm/detail/func_integer.inl" 1 3
# 20 "/usr/local/include/glm/detail/func_integer.inl" 3
#pragma clang diagnostic ignored "-Wc++11-long-long"



namespace glm{
namespace detail
{
 template <typename T> inline
                    T mask(T Bits)
 {
  return Bits >= sizeof(T) * 8 ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
 struct compute_bitfieldReverseStep
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T, T)
  {
   return v;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
 struct compute_bitfieldReverseStep<T, P, vecType, Aligned, true>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned, bool EXEC>
 struct compute_bitfieldBitCountStep
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T, T)
  {
   return v;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, bool Aligned>
 struct compute_bitfieldBitCountStep<T, P, vecType, Aligned, true>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template <typename genIUType, size_t Bits>
 struct compute_findLSB
 { inline
                     static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 107 "/usr/local/include/glm/detail/func_integer.inl" 3
 template <typename T, glm::precision P, template <class, glm::precision> class vecType, bool EXEC = true>
 struct compute_findMSB_step_vec
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
 struct compute_findMSB_step_vec<T, P, vecType, false>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x, T)
  {
   return x;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, int>
 struct compute_findMSB_vec
 { inline
                     static vecType<int, P> call(vecType<T, P> const & vec)
  {
   vecType<T, P> x(vec);
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vecType<int, P>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 178 "/usr/local/include/glm/detail/func_integer.inl" 3
} inline


                    uint uaddCarry(uint const & x, uint const & y, uint & Carry)
 {
  uint64 const Value64(static_cast<uint64>(x) + static_cast<uint64>(y));
  uint64 const Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
  Carry = Value64 > Max32 ? 1u : 0u;
  return static_cast<uint32>(Value64 % (Max32 + static_cast<uint64>(1)));
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<uint, P> uaddCarry(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Carry)
 {
  vecType<uint64, P> Value64(vecType<uint64, P>(x) + vecType<uint64, P>(y));
  vecType<uint64, P> Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
  Carry = mix(vecType<uint32, P>(0), vecType<uint32, P>(1), greaterThan(Value64, Max32));
  return vecType<uint32,P>(Value64 % (Max32 + static_cast<uint64>(1)));
 } inline


                    uint usubBorrow(uint const & x, uint const & y, uint & Borrow)
 {
                                                                                    ;

  Borrow = x >= y ? static_cast<uint32>(0) : static_cast<uint32>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint32>((static_cast<int64>(1) << static_cast<int64>(32)) + (static_cast<int64>(y) - static_cast<int64>(x)));
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<uint, P> usubBorrow(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Borrow)
 {
  Borrow = mix(vecType<uint, P>(1), vecType<uint, P>(0), greaterThanEqual(x, y));
  vecType<uint, P> const YgeX(y - x);
  vecType<uint, P> const XgeY(vecType<uint32, P>((static_cast<int64>(1) << static_cast<int64>(32)) + (vecType<int64, P>(y) - vecType<int64, P>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 } inline


                    void umulExtended(uint const & x, uint const & y, uint & msb, uint & lsb)
 {
                                                                                    ;

  uint64 Value64 = static_cast<uint64>(x) * static_cast<uint64>(y);
  msb = static_cast<uint>(Value64 >> static_cast<uint64>(32));
  lsb = static_cast<uint>(Value64);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    void umulExtended(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & msb, vecType<uint, P> & lsb)
 {
                                                                                    ;

  vecType<uint64, P> Value64(vecType<uint64, P>(x) * vecType<uint64, P>(y));
  msb = vecType<uint32, P>(Value64 >> static_cast<uint64>(32));
  lsb = vecType<uint32, P>(Value64);
 } inline


                    void imulExtended(int x, int y, int & msb, int & lsb)
 {
                                                                                ;

  int64 Value64 = static_cast<int64>(x) * static_cast<int64>(y);
  msb = static_cast<int>(Value64 >> static_cast<int64>(32));
  lsb = static_cast<int>(Value64);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    void imulExtended(vecType<int, P> const & x, vecType<int, P> const & y, vecType<int, P> & msb, vecType<int, P> & lsb)
 {
                                                                                ;

  vecType<int64, P> Value64(vecType<int64, P>(x) * vecType<int64, P>(y));
  lsb = vecType<int32, P>(Value64 & static_cast<int64>(0xFFFFFFFF));
  msb = vecType<int32, P>((Value64 >> static_cast<int64>(32)) & static_cast<int64>(0xFFFFFFFF));
 }


 template <typename genIUType> inline
                    genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(tvec1<genIUType>(Value), Offset, Bits).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldExtract(vecType<T, P> const & Value, int Offset, int Bits)
 {
                                                                                                       ;

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template <typename genIUType> inline
                    genIUType bitfieldInsert(genIUType const & Base, genIUType const & Insert, int Offset, int Bits)
 {
  return bitfieldInsert(tvec1<genIUType>(Base), tvec1<genIUType>(Insert), Offset, Bits).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldInsert(vecType<T, P> const & Base, vecType<T, P> const & Insert, int Offset, int Bits)
 {
                                                                                                      ;

  T const Mask = static_cast<T>(detail::mask(Bits) << Offset);
  return (Base & ~Mask) | (Insert & Mask);
 }


 template <typename genType> inline
                    genType bitfieldReverse(genType x)
 {
  return bitfieldReverse(glm::tvec1<genType, glm::defaultp>(x)).x;
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType> inline
                    vecType<T, P> bitfieldReverse(vecType<T, P> const & v)
 {
  vecType<T, P> x(v);
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 2>::call(x, T(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 4>::call(x, T(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 8>::call(x, T(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, T(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, T(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<T, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, T(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }


 template <typename genType> inline
                    int bitCount(genType x)
 {
  return bitCount(glm::tvec1<genType, glm::defaultp>(x)).x;
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType> inline
                    vecType<int, P> bitCount(vecType<T, P> const & v)
 {
  vecType<typename detail::make_unsigned<T>::type, P> x(*reinterpret_cast<vecType<typename detail::make_unsigned<T>::type, P> const *>(&v));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<typename detail::make_unsigned<T>::type, P, vecType, detail::is_aligned<P>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vecType<int, P>(x);
 }


 template <typename genIUType> inline
                    int findLSB(genIUType Value)
 {
                                                                                                       ;

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<int, P> findLSB(vecType<T, P> const & x)
 {
                                                                                               ;

  return detail::functor1<int, T, P, vecType>::call(findLSB, x);
 }


 template <typename genIUType> inline
                    int findMSB(genIUType x)
 {
                                                                                                       ;

  return findMSB(tvec1<genIUType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<int, P> findMSB(vecType<T, P> const & x)
 {
                                                                                               ;

  return detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(x);
 }
}
# 203 "/usr/local/include/glm/detail/func_integer.hpp" 2 3
# 6 "/usr/local/include/glm/integer.hpp" 2 3
# 88 "/usr/local/include/glm/glm.hpp" 2 3
# 12 "./common_utils_cpp.hpp" 2
# 1 "/usr/local/include/glm/gtc/matrix_transform.hpp" 1 3
# 28 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
# 1 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 1 3
# 23 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 3
namespace glm
{





 template <typename genType>
                             genType epsilon();



 template <typename genType>
                             genType zero();



 template <typename genType>
                             genType one();



 template <typename genType>
                             genType pi();



 template <typename genType>
                             genType two_pi();



 template <typename genType>
                             genType root_pi();



 template <typename genType>
                             genType half_pi();



 template <typename genType>
                             genType three_over_two_pi();



 template <typename genType>
                             genType quarter_pi();



 template <typename genType>
                             genType one_over_pi();



 template <typename genType>
                             genType one_over_two_pi();



 template <typename genType>
                             genType two_over_pi();



 template <typename genType>
                             genType four_over_pi();



 template <typename genType>
                             genType two_over_root_pi();



 template <typename genType>
                             genType one_over_root_two();



 template <typename genType>
                             genType root_half_pi();



 template <typename genType>
                             genType root_two_pi();



 template <typename genType>
                             genType root_ln_four();



 template <typename genType>
                             genType e();



 template <typename genType>
                             genType euler();



 template <typename genType>
                             genType root_two();



 template <typename genType>
                             genType root_three();



 template <typename genType>
                             genType root_five();



 template <typename genType>
                             genType ln_two();



 template <typename genType>
                             genType ln_ten();



 template <typename genType>
                             genType ln_ln_two();



 template <typename genType>
                             genType third();



 template <typename genType>
                             genType two_thirds();



 template <typename genType>
                             genType golden_ratio();


}


# 1 "/usr/local/include/glm/gtc/constants.inl" 1 3





namespace glm
{
 template <typename genType> inline
                                  genType epsilon()
 {
  return std::numeric_limits<genType>::epsilon();
 }

 template <typename genType> inline
                                  genType zero()
 {
  return genType(0);
 }

 template <typename genType> inline
                                  genType one()
 {
  return genType(1);
 }

 template <typename genType> inline
                                  genType pi()
 {
  return genType(3.14159265358979323846264338327950288);
 }

 template <typename genType> inline
                                  genType two_pi()
 {
  return genType(6.28318530717958647692528676655900576);
 }

 template <typename genType> inline
                                  genType root_pi()
 {
  return genType(1.772453850905516027);
 }

 template <typename genType> inline
                                  genType half_pi()
 {
  return genType(1.57079632679489661923132169163975144);
 }

 template <typename genType> inline
                                  genType three_over_two_pi()
 {
  return genType(4.71238898038468985769396507491925432);
 }

 template <typename genType> inline
                                  genType quarter_pi()
 {
  return genType(0.785398163397448309615660845819875721);
 }

 template <typename genType> inline
                                  genType one_over_pi()
 {
  return genType(0.318309886183790671537767526745028724);
 }

 template <typename genType> inline
                                  genType one_over_two_pi()
 {
  return genType(0.159154943091895335768883763372514362);
 }

 template <typename genType> inline
                                  genType two_over_pi()
 {
  return genType(0.636619772367581343075535053490057448);
 }

 template <typename genType> inline
                                  genType four_over_pi()
 {
  return genType(1.273239544735162686151070106980114898);
 }

 template <typename genType> inline
                                  genType two_over_root_pi()
 {
  return genType(1.12837916709551257389615890312154517);
 }

 template <typename genType> inline
                                  genType one_over_root_two()
 {
  return genType(0.707106781186547524400844362104849039);
 }

 template <typename genType> inline
                                  genType root_half_pi()
 {
  return genType(1.253314137315500251);
 }

 template <typename genType> inline
                                  genType root_two_pi()
 {
  return genType(2.506628274631000502);
 }

 template <typename genType> inline
                                  genType root_ln_four()
 {
  return genType(1.17741002251547469);
 }

 template <typename genType> inline
                                  genType e()
 {
  return genType(2.71828182845904523536);
 }

 template <typename genType> inline
                                  genType euler()
 {
  return genType(0.577215664901532860606);
 }

 template <typename genType> inline
                                  genType root_two()
 {
  return genType(1.41421356237309504880168872420969808);
 }

 template <typename genType> inline
                                  genType root_three()
 {
  return genType(1.73205080756887729352744634150587236);
 }

 template <typename genType> inline
                                  genType root_five()
 {
  return genType(2.23606797749978969640917366873127623);
 }

 template <typename genType> inline
                                  genType ln_two()
 {
  return genType(0.693147180559945309417232121458176568);
 }

 template <typename genType> inline
                                  genType ln_ten()
 {
  return genType(2.30258509299404568401799145468436421);
 }

 template <typename genType> inline
                                  genType ln_ln_two()
 {
  return genType(-0.3665129205816643);
 }

 template <typename genType> inline
                                  genType third()
 {
  return genType(0.3333333333333333333333333333333333333333);
 }

 template <typename genType> inline
                                  genType two_thirds()
 {
  return genType(0.666666666666666666666666666666666666667);
 }

 template <typename genType> inline
                                  genType golden_ratio()
 {
  return genType(1.61803398874989484820458683436563811);
 }
}
# 176 "/usr/local/include/glm/gtc/../gtc/constants.hpp" 2 3
# 28 "/usr/local/include/glm/gtc/matrix_transform.hpp" 2 3






namespace glm
{
# 57 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> translate(
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v);
# 71 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> rotate(
  tmat4x4<T, P> const & m,
  T angle,
  tvec3<T, P> const & axis);
# 85 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> scale(
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v);
# 101 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> ortho(
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar);
# 121 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> orthoLH(
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar);
# 141 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> orthoRH(
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar);
# 159 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> ortho(
  T left,
  T right,
  T bottom,
  T top);
# 176 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> frustum(
  T left,
  T right,
  T bottom,
  T top,
  T near,
  T far);
# 195 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> frustumLH(
  T left,
  T right,
  T bottom,
  T top,
  T near,
  T far);
# 214 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> frustumRH(
  T left,
  T right,
  T bottom,
  T top,
  T near,
  T far);
# 231 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspective(
  T fovy,
  T aspect,
  T near,
  T far);
# 246 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveRH(
  T fovy,
  T aspect,
  T near,
  T far);
# 261 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveLH(
  T fovy,
  T aspect,
  T near,
  T far);
# 277 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveFov(
  T fov,
  T width,
  T height,
  T near,
  T far);
# 294 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveFovRH(
  T fov,
  T width,
  T height,
  T near,
  T far);
# 311 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> perspectiveFovLH(
  T fov,
  T width,
  T height,
  T near,
  T far);
# 326 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> infinitePerspective(
  T fovy, T aspect, T near);
# 337 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> infinitePerspectiveLH(
  T fovy, T aspect, T near);
# 348 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> infinitePerspectiveRH(
  T fovy, T aspect, T near);
# 359 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 371 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T>
               tmat4x4<T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near, T ep);
# 385 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, typename U, precision P>
               tvec3<T, P> project(
  tvec3<T, P> const & obj,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport);
# 402 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, typename U, precision P>
               tvec3<T, P> unProject(
  tvec3<T, P> const & win,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport);
# 417 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P, typename U>
               tmat4x4<T, P> pickMatrix(
  tvec2<T, P> const & center,
  tvec2<T, P> const & delta,
  tvec4<U, P> const & viewport);
# 430 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> lookAt(
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up);
# 443 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> lookAtRH(
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up);
# 456 "/usr/local/include/glm/gtc/matrix_transform.hpp" 3
 template <typename T, precision P>
               tmat4x4<T, P> lookAtLH(
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up);


}


# 1 "/usr/local/include/glm/gtc/matrix_transform.inl" 1 3







namespace glm
{
 template <typename T, precision P> inline
                    tmat4x4<T, P> translate(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
 {
  tmat4x4<T, P> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rotate(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);

  tvec3<T, P> axis(normalize(v));
  tvec3<T, P> temp((T(1) - c) * axis);

  tmat4x4<T, P> Rotate(uninitialize);
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  tmat4x4<T, P> Result(uninitialize);
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rotate_slow(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);
  tmat4x4<T, P> Result;

  tvec3<T, P> axis = normalize(v);

  Result[0][0] = c + (static_cast<T>(1) - c) * axis.x * axis.x;
  Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = static_cast<T>(0);

  Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
  Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = static_cast<T>(0);

  Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
  Result[2][3] = static_cast<T>(0);

  Result[3] = tvec4<T, P>(0, 0, 0, 1);
  return m * Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scale(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
 {
  tmat4x4<T, P> Result(uninitialize);
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scale_slow(tmat4x4<T, P> const & m, tvec3<T, P> const & v)
 {
  tmat4x4<T, P> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> ortho
 (
  T left, T right,
  T bottom, T top,
  T zNear, T zFar
 )
 {



   return orthoRH(left, right, bottom, top, zNear, zFar);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> orthoLH
 (
  T left, T right,
  T bottom, T top,
  T zNear, T zFar
 )
 {
  tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);





   Result[2][2] = static_cast<T>(2) / (zFar - zNear);
   Result[3][2] = - (zFar + zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> orthoRH
 (
  T left, T right,
  T bottom, T top,
  T zNear, T zFar
 )
 {
  tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);





   Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
   Result[3][2] = - (zFar + zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> ortho
 (
  T left, T right,
  T bottom, T top
 )
 {
  tmat4x4<T, defaultp> Result(static_cast<T>(1));
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> frustum
 (
  T left, T right,
  T bottom, T top,
  T nearVal, T farVal
 )
 {



   return frustumRH(left, right, bottom, top, nearVal, farVal);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> frustumLH
 (
  T left, T right,
  T bottom, T top,
  T nearVal, T farVal
 )
 {
  tmat4x4<T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][3] = static_cast<T>(1);





   Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
   Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> frustumRH
 (
  T left, T right,
  T bottom, T top,
  T nearVal, T farVal
 )
 {
  tmat4x4<T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][3] = static_cast<T>(-1);





   Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
   Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH(fovy, aspect, zNear, zFar);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
 {
  (__builtin_expect(!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 260, "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)") : (void)0);

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][3] = - static_cast<T>(1);





   Result[2][2] = - (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
 {
  (__builtin_expect(!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 283, "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)") : (void)0);

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][3] = static_cast<T>(1);





   Result[2][2] = (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH(fov, width, height, zNear, zFar);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
 {
  (__builtin_expect(!(width > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 316, "width > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(height > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 317, "height > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(fov > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 318, "fov > static_cast<T>(0)") : (void)0);

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][3] = - static_cast<T>(1);





   Result[2][2] = - (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
 {
  (__builtin_expect(!(width > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 343, "width > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(height > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 344, "height > static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(fov > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 345, "fov > static_cast<T>(0)") : (void)0);

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][3] = static_cast<T>(1);





   Result[2][2] = (zFar + zNear) / (zFar - zNear);
   Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);


  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
 {



   return infinitePerspectiveRH(fovy, aspect, zNear);

 }

 template <typename T> inline
                    tmat4x4<T, defaultp> infinitePerspectiveRH(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> infinitePerspectiveLH(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }


 template <typename T> inline
                    tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = ep - static_cast<T>(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = (ep - static_cast<T>(2)) * zNear;
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
 {
  return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
 }

 template <typename T, typename U, precision P> inline
                    tvec3<T, P> project
 (
  tvec3<T, P> const & obj,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport
 )
 {
  tvec4<T, P> tmp = tvec4<T, P>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;




   tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);

  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return tvec3<T, P>(tmp);
 }

 template <typename T, typename U, precision P> inline
                    tvec3<T, P> unProject
 (
  tvec3<T, P> const & win,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport
 )
 {
  tmat4x4<T, P> Inverse = inverse(proj * model);

  tvec4<T, P> tmp = tvec4<T, P>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);




   tmp = tmp * static_cast<T>(2) - static_cast<T>(1);


  tvec4<T, P> obj = Inverse * tmp;
  obj /= obj.w;

  return tvec3<T, P>(obj);
 }

 template <typename T, precision P, typename U> inline
                    tmat4x4<T, P> pickMatrix(tvec2<T, P> const & center, tvec2<T, P> const & delta, tvec4<U, P> const & viewport)
 {
  (__builtin_expect(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_transform.inl", 494, "delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)") : (void)0);
  tmat4x4<T, P> Result(static_cast<T>(1));

  if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
   return Result;

  tvec3<T, P> Temp(
   (static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
   (static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
   static_cast<T>(0));


  Result = translate(Result, Temp);
  return scale(Result, tvec3<T, P>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> lookAt(tvec3<T, P> const & eye, tvec3<T, P> const & center, tvec3<T, P> const & up)
 {



   return lookAtRH(eye, center, up);

 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> lookAtRH
 (
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up
 )
 {
  tvec3<T, P> const f(normalize(center - eye));
  tvec3<T, P> const s(normalize(cross(f, up)));
  tvec3<T, P> const u(cross(s, f));

  tmat4x4<T, P> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> lookAtLH
 (
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up
 )
 {
  tvec3<T, P> const f(normalize(center - eye));
  tvec3<T, P> const s(normalize(cross(up, f)));
  tvec3<T, P> const u(cross(f, s));

  tmat4x4<T, P> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] = f.x;
  Result[1][2] = f.y;
  Result[2][2] = f.z;
  Result[3][0] = -dot(s, eye);
  Result[3][1] = -dot(u, eye);
  Result[3][2] = -dot(f, eye);
  return Result;
 }
}
# 465 "/usr/local/include/glm/gtc/matrix_transform.hpp" 2 3
# 13 "./common_utils_cpp.hpp" 2
# 1 "/usr/local/include/glm/gtc/type_ptr.hpp" 1 3
# 37 "/usr/local/include/glm/gtc/type_ptr.hpp" 3
# 1 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 1 3
# 28 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
namespace glm
{



 template <typename T, precision P = defaultp>
 struct tquat
 {


  typedef tquat<T, P> type;
  typedef T value_type;
# 67 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
   T x, y, z, w;




  typedef length_t length_type;

                static length_type length(){return 4;}

                T & operator[](length_type i);
                T const & operator[](length_type i) const;



                              tquat() ;
                              tquat(tquat<T, P> const & q) ;
  template <precision Q>
                              tquat(tquat<T, Q> const & q);



                                   explicit tquat(ctor);
                              tquat(T const & s, tvec3<T, P> const & v);
                              tquat(T const & w, T const & x, T const & y, T const & z);



  template <typename U, precision Q>
                                           tquat(tquat<U, Q> const & q);
# 109 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
                tquat(tvec3<T, P> const & u, tvec3<T, P> const & v);


                             tquat(tvec3<T, P> const & eulerAngles);
                             tquat(tmat3x3<T, P> const & m);
                             tquat(tmat4x4<T, P> const & m);



                tquat<T, P> & operator=(tquat<T, P> const & m) ;

  template <typename U>
                tquat<T, P> & operator=(tquat<U, P> const & m);
  template <typename U>
                tquat<T, P> & operator+=(tquat<U, P> const & q);
  template <typename U>
                tquat<T, P> & operator-=(tquat<U, P> const & q);
  template <typename U>
                tquat<T, P> & operator*=(tquat<U, P> const & q);
  template <typename U>
                tquat<T, P> & operator*=(U s);
  template <typename U>
                tquat<T, P> & operator/=(U s);
 };



 template <typename T, precision P>
               tquat<T, P> operator+(tquat<T, P> const & q);

 template <typename T, precision P>
               tquat<T, P> operator-(tquat<T, P> const & q);



 template <typename T, precision P>
               tquat<T, P> operator+(tquat<T, P> const & q, tquat<T, P> const & p);

 template <typename T, precision P>
               tquat<T, P> operator*(tquat<T, P> const & q, tquat<T, P> const & p);

 template <typename T, precision P>
               tvec3<T, P> operator*(tquat<T, P> const & q, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q);

 template <typename T, precision P>
               tvec4<T, P> operator*(tquat<T, P> const & q, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q);

 template <typename T, precision P>
               tquat<T, P> operator*(tquat<T, P> const & q, T const & s);

 template <typename T, precision P>
               tquat<T, P> operator*(T const & s, tquat<T, P> const & q);

 template <typename T, precision P>
               tquat<T, P> operator/(tquat<T, P> const & q, T const & s);



 template <typename T, precision P>
               bool operator==(tquat<T, P> const & q1, tquat<T, P> const & q2);

 template <typename T, precision P>
               bool operator!=(tquat<T, P> const & q1, tquat<T, P> const & q2);




 template <typename T, precision P>
               T length(tquat<T, P> const & q);




 template <typename T, precision P>
               tquat<T, P> normalize(tquat<T, P> const & q);




 template <typename T, precision P, template <typename, precision> class quatType>
               T dot(quatType<T, P> const & x, quatType<T, P> const & y);
# 207 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a);
# 218 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);
# 229 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> slerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);




 template <typename T, precision P>
               tquat<T, P> conjugate(tquat<T, P> const & q);




 template <typename T, precision P>
               tquat<T, P> inverse(tquat<T, P> const & q);
# 251 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & axis);





 template <typename T, precision P>
               tvec3<T, P> eulerAngles(tquat<T, P> const & x);




 template <typename T, precision P>
               T roll(tquat<T, P> const & x);




 template <typename T, precision P>
               T pitch(tquat<T, P> const & x);




 template <typename T, precision P>
               T yaw(tquat<T, P> const & x);




 template <typename T, precision P>
               tmat3x3<T, P> mat3_cast(tquat<T, P> const & x);




 template <typename T, precision P>
               tmat4x4<T, P> mat4_cast(tquat<T, P> const & x);




 template <typename T, precision P>
               tquat<T, P> quat_cast(tmat3x3<T, P> const & x);




 template <typename T, precision P>
               tquat<T, P> quat_cast(tmat4x4<T, P> const & x);




 template <typename T, precision P>
               T angle(tquat<T, P> const & x);




 template <typename T, precision P>
               tvec3<T, P> axis(tquat<T, P> const & x);







 template <typename T, precision P>
               tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & axis);






 template <typename T, precision P>
               tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y);






 template <typename T, precision P>
               tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y);
# 381 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tvec4<bool, P> isnan(tquat<T, P> const & x);
# 391 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 3
 template <typename T, precision P>
               tvec4<bool, P> isinf(tquat<T, P> const & x);


}


# 1 "/usr/local/include/glm/gtc/quaternion.inl" 1 3








namespace glm{
namespace detail
{
 template <typename T, precision P, bool Aligned>
 struct compute_dot<tquat, T, P, Aligned>
 {
  static inline T call(tquat<T, P> const& x, tquat<T, P> const& y)
  {
   tvec4<T, P> tmp(x.x * y.x, x.y * y.y, x.z * y.z, x.w * y.w);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_add
 {
  static tquat<T, P> call(tquat<T, P> const& q, tquat<T, P> const& p)
  {
   return tquat<T, P>(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_sub
 {
  static tquat<T, P> call(tquat<T, P> const& q, tquat<T, P> const& p)
  {
   return tquat<T, P>(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_mul_scalar
 {
  static tquat<T, P> call(tquat<T, P> const& q, T s)
  {
   return tquat<T, P>(q.w * s, q.x * s, q.y * s, q.z * s);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_div_scalar
 {
  static tquat<T, P> call(tquat<T, P> const& q, T s)
  {
   return tquat<T, P>(q.w / s, q.x / s, q.y / s, q.z / s);
  }
 };

 template <typename T, precision P, bool Aligned>
 struct compute_quat_mul_vec4
 {
  static tvec4<T, P> call(tquat<T, P> const & q, tvec4<T, P> const & v)
  {
   return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
  }
 };
}



 template <typename T, precision P> inline
                    T & tquat<T, P>::operator[](typename tquat<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 73, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T, precision P> inline
                    T const & tquat<T, P>::operator[](typename tquat<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 80, "i >= 0 && i < this->length()") : (void)0);
  return (&x)[i];
 }




  template <typename T, precision P> inline
                                   tquat<T, P>::tquat()

    : x(0), y(0), z(0), w(1)

  {}



  template <typename T, precision P> inline
                                   tquat<T, P>::tquat(tquat<T, P> const & q)
   : x(q.x), y(q.y), z(q.z), w(q.w)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                  tquat<T, P>::tquat(tquat<T, Q> const & q)
  : x(q.x), y(q.y), z(q.z), w(q.w)
 {}



 template <typename T, precision P> inline
                                       tquat<T, P>::tquat(ctor)
 {}

 template <typename T, precision P> inline
                                  tquat<T, P>::tquat(T const & s, tvec3<T, P> const & v)
  : x(v.x), y(v.y), z(v.z), w(s)
 {}

 template <typename T, precision P> inline
                                  tquat<T, P>::tquat(T const & w, T const & x, T const & y, T const & z)
  : x(x), y(y), z(z), w(w)
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                  tquat<T, P>::tquat(tquat<U, Q> const & q)
  : x(static_cast<T>(q.x))
  , y(static_cast<T>(q.y))
  , z(static_cast<T>(q.z))
  , w(static_cast<T>(q.w))
 {}
# 153 "/usr/local/include/glm/gtc/quaternion.inl" 3
 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tvec3<T, P> const & u, tvec3<T, P> const & v)
 {
  tvec3<T, P> const LocalW(cross(u, v));
  T Dot = detail::compute_dot<tvec3, T, P, detail::is_aligned<P>::value>::call(u, v);
  tquat<T, P> q(T(1) + Dot, LocalW.x, LocalW.y, LocalW.z);

  *this = normalize(q);
 }

 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tvec3<T, P> const & eulerAngle)
 {
  tvec3<T, P> c = glm::cos(eulerAngle * T(0.5));
  tvec3<T, P> s = glm::sin(eulerAngle * T(0.5));

  this->w = c.x * c.y * c.z + s.x * s.y * s.z;
  this->x = s.x * c.y * c.z - c.x * s.y * s.z;
  this->y = c.x * s.y * c.z + s.x * c.y * s.z;
  this->z = c.x * c.y * s.z - s.x * s.y * c.z;
 }

 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tmat3x3<T, P> const & m)
 {
  *this = quat_cast(m);
 }

 template <typename T, precision P> inline
                    tquat<T, P>::tquat(tmat4x4<T, P> const & m)
 {
  *this = quat_cast(m);
 }
# 201 "/usr/local/include/glm/gtc/quaternion.inl" 3
 template <typename T, precision P> inline
                    tquat<T, P> conjugate(tquat<T, P> const & q)
 {
  return tquat<T, P>(q.w, -q.x, -q.y, -q.z);
 }

 template <typename T, precision P> inline
                    tquat<T, P> inverse(tquat<T, P> const & q)
 {
  return conjugate(q) / dot(q, q);
 }




  template <typename T, precision P> inline
                     tquat<T, P> & tquat<T, P>::operator=(tquat<T, P> const & q)
  {
   this->w = q.w;
   this->x = q.x;
   this->y = q.y;
   this->z = q.z;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator=(tquat<U, P> const & q)
 {
  this->w = static_cast<T>(q.w);
  this->x = static_cast<T>(q.x);
  this->y = static_cast<T>(q.y);
  this->z = static_cast<T>(q.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator+=(tquat<U, P> const& q)
 {
  return (*this = detail::compute_quat_add<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator-=(tquat<U, P> const& q)
 {
  return (*this = detail::compute_quat_sub<T, P, detail::is_aligned<P>::value>::call(*this, tquat<T, P>(q)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator*=(tquat<U, P> const & r)
 {
  tquat<T, P> const p(*this);
  tquat<T, P> const q(r);

  this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
  this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
  this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
  this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator*=(U s)
 {
  return (*this = detail::compute_quat_mul_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
 }

 template <typename T, precision P>
 template <typename U> inline
                    tquat<T, P> & tquat<T, P>::operator/=(U s)
 {
  return (*this = detail::compute_quat_div_scalar<T, P, detail::is_aligned<P>::value>::call(*this, static_cast<U>(s)));
 }



 template <typename T, precision P> inline
                    tquat<T, P> operator+(tquat<T, P> const & q)
 {
  return q;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator-(tquat<T, P> const & q)
 {
  return tquat<T, P>(-q.w, -q.x, -q.y, -q.z);
 }



 template <typename T, precision P> inline
                    tquat<T, P> operator+(tquat<T, P> const & q, tquat<T, P> const & p)
 {
  return tquat<T, P>(q) += p;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator*(tquat<T, P> const & q, tquat<T, P> const & p)
 {
  return tquat<T, P>(q) *= p;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tquat<T, P> const & q, tvec3<T, P> const & v)
 {
  tvec3<T, P> const QuatVector(q.x, q.y, q.z);
  tvec3<T, P> const uv(glm::cross(QuatVector, v));
  tvec3<T, P> const uuv(glm::cross(QuatVector, uv));

  return v + ((uv * q.w) + uuv) * static_cast<T>(2);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tquat<T, P> const& q, tvec4<T, P> const& v)
 {
  return detail::compute_quat_mul_vec4<T, P, detail::is_aligned<P>::value>::call(q, v);
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator*(tquat<T, P> const & q, T const & s)
 {
  return tquat<T, P>(
   q.w * s, q.x * s, q.y * s, q.z * s);
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator*(T const & s, tquat<T, P> const & q)
 {
  return q * s;
 }

 template <typename T, precision P> inline
                    tquat<T, P> operator/(tquat<T, P> const & q, T const & s)
 {
  return tquat<T, P>(
   q.w / s, q.x / s, q.y / s, q.z / s);
 }



 template <typename T, precision P> inline
                    bool operator==(tquat<T, P> const & q1, tquat<T, P> const & q2)
 {
  return (q1.x == q2.x) && (q1.y == q2.y) && (q1.z == q2.z) && (q1.w == q2.w);
 }

 template <typename T, precision P> inline
                    bool operator!=(tquat<T, P> const & q1, tquat<T, P> const & q2)
 {
  return (q1.x != q2.x) || (q1.y != q2.y) || (q1.z != q2.z) || (q1.w != q2.w);
 }



 template <typename T, precision P> inline
                    T length(tquat<T, P> const & q)
 {
  return glm::sqrt(dot(q, q));
 }

 template <typename T, precision P> inline
                    tquat<T, P> normalize(tquat<T, P> const & q)
 {
  T len = length(q);
  if(len <= T(0))
   return tquat<T, P>(1, 0, 0, 0);
  T oneOverLen = T(1) / len;
  return tquat<T, P>(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
 }

 template <typename T, precision P> inline
                    tquat<T, P> cross(tquat<T, P> const & q1, tquat<T, P> const & q2)
 {
  return tquat<T, P>(
   q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
   q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
   q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
   q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
 }
# 474 "/usr/local/include/glm/gtc/quaternion.inl" 3
 template <typename T, precision P> inline
                    tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a)
 {
  T cosTheta = dot(x, y);


  if(cosTheta > T(1) - epsilon<T>())
  {

   return tquat<T, P>(
    mix(x.w, y.w, a),
    mix(x.x, y.x, a),
    mix(x.y, y.y, a),
    mix(x.z, y.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((T(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
  }
 }

 template <typename T, precision P> inline
                    tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a)
 {

  (__builtin_expect(!(a >= static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 501, "a >= static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(a <= static_cast<T>(1)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 502, "a <= static_cast<T>(1)") : (void)0);

  return x * (T(1) - a) + (y * a);
 }

 template <typename T, precision P> inline
                    tquat<T, P> slerp(tquat<T, P> const & x, tquat<T, P> const & y, T a)
 {
  tquat<T, P> z = y;

  T cosTheta = dot(x, y);



  if (cosTheta < T(0))
  {
   z = -y;
   cosTheta = -cosTheta;
  }


  if(cosTheta > T(1) - epsilon<T>())
  {

   return tquat<T, P>(
    mix(x.w, z.w, a),
    mix(x.x, z.x, a),
    mix(x.y, z.y, a),
    mix(x.z, z.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((T(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
  }
 }

 template <typename T, precision P> inline
                    tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & v)
 {
  tvec3<T, P> Tmp = v;


  T len = glm::length(Tmp);
  if(abs(len - T(1)) > T(0.001))
  {
   T oneOverLen = static_cast<T>(1) / len;
   Tmp.x *= oneOverLen;
   Tmp.y *= oneOverLen;
   Tmp.z *= oneOverLen;
  }

  T const AngleRad(angle);
  T const Sin = sin(AngleRad * T(0.5));

  return q * tquat<T, P>(cos(AngleRad * T(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);

 }

 template <typename T, precision P> inline
                    tvec3<T, P> eulerAngles(tquat<T, P> const & x)
 {
  return tvec3<T, P>(pitch(x), yaw(x), roll(x));
 }

 template <typename T, precision P> inline
                    T roll(tquat<T, P> const & q)
 {
  return T(atan(T(2) * (q.x * q.y + q.w * q.z), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z));
 }

 template <typename T, precision P> inline
                    T pitch(tquat<T, P> const & q)
 {
  return T(atan(T(2) * (q.y * q.z + q.w * q.x), q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z));
 }

 template <typename T, precision P> inline
                    T yaw(tquat<T, P> const & q)
 {
  return asin(clamp(T(-2) * (q.x * q.z - q.w * q.y), T(-1), T(1)));
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> mat3_cast(tquat<T, P> const & q)
 {
  tmat3x3<T, P> Result(T(1));
  T qxx(q.x * q.x);
  T qyy(q.y * q.y);
  T qzz(q.z * q.z);
  T qxz(q.x * q.z);
  T qxy(q.x * q.y);
  T qyz(q.y * q.z);
  T qwx(q.w * q.x);
  T qwy(q.w * q.y);
  T qwz(q.w * q.z);

  Result[0][0] = T(1) - T(2) * (qyy + qzz);
  Result[0][1] = T(2) * (qxy + qwz);
  Result[0][2] = T(2) * (qxz - qwy);

  Result[1][0] = T(2) * (qxy - qwz);
  Result[1][1] = T(1) - T(2) * (qxx + qzz);
  Result[1][2] = T(2) * (qyz + qwx);

  Result[2][0] = T(2) * (qxz + qwy);
  Result[2][1] = T(2) * (qyz - qwx);
  Result[2][2] = T(1) - T(2) * (qxx + qyy);
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> mat4_cast(tquat<T, P> const & q)
 {
  return tmat4x4<T, P>(mat3_cast(q));
 }

 template <typename T, precision P> inline
                    tquat<T, P> quat_cast(tmat3x3<T, P> const & m)
 {
  T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
  T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
  T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
  T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

  int biggestIndex = 0;
  T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
  if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourXSquaredMinus1;
   biggestIndex = 1;
  }
  if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourYSquaredMinus1;
   biggestIndex = 2;
  }
  if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourZSquaredMinus1;
   biggestIndex = 3;
  }

  T biggestVal = sqrt(fourBiggestSquaredMinus1 + T(1)) * T(0.5);
  T mult = static_cast<T>(0.25) / biggestVal;

  tquat<T, P> Result(uninitialize);
  switch(biggestIndex)
  {
  case 0:
   Result.w = biggestVal;
   Result.x = (m[1][2] - m[2][1]) * mult;
   Result.y = (m[2][0] - m[0][2]) * mult;
   Result.z = (m[0][1] - m[1][0]) * mult;
   break;
  case 1:
   Result.w = (m[1][2] - m[2][1]) * mult;
   Result.x = biggestVal;
   Result.y = (m[0][1] + m[1][0]) * mult;
   Result.z = (m[2][0] + m[0][2]) * mult;
   break;
  case 2:
   Result.w = (m[2][0] - m[0][2]) * mult;
   Result.x = (m[0][1] + m[1][0]) * mult;
   Result.y = biggestVal;
   Result.z = (m[1][2] + m[2][1]) * mult;
   break;
  case 3:
   Result.w = (m[0][1] - m[1][0]) * mult;
   Result.x = (m[2][0] + m[0][2]) * mult;
   Result.y = (m[1][2] + m[2][1]) * mult;
   Result.z = biggestVal;
   break;

  default:
   (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/quaternion.inl", 678, "false") : (void)0);
   break;
  }
  return Result;
 }

 template <typename T, precision P> inline
                    tquat<T, P> quat_cast(tmat4x4<T, P> const & m4)
 {
  return quat_cast(tmat3x3<T, P>(m4));
 }

 template <typename T, precision P> inline
                    T angle(tquat<T, P> const & x)
 {
  return acos(x.w) * T(2);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> axis(tquat<T, P> const & x)
 {
  T tmp1 = static_cast<T>(1) - x.w * x.w;
  if(tmp1 <= static_cast<T>(0))
   return tvec3<T, P>(0, 0, 1);
  T tmp2 = static_cast<T>(1) / sqrt(tmp1);
  return tvec3<T, P>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
 }

 template <typename T, precision P> inline
                    tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & v)
 {
  tquat<T, P> Result(uninitialize);

  T const a(angle);
  T const s = glm::sin(a * static_cast<T>(0.5));

  Result.w = glm::cos(a * static_cast<T>(0.5));
  Result.x = v.x * s;
  Result.y = v.y * s;
  Result.z = v.z * s;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y)
 {
  tvec4<bool, P> Result(uninitialize);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isnan(tquat<T, P> const& q)
 {
                                                                                                   ;

  return tvec4<bool, P>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isinf(tquat<T, P> const& q)
 {
                                                                                                   ;

  return tvec4<bool, P>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
 }
}
# 397 "/usr/local/include/glm/gtc/../gtc/quaternion.hpp" 2 3
# 37 "/usr/local/include/glm/gtc/type_ptr.hpp" 2 3
# 56 "/usr/local/include/glm/gtc/type_ptr.hpp" 3
namespace glm
{





 template<typename genType>
               typename genType::value_type const * value_ptr(genType const & vec);



 template<typename T>
               tvec2<T, defaultp> make_vec2(T const * const ptr);



 template<typename T>
               tvec3<T, defaultp> make_vec3(T const * const ptr);



 template<typename T>
               tvec4<T, defaultp> make_vec4(T const * const ptr);



 template<typename T>
               tmat2x2<T, defaultp> make_mat2x2(T const * const ptr);



 template<typename T>
               tmat2x3<T, defaultp> make_mat2x3(T const * const ptr);



 template<typename T>
               tmat2x4<T, defaultp> make_mat2x4(T const * const ptr);



 template<typename T>
               tmat3x2<T, defaultp> make_mat3x2(T const * const ptr);



 template<typename T>
               tmat3x3<T, defaultp> make_mat3x3(T const * const ptr);



 template<typename T>
               tmat3x4<T, defaultp> make_mat3x4(T const * const ptr);



 template<typename T>
               tmat4x2<T, defaultp> make_mat4x2(T const * const ptr);



 template<typename T>
               tmat4x3<T, defaultp> make_mat4x3(T const * const ptr);



 template<typename T>
               tmat4x4<T, defaultp> make_mat4x4(T const * const ptr);



 template<typename T>
               tmat2x2<T, defaultp> make_mat2(T const * const ptr);



 template<typename T>
               tmat3x3<T, defaultp> make_mat3(T const * const ptr);



 template<typename T>
               tmat4x4<T, defaultp> make_mat4(T const * const ptr);



 template<typename T>
               tquat<T, defaultp> make_quat(T const * const ptr);


}


# 1 "/usr/local/include/glm/gtc/type_ptr.inl" 1 3





namespace glm
{





 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tvec2<T, P> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tvec2<T, P> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tvec3<T, P> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tvec3<T, P> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tvec4<T, P> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tvec4<T, P> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat2x2<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat2x2<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat3x3<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat3x3<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat4x4<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat4x4<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat2x3<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat2x3<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat3x2<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat3x2<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat2x4<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat2x4<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat4x2<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat4x2<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat3x4<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tmat3x4<T, P> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tmat4x3<T, P> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T * value_ptr(tmat4x3<T, P> & mat)
 {
  return &(mat[0].x);
 }



 template<typename T, precision P> inline
                    T const * value_ptr
 (
  tquat<T, P> const & q
 )
 {
  return &(q[0]);
 }



 template<typename T, precision P> inline
                    T * value_ptr
 (
  tquat<T, P> & q
 )
 {
  return &(q[0]);
 }



 template <typename T> inline
                    tvec2<T, defaultp> make_vec2(T const * const ptr)
 {
  tvec2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tvec3<T, defaultp> make_vec3(T const * const ptr)
 {
  tvec3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tvec4<T, defaultp> make_vec4(T const * const ptr)
 {
  tvec4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x2<T, defaultp> make_mat2x2(T const * const ptr)
 {
  tmat2x2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x3<T, defaultp> make_mat2x3(T const * const ptr)
 {
  tmat2x3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x4<T, defaultp> make_mat2x4(T const * const ptr)
 {
  tmat2x4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat3x2<T, defaultp> make_mat3x2(T const * const ptr)
 {
  tmat3x2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat3x3<T, defaultp> make_mat3x3(T const * const ptr)
 {
  tmat3x3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat3x4<T, defaultp> make_mat3x4(T const * const ptr)
 {
  tmat3x4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat4x2<T, defaultp> make_mat4x2(T const * const ptr)
 {
  tmat4x2<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat4x3<T, defaultp> make_mat4x3(T const * const ptr)
 {
  tmat4x3<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat4x4<T, defaultp> make_mat4x4(T const * const ptr)
 {
  tmat4x4<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));
  return Result;
 }



 template <typename T> inline
                    tmat2x2<T, defaultp> make_mat2(T const * const ptr)
 {
  return make_mat2x2(ptr);
 }



 template <typename T> inline
                    tmat3x3<T, defaultp> make_mat3(T const * const ptr)
 {
  return make_mat3x3(ptr);
 }



 template <typename T> inline
                    tmat4x4<T, defaultp> make_mat4(T const * const ptr)
 {
  return make_mat4x4(ptr);
 }



 template <typename T> inline
                    tquat<T, defaultp> make_quat(T const * const ptr)
 {
  tquat<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));
  return Result;
 }


}
# 149 "/usr/local/include/glm/gtc/type_ptr.hpp" 2 3
# 14 "./common_utils_cpp.hpp" 2
# 1 "/usr/local/include/glm/ext.hpp" 1 3
# 37 "/usr/local/include/glm/ext.hpp" 3
# 1 "/usr/local/include/glm/./gtc/bitfield.hpp" 1 3
# 27 "/usr/local/include/glm/./gtc/bitfield.hpp" 3
namespace glm
{






 template <typename genIUType>
               genIUType mask(genIUType Bits);




 template <typename T, precision P, template <typename, precision> class vecIUType>
               vecIUType<T, P> mask(vecIUType<T, P> const & v);




 template <typename genIUType>
               genIUType bitfieldRotateRight(genIUType In, int Shift);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldRotateRight(vecType<T, P> const & In, int Shift);




 template <typename genIUType>
               genIUType bitfieldRotateLeft(genIUType In, int Shift);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldRotateLeft(vecType<T, P> const & In, int Shift);




 template <typename genIUType>
               genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldFillOne(vecType<T, P> const & Value, int FirstBit, int BitCount);




 template <typename genIUType>
               genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> bitfieldFillZero(vecType<T, P> const & Value, int FirstBit, int BitCount);






               int16 bitfieldInterleave(int8 x, int8 y);






               uint16 bitfieldInterleave(uint8 x, uint8 y);






               int32 bitfieldInterleave(int16 x, int16 y);






               uint32 bitfieldInterleave(uint16 x, uint16 y);






               int64 bitfieldInterleave(int32 x, int32 y);






               uint64 bitfieldInterleave(uint32 x, uint32 y);






               int32 bitfieldInterleave(int8 x, int8 y, int8 z);






               uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z);






               int64 bitfieldInterleave(int16 x, int16 y, int16 z);






               uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z);






               int64 bitfieldInterleave(int32 x, int32 y, int32 z);






               uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z);






               int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w);






               uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w);






               int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w);






               uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w);


}


# 1 "/usr/local/include/glm/gtc/bitfield.inl" 1 3



# 1 "/usr/local/include/glm/gtc/../simd/integer.h" 1 3
 inline






                   glm_uvec4 glm_i128_interleave(glm_uvec4 x)
{
 glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
 glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
 glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
 glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
 glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);

 glm_uvec4 Reg1;
 glm_uvec4 Reg2;




 Reg1 = x;



 Reg2 = __extension__ ({
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 26 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (2)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask4);



 Reg2 = __extension__ ({
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 32 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (1)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask3);



 Reg2 = _mm_slli_epi32(Reg1, 4);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask2);



 Reg2 = _mm_slli_epi32(Reg1, 2);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask1);



 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask0);


 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg2 = __extension__ ({
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg2);
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 56 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_psrldqi128(__a, (8)*8); });
 Reg1 = _mm_or_si128(Reg1, Reg2);

 return Reg1;
} inline

                   glm_uvec4 glm_i128_interleave2(glm_uvec4 x, glm_uvec4 y)
{
 glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
 glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
 glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
 glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
 glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);

 glm_uvec4 Reg1;
 glm_uvec4 Reg2;



 Reg1 = _mm_unpacklo_epi64(x, y);



 Reg2 = __extension__ ({
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 79 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (2)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask4);



 Reg2 = __extension__ ({
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg1);
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 85 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_pslldqi128(__a, (1)*8); });
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask3);



 Reg2 = _mm_slli_epi32(Reg1, 4);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask2);



 Reg2 = _mm_slli_epi32(Reg1, 2);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask1);



 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg1 = _mm_or_si128(Reg2, Reg1);
 Reg1 = _mm_and_si128(Reg1, Mask0);


 Reg2 = _mm_slli_epi32(Reg1, 1);
 Reg2 = __extension__ ({
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic push
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic ignored "-Wshadow"
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; __m128i __a = (Reg2);
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
#pragma clang diagnostic pop
# 109 "/usr/local/include/glm/gtc/../simd/integer.h" 3
; (__m128i)__builtin_ia32_psrldqi128(__a, (8)*8); });
 Reg1 = _mm_or_si128(Reg1, Reg2);

 return Reg1;
}
# 4 "/usr/local/include/glm/gtc/bitfield.inl" 2 3


namespace glm{
namespace detail
{
 template <typename PARAM, typename RET>
               RET bitfieldInterleave(PARAM x, PARAM y);

 template <typename PARAM, typename RET>
               RET bitfieldInterleave(PARAM x, PARAM y, PARAM z);

 template <typename PARAM, typename RET>
               RET bitfieldInterleave(PARAM x, PARAM y, PARAM z, PARAM w);

 template <> inline
                    glm::uint16 bitfieldInterleave(glm::uint8 x, glm::uint8 y)
 {
  glm::uint16 REG1(x);
  glm::uint16 REG2(y);

  REG1 = ((REG1 << 4) | REG1) & glm::uint16(0x0F0F);
  REG2 = ((REG2 << 4) | REG2) & glm::uint16(0x0F0F);

  REG1 = ((REG1 << 2) | REG1) & glm::uint16(0x3333);
  REG2 = ((REG2 << 2) | REG2) & glm::uint16(0x3333);

  REG1 = ((REG1 << 1) | REG1) & glm::uint16(0x5555);
  REG2 = ((REG2 << 1) | REG2) & glm::uint16(0x5555);

  return REG1 | (REG2 << 1);
 }

 template <> inline
                    glm::uint32 bitfieldInterleave(glm::uint16 x, glm::uint16 y)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);

  REG1 = ((REG1 << 8) | REG1) & glm::uint32(0x00FF00FF);
  REG2 = ((REG2 << 8) | REG2) & glm::uint32(0x00FF00FF);

  REG1 = ((REG1 << 4) | REG1) & glm::uint32(0x0F0F0F0F);
  REG2 = ((REG2 << 4) | REG2) & glm::uint32(0x0F0F0F0F);

  REG1 = ((REG1 << 2) | REG1) & glm::uint32(0x33333333);
  REG2 = ((REG2 << 2) | REG2) & glm::uint32(0x33333333);

  REG1 = ((REG1 << 1) | REG1) & glm::uint32(0x55555555);
  REG2 = ((REG2 << 1) | REG2) & glm::uint32(0x55555555);

  return REG1 | (REG2 << 1);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);

  REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x0000FFFF0000FFFFull);
  REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x0000FFFF0000FFFFull);

  REG1 = ((REG1 << 8) | REG1) & glm::uint64(0x00FF00FF00FF00FFull);
  REG2 = ((REG2 << 8) | REG2) & glm::uint64(0x00FF00FF00FF00FFull);

  REG1 = ((REG1 << 4) | REG1) & glm::uint64(0x0F0F0F0F0F0F0F0Full);
  REG2 = ((REG2 << 4) | REG2) & glm::uint64(0x0F0F0F0F0F0F0F0Full);

  REG1 = ((REG1 << 2) | REG1) & glm::uint64(0x3333333333333333ull);
  REG2 = ((REG2 << 2) | REG2) & glm::uint64(0x3333333333333333ull);

  REG1 = ((REG1 << 1) | REG1) & glm::uint64(0x5555555555555555ull);
  REG2 = ((REG2 << 1) | REG2) & glm::uint64(0x5555555555555555ull);

  return REG1 | (REG2 << 1);
 }

 template <> inline
                    glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);
  glm::uint32 REG3(z);

  REG1 = ((REG1 << 16) | REG1) & glm::uint32(0x00FF0000FF0000FF);
  REG2 = ((REG2 << 16) | REG2) & glm::uint32(0x00FF0000FF0000FF);
  REG3 = ((REG3 << 16) | REG3) & glm::uint32(0x00FF0000FF0000FF);

  REG1 = ((REG1 << 8) | REG1) & glm::uint32(0xF00F00F00F00F00F);
  REG2 = ((REG2 << 8) | REG2) & glm::uint32(0xF00F00F00F00F00F);
  REG3 = ((REG3 << 8) | REG3) & glm::uint32(0xF00F00F00F00F00F);

  REG1 = ((REG1 << 4) | REG1) & glm::uint32(0x30C30C30C30C30C3);
  REG2 = ((REG2 << 4) | REG2) & glm::uint32(0x30C30C30C30C30C3);
  REG3 = ((REG3 << 4) | REG3) & glm::uint32(0x30C30C30C30C30C3);

  REG1 = ((REG1 << 2) | REG1) & glm::uint32(0x9249249249249249);
  REG2 = ((REG2 << 2) | REG2) & glm::uint32(0x9249249249249249);
  REG3 = ((REG3 << 2) | REG3) & glm::uint32(0x9249249249249249);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);

  REG1 = ((REG1 << 32) | REG1) & glm::uint64(0xFFFF00000000FFFFull);
  REG2 = ((REG2 << 32) | REG2) & glm::uint64(0xFFFF00000000FFFFull);
  REG3 = ((REG3 << 32) | REG3) & glm::uint64(0xFFFF00000000FFFFull);

  REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x00FF0000FF0000FFull);
  REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x00FF0000FF0000FFull);
  REG3 = ((REG3 << 16) | REG3) & glm::uint64(0x00FF0000FF0000FFull);

  REG1 = ((REG1 << 8) | REG1) & glm::uint64(0xF00F00F00F00F00Full);
  REG2 = ((REG2 << 8) | REG2) & glm::uint64(0xF00F00F00F00F00Full);
  REG3 = ((REG3 << 8) | REG3) & glm::uint64(0xF00F00F00F00F00Full);

  REG1 = ((REG1 << 4) | REG1) & glm::uint64(0x30C30C30C30C30C3ull);
  REG2 = ((REG2 << 4) | REG2) & glm::uint64(0x30C30C30C30C30C3ull);
  REG3 = ((REG3 << 4) | REG3) & glm::uint64(0x30C30C30C30C30C3ull);

  REG1 = ((REG1 << 2) | REG1) & glm::uint64(0x9249249249249249ull);
  REG2 = ((REG2 << 2) | REG2) & glm::uint64(0x9249249249249249ull);
  REG3 = ((REG3 << 2) | REG3) & glm::uint64(0x9249249249249249ull);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint32 x, glm::uint32 y, glm::uint32 z)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);

  REG1 = ((REG1 << 32) | REG1) & glm::uint64(0xFFFF00000000FFFFull);
  REG2 = ((REG2 << 32) | REG2) & glm::uint64(0xFFFF00000000FFFFull);
  REG3 = ((REG3 << 32) | REG3) & glm::uint64(0xFFFF00000000FFFFull);

  REG1 = ((REG1 << 16) | REG1) & glm::uint64(0x00FF0000FF0000FFull);
  REG2 = ((REG2 << 16) | REG2) & glm::uint64(0x00FF0000FF0000FFull);
  REG3 = ((REG3 << 16) | REG3) & glm::uint64(0x00FF0000FF0000FFull);

  REG1 = ((REG1 << 8) | REG1) & glm::uint64(0xF00F00F00F00F00Full);
  REG2 = ((REG2 << 8) | REG2) & glm::uint64(0xF00F00F00F00F00Full);
  REG3 = ((REG3 << 8) | REG3) & glm::uint64(0xF00F00F00F00F00Full);

  REG1 = ((REG1 << 4) | REG1) & glm::uint64(0x30C30C30C30C30C3ull);
  REG2 = ((REG2 << 4) | REG2) & glm::uint64(0x30C30C30C30C30C3ull);
  REG3 = ((REG3 << 4) | REG3) & glm::uint64(0x30C30C30C30C30C3ull);

  REG1 = ((REG1 << 2) | REG1) & glm::uint64(0x9249249249249249ull);
  REG2 = ((REG2 << 2) | REG2) & glm::uint64(0x9249249249249249ull);
  REG3 = ((REG3 << 2) | REG3) & glm::uint64(0x9249249249249249ull);

  return REG1 | (REG2 << 1) | (REG3 << 2);
 }

 template <> inline
                    glm::uint32 bitfieldInterleave(glm::uint8 x, glm::uint8 y, glm::uint8 z, glm::uint8 w)
 {
  glm::uint32 REG1(x);
  glm::uint32 REG2(y);
  glm::uint32 REG3(z);
  glm::uint32 REG4(w);

  REG1 = ((REG1 << 12) | REG1) & glm::uint32(0x000F000F000F000F);
  REG2 = ((REG2 << 12) | REG2) & glm::uint32(0x000F000F000F000F);
  REG3 = ((REG3 << 12) | REG3) & glm::uint32(0x000F000F000F000F);
  REG4 = ((REG4 << 12) | REG4) & glm::uint32(0x000F000F000F000F);

  REG1 = ((REG1 << 6) | REG1) & glm::uint32(0x0303030303030303);
  REG2 = ((REG2 << 6) | REG2) & glm::uint32(0x0303030303030303);
  REG3 = ((REG3 << 6) | REG3) & glm::uint32(0x0303030303030303);
  REG4 = ((REG4 << 6) | REG4) & glm::uint32(0x0303030303030303);

  REG1 = ((REG1 << 3) | REG1) & glm::uint32(0x1111111111111111);
  REG2 = ((REG2 << 3) | REG2) & glm::uint32(0x1111111111111111);
  REG3 = ((REG3 << 3) | REG3) & glm::uint32(0x1111111111111111);
  REG4 = ((REG4 << 3) | REG4) & glm::uint32(0x1111111111111111);

  return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
 }

 template <> inline
                    glm::uint64 bitfieldInterleave(glm::uint16 x, glm::uint16 y, glm::uint16 z, glm::uint16 w)
 {
  glm::uint64 REG1(x);
  glm::uint64 REG2(y);
  glm::uint64 REG3(z);
  glm::uint64 REG4(w);

  REG1 = ((REG1 << 24) | REG1) & glm::uint64(0x000000FF000000FFull);
  REG2 = ((REG2 << 24) | REG2) & glm::uint64(0x000000FF000000FFull);
  REG3 = ((REG3 << 24) | REG3) & glm::uint64(0x000000FF000000FFull);
  REG4 = ((REG4 << 24) | REG4) & glm::uint64(0x000000FF000000FFull);

  REG1 = ((REG1 << 12) | REG1) & glm::uint64(0x000F000F000F000Full);
  REG2 = ((REG2 << 12) | REG2) & glm::uint64(0x000F000F000F000Full);
  REG3 = ((REG3 << 12) | REG3) & glm::uint64(0x000F000F000F000Full);
  REG4 = ((REG4 << 12) | REG4) & glm::uint64(0x000F000F000F000Full);

  REG1 = ((REG1 << 6) | REG1) & glm::uint64(0x0303030303030303ull);
  REG2 = ((REG2 << 6) | REG2) & glm::uint64(0x0303030303030303ull);
  REG3 = ((REG3 << 6) | REG3) & glm::uint64(0x0303030303030303ull);
  REG4 = ((REG4 << 6) | REG4) & glm::uint64(0x0303030303030303ull);

  REG1 = ((REG1 << 3) | REG1) & glm::uint64(0x1111111111111111ull);
  REG2 = ((REG2 << 3) | REG2) & glm::uint64(0x1111111111111111ull);
  REG3 = ((REG3 << 3) | REG3) & glm::uint64(0x1111111111111111ull);
  REG4 = ((REG4 << 3) | REG4) & glm::uint64(0x1111111111111111ull);

  return REG1 | (REG2 << 1) | (REG3 << 2) | (REG4 << 3);
 }
}

 template <typename genIUType> inline
                    genIUType mask(genIUType Bits)
 {
                                                                                                     ;

  return Bits >= sizeof(genIUType) * 8 ? ~static_cast<genIUType>(0) : (static_cast<genIUType>(1) << Bits) - static_cast<genIUType>(1);
 }

 template <typename T, precision P, template <typename, precision> class vecIUType> inline
                    vecIUType<T, P> mask(vecIUType<T, P> const& v)
 {
                                                                                             ;

  return detail::functor1<T, T, P, vecIUType>::call(mask, v);
 }

 template <typename genIType> inline
                    genIType bitfieldRotateRight(genIType In, int Shift)
 {
                                                                                                                   ;

  int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
  return (In << static_cast<genIType>(Shift)) | (In >> static_cast<genIType>(BitSize - Shift));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldRotateRight(vecType<T, P> const & In, int Shift)
 {
                                                                                                            ;

  int const BitSize = static_cast<int>(sizeof(T) * 8);
  return (In << static_cast<T>(Shift)) | (In >> static_cast<T>(BitSize - Shift));
 }

 template <typename genIType> inline
                    genIType bitfieldRotateLeft(genIType In, int Shift)
 {
                                                                                                                  ;

  int const BitSize = static_cast<genIType>(sizeof(genIType) * 8);
  return (In >> static_cast<genIType>(Shift)) | (In << static_cast<genIType>(BitSize - Shift));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldRotateLeft(vecType<T, P> const& In, int Shift)
 {
                                                                                                           ;

  int const BitSize = static_cast<int>(sizeof(T) * 8);
  return (In >> static_cast<T>(Shift)) | (In << static_cast<T>(BitSize - Shift));
 }

 template <typename genIUType> inline
                    genIUType bitfieldFillOne(genIUType Value, int FirstBit, int BitCount)
 {
  return Value | static_cast<genIUType>(mask(BitCount) << FirstBit);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldFillOne(vecType<T, P> const& Value, int FirstBit, int BitCount)
 {
  return Value | static_cast<T>(mask(BitCount) << FirstBit);
 }

 template <typename genIUType> inline
                    genIUType bitfieldFillZero(genIUType Value, int FirstBit, int BitCount)
 {
  return Value & static_cast<genIUType>(~(mask(BitCount) << FirstBit));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> bitfieldFillZero(vecType<T, P> const& Value, int FirstBit, int BitCount)
 {
  return Value & static_cast<T>(~(mask(BitCount) << FirstBit));
 } inline

                    int16 bitfieldInterleave(int8 x, int8 y)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y;

  union sign16
  {
   int16 i;
   uint16 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 } inline

                    uint16 bitfieldInterleave(uint8 x, uint8 y)
 {
  return detail::bitfieldInterleave<uint8, uint16>(x, y);
 } inline

                    int32 bitfieldInterleave(int16 x, int16 y)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 } inline

                    uint32 bitfieldInterleave(uint16 x, uint16 y)
 {
  return detail::bitfieldInterleave<uint16, uint32>(x, y);
 } inline

                    int64 bitfieldInterleave(int32 x, int32 y)
 {
  union sign32
  {
   int32 i;
   uint32 u;
  } sign_x, sign_y;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint32 x, uint32 y)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y);
 } inline

                    int32 bitfieldInterleave(int8 x, int8 y, int8 z)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y, sign_z;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 } inline

                    uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z)
 {
  return detail::bitfieldInterleave<uint8, uint32>(x, y, z);
 } inline

                    int64 bitfieldInterleave(int16 x, int16 y, int16 z)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y, sign_z;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
 } inline

                    int64 bitfieldInterleave(int32 x, int32 y, int32 z)
 {
  union sign16
  {
   int32 i;
   uint32 u;
  } sign_x, sign_y, sign_z;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint32 x, uint32 y, uint32 z)
 {
  return detail::bitfieldInterleave<uint32, uint64>(x, y, z);
 } inline

                    int32 bitfieldInterleave(int8 x, int8 y, int8 z, int8 w)
 {
  union sign8
  {
   int8 i;
   uint8 u;
  } sign_x, sign_y, sign_z, sign_w;

  union sign32
  {
   int32 i;
   uint32 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  sign_w.i = w;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

  return result.i;
 } inline

                    uint32 bitfieldInterleave(uint8 x, uint8 y, uint8 z, uint8 w)
 {
  return detail::bitfieldInterleave<uint8, uint32>(x, y, z, w);
 } inline

                    int64 bitfieldInterleave(int16 x, int16 y, int16 z, int16 w)
 {
  union sign16
  {
   int16 i;
   uint16 u;
  } sign_x, sign_y, sign_z, sign_w;

  union sign64
  {
   int64 i;
   uint64 u;
  } result;

  sign_x.i = x;
  sign_y.i = y;
  sign_z.i = z;
  sign_w.i = w;
  result.u = bitfieldInterleave(sign_x.u, sign_y.u, sign_z.u, sign_w.u);

  return result.i;
 } inline

                    uint64 bitfieldInterleave(uint16 x, uint16 y, uint16 z, uint16 w)
 {
  return detail::bitfieldInterleave<uint16, uint64>(x, y, z, w);
 }
}
# 207 "/usr/local/include/glm/./gtc/bitfield.hpp" 2 3
# 37 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/color_space.hpp" 1 3
# 28 "/usr/local/include/glm/./gtc/color_space.hpp" 3
namespace glm
{





 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertLinearToSRGB(vecType<T, P> const & ColorLinear);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertLinearToSRGB(vecType<T, P> const & ColorLinear, T Gamma);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertSRGBToLinear(vecType<T, P> const & ColorSRGB);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> convertSRGBToLinear(vecType<T, P> const & ColorSRGB, T Gamma);


}


# 1 "/usr/local/include/glm/gtc/color_space.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_rgbToSrgb
 { inline
                     static vecType<T, P> call(vecType<T, P> const& ColorRGB, T GammaCorrection)
  {
   vecType<T, P> const ClampedColor(clamp(ColorRGB, static_cast<T>(0), static_cast<T>(1)));

   return mix(
    pow(ClampedColor, vecType<T, P>(GammaCorrection)) * static_cast<T>(1.055) - static_cast<T>(0.055),
    ClampedColor * static_cast<T>(12.92),
    lessThan(ClampedColor, vecType<T, P>(static_cast<T>(0.0031308))));
  }
 };

 template <typename T, precision P>
 struct compute_rgbToSrgb<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const& ColorRGB, T GammaCorrection)
  {
   return tvec4<T, P>(compute_rgbToSrgb<T, P, tvec3>::call(tvec3<T, P>(ColorRGB), GammaCorrection), ColorRGB.w);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_srgbToRgb
 { inline
                     static vecType<T, P> call(vecType<T, P> const& ColorSRGB, T Gamma)
  {
   return mix(
    pow((ColorSRGB + static_cast<T>(0.055)) * static_cast<T>(0.94786729857819905213270142180095), vecType<T, P>(Gamma)),
    ColorSRGB * static_cast<T>(0.07739938080495356037151702786378),
    lessThanEqual(ColorSRGB, vecType<T, P>(static_cast<T>(0.04045))));
  }
 };

 template <typename T, precision P>
 struct compute_srgbToRgb<T, P, tvec4>
 { inline
                     static tvec4<T, P> call(tvec4<T, P> const& ColorSRGB, T Gamma)
  {
   return tvec4<T, P>(compute_srgbToRgb<T, P, tvec3>::call(tvec3<T, P>(ColorSRGB), Gamma), ColorSRGB.w);
  }
 };
}

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertLinearToSRGB(vecType<T, P> const& ColorLinear)
 {
  return detail::compute_rgbToSrgb<T, P, vecType>::call(ColorLinear, static_cast<T>(0.41666));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertLinearToSRGB(vecType<T, P> const& ColorLinear, T Gamma)
 {
  return detail::compute_rgbToSrgb<T, P, vecType>::call(ColorLinear, static_cast<T>(1) / Gamma);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertSRGBToLinear(vecType<T, P> const& ColorSRGB)
 {
  return detail::compute_srgbToRgb<T, P, vecType>::call(ColorSRGB, static_cast<T>(2.4));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> convertSRGBToLinear(vecType<T, P> const& ColorSRGB, T Gamma)
 {
  return detail::compute_srgbToRgb<T, P, vecType>::call(ColorSRGB, Gamma);
 }
}
# 56 "/usr/local/include/glm/./gtc/color_space.hpp" 2 3
# 38 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/epsilon.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/epsilon.hpp" 3
namespace glm
{







 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> epsilonEqual(
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  T const & epsilon);





 template <typename genType>
               bool epsilonEqual(
  genType const & x,
  genType const & y,
  genType const & epsilon);





 template <typename genType>
               typename genType::boolType epsilonNotEqual(
  genType const & x,
  genType const & y,
  typename genType::value_type const & epsilon);





 template <typename genType>
               bool epsilonNotEqual(
  genType const & x,
  genType const & y,
  genType const & epsilon);


}


# 1 "/usr/local/include/glm/gtc/epsilon.inl" 1 3
# 12 "/usr/local/include/glm/gtc/epsilon.inl" 3
namespace glm
{
 template <> inline
                    bool epsilonEqual
 (
  float const & x,
  float const & y,
  float const & epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template <> inline
                    bool epsilonEqual
 (
  double const & x,
  double const & y,
  double const & epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template <> inline
                    bool epsilonNotEqual
 (
  float const & x,
  float const & y,
  float const & epsilon
 )
 {
  return abs(x - y) >= epsilon;
 }

 template <> inline
                    bool epsilonNotEqual
 (
  double const & x,
  double const & y,
  double const & epsilon
 )
 {
  return abs(x - y) >= epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  T const & epsilon
 )
 {
  return lessThan(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  vecType<T, P> const & epsilon
 )
 {
  return lessThan(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonNotEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  T const & epsilon
 )
 {
  return greaterThanEqual(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> epsilonNotEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y,
  vecType<T, P> const & epsilon
 )
 {
  return greaterThanEqual(abs(x - y), vecType<T, P>(epsilon));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> epsilonEqual
 (
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & epsilon
 )
 {
  tvec4<T, P> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), tvec4<T, P>(epsilon));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> epsilonNotEqual
 (
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & epsilon
 )
 {
  tvec4<T, P> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), tvec4<T, P>(epsilon));
 }
}
# 73 "/usr/local/include/glm/./gtc/epsilon.hpp" 2 3
# 40 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/functions.hpp" 1 3
# 26 "/usr/local/include/glm/./gtc/functions.hpp" 3
namespace glm
{






 template <typename T>
               T gauss(
  T x,
  T ExpectedValue,
  T StandardDeviation);




 template <typename T, precision P>
               T gauss(
  tvec2<T, P> const& Coord,
  tvec2<T, P> const& ExpectedValue,
  tvec2<T, P> const& StandardDeviation);


}


# 1 "/usr/local/include/glm/gtc/functions.inl" 1 3





namespace glm
{
 template <typename T> inline
                    T gauss
 (
  T x,
  T ExpectedValue,
  T StandardDeviation
 )
 {
  return exp(-((x - ExpectedValue) * (x - ExpectedValue)) / (static_cast<T>(2) * StandardDeviation * StandardDeviation)) / (StandardDeviation * sqrt(static_cast<T>(6.28318530717958647692528676655900576)));
 }

 template <typename T, precision P> inline
                    T gauss
 (
  tvec2<T, P> const& Coord,
  tvec2<T, P> const& ExpectedValue,
  tvec2<T, P> const& StandardDeviation
 )
 {
  tvec2<T, P> const Squared = ((Coord - ExpectedValue) * (Coord - ExpectedValue)) / (static_cast<T>(2) * StandardDeviation * StandardDeviation);
  return exp(-(Squared.x + Squared.y));
 }
}
# 52 "/usr/local/include/glm/./gtc/functions.hpp" 2 3
# 41 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/integer.hpp" 1 3
# 28 "/usr/local/include/glm/./gtc/integer.hpp" 3
namespace glm
{





 template <typename genIUType>
               genIUType log2(genIUType x);
# 46 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename genIUType>
               genIUType mod(genIUType x, genIUType y);
# 58 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, T y);
# 70 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y);
# 83 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<int, P> iround(vecType<T, P> const & x);
# 96 "/usr/local/include/glm/./gtc/integer.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<uint, P> uround(vecType<T, P> const & x);


}


# 1 "/usr/local/include/glm/gtc/integer.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType, bool Aligned>
 struct compute_log2<T, P, vecType, false, Aligned>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & vec)
  {


   return vecType<T, P>(detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(vec));
  }
 };
# 35 "/usr/local/include/glm/gtc/integer.inl" 3
}
 template <typename genType> inline
                    int iround(genType x)
 {
                                                                                                          ;
  (__builtin_expect(!(static_cast<genType>(0.0) <= x), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 40, "static_cast<genType>(0.0) <= x") : (void)0);

  return static_cast<int>(x + static_cast<genType>(0.5));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<int, P> iround(vecType<T, P> const& x)
 {
                                                                                                    ;
  (__builtin_expect(!(all(lessThanEqual(vecType<T, P>(0), x))), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 49, "all(lessThanEqual(vecType<T, P>(0), x))") : (void)0);

  return vecType<int, P>(x + static_cast<T>(0.5));
 }

 template <typename genType> inline
                    uint uround(genType x)
 {
                                                                                                          ;
  (__builtin_expect(!(static_cast<genType>(0.0) <= x), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 58, "static_cast<genType>(0.0) <= x") : (void)0);

  return static_cast<uint>(x + static_cast<genType>(0.5));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<uint, P> uround(vecType<T, P> const& x)
 {
                                                                                                    ;
  (__builtin_expect(!(all(lessThanEqual(vecType<T, P>(0), x))), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/integer.inl", 67, "all(lessThanEqual(vecType<T, P>(0), x))") : (void)0);

  return vecType<uint, P>(x + static_cast<T>(0.5));
 }
}
# 102 "/usr/local/include/glm/./gtc/integer.hpp" 2 3
# 42 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/matrix_access.hpp" 1 3
# 21 "/usr/local/include/glm/./gtc/matrix_access.hpp" 3
namespace glm
{





 template <typename genType>
               typename genType::row_type row(
  genType const & m,
  length_t index);



 template <typename genType>
               genType row(
  genType const & m,
  length_t index,
  typename genType::row_type const & x);



 template <typename genType>
               typename genType::col_type column(
  genType const & m,
  length_t index);



 template <typename genType>
               genType column(
  genType const & m,
  length_t index,
  typename genType::col_type const & x);


}


# 1 "/usr/local/include/glm/gtc/matrix_access.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType row
 (
  genType const & m,
  length_t index,
  typename genType::row_type const & x
 )
 {
  (__builtin_expect(!(index >= 0 && index < m[0].length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 14, "index >= 0 && index < m[0].length()") : (void)0);

  genType Result = m;
  for(length_t i = 0; i < m.length(); ++i)
   Result[i][index] = x[i];
  return Result;
 }

 template <typename genType> inline
                    typename genType::row_type row
 (
  genType const & m,
  length_t index
 )
 {
  (__builtin_expect(!(index >= 0 && index < m[0].length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 29, "index >= 0 && index < m[0].length()") : (void)0);

  typename genType::row_type Result;
  for(length_t i = 0; i < m.length(); ++i)
   Result[i] = m[i][index];
  return Result;
 }

 template <typename genType> inline
                    genType column
 (
  genType const & m,
  length_t index,
  typename genType::col_type const & x
 )
 {
  (__builtin_expect(!(index >= 0 && index < m.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 45, "index >= 0 && index < m.length()") : (void)0);

  genType Result = m;
  Result[index] = x;
  return Result;
 }

 template <typename genType> inline
                    typename genType::col_type column
 (
  genType const & m,
  length_t index
 )
 {
  (__builtin_expect(!(index >= 0 && index < m.length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/gtc/matrix_access.inl", 59, "index >= 0 && index < m.length()") : (void)0);

  return m[index];
 }
}
# 59 "/usr/local/include/glm/./gtc/matrix_access.hpp" 2 3
# 43 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 1 3
# 29 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
namespace glm
{





 typedef tmat2x2<int, highp> highp_imat2;



 typedef tmat3x3<int, highp> highp_imat3;



 typedef tmat4x4<int, highp> highp_imat4;



 typedef tmat2x2<int, highp> highp_imat2x2;



 typedef tmat2x3<int, highp> highp_imat2x3;



 typedef tmat2x4<int, highp> highp_imat2x4;



 typedef tmat3x2<int, highp> highp_imat3x2;



 typedef tmat3x3<int, highp> highp_imat3x3;



 typedef tmat3x4<int, highp> highp_imat3x4;



 typedef tmat4x2<int, highp> highp_imat4x2;



 typedef tmat4x3<int, highp> highp_imat4x3;



 typedef tmat4x4<int, highp> highp_imat4x4;




 typedef tmat2x2<int, mediump> mediump_imat2;



 typedef tmat3x3<int, mediump> mediump_imat3;



 typedef tmat4x4<int, mediump> mediump_imat4;




 typedef tmat2x2<int, mediump> mediump_imat2x2;



 typedef tmat2x3<int, mediump> mediump_imat2x3;



 typedef tmat2x4<int, mediump> mediump_imat2x4;



 typedef tmat3x2<int, mediump> mediump_imat3x2;



 typedef tmat3x3<int, mediump> mediump_imat3x3;



 typedef tmat3x4<int, mediump> mediump_imat3x4;



 typedef tmat4x2<int, mediump> mediump_imat4x2;



 typedef tmat4x3<int, mediump> mediump_imat4x3;



 typedef tmat4x4<int, mediump> mediump_imat4x4;




 typedef tmat2x2<int, lowp> lowp_imat2;



 typedef tmat3x3<int, lowp> lowp_imat3;



 typedef tmat4x4<int, lowp> lowp_imat4;




 typedef tmat2x2<int, lowp> lowp_imat2x2;



 typedef tmat2x3<int, lowp> lowp_imat2x3;



 typedef tmat2x4<int, lowp> lowp_imat2x4;



 typedef tmat3x2<int, lowp> lowp_imat3x2;



 typedef tmat3x3<int, lowp> lowp_imat3x3;



 typedef tmat3x4<int, lowp> lowp_imat3x4;



 typedef tmat4x2<int, lowp> lowp_imat4x2;



 typedef tmat4x3<int, lowp> lowp_imat4x3;



 typedef tmat4x4<int, lowp> lowp_imat4x4;




 typedef tmat2x2<uint, highp> highp_umat2;



 typedef tmat3x3<uint, highp> highp_umat3;



 typedef tmat4x4<uint, highp> highp_umat4;



 typedef tmat2x2<uint, highp> highp_umat2x2;



 typedef tmat2x3<uint, highp> highp_umat2x3;



 typedef tmat2x4<uint, highp> highp_umat2x4;



 typedef tmat3x2<uint, highp> highp_umat3x2;



 typedef tmat3x3<uint, highp> highp_umat3x3;



 typedef tmat3x4<uint, highp> highp_umat3x4;



 typedef tmat4x2<uint, highp> highp_umat4x2;



 typedef tmat4x3<uint, highp> highp_umat4x3;



 typedef tmat4x4<uint, highp> highp_umat4x4;




 typedef tmat2x2<uint, mediump> mediump_umat2;



 typedef tmat3x3<uint, mediump> mediump_umat3;



 typedef tmat4x4<uint, mediump> mediump_umat4;




 typedef tmat2x2<uint, mediump> mediump_umat2x2;



 typedef tmat2x3<uint, mediump> mediump_umat2x3;



 typedef tmat2x4<uint, mediump> mediump_umat2x4;



 typedef tmat3x2<uint, mediump> mediump_umat3x2;



 typedef tmat3x3<uint, mediump> mediump_umat3x3;



 typedef tmat3x4<uint, mediump> mediump_umat3x4;



 typedef tmat4x2<uint, mediump> mediump_umat4x2;



 typedef tmat4x3<uint, mediump> mediump_umat4x3;



 typedef tmat4x4<uint, mediump> mediump_umat4x4;




 typedef tmat2x2<uint, lowp> lowp_umat2;



 typedef tmat3x3<uint, lowp> lowp_umat3;



 typedef tmat4x4<uint, lowp> lowp_umat4;




 typedef tmat2x2<uint, lowp> lowp_umat2x2;



 typedef tmat2x3<uint, lowp> lowp_umat2x3;



 typedef tmat2x4<uint, lowp> lowp_umat2x4;



 typedef tmat3x2<uint, lowp> lowp_umat3x2;



 typedef tmat3x3<uint, lowp> lowp_umat3x3;



 typedef tmat3x4<uint, lowp> lowp_umat3x4;



 typedef tmat4x2<uint, lowp> lowp_umat4x2;



 typedef tmat4x3<uint, lowp> lowp_umat4x3;



 typedef tmat4x4<uint, lowp> lowp_umat4x4;
# 361 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
 typedef mediump_imat2 imat2;



 typedef mediump_imat3 imat3;



 typedef mediump_imat4 imat4;



 typedef mediump_imat2x2 imat2x2;



 typedef mediump_imat2x3 imat2x3;



 typedef mediump_imat2x4 imat2x4;



 typedef mediump_imat3x2 imat3x2;



 typedef mediump_imat3x3 imat3x3;



 typedef mediump_imat3x4 imat3x4;



 typedef mediump_imat4x2 imat4x2;



 typedef mediump_imat4x3 imat4x3;



 typedef mediump_imat4x4 imat4x4;
# 438 "/usr/local/include/glm/./gtc/matrix_integer.hpp" 3
 typedef mediump_umat2 umat2;



 typedef mediump_umat3 umat3;



 typedef mediump_umat4 umat4;



 typedef mediump_umat2x2 umat2x2;



 typedef mediump_umat2x3 umat2x3;



 typedef mediump_umat2x4 umat2x4;



 typedef mediump_umat3x2 umat3x2;



 typedef mediump_umat3x3 umat3x3;



 typedef mediump_umat3x4 umat3x4;



 typedef mediump_umat4x2 umat4x2;



 typedef mediump_umat4x3 umat4x3;



 typedef mediump_umat4x4 umat4x4;



}
# 44 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 3
namespace glm
{
# 35 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 3
 template <typename genType>
               genType affineInverse(genType const & m);






 template <typename genType>
               genType inverseTranspose(genType const & m);


}


# 1 "/usr/local/include/glm/gtc/matrix_inverse.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> affineInverse(tmat3x3<T, P> const & m)
 {
  tmat2x2<T, P> const Inv(inverse(tmat2x2<T, P>(m)));

  return tmat3x3<T, P>(
   tvec3<T, P>(Inv[0], static_cast<T>(0)),
   tvec3<T, P>(Inv[1], static_cast<T>(0)),
   tvec3<T, P>(-Inv * tvec2<T, P>(m[2]), static_cast<T>(1)));
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> affineInverse(tmat4x4<T, P> const & m)
 {
  tmat3x3<T, P> const Inv(inverse(tmat3x3<T, P>(m)));

  return tmat4x4<T, P>(
   tvec4<T, P>(Inv[0], static_cast<T>(0)),
   tvec4<T, P>(Inv[1], static_cast<T>(0)),
   tvec4<T, P>(Inv[2], static_cast<T>(0)),
   tvec4<T, P>(-Inv * tvec3<T, P>(m[3]), static_cast<T>(1)));
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> inverseTranspose(tmat2x2<T, P> const & m)
 {
  T Determinant = m[0][0] * m[1][1] - m[1][0] * m[0][1];

  tmat2x2<T, P> Inverse(
   + m[1][1] / Determinant,
   - m[0][1] / Determinant,
   - m[1][0] / Determinant,
   + m[0][0] / Determinant);

  return Inverse;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> inverseTranspose(tmat3x3<T, P> const & m)
 {
  T Determinant =
   + m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
   - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
   + m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

  tmat3x3<T, P> Inverse(uninitialize);
  Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
  Inverse[0][1] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
  Inverse[0][2] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
  Inverse[1][0] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
  Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
  Inverse[1][2] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
  Inverse[2][0] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  Inverse[2][1] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
  Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
  Inverse /= Determinant;

  return Inverse;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> inverseTranspose(tmat4x4<T, P> const & m)
 {
  T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T SubFactor11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
  T SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
  T SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
  T SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
  T SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
  T SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  tmat4x4<T, P> Inverse(uninitialize);
  Inverse[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);
  Inverse[0][1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);
  Inverse[0][2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);
  Inverse[0][3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);

  Inverse[1][0] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);
  Inverse[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);
  Inverse[1][2] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);
  Inverse[1][3] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);

  Inverse[2][0] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);
  Inverse[2][1] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);
  Inverse[2][2] = + (m[0][0] * SubFactor11 - m[0][1] * SubFactor09 + m[0][3] * SubFactor12);
  Inverse[2][3] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor12);

  Inverse[3][0] = - (m[0][1] * SubFactor13 - m[0][2] * SubFactor14 + m[0][3] * SubFactor15);
  Inverse[3][1] = + (m[0][0] * SubFactor13 - m[0][2] * SubFactor16 + m[0][3] * SubFactor17);
  Inverse[3][2] = - (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][3] * SubFactor18);
  Inverse[3][3] = + (m[0][0] * SubFactor15 - m[0][1] * SubFactor17 + m[0][2] * SubFactor18);

  T Determinant =
   + m[0][0] * Inverse[0][0]
   + m[0][1] * Inverse[0][1]
   + m[0][2] * Inverse[0][2]
   + m[0][3] * Inverse[0][3];

  Inverse /= Determinant;

  return Inverse;
 }
}
# 49 "/usr/local/include/glm/./gtc/matrix_inverse.hpp" 2 3
# 45 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/noise.hpp" 1 3
# 21 "/usr/local/include/glm/./gtc/noise.hpp" 3
# 1 "/usr/local/include/glm/gtc/../detail/_noise.hpp" 1 3
# 11 "/usr/local/include/glm/gtc/../detail/_noise.hpp" 3
namespace glm{
namespace detail
{
 template <typename T> inline
                    T mod289(T const & x)
 {
  return x - floor(x * static_cast<T>(1.0) / static_cast<T>(289.0)) * static_cast<T>(289.0);
 }

 template <typename T> inline
                    T permute(T const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template <typename T, precision P> inline
                    tvec2<T, P> permute(tvec2<T, P> const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> permute(tvec3<T, P> const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }

 template <typename T, precision P> inline
                    tvec4<T, P> permute(tvec4<T, P> const & x)
 {
  return mod289(((x * static_cast<T>(34)) + static_cast<T>(1)) * x);
 }







 template <typename T> inline
                    T taylorInvSqrt(T const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> taylorInvSqrt(tvec2<T, P> const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> taylorInvSqrt(tvec3<T, P> const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> taylorInvSqrt(tvec4<T, P> const & r)
 {
  return T(1.79284291400159) - T(0.85373472095314) * r;
 }
# 81 "/usr/local/include/glm/gtc/../detail/_noise.hpp" 3
 template <typename T, precision P> inline
                    tvec2<T, P> fade(tvec2<T, P> const & t)
 {
  return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> fade(tvec3<T, P> const & t)
 {
  return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> fade(tvec4<T, P> const & t)
 {
  return (t * t * t) * (t * (t * T(6) - T(15)) + T(10));
 }







}
}
# 21 "/usr/local/include/glm/./gtc/noise.hpp" 2 3
# 33 "/usr/local/include/glm/./gtc/noise.hpp" 3
namespace glm
{





 template <typename T, precision P, template<typename, precision> class vecType>
               T perlin(
  vecType<T, P> const & p);



 template <typename T, precision P, template<typename, precision> class vecType>
               T perlin(
  vecType<T, P> const & p,
  vecType<T, P> const & rep);



 template <typename T, precision P, template<typename, precision> class vecType>
               T simplex(
  vecType<T, P> const & p);


}


# 1 "/usr/local/include/glm/gtc/noise.inl" 1 3








namespace glm{
namespace gtc
{
 template <typename T, precision P> inline
                    tvec4<T, P> grad4(T const & j, tvec4<T, P> const & ip)
 {
  tvec3<T, P> pXYZ = floor(fract(tvec3<T, P>(j) * tvec3<T, P>(ip)) * T(7)) * ip[2] - T(1);
  T pW = static_cast<T>(1.5) - dot(abs(pXYZ), tvec3<T, P>(1));
  tvec4<T, P> s = tvec4<T, P>(lessThan(tvec4<T, P>(pXYZ, pW), tvec4<T, P>(0.0)));
  pXYZ = pXYZ + (tvec3<T, P>(s) * T(2) - T(1)) * s.w;
  return tvec4<T, P>(pXYZ, pW);
 }
}


 template <typename T, precision P> inline
                    T perlin(tvec2<T, P> const & Position)
 {
  tvec4<T, P> Pi = glm::floor(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) + tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  tvec4<T, P> Pf = glm::fract(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) - tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, tvec4<T, P>(289));
  tvec4<T, P> ix(Pi.x, Pi.z, Pi.x, Pi.z);
  tvec4<T, P> iy(Pi.y, Pi.y, Pi.w, Pi.w);
  tvec4<T, P> fx(Pf.x, Pf.z, Pf.x, Pf.z);
  tvec4<T, P> fy(Pf.y, Pf.y, Pf.w, Pf.w);

  tvec4<T, P> i = detail::permute(detail::permute(ix) + iy);

  tvec4<T, P> gx = static_cast<T>(2) * glm::fract(i / T(41)) - T(1);
  tvec4<T, P> gy = glm::abs(gx) - T(0.5);
  tvec4<T, P> tx = glm::floor(gx + T(0.5));
  gx = gx - tx;

  tvec2<T, P> g00(gx.x, gy.x);
  tvec2<T, P> g10(gx.y, gy.y);
  tvec2<T, P> g01(gx.z, gy.z);
  tvec2<T, P> g11(gx.w, gy.w);

  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  T n00 = dot(g00, tvec2<T, P>(fx.x, fy.x));
  T n10 = dot(g10, tvec2<T, P>(fx.y, fy.y));
  T n01 = dot(g01, tvec2<T, P>(fx.z, fy.z));
  T n11 = dot(g11, tvec2<T, P>(fx.w, fy.w));

  tvec2<T, P> fade_xy = detail::fade(tvec2<T, P>(Pf.x, Pf.y));
  tvec2<T, P> n_x = mix(tvec2<T, P>(n00, n01), tvec2<T, P>(n10, n11), fade_xy.x);
  T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return T(2.3) * n_xy;
 }


 template <typename T, precision P> inline
                    T perlin(tvec3<T, P> const & Position)
 {
  tvec3<T, P> Pi0 = floor(Position);
  tvec3<T, P> Pi1 = Pi0 + T(1);
  Pi0 = detail::mod289(Pi0);
  Pi1 = detail::mod289(Pi1);
  tvec3<T, P> Pf0 = fract(Position);
  tvec3<T, P> Pf1 = Pf0 - T(1);
  tvec4<T, P> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy = tvec4<T, P>(tvec2<T, P>(Pi0.y), tvec2<T, P>(Pi1.y));
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);

  tvec4<T, P> gx0 = ixy0 * T(1.0 / 7.0);
  tvec4<T, P> gy0 = fract(floor(gx0) * T(1.0 / 7.0)) - T(0.5);
  gx0 = fract(gx0);
  tvec4<T, P> gz0 = tvec4<T, P>(0.5) - abs(gx0) - abs(gy0);
  tvec4<T, P> sz0 = step(gz0, tvec4<T, P>(0.0));
  gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
  gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

  tvec4<T, P> gx1 = ixy1 * T(1.0 / 7.0);
  tvec4<T, P> gy1 = fract(floor(gx1) * T(1.0 / 7.0)) - T(0.5);
  gx1 = fract(gx1);
  tvec4<T, P> gz1 = tvec4<T, P>(0.5) - abs(gx1) - abs(gy1);
  tvec4<T, P> sz1 = step(gz1, tvec4<T, P>(0.0));
  gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
  gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

  tvec3<T, P> g000(gx0.x, gy0.x, gz0.x);
  tvec3<T, P> g100(gx0.y, gy0.y, gz0.y);
  tvec3<T, P> g010(gx0.z, gy0.z, gz0.z);
  tvec3<T, P> g110(gx0.w, gy0.w, gz0.w);
  tvec3<T, P> g001(gx1.x, gy1.x, gz1.x);
  tvec3<T, P> g101(gx1.y, gy1.y, gz1.y);
  tvec3<T, P> g011(gx1.z, gy1.z, gz1.z);
  tvec3<T, P> g111(gx1.w, gy1.w, gz1.w);

  tvec4<T, P> norm0 = detail::taylorInvSqrt(tvec4<T, P>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  tvec4<T, P> norm1 = detail::taylorInvSqrt(tvec4<T, P>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  T n000 = dot(g000, Pf0);
  T n100 = dot(g100, tvec3<T, P>(Pf1.x, Pf0.y, Pf0.z));
  T n010 = dot(g010, tvec3<T, P>(Pf0.x, Pf1.y, Pf0.z));
  T n110 = dot(g110, tvec3<T, P>(Pf1.x, Pf1.y, Pf0.z));
  T n001 = dot(g001, tvec3<T, P>(Pf0.x, Pf0.y, Pf1.z));
  T n101 = dot(g101, tvec3<T, P>(Pf1.x, Pf0.y, Pf1.z));
  T n011 = dot(g011, tvec3<T, P>(Pf0.x, Pf1.y, Pf1.z));
  T n111 = dot(g111, Pf1);

  tvec3<T, P> fade_xyz = detail::fade(Pf0);
  tvec4<T, P> n_z = mix(tvec4<T, P>(n000, n100, n010, n110), tvec4<T, P>(n001, n101, n011, n111), fade_xyz.z);
  tvec2<T, P> n_yz = mix(tvec2<T, P>(n_z.x, n_z.y), tvec2<T, P>(n_z.z, n_z.w), fade_xyz.y);
  T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return T(2.2) * n_xyz;
 }
# 209 "/usr/local/include/glm/gtc/noise.inl" 3
 template <typename T, precision P> inline
                    T perlin(tvec4<T, P> const & Position)
 {
  tvec4<T, P> Pi0 = floor(Position);
  tvec4<T, P> Pi1 = Pi0 + T(1);
  Pi0 = mod(Pi0, tvec4<T, P>(289));
  Pi1 = mod(Pi1, tvec4<T, P>(289));
  tvec4<T, P> Pf0 = fract(Position);
  tvec4<T, P> Pf1 = Pf0 - T(1);
  tvec4<T, P> ix(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);
  tvec4<T, P> iw0(Pi0.w);
  tvec4<T, P> iw1(Pi1.w);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);
  tvec4<T, P> ixy00 = detail::permute(ixy0 + iw0);
  tvec4<T, P> ixy01 = detail::permute(ixy0 + iw1);
  tvec4<T, P> ixy10 = detail::permute(ixy1 + iw0);
  tvec4<T, P> ixy11 = detail::permute(ixy1 + iw1);

  tvec4<T, P> gx00 = ixy00 / T(7);
  tvec4<T, P> gy00 = floor(gx00) / T(7);
  tvec4<T, P> gz00 = floor(gy00) / T(6);
  gx00 = fract(gx00) - T(0.5);
  gy00 = fract(gy00) - T(0.5);
  gz00 = fract(gz00) - T(0.5);
  tvec4<T, P> gw00 = tvec4<T, P>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  tvec4<T, P> sw00 = step(gw00, tvec4<T, P>(0.0));
  gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
  gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

  tvec4<T, P> gx01 = ixy01 / T(7);
  tvec4<T, P> gy01 = floor(gx01) / T(7);
  tvec4<T, P> gz01 = floor(gy01) / T(6);
  gx01 = fract(gx01) - T(0.5);
  gy01 = fract(gy01) - T(0.5);
  gz01 = fract(gz01) - T(0.5);
  tvec4<T, P> gw01 = tvec4<T, P>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  tvec4<T, P> sw01 = step(gw01, tvec4<T, P>(0.0));
  gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
  gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

  tvec4<T, P> gx10 = ixy10 / T(7);
  tvec4<T, P> gy10 = floor(gx10) / T(7);
  tvec4<T, P> gz10 = floor(gy10) / T(6);
  gx10 = fract(gx10) - T(0.5);
  gy10 = fract(gy10) - T(0.5);
  gz10 = fract(gz10) - T(0.5);
  tvec4<T, P> gw10 = tvec4<T, P>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  tvec4<T, P> sw10 = step(gw10, tvec4<T, P>(0));
  gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
  gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

  tvec4<T, P> gx11 = ixy11 / T(7);
  tvec4<T, P> gy11 = floor(gx11) / T(7);
  tvec4<T, P> gz11 = floor(gy11) / T(6);
  gx11 = fract(gx11) - T(0.5);
  gy11 = fract(gy11) - T(0.5);
  gz11 = fract(gz11) - T(0.5);
  tvec4<T, P> gw11 = tvec4<T, P>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  tvec4<T, P> sw11 = step(gw11, tvec4<T, P>(0.0));
  gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
  gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

  tvec4<T, P> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
  tvec4<T, P> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
  tvec4<T, P> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
  tvec4<T, P> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
  tvec4<T, P> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
  tvec4<T, P> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
  tvec4<T, P> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
  tvec4<T, P> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
  tvec4<T, P> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
  tvec4<T, P> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
  tvec4<T, P> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
  tvec4<T, P> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
  tvec4<T, P> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
  tvec4<T, P> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
  tvec4<T, P> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
  tvec4<T, P> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

  tvec4<T, P> norm00 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  tvec4<T, P> norm01 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  tvec4<T, P> norm10 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  tvec4<T, P> norm11 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  T n0000 = dot(g0000, Pf0);
  T n1000 = dot(g1000, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
  T n0100 = dot(g0100, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
  T n1100 = dot(g1100, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
  T n0010 = dot(g0010, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
  T n1010 = dot(g1010, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  T n0110 = dot(g0110, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
  T n1110 = dot(g1110, tvec4<T, P>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
  T n0001 = dot(g0001, tvec4<T, P>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
  T n1001 = dot(g1001, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
  T n0101 = dot(g0101, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  T n1101 = dot(g1101, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
  T n0011 = dot(g0011, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
  T n1011 = dot(g1011, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
  T n0111 = dot(g0111, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
  T n1111 = dot(g1111, Pf1);

  tvec4<T, P> fade_xyzw = detail::fade(Pf0);
  tvec4<T, P> n_0w = mix(tvec4<T, P>(n0000, n1000, n0100, n1100), tvec4<T, P>(n0001, n1001, n0101, n1101), fade_xyzw.w);
  tvec4<T, P> n_1w = mix(tvec4<T, P>(n0010, n1010, n0110, n1110), tvec4<T, P>(n0011, n1011, n0111, n1111), fade_xyzw.w);
  tvec4<T, P> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  tvec2<T, P> n_yzw = mix(tvec2<T, P>(n_zw.x, n_zw.y), tvec2<T, P>(n_zw.z, n_zw.w), fade_xyzw.y);
  T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return T(2.2) * n_xyzw;
 }


 template <typename T, precision P> inline
                    T perlin(tvec2<T, P> const & Position, tvec2<T, P> const & rep)
 {
  tvec4<T, P> Pi = floor(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) + tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  tvec4<T, P> Pf = fract(tvec4<T, P>(Position.x, Position.y, Position.x, Position.y)) - tvec4<T, P>(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, tvec4<T, P>(rep.x, rep.y, rep.x, rep.y));
  Pi = mod(Pi, tvec4<T, P>(289));
  tvec4<T, P> ix(Pi.x, Pi.z, Pi.x, Pi.z);
  tvec4<T, P> iy(Pi.y, Pi.y, Pi.w, Pi.w);
  tvec4<T, P> fx(Pf.x, Pf.z, Pf.x, Pf.z);
  tvec4<T, P> fy(Pf.y, Pf.y, Pf.w, Pf.w);

  tvec4<T, P> i = detail::permute(detail::permute(ix) + iy);

  tvec4<T, P> gx = static_cast<T>(2) * fract(i / T(41)) - T(1);
  tvec4<T, P> gy = abs(gx) - T(0.5);
  tvec4<T, P> tx = floor(gx + T(0.5));
  gx = gx - tx;

  tvec2<T, P> g00(gx.x, gy.x);
  tvec2<T, P> g10(gx.y, gy.y);
  tvec2<T, P> g01(gx.z, gy.z);
  tvec2<T, P> g11(gx.w, gy.w);

  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;

  T n00 = dot(g00, tvec2<T, P>(fx.x, fy.x));
  T n10 = dot(g10, tvec2<T, P>(fx.y, fy.y));
  T n01 = dot(g01, tvec2<T, P>(fx.z, fy.z));
  T n11 = dot(g11, tvec2<T, P>(fx.w, fy.w));

  tvec2<T, P> fade_xy = detail::fade(tvec2<T, P>(Pf.x, Pf.y));
  tvec2<T, P> n_x = mix(tvec2<T, P>(n00, n01), tvec2<T, P>(n10, n11), fade_xy.x);
  T n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return T(2.3) * n_xy;
 }


 template <typename T, precision P> inline
                    T perlin(tvec3<T, P> const & Position, tvec3<T, P> const & rep)
 {
  tvec3<T, P> Pi0 = mod(floor(Position), rep);
  tvec3<T, P> Pi1 = mod(Pi0 + tvec3<T, P>(T(1)), rep);
  Pi0 = mod(Pi0, tvec3<T, P>(289));
  Pi1 = mod(Pi1, tvec3<T, P>(289));
  tvec3<T, P> Pf0 = fract(Position);
  tvec3<T, P> Pf1 = Pf0 - tvec3<T, P>(T(1));
  tvec4<T, P> ix = tvec4<T, P>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy = tvec4<T, P>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);

  tvec4<T, P> gx0 = ixy0 / T(7);
  tvec4<T, P> gy0 = fract(floor(gx0) / T(7)) - T(0.5);
  gx0 = fract(gx0);
  tvec4<T, P> gz0 = tvec4<T, P>(0.5) - abs(gx0) - abs(gy0);
  tvec4<T, P> sz0 = step(gz0, tvec4<T, P>(0));
  gx0 -= sz0 * (step(T(0), gx0) - T(0.5));
  gy0 -= sz0 * (step(T(0), gy0) - T(0.5));

  tvec4<T, P> gx1 = ixy1 / T(7);
  tvec4<T, P> gy1 = fract(floor(gx1) / T(7)) - T(0.5);
  gx1 = fract(gx1);
  tvec4<T, P> gz1 = tvec4<T, P>(0.5) - abs(gx1) - abs(gy1);
  tvec4<T, P> sz1 = step(gz1, tvec4<T, P>(T(0)));
  gx1 -= sz1 * (step(T(0), gx1) - T(0.5));
  gy1 -= sz1 * (step(T(0), gy1) - T(0.5));

  tvec3<T, P> g000 = tvec3<T, P>(gx0.x, gy0.x, gz0.x);
  tvec3<T, P> g100 = tvec3<T, P>(gx0.y, gy0.y, gz0.y);
  tvec3<T, P> g010 = tvec3<T, P>(gx0.z, gy0.z, gz0.z);
  tvec3<T, P> g110 = tvec3<T, P>(gx0.w, gy0.w, gz0.w);
  tvec3<T, P> g001 = tvec3<T, P>(gx1.x, gy1.x, gz1.x);
  tvec3<T, P> g101 = tvec3<T, P>(gx1.y, gy1.y, gz1.y);
  tvec3<T, P> g011 = tvec3<T, P>(gx1.z, gy1.z, gz1.z);
  tvec3<T, P> g111 = tvec3<T, P>(gx1.w, gy1.w, gz1.w);

  tvec4<T, P> norm0 = detail::taylorInvSqrt(tvec4<T, P>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  tvec4<T, P> norm1 = detail::taylorInvSqrt(tvec4<T, P>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  T n000 = dot(g000, Pf0);
  T n100 = dot(g100, tvec3<T, P>(Pf1.x, Pf0.y, Pf0.z));
  T n010 = dot(g010, tvec3<T, P>(Pf0.x, Pf1.y, Pf0.z));
  T n110 = dot(g110, tvec3<T, P>(Pf1.x, Pf1.y, Pf0.z));
  T n001 = dot(g001, tvec3<T, P>(Pf0.x, Pf0.y, Pf1.z));
  T n101 = dot(g101, tvec3<T, P>(Pf1.x, Pf0.y, Pf1.z));
  T n011 = dot(g011, tvec3<T, P>(Pf0.x, Pf1.y, Pf1.z));
  T n111 = dot(g111, Pf1);

  tvec3<T, P> fade_xyz = detail::fade(Pf0);
  tvec4<T, P> n_z = mix(tvec4<T, P>(n000, n100, n010, n110), tvec4<T, P>(n001, n101, n011, n111), fade_xyz.z);
  tvec2<T, P> n_yz = mix(tvec2<T, P>(n_z.x, n_z.y), tvec2<T, P>(n_z.z, n_z.w), fade_xyz.y);
  T n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return T(2.2) * n_xyz;
 }


 template <typename T, precision P> inline
                    T perlin(tvec4<T, P> const & Position, tvec4<T, P> const & rep)
 {
  tvec4<T, P> Pi0 = mod(floor(Position), rep);
  tvec4<T, P> Pi1 = mod(Pi0 + T(1), rep);
  tvec4<T, P> Pf0 = fract(Position);
  tvec4<T, P> Pf1 = Pf0 - T(1);
  tvec4<T, P> ix = tvec4<T, P>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  tvec4<T, P> iy = tvec4<T, P>(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
  tvec4<T, P> iz0(Pi0.z);
  tvec4<T, P> iz1(Pi1.z);
  tvec4<T, P> iw0(Pi0.w);
  tvec4<T, P> iw1(Pi1.w);

  tvec4<T, P> ixy = detail::permute(detail::permute(ix) + iy);
  tvec4<T, P> ixy0 = detail::permute(ixy + iz0);
  tvec4<T, P> ixy1 = detail::permute(ixy + iz1);
  tvec4<T, P> ixy00 = detail::permute(ixy0 + iw0);
  tvec4<T, P> ixy01 = detail::permute(ixy0 + iw1);
  tvec4<T, P> ixy10 = detail::permute(ixy1 + iw0);
  tvec4<T, P> ixy11 = detail::permute(ixy1 + iw1);

  tvec4<T, P> gx00 = ixy00 / T(7);
  tvec4<T, P> gy00 = floor(gx00) / T(7);
  tvec4<T, P> gz00 = floor(gy00) / T(6);
  gx00 = fract(gx00) - T(0.5);
  gy00 = fract(gy00) - T(0.5);
  gz00 = fract(gz00) - T(0.5);
  tvec4<T, P> gw00 = tvec4<T, P>(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  tvec4<T, P> sw00 = step(gw00, tvec4<T, P>(0));
  gx00 -= sw00 * (step(T(0), gx00) - T(0.5));
  gy00 -= sw00 * (step(T(0), gy00) - T(0.5));

  tvec4<T, P> gx01 = ixy01 / T(7);
  tvec4<T, P> gy01 = floor(gx01) / T(7);
  tvec4<T, P> gz01 = floor(gy01) / T(6);
  gx01 = fract(gx01) - T(0.5);
  gy01 = fract(gy01) - T(0.5);
  gz01 = fract(gz01) - T(0.5);
  tvec4<T, P> gw01 = tvec4<T, P>(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  tvec4<T, P> sw01 = step(gw01, tvec4<T, P>(0.0));
  gx01 -= sw01 * (step(T(0), gx01) - T(0.5));
  gy01 -= sw01 * (step(T(0), gy01) - T(0.5));

  tvec4<T, P> gx10 = ixy10 / T(7);
  tvec4<T, P> gy10 = floor(gx10) / T(7);
  tvec4<T, P> gz10 = floor(gy10) / T(6);
  gx10 = fract(gx10) - T(0.5);
  gy10 = fract(gy10) - T(0.5);
  gz10 = fract(gz10) - T(0.5);
  tvec4<T, P> gw10 = tvec4<T, P>(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  tvec4<T, P> sw10 = step(gw10, tvec4<T, P>(0.0));
  gx10 -= sw10 * (step(T(0), gx10) - T(0.5));
  gy10 -= sw10 * (step(T(0), gy10) - T(0.5));

  tvec4<T, P> gx11 = ixy11 / T(7);
  tvec4<T, P> gy11 = floor(gx11) / T(7);
  tvec4<T, P> gz11 = floor(gy11) / T(6);
  gx11 = fract(gx11) - T(0.5);
  gy11 = fract(gy11) - T(0.5);
  gz11 = fract(gz11) - T(0.5);
  tvec4<T, P> gw11 = tvec4<T, P>(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  tvec4<T, P> sw11 = step(gw11, tvec4<T, P>(T(0)));
  gx11 -= sw11 * (step(T(0), gx11) - T(0.5));
  gy11 -= sw11 * (step(T(0), gy11) - T(0.5));

  tvec4<T, P> g0000(gx00.x, gy00.x, gz00.x, gw00.x);
  tvec4<T, P> g1000(gx00.y, gy00.y, gz00.y, gw00.y);
  tvec4<T, P> g0100(gx00.z, gy00.z, gz00.z, gw00.z);
  tvec4<T, P> g1100(gx00.w, gy00.w, gz00.w, gw00.w);
  tvec4<T, P> g0010(gx10.x, gy10.x, gz10.x, gw10.x);
  tvec4<T, P> g1010(gx10.y, gy10.y, gz10.y, gw10.y);
  tvec4<T, P> g0110(gx10.z, gy10.z, gz10.z, gw10.z);
  tvec4<T, P> g1110(gx10.w, gy10.w, gz10.w, gw10.w);
  tvec4<T, P> g0001(gx01.x, gy01.x, gz01.x, gw01.x);
  tvec4<T, P> g1001(gx01.y, gy01.y, gz01.y, gw01.y);
  tvec4<T, P> g0101(gx01.z, gy01.z, gz01.z, gw01.z);
  tvec4<T, P> g1101(gx01.w, gy01.w, gz01.w, gw01.w);
  tvec4<T, P> g0011(gx11.x, gy11.x, gz11.x, gw11.x);
  tvec4<T, P> g1011(gx11.y, gy11.y, gz11.y, gw11.y);
  tvec4<T, P> g0111(gx11.z, gy11.z, gz11.z, gw11.z);
  tvec4<T, P> g1111(gx11.w, gy11.w, gz11.w, gw11.w);

  tvec4<T, P> norm00 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  tvec4<T, P> norm01 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  tvec4<T, P> norm10 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  tvec4<T, P> norm11 = detail::taylorInvSqrt(tvec4<T, P>(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  T n0000 = dot(g0000, Pf0);
  T n1000 = dot(g1000, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf0.w));
  T n0100 = dot(g0100, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf0.w));
  T n1100 = dot(g1100, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf0.w));
  T n0010 = dot(g0010, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf0.w));
  T n1010 = dot(g1010, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  T n0110 = dot(g0110, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf0.w));
  T n1110 = dot(g1110, tvec4<T, P>(Pf1.x, Pf1.y, Pf1.z, Pf0.w));
  T n0001 = dot(g0001, tvec4<T, P>(Pf0.x, Pf0.y, Pf0.z, Pf1.w));
  T n1001 = dot(g1001, tvec4<T, P>(Pf1.x, Pf0.y, Pf0.z, Pf1.w));
  T n0101 = dot(g0101, tvec4<T, P>(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  T n1101 = dot(g1101, tvec4<T, P>(Pf1.x, Pf1.y, Pf0.z, Pf1.w));
  T n0011 = dot(g0011, tvec4<T, P>(Pf0.x, Pf0.y, Pf1.z, Pf1.w));
  T n1011 = dot(g1011, tvec4<T, P>(Pf1.x, Pf0.y, Pf1.z, Pf1.w));
  T n0111 = dot(g0111, tvec4<T, P>(Pf0.x, Pf1.y, Pf1.z, Pf1.w));
  T n1111 = dot(g1111, Pf1);

  tvec4<T, P> fade_xyzw = detail::fade(Pf0);
  tvec4<T, P> n_0w = mix(tvec4<T, P>(n0000, n1000, n0100, n1100), tvec4<T, P>(n0001, n1001, n0101, n1101), fade_xyzw.w);
  tvec4<T, P> n_1w = mix(tvec4<T, P>(n0010, n1010, n0110, n1110), tvec4<T, P>(n0011, n1011, n0111, n1111), fade_xyzw.w);
  tvec4<T, P> n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  tvec2<T, P> n_yzw = mix(tvec2<T, P>(n_zw.x, n_zw.y), tvec2<T, P>(n_zw.z, n_zw.w), fade_xyzw.y);
  T n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return T(2.2) * n_xyzw;
 }

 template <typename T, precision P> inline
                    T simplex(glm::tvec2<T, P> const & v)
 {
  tvec4<T, P> const C = tvec4<T, P>(
   T( 0.211324865405187),
   T( 0.366025403784439),
   T(-0.577350269189626),
   T( 0.024390243902439));


  tvec2<T, P> i = floor(v + dot(v, tvec2<T, P>(C[1])));
  tvec2<T, P> x0 = v - i + dot(i, tvec2<T, P>(C[0]));




  tvec2<T, P> i1 = (x0.x > x0.y) ? tvec2<T, P>(1, 0) : tvec2<T, P>(0, 1);



  tvec4<T, P> x12 = tvec4<T, P>(x0.x, x0.y, x0.x, x0.y) + tvec4<T, P>(C.x, C.x, C.z, C.z);
  x12 = tvec4<T, P>(tvec2<T, P>(x12) - i1, x12.z, x12.w);


  i = mod(i, tvec2<T, P>(289));
  tvec3<T, P> p = detail::permute(
   detail::permute(i.y + tvec3<T, P>(T(0), i1.y, T(1)))
   + i.x + tvec3<T, P>(T(0), i1.x, T(1)));

  tvec3<T, P> m = max(tvec3<T, P>(0.5) - tvec3<T, P>(
   dot(x0, x0),
   dot(tvec2<T, P>(x12.x, x12.y), tvec2<T, P>(x12.x, x12.y)),
   dot(tvec2<T, P>(x12.z, x12.w), tvec2<T, P>(x12.z, x12.w))), tvec3<T, P>(0));
  m = m * m ;
  m = m * m ;




  tvec3<T, P> x = static_cast<T>(2) * fract(p * C.w) - T(1);
  tvec3<T, P> h = abs(x) - T(0.5);
  tvec3<T, P> ox = floor(x + T(0.5));
  tvec3<T, P> a0 = x - ox;



  m *= static_cast<T>(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);


  tvec3<T, P> g;
  g.x = a0.x * x0.x + h.x * x0.y;

  g.y = a0.y * x12.x + h.y * x12.y;
  g.z = a0.z * x12.z + h.z * x12.w;
  return T(130) * dot(m, g);
 }

 template <typename T, precision P> inline
                    T simplex(tvec3<T, P> const & v)
 {
  tvec2<T, P> const C(1.0 / 6.0, 1.0 / 3.0);
  tvec4<T, P> const D(0.0, 0.5, 1.0, 2.0);


  tvec3<T, P> i(floor(v + dot(v, tvec3<T, P>(C.y))));
  tvec3<T, P> x0(v - i + dot(i, tvec3<T, P>(C.x)));


  tvec3<T, P> g(step(tvec3<T, P>(x0.y, x0.z, x0.x), x0));
  tvec3<T, P> l(T(1) - g);
  tvec3<T, P> i1(min(g, tvec3<T, P>(l.z, l.x, l.y)));
  tvec3<T, P> i2(max(g, tvec3<T, P>(l.z, l.x, l.y)));





  tvec3<T, P> x1(x0 - i1 + C.x);
  tvec3<T, P> x2(x0 - i2 + C.y);
  tvec3<T, P> x3(x0 - D.y);


  i = detail::mod289(i);
  tvec4<T, P> p(detail::permute(detail::permute(detail::permute(
   i.z + tvec4<T, P>(T(0), i1.z, i2.z, T(1))) +
   i.y + tvec4<T, P>(T(0), i1.y, i2.y, T(1))) +
   i.x + tvec4<T, P>(T(0), i1.x, i2.x, T(1))));



  T n_ = static_cast<T>(0.142857142857);
  tvec3<T, P> ns(n_ * tvec3<T, P>(D.w, D.y, D.z) - tvec3<T, P>(D.x, D.z, D.x));

  tvec4<T, P> j(p - T(49) * floor(p * ns.z * ns.z));

  tvec4<T, P> x_(floor(j * ns.z));
  tvec4<T, P> y_(floor(j - T(7) * x_));

  tvec4<T, P> x(x_ * ns.x + ns.y);
  tvec4<T, P> y(y_ * ns.x + ns.y);
  tvec4<T, P> h(T(1) - abs(x) - abs(y));

  tvec4<T, P> b0(x.x, x.y, y.x, y.y);
  tvec4<T, P> b1(x.z, x.w, y.z, y.w);



  tvec4<T, P> s0(floor(b0) * T(2) + T(1));
  tvec4<T, P> s1(floor(b1) * T(2) + T(1));
  tvec4<T, P> sh(-step(h, tvec4<T, P>(0.0)));

  tvec4<T, P> a0 = tvec4<T, P>(b0.x, b0.z, b0.y, b0.w) + tvec4<T, P>(s0.x, s0.z, s0.y, s0.w) * tvec4<T, P>(sh.x, sh.x, sh.y, sh.y);
  tvec4<T, P> a1 = tvec4<T, P>(b1.x, b1.z, b1.y, b1.w) + tvec4<T, P>(s1.x, s1.z, s1.y, s1.w) * tvec4<T, P>(sh.z, sh.z, sh.w, sh.w);

  tvec3<T, P> p0(a0.x, a0.y, h.x);
  tvec3<T, P> p1(a0.z, a0.w, h.y);
  tvec3<T, P> p2(a1.x, a1.y, h.z);
  tvec3<T, P> p3(a1.z, a1.w, h.w);


  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;


  tvec4<T, P> m = max(T(0.6) - tvec4<T, P>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), tvec4<T, P>(0));
  m = m * m;
  return T(42) * dot(m * m, tvec4<T, P>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
 }

 template <typename T, precision P> inline
                    T simplex(tvec4<T, P> const & v)
 {
  tvec4<T, P> const C(
   0.138196601125011,
   0.276393202250021,
   0.414589803375032,
   -0.447213595499958);


  T const F4 = static_cast<T>(0.309016994374947451);


  tvec4<T, P> i = floor(v + dot(v, vec4(F4)));
  tvec4<T, P> x0 = v - i + dot(i, vec4(C.x));




  tvec4<T, P> i0;
  tvec3<T, P> isX = step(tvec3<T, P>(x0.y, x0.z, x0.w), tvec3<T, P>(x0.x));
  tvec3<T, P> isYZ = step(tvec3<T, P>(x0.z, x0.w, x0.w), tvec3<T, P>(x0.y, x0.y, x0.z));



  i0 = tvec4<T, P>(isX.x + isX.y + isX.z, T(1) - isX);

  i0.y += isYZ.x + isYZ.y;

  i0.z += static_cast<T>(1) - isYZ.x;
  i0.w += static_cast<T>(1) - isYZ.y;
  i0.z += isYZ.z;
  i0.w += static_cast<T>(1) - isYZ.z;


  tvec4<T, P> i3 = clamp(i0, T(0), T(1));
  tvec4<T, P> i2 = clamp(i0 - T(1), T(0), T(1));
  tvec4<T, P> i1 = clamp(i0 - T(2), T(0), T(1));






  tvec4<T, P> x1 = x0 - i1 + C.x;
  tvec4<T, P> x2 = x0 - i2 + C.y;
  tvec4<T, P> x3 = x0 - i3 + C.z;
  tvec4<T, P> x4 = x0 + C.w;


  i = mod(i, tvec4<T, P>(289));
  T j0 = detail::permute(detail::permute(detail::permute(detail::permute(i.w) + i.z) + i.y) + i.x);
  tvec4<T, P> j1 = detail::permute(detail::permute(detail::permute(detail::permute(
   i.w + tvec4<T, P>(i1.w, i2.w, i3.w, T(1))) +
   i.z + tvec4<T, P>(i1.z, i2.z, i3.z, T(1))) +
   i.y + tvec4<T, P>(i1.y, i2.y, i3.y, T(1))) +
   i.x + tvec4<T, P>(i1.x, i2.x, i3.x, T(1)));



  tvec4<T, P> ip = tvec4<T, P>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));

  tvec4<T, P> p0 = gtc::grad4(j0, ip);
  tvec4<T, P> p1 = gtc::grad4(j1.x, ip);
  tvec4<T, P> p2 = gtc::grad4(j1.y, ip);
  tvec4<T, P> p3 = gtc::grad4(j1.z, ip);
  tvec4<T, P> p4 = gtc::grad4(j1.w, ip);


  tvec4<T, P> norm = detail::taylorInvSqrt(tvec4<T, P>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= detail::taylorInvSqrt(dot(p4, p4));


  tvec3<T, P> m0 = max(T(0.6) - tvec3<T, P>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), tvec3<T, P>(0));
  tvec2<T, P> m1 = max(T(0.6) - tvec2<T, P>(dot(x3, x3), dot(x4, x4) ), tvec2<T, P>(0));
  m0 = m0 * m0;
  m1 = m1 * m1;
  return T(49) *
   (dot(m0 * m0, tvec3<T, P>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) +
   dot(m1 * m1, tvec2<T, P>(dot(p3, x3), dot(p4, x4))));
 }
}
# 60 "/usr/local/include/glm/./gtc/noise.hpp" 2 3
# 47 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/packing.hpp" 1 3
# 17 "/usr/local/include/glm/./gtc/packing.hpp" 3
# 1 "/usr/local/include/glm/gtc/type_precision.hpp" 1 3
# 22 "/usr/local/include/glm/gtc/type_precision.hpp" 3
# 1 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 1 3
# 22 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
namespace glm
{



 typedef highp_vec1_t highp_vec1;




 typedef mediump_vec1_t mediump_vec1;




 typedef lowp_vec1_t lowp_vec1;




 typedef highp_dvec1_t highp_dvec1;




 typedef mediump_dvec1_t mediump_dvec1;




 typedef lowp_dvec1_t lowp_dvec1;




 typedef highp_ivec1_t highp_ivec1;




 typedef mediump_ivec1_t mediump_ivec1;




 typedef lowp_ivec1_t lowp_ivec1;




 typedef highp_uvec1_t highp_uvec1;




 typedef mediump_uvec1_t mediump_uvec1;




 typedef lowp_uvec1_t lowp_uvec1;




 typedef highp_bvec1_t highp_bvec1;




 typedef mediump_bvec1_t mediump_bvec1;




 typedef lowp_bvec1_t lowp_bvec1;
# 111 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_bvec1 bvec1;
# 123 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_vec1 vec1;
# 135 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_dvec1 dvec1;
# 147 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_ivec1 ivec1;
# 159 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 3
 typedef highp_uvec1 uvec1;


}


# 1 "/usr/local/include/glm/gtc/vec1.inl" 1 3
# 164 "/usr/local/include/glm/gtc/../gtc/vec1.hpp" 2 3
# 22 "/usr/local/include/glm/gtc/type_precision.hpp" 2 3
# 40 "/usr/local/include/glm/gtc/type_precision.hpp" 3
namespace glm
{
# 50 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;




 typedef detail::int8 int8;



 typedef detail::int16 int16;



 typedef detail::int32 int32;



 typedef detail::int64 int64;
# 217 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef detail::int8 int8_t;



 typedef detail::int16 int16_t;



 typedef detail::int32 int32_t;



 typedef detail::int64 int64_t;




 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;




 typedef tvec1<i8, defaultp> i8vec1;



 typedef tvec2<i8, defaultp> i8vec2;



 typedef tvec3<i8, defaultp> i8vec3;



 typedef tvec4<i8, defaultp> i8vec4;




 typedef tvec1<i16, defaultp> i16vec1;



 typedef tvec2<i16, defaultp> i16vec2;



 typedef tvec3<i16, defaultp> i16vec3;



 typedef tvec4<i16, defaultp> i16vec4;




 typedef tvec1<i32, defaultp> i32vec1;



 typedef tvec2<i32, defaultp> i32vec2;



 typedef tvec3<i32, defaultp> i32vec3;



 typedef tvec4<i32, defaultp> i32vec4;




 typedef tvec1<i64, defaultp> i64vec1;



 typedef tvec2<i64, defaultp> i64vec2;



 typedef tvec3<i64, defaultp> i64vec3;



 typedef tvec4<i64, defaultp> i64vec4;







 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;



 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;



 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;



 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;



 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;



 typedef detail::uint8 uint8;



 typedef detail::uint16 uint16;



 typedef detail::uint32 uint32;



 typedef detail::uint64 uint64;
# 488 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef detail::uint8 uint8_t;



 typedef detail::uint16 uint16_t;



 typedef detail::uint32 uint32_t;



 typedef detail::uint64 uint64_t;




 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;





 typedef tvec1<u8, defaultp> u8vec1;



 typedef tvec2<u8, defaultp> u8vec2;



 typedef tvec3<u8, defaultp> u8vec3;



 typedef tvec4<u8, defaultp> u8vec4;




 typedef tvec1<u16, defaultp> u16vec1;



 typedef tvec2<u16, defaultp> u16vec2;



 typedef tvec3<u16, defaultp> u16vec3;



 typedef tvec4<u16, defaultp> u16vec4;




 typedef tvec1<u32, defaultp> u32vec1;



 typedef tvec2<u32, defaultp> u32vec2;



 typedef tvec3<u32, defaultp> u32vec3;



 typedef tvec4<u32, defaultp> u32vec4;




 typedef tvec1<u64, defaultp> u64vec1;



 typedef tvec2<u64, defaultp> u64vec2;



 typedef tvec3<u64, defaultp> u64vec3;



 typedef tvec4<u64, defaultp> u64vec4;







 typedef detail::float32 float32;



 typedef detail::float64 float64;




 typedef detail::float32 float32_t;



 typedef detail::float64 float64_t;




 typedef float32 f32;



 typedef float64 f64;




 typedef tvec1<float, defaultp> fvec1;



 typedef tvec2<float, defaultp> fvec2;



 typedef tvec3<float, defaultp> fvec3;



 typedef tvec4<float, defaultp> fvec4;




 typedef tvec1<f32, defaultp> f32vec1;



 typedef tvec2<f32, defaultp> f32vec2;



 typedef tvec3<f32, defaultp> f32vec3;



 typedef tvec4<f32, defaultp> f32vec4;




 typedef tvec1<f64, defaultp> f64vec1;



 typedef tvec2<f64, defaultp> f64vec2;



 typedef tvec3<f64, defaultp> f64vec3;



 typedef tvec4<f64, defaultp> f64vec4;
# 679 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> fmat2;



 typedef tmat3x3<f32, defaultp> fmat3;



 typedef tmat4x4<f32, defaultp> fmat4;
# 696 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> fmat2x2;



 typedef tmat2x3<f32, defaultp> fmat2x3;



 typedef tmat2x4<f32, defaultp> fmat2x4;



 typedef tmat3x2<f32, defaultp> fmat3x2;



 typedef tmat3x3<f32, defaultp> fmat3x3;



 typedef tmat3x4<f32, defaultp> fmat3x4;



 typedef tmat4x2<f32, defaultp> fmat4x2;



 typedef tmat4x3<f32, defaultp> fmat4x3;



 typedef tmat4x4<f32, defaultp> fmat4x4;
# 737 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> f32mat2;



 typedef tmat3x3<f32, defaultp> f32mat3;



 typedef tmat4x4<f32, defaultp> f32mat4;
# 754 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f32, defaultp> f32mat2x2;



 typedef tmat2x3<f32, defaultp> f32mat2x3;



 typedef tmat2x4<f32, defaultp> f32mat2x4;



 typedef tmat3x2<f32, defaultp> f32mat3x2;



 typedef tmat3x3<f32, defaultp> f32mat3x3;



 typedef tmat3x4<f32, defaultp> f32mat3x4;



 typedef tmat4x2<f32, defaultp> f32mat4x2;



 typedef tmat4x3<f32, defaultp> f32mat4x3;



 typedef tmat4x4<f32, defaultp> f32mat4x4;
# 795 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f64, defaultp> f64mat2;



 typedef tmat3x3<f64, defaultp> f64mat3;



 typedef tmat4x4<f64, defaultp> f64mat4;
# 812 "/usr/local/include/glm/gtc/type_precision.hpp" 3
 typedef tmat2x2<f64, defaultp> f64mat2x2;



 typedef tmat2x3<f64, defaultp> f64mat2x3;



 typedef tmat2x4<f64, defaultp> f64mat2x4;



 typedef tmat3x2<f64, defaultp> f64mat3x2;



 typedef tmat3x3<f64, defaultp> f64mat3x3;



 typedef tmat3x4<f64, defaultp> f64mat3x4;



 typedef tmat4x2<f64, defaultp> f64mat4x2;



 typedef tmat4x3<f64, defaultp> f64mat4x3;



 typedef tmat4x4<f64, defaultp> f64mat4x4;







 typedef tquat<f32, defaultp> f32quat;



 typedef tquat<f64, defaultp> f64quat;


}


# 1 "/usr/local/include/glm/gtc/type_precision.inl" 1 3



namespace glm
{

}
# 861 "/usr/local/include/glm/gtc/type_precision.hpp" 2 3
# 17 "/usr/local/include/glm/./gtc/packing.hpp" 2 3






namespace glm
{
# 39 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint8 packUnorm1x8(float v);
# 51 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackUnorm1x8(uint8 p);
# 67 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packUnorm2x8(vec2 const & v);
# 83 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec2 unpackUnorm2x8(uint16 p);
# 96 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint8 packSnorm1x8(float s);
# 109 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackSnorm1x8(uint8 p);
# 125 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packSnorm2x8(vec2 const & v);
# 141 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec2 unpackSnorm2x8(uint16 p);
# 154 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packUnorm1x16(float v);
# 167 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackUnorm1x16(uint16 p);
# 183 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint64 packUnorm4x16(vec4 const & v);
# 199 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackUnorm4x16(uint64 p);
# 212 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packSnorm1x16(float v);
# 225 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackSnorm1x16(uint16 p);
# 241 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint64 packSnorm4x16(vec4 const & v);
# 257 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackSnorm4x16(uint64 p);
# 268 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint16 packHalf1x16(float v);
# 279 "/usr/local/include/glm/./gtc/packing.hpp" 3
               float unpackHalf1x16(uint16 v);
# 292 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint64 packHalf4x16(vec4 const & v);
# 305 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackHalf4x16(uint64 p);
# 318 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packI3x10_1x2(ivec4 const & v);
# 329 "/usr/local/include/glm/./gtc/packing.hpp" 3
               ivec4 unpackI3x10_1x2(uint32 p);
# 342 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packU3x10_1x2(uvec4 const & v);
# 353 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uvec4 unpackU3x10_1x2(uint32 p);
# 371 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packSnorm3x10_1x2(vec4 const & v);
# 388 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackSnorm3x10_1x2(uint32 p);
# 406 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packUnorm3x10_1x2(vec4 const & v);
# 423 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec4 unpackUnorm3x10_1x2(uint32 p);
# 434 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packF2x11_1x10(vec3 const & v);
# 444 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec3 unpackF2x11_1x10(uint32 p);
# 456 "/usr/local/include/glm/./gtc/packing.hpp" 3
               uint32 packF3x9_E1x5(vec3 const & v);
# 466 "/usr/local/include/glm/./gtc/packing.hpp" 3
               vec3 unpackF3x9_E1x5(uint32 p);
# 476 "/usr/local/include/glm/./gtc/packing.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<uint16, P> packHalf(vecType<float, P> const & v);
# 486 "/usr/local/include/glm/./gtc/packing.hpp" 3
 template <precision P, template <typename, precision> class vecType>
               vecType<float, P> unpackHalf(vecType<uint16, P> const & p);





 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<uintType, P> packUnorm(vecType<floatType, P> const & v);





 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<floatType, P> unpackUnorm(vecType<uintType, P> const & v);





 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<intType, P> packSnorm(vecType<floatType, P> const & v);





 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<floatType, P> unpackSnorm(vecType<intType, P> const & v);





               uint8 packUnorm2x4(vec2 const & v);





               vec2 unpackUnorm2x4(uint8 p);





               uint16 packUnorm4x4(vec4 const & v);





               vec4 unpackUnorm4x4(uint16 p);





               uint16 packUnorm1x5_1x6_1x5(vec3 const & v);





               vec3 unpackUnorm1x5_1x6_1x5(uint16 p);





               uint16 packUnorm3x5_1x1(vec4 const & v);





               vec4 unpackUnorm3x5_1x1(uint16 p);





               uint8 packUnorm2x3_1x2(vec3 const & v);





               vec3 unpackUnorm2x3_1x2(uint8 p);

}


# 1 "/usr/local/include/glm/gtc/packing.inl" 1 3
# 12 "/usr/local/include/glm/gtc/packing.inl" 3
namespace glm{
namespace detail
{ inline
                    glm::uint16 float2half(glm::uint32 f)
 {
# 27 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((f >> 16) & 0x8000) |
   ((((f & 0x7f800000) - 0x38000000) >> 13) & 0x7c00) |
   ((f >> 13) & 0x03ff);
 } inline

                    glm::uint32 float2packed11(glm::uint32 f)
 {
# 46 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((f & 0x7f800000) - 0x38000000) >> 17) & 0x07c0) |
   ((f >> 17) & 0x003f);
 } inline

                    glm::uint32 packed11ToFloat(glm::uint32 p)
 {
# 64 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((p & 0x07c0) << 17) + 0x38000000) & 0x7f800000) |
   ((p & 0x003f) << 17);
 } inline

                    glm::uint32 float2packed10(glm::uint32 f)
 {
# 85 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((f & 0x7f800000) - 0x38000000) >> 18) & 0x03E0) |
   ((f >> 18) & 0x001f);
 } inline

                    glm::uint32 packed10ToFloat(glm::uint32 p)
 {
# 106 "/usr/local/include/glm/gtc/packing.inl" 3
  return
   ((((p & 0x03E0) << 18) + 0x38000000) & 0x7f800000) |
   ((p & 0x001f) << 18);
 } inline

                    glm::uint half2float(glm::uint h)
 {
  return ((h & 0x8000) << 16) | ((( h & 0x7c00) + 0x1C000) << 13) | ((h & 0x03FF) << 13);
 } inline

                    glm::uint floatTo11bit(float x)
 {
  if(x == 0.0f)
   return 0u;
  else if(glm::isnan(x))
   return ~0u;
  else if(glm::isinf(x))
   return 0x1Fu << 6u;

  uint Pack = 0u;
  memcpy(&Pack, &x, sizeof(Pack));
  return float2packed11(Pack);
 } inline

                    float packed11bitToFloat(glm::uint x)
 {
  if(x == 0)
   return 0.0f;
  else if(x == ((1 << 11) - 1))
   return ~0;
  else if(x == (0x1f << 6))
   return ~0;

  uint Result = packed11ToFloat(x);

  float Temp = 0;
  memcpy(&Temp, &Result, sizeof(Temp));
  return Temp;
 } inline

                    glm::uint floatTo10bit(float x)
 {
  if(x == 0.0f)
   return 0u;
  else if(glm::isnan(x))
   return ~0u;
  else if(glm::isinf(x))
   return 0x1Fu << 5u;

  uint Pack = 0;
  memcpy(&Pack, &x, sizeof(Pack));
  return float2packed10(Pack);
 } inline

                    float packed10bitToFloat(glm::uint x)
 {
  if(x == 0)
   return 0.0f;
  else if(x == ((1 << 10) - 1))
   return ~0;
  else if(x == (0x1f << 5))
   return ~0;

  uint Result = packed10ToFloat(x);

  float Temp = 0;
  memcpy(&Temp, &Result, sizeof(Temp));
  return Temp;
 }






 union u3u3u2
 {
  struct
  {
   uint x : 3;
   uint y : 3;
   uint z : 2;
  } data;
  uint8 pack;
 };

 union u4u4
 {
  struct
  {
   uint x : 4;
   uint y : 4;
  } data;
  uint8 pack;
 };

 union u4u4u4u4
 {
  struct
  {
   uint x : 4;
   uint y : 4;
   uint z : 4;
   uint w : 4;
  } data;
  uint16 pack;
 };

 union u5u6u5
 {
  struct
  {
   uint x : 5;
   uint y : 6;
   uint z : 5;
  } data;
  uint16 pack;
 };

 union u5u5u5u1
 {
  struct
  {
   uint x : 5;
   uint y : 5;
   uint z : 5;
   uint w : 1;
  } data;
  uint16 pack;
 };

 union u10u10u10u2
 {
  struct
  {
   uint x : 10;
   uint y : 10;
   uint z : 10;
   uint w : 2;
  } data;
  uint32 pack;
 };

 union i10i10i10i2
 {
  struct
  {
   int x : 10;
   int y : 10;
   int z : 10;
   int w : 2;
  } data;
  uint32 pack;
 };

 union u9u9u9e5
 {
  struct
  {
   uint x : 9;
   uint y : 9;
   uint z : 9;
   uint w : 5;
  } data;
  uint32 pack;
 };

 template <precision P, template <typename, precision> class vecType>
 struct compute_half
 {};

 template <precision P>
 struct compute_half<P, tvec1>
 { inline
                     static tvec1<uint16, P> pack(tvec1<float, P> const & v)
  {
   int16 const Unpack(detail::toFloat16(v.x));
   u16vec1 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec1<float, P> unpack(tvec1<uint16, P> const & v)
  {
   i16vec1 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec1<float, P>(detail::toFloat32(v.x));
  }
 };

 template <precision P>
 struct compute_half<P, tvec2>
 { inline
                     static tvec2<uint16, P> pack(tvec2<float, P> const & v)
  {
   tvec2<int16, P> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y));
   u16vec2 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec2<float, P> unpack(tvec2<uint16, P> const & v)
  {
   i16vec2 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec2<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y));
  }
 };

 template <precision P>
 struct compute_half<P, tvec3>
 { inline
                     static tvec3<uint16, P> pack(tvec3<float, P> const & v)
  {
   tvec3<int16, P> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z));
   u16vec3 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec3<float, P> unpack(tvec3<uint16, P> const & v)
  {
   i16vec3 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec3<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z));
  }
 };

 template <precision P>
 struct compute_half<P, tvec4>
 { inline
                     static tvec4<uint16, P> pack(tvec4<float, P> const & v)
  {
   tvec4<int16, P> const Unpack(detail::toFloat16(v.x), detail::toFloat16(v.y), detail::toFloat16(v.z), detail::toFloat16(v.w));
   u16vec4 Packed(uninitialize);
   memcpy(&Packed, &Unpack, sizeof(Packed));
   return Packed;
  } inline

                     static tvec4<float, P> unpack(tvec4<uint16, P> const & v)
  {
   i16vec4 Unpack(uninitialize);
   memcpy(&Unpack, &v, sizeof(Unpack));
   return tvec4<float, P>(detail::toFloat32(v.x), detail::toFloat32(v.y), detail::toFloat32(v.z), detail::toFloat32(v.w));
  }
 };
} inline

                    uint8 packUnorm1x8(float v)
 {
  return static_cast<uint8>(round(clamp(v, 0.0f, 1.0f) * 255.0f));
 } inline

                    float unpackUnorm1x8(uint8 p)
 {
  float const Unpack(p);
  return Unpack * static_cast<float>(0.0039215686274509803921568627451);
 } inline

                    uint16 packUnorm2x8(vec2 const & v)
 {
  u8vec2 const Topack(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  uint16 Unpack = 0;
  memcpy(&Unpack, &Topack, sizeof(Unpack));
  return Unpack;
 } inline

                    vec2 unpackUnorm2x8(uint16 p)
 {
  u8vec2 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return vec2(Unpack) * float(0.0039215686274509803921568627451);
 } inline

                    uint8 packSnorm1x8(float v)
 {
  int8 const Topack(static_cast<int8>(round(clamp(v ,-1.0f, 1.0f) * 127.0f)));
  uint8 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    float unpackSnorm1x8(uint8 p)
 {
  int8 Unpack = 0;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   static_cast<float>(Unpack) * 0.00787401574803149606299212598425f,
   -1.0f, 1.0f);
 } inline

                    uint16 packSnorm2x8(vec2 const & v)
 {
  i8vec2 const Topack(round(clamp(v, -1.0f, 1.0f) * 127.0f));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    vec2 unpackSnorm2x8(uint16 p)
 {
  i8vec2 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   vec2(Unpack) * 0.00787401574803149606299212598425f,
   -1.0f, 1.0f);
 } inline

                    uint16 packUnorm1x16(float s)
 {
  return static_cast<uint16>(round(clamp(s, 0.0f, 1.0f) * 65535.0f));
 } inline

                    float unpackUnorm1x16(uint16 p)
 {
  float const Unpack(p);
  return Unpack * 1.5259021896696421759365224689097e-5f;
 } inline

                    uint64 packUnorm4x16(vec4 const & v)
 {
  u16vec4 const Topack(round(clamp(v , 0.0f, 1.0f) * 65535.0f));
  uint64 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    vec4 unpackUnorm4x16(uint64 p)
 {
  u16vec4 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return vec4(Unpack) * 1.5259021896696421759365224689097e-5f;
 } inline

                    uint16 packSnorm1x16(float v)
 {
  int16 const Topack = static_cast<int16>(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    float unpackSnorm1x16(uint16 p)
 {
  int16 Unpack = 0;
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   static_cast<float>(Unpack) * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 } inline

                    uint64 packSnorm4x16(vec4 const & v)
 {
  i16vec4 const Topack(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
  uint64 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    vec4 unpackSnorm4x16(uint64 p)
 {
  i16vec4 Unpack(uninitialize);
  memcpy(&Unpack, &p, sizeof(Unpack));
  return clamp(
   vec4(Unpack) * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 } inline

                    uint16 packHalf1x16(float v)
 {
  int16 const Topack(detail::toFloat16(v));
  uint16 Packed = 0;
  memcpy(&Packed, &Topack, sizeof(Packed));
  return Packed;
 } inline

                    float unpackHalf1x16(uint16 v)
 {
  int16 Unpack = 0;
  memcpy(&Unpack, &v, sizeof(Unpack));
  return detail::toFloat32(Unpack);
 } inline

                    uint64 packHalf4x16(glm::vec4 const & v)
 {
  i16vec4 const Unpack(
   detail::toFloat16(v.x),
   detail::toFloat16(v.y),
   detail::toFloat16(v.z),
   detail::toFloat16(v.w));
  uint64 Packed = 0;
  memcpy(&Packed, &Unpack, sizeof(Packed));
  return Packed;
 } inline

                    glm::vec4 unpackHalf4x16(uint64 v)
 {
  i16vec4 Unpack(uninitialize);
  memcpy(&Unpack, &v, sizeof(Unpack));
  return vec4(
   detail::toFloat32(Unpack.x),
   detail::toFloat32(Unpack.y),
   detail::toFloat32(Unpack.z),
   detail::toFloat32(Unpack.w));
 } inline

                    uint32 packI3x10_1x2(ivec4 const & v)
 {
  detail::i10i10i10i2 Result;
  Result.data.x = v.x;
  Result.data.y = v.y;
  Result.data.z = v.z;
  Result.data.w = v.w;
  return Result.pack;
 } inline

                    ivec4 unpackI3x10_1x2(uint32 v)
 {
  detail::i10i10i10i2 Unpack;
  Unpack.pack = v;
  return ivec4(
   Unpack.data.x,
   Unpack.data.y,
   Unpack.data.z,
   Unpack.data.w);
 } inline

                    uint32 packU3x10_1x2(uvec4 const & v)
 {
  detail::u10u10u10u2 Result;
  Result.data.x = v.x;
  Result.data.y = v.y;
  Result.data.z = v.z;
  Result.data.w = v.w;
  return Result.pack;
 } inline

                    uvec4 unpackU3x10_1x2(uint32 v)
 {
  detail::u10u10u10u2 Unpack;
  Unpack.pack = v;
  return uvec4(
   Unpack.data.x,
   Unpack.data.y,
   Unpack.data.z,
   Unpack.data.w);
 } inline

                    uint32 packSnorm3x10_1x2(vec4 const & v)
 {
  detail::i10i10i10i2 Result;
  Result.data.x = int(round(clamp(v.x,-1.0f, 1.0f) * 511.f));
  Result.data.y = int(round(clamp(v.y,-1.0f, 1.0f) * 511.f));
  Result.data.z = int(round(clamp(v.z,-1.0f, 1.0f) * 511.f));
  Result.data.w = int(round(clamp(v.w,-1.0f, 1.0f) * 1.f));
  return Result.pack;
 } inline

                    vec4 unpackSnorm3x10_1x2(uint32 v)
 {
  detail::i10i10i10i2 Unpack;
  Unpack.pack = v;
  vec4 Result;
  Result.x = clamp(float(Unpack.data.x) / 511.f, -1.0f, 1.0f);
  Result.y = clamp(float(Unpack.data.y) / 511.f, -1.0f, 1.0f);
  Result.z = clamp(float(Unpack.data.z) / 511.f, -1.0f, 1.0f);
  Result.w = clamp(float(Unpack.data.w) / 1.f, -1.0f, 1.0f);
  return Result;
 } inline

                    uint32 packUnorm3x10_1x2(vec4 const & v)
 {
  uvec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(1023.f, 1023.f, 1023.f, 3.f)));

  detail::u10u10u10u2 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 } inline

                    vec4 unpackUnorm3x10_1x2(uint32 v)
 {
  vec4 const ScaleFactors(1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 1023.f, 1.0f / 3.f);

  detail::u10u10u10u2 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactors;
 } inline

                    uint32 packF2x11_1x10(vec3 const & v)
 {
  return
   ((detail::floatTo11bit(v.x) & ((1 << 11) - 1)) << 0) |
   ((detail::floatTo11bit(v.y) & ((1 << 11) - 1)) << 11) |
   ((detail::floatTo10bit(v.z) & ((1 << 10) - 1)) << 22);
 } inline

                    vec3 unpackF2x11_1x10(uint32 v)
 {
  return vec3(
   detail::packed11bitToFloat(v >> 0),
   detail::packed11bitToFloat(v >> 11),
   detail::packed10bitToFloat(v >> 22));
 } inline

                    uint32 packF3x9_E1x5(vec3 const & v)
 {
  float const SharedExpMax = (pow(2.0f, 9.0f - 1.0f) / pow(2.0f, 9.0f)) * pow(2.0f, 31.f - 15.f);
  vec3 const Color = clamp(v, 0.0f, SharedExpMax);
  float const MaxColor = max(Color.x, max(Color.y, Color.z));

  float const ExpSharedP = max(-15.f - 1.f, floor(log2(MaxColor))) + 1.0f + 15.f;
  float const MaxShared = floor(MaxColor / pow(2.0f, (ExpSharedP - 16.f - 9.f)) + 0.5f);
  float const ExpShared = MaxShared == pow(2.0f, 9.0f) ? ExpSharedP + 1.0f : ExpSharedP;

  uvec3 const ColorComp(floor(Color / pow(2.f, (ExpShared - 15.f - 9.f)) + 0.5f));

  detail::u9u9u9e5 Unpack;
  Unpack.data.x = ColorComp.x;
  Unpack.data.y = ColorComp.y;
  Unpack.data.z = ColorComp.z;
  Unpack.data.w = uint(ExpShared);
  return Unpack.pack;
 } inline

                    vec3 unpackF3x9_E1x5(uint32 v)
 {
  detail::u9u9u9e5 Unpack;
  Unpack.pack = v;

  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * pow(2.0f, Unpack.data.w - 15.f - 9.f);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<uint16, P> packHalf(vecType<float, P> const & v)
 {
  return detail::compute_half<P, vecType>::pack(v);
 }

 template <precision P, template <typename, precision> class vecType> inline
                    vecType<float, P> unpackHalf(vecType<uint16, P> const & v)
 {
  return detail::compute_half<P, vecType>::unpack(v);
 }

 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<uintType, P> packUnorm(vecType<floatType, P> const & v)
 {
                                                                                                  ;
                                                                                                         ;

  return vecType<uintType, P>(round(clamp(v, static_cast<floatType>(0), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<uintType>::max())));
 }

 template <typename uintType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<floatType, P> unpackUnorm(vecType<uintType, P> const & v)
 {
                                                                                                  ;
                                                                                                         ;

  return vecType<float, P>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<uintType>::max()));
 }

 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<intType, P> packSnorm(vecType<floatType, P> const & v)
 {
                                                                                                 ;
                                                                                                         ;

  return vecType<intType, P>(round(clamp(v , static_cast<floatType>(-1), static_cast<floatType>(1)) * static_cast<floatType>(std::numeric_limits<intType>::max())));
 }

 template <typename intType, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<floatType, P> unpackSnorm(vecType<intType, P> const & v)
 {
                                                                                                 ;
                                                                                                         ;

  return clamp(vecType<floatType, P>(v) * (static_cast<floatType>(1) / static_cast<floatType>(std::numeric_limits<intType>::max())), static_cast<floatType>(-1), static_cast<floatType>(1));
 } inline

                    uint8 packUnorm2x4(vec2 const & v)
 {
  u32vec2 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
  detail::u4u4 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  return Result.pack;
 } inline

                    vec2 unpackUnorm2x4(uint8 v)
 {
  float const ScaleFactor(1.f / 15.f);
  detail::u4u4 Unpack;
  Unpack.pack = v;
  return vec2(Unpack.data.x, Unpack.data.y) * ScaleFactor;
 } inline

                    uint16 packUnorm4x4(vec4 const & v)
 {
  u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * 15.0f));
  detail::u4u4u4u4 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 } inline

                    vec4 unpackUnorm4x4(uint16 v)
 {
  float const ScaleFactor(1.f / 15.f);
  detail::u4u4u4u4 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
 } inline

                    uint16 packUnorm1x5_1x6_1x5(vec3 const & v)
 {
  u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(31.f, 63.f, 31.f)));
  detail::u5u6u5 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  return Result.pack;
 } inline

                    vec3 unpackUnorm1x5_1x6_1x5(uint16 v)
 {
  vec3 const ScaleFactor(1.f / 31.f, 1.f / 63.f, 1.f / 31.f);
  detail::u5u6u5 Unpack;
  Unpack.pack = v;
  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
 } inline

                    uint16 packUnorm3x5_1x1(vec4 const & v)
 {
  u32vec4 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec4(31.f, 31.f, 31.f, 1.f)));
  detail::u5u5u5u1 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  Result.data.w = Unpack.w;
  return Result.pack;
 } inline

                    vec4 unpackUnorm3x5_1x1(uint16 v)
 {
  vec4 const ScaleFactor(1.f / 31.f, 1.f / 31.f, 1.f / 31.f, 1.f);
  detail::u5u5u5u1 Unpack;
  Unpack.pack = v;
  return vec4(Unpack.data.x, Unpack.data.y, Unpack.data.z, Unpack.data.w) * ScaleFactor;
 } inline

                    uint8 packUnorm2x3_1x2(vec3 const & v)
 {
  u32vec3 const Unpack(round(clamp(v, 0.0f, 1.0f) * vec3(7.f, 7.f, 3.f)));
  detail::u3u3u2 Result;
  Result.data.x = Unpack.x;
  Result.data.y = Unpack.y;
  Result.data.z = Unpack.z;
  return Result.pack;
 } inline

                    vec3 unpackUnorm2x3_1x2(uint8 v)
 {
  vec3 const ScaleFactor(1.f / 7.f, 1.f / 7.f, 1.f / 3.f);
  detail::u3u3u2 Unpack;
  Unpack.pack = v;
  return vec3(Unpack.data.x, Unpack.data.y, Unpack.data.z) * ScaleFactor;
 }
}
# 579 "/usr/local/include/glm/./gtc/packing.hpp" 2 3
# 48 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtc/random.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/random.hpp" 3
namespace glm
{
# 36 "/usr/local/include/glm/./gtc/random.hpp" 3
 template <typename genTYpe>
               genTYpe linearRand(
  genTYpe Min,
  genTYpe Max);
# 48 "/usr/local/include/glm/./gtc/random.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> linearRand(
  vecType<T, P> const & Min,
  vecType<T, P> const & Max);






 template <typename genType>
               genType gaussRand(
  genType Mean,
  genType Deviation);





 template <typename T>
               tvec2<T, defaultp> circularRand(
  T Radius);





 template <typename T>
               tvec3<T, defaultp> sphericalRand(
  T Radius);





 template <typename T>
               tvec2<T, defaultp> diskRand(
  T Radius);





 template <typename T>
               tvec3<T, defaultp> ballRand(
  T Radius);


}


# 1 "/usr/local/include/glm/gtc/random.inl" 1 3





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 1 3
# 93 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;
using ::getenv;
using ::system;
using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
# 159 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long abs( long __x) throw() {return labs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long abs(long long __x) throw() {return llabs(__x);}


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) ldiv_t div( long __x, long __y) throw() {return ldiv(__x, __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) lldiv_t div(long long __x, long long __y) throw() {return lldiv(__x, __y);}



} }
# 6 "/usr/local/include/glm/gtc/random.inl" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 8 "/usr/local/include/glm/gtc/random.inl" 2 3


namespace glm{
namespace detail
{
 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_rand
 { inline
                     static vecType<T, P> call();
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec1>
 { inline
                     static tvec1<uint8, P> call()
  {
   return tvec1<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec2>
 { inline
                     static tvec2<uint8, P> call()
  {
   return tvec2<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec3>
 { inline
                     static tvec3<uint8, P> call()
  {
   return tvec3<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P>
 struct compute_rand<uint8, P, tvec4>
 { inline
                     static tvec4<uint8, P> call()
  {
   return tvec4<uint8, P>(
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max(),
    std::rand() % std::numeric_limits<uint8>::max());
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_rand<uint16, P, vecType>
 { inline
                     static vecType<uint16, P> call()
  {
   return
    (vecType<uint16, P>(compute_rand<uint8, P, vecType>::call()) << static_cast<uint16>(8)) |
    (vecType<uint16, P>(compute_rand<uint8, P, vecType>::call()) << static_cast<uint16>(0));
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_rand<uint32, P, vecType>
 { inline
                     static vecType<uint32, P> call()
  {
   return
    (vecType<uint32, P>(compute_rand<uint16, P, vecType>::call()) << static_cast<uint32>(16)) |
    (vecType<uint32, P>(compute_rand<uint16, P, vecType>::call()) << static_cast<uint32>(0));
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_rand<uint64, P, vecType>
 { inline
                     static vecType<uint64, P> call()
  {
   return
    (vecType<uint64, P>(compute_rand<uint32, P, vecType>::call()) << static_cast<uint64>(32)) |
    (vecType<uint64, P>(compute_rand<uint32, P, vecType>::call()) << static_cast<uint64>(0));
  }
 };

 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_linearRand
 { inline
                     static vecType<T, P> call(vecType<T, P> const & Min, vecType<T, P> const & Max);
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int8, P, vecType>
 { inline
                     static vecType<int8, P> call(vecType<int8, P> const & Min, vecType<int8, P> const & Max)
  {
   return (vecType<int8, P>(compute_rand<uint8, P, vecType>::call() % vecType<uint8, P>(Max + static_cast<int8>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint8, P, vecType>
 { inline
                     static vecType<uint8, P> call(vecType<uint8, P> const & Min, vecType<uint8, P> const & Max)
  {
   return (compute_rand<uint8, P, vecType>::call() % (Max + static_cast<uint8>(1) - Min)) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int16, P, vecType>
 { inline
                     static vecType<int16, P> call(vecType<int16, P> const & Min, vecType<int16, P> const & Max)
  {
   return (vecType<int16, P>(compute_rand<uint16, P, vecType>::call() % vecType<uint16, P>(Max + static_cast<int16>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint16, P, vecType>
 { inline
                     static vecType<uint16, P> call(vecType<uint16, P> const & Min, vecType<uint16, P> const & Max)
  {
   return (compute_rand<uint16, P, vecType>::call() % (Max + static_cast<uint16>(1) - Min)) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int32, P, vecType>
 { inline
                     static vecType<int32, P> call(vecType<int32, P> const & Min, vecType<int32, P> const & Max)
  {
   return (vecType<int32, P>(compute_rand<uint32, P, vecType>::call() % vecType<uint32, P>(Max + static_cast<int32>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint32, P, vecType>
 { inline
                     static vecType<uint32, P> call(vecType<uint32, P> const & Min, vecType<uint32, P> const & Max)
  {
   return (compute_rand<uint32, P, vecType>::call() % (Max + static_cast<uint32>(1) - Min)) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<int64, P, vecType>
 { inline
                     static vecType<int64, P> call(vecType<int64, P> const & Min, vecType<int64, P> const & Max)
  {
   return (vecType<int64, P>(compute_rand<uint64, P, vecType>::call() % vecType<uint64, P>(Max + static_cast<int64>(1) - Min))) + Min;
  }
 };

 template <precision P, template <class, precision> class vecType>
 struct compute_linearRand<uint64, P, vecType>
 { inline
                     static vecType<uint64, P> call(vecType<uint64, P> const & Min, vecType<uint64, P> const & Max)
  {
   return (compute_rand<uint64, P, vecType>::call() % (Max + static_cast<uint64>(1) - Min)) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<float, lowp, vecType>
 { inline
                     static vecType<float, lowp> call(vecType<float, lowp> const & Min, vecType<float, lowp> const & Max)
  {
   return vecType<float, lowp>(compute_rand<uint8, lowp, vecType>::call()) / static_cast<float>(std::numeric_limits<uint8>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<float, mediump, vecType>
 { inline
                     static vecType<float, mediump> call(vecType<float, mediump> const & Min, vecType<float, mediump> const & Max)
  {
   return vecType<float, mediump>(compute_rand<uint16, mediump, vecType>::call()) / static_cast<float>(std::numeric_limits<uint16>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<float, highp, vecType>
 { inline
                     static vecType<float, highp> call(vecType<float, highp> const & Min, vecType<float, highp> const & Max)
  {
   return vecType<float, highp>(compute_rand<uint32, highp, vecType>::call()) / static_cast<float>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<double, lowp, vecType>
 { inline
                     static vecType<double, lowp> call(vecType<double, lowp> const & Min, vecType<double, lowp> const & Max)
  {
   return vecType<double, lowp>(compute_rand<uint16, lowp, vecType>::call()) / static_cast<double>(std::numeric_limits<uint16>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<double, mediump, vecType>
 { inline
                     static vecType<double, mediump> call(vecType<double, mediump> const & Min, vecType<double, mediump> const & Max)
  {
   return vecType<double, mediump>(compute_rand<uint32, mediump, vecType>::call()) / static_cast<double>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<double, highp, vecType>
 { inline
                     static vecType<double, highp> call(vecType<double, highp> const & Min, vecType<double, highp> const & Max)
  {
   return vecType<double, highp>(compute_rand<uint64, highp, vecType>::call()) / static_cast<double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<long double, lowp, vecType>
 { inline
                     static vecType<long double, lowp> call(vecType<long double, lowp> const & Min, vecType<long double, lowp> const & Max)
  {
   return vecType<long double, lowp>(compute_rand<uint32, lowp, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint32>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<long double, mediump, vecType>
 { inline
                     static vecType<long double, mediump> call(vecType<long double, mediump> const & Min, vecType<long double, mediump> const & Max)
  {
   return vecType<long double, mediump>(compute_rand<uint64, mediump, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };

 template <template <class, precision> class vecType>
 struct compute_linearRand<long double, highp, vecType>
 { inline
                     static vecType<long double, highp> call(vecType<long double, highp> const & Min, vecType<long double, highp> const & Max)
  {
   return vecType<long double, highp>(compute_rand<uint64, highp, vecType>::call()) / static_cast<long double>(std::numeric_limits<uint64>::max()) * (Max - Min) + Min;
  }
 };
}

 template <typename genType> inline
                    genType linearRand(genType Min, genType Max)
 {
  return detail::compute_linearRand<genType, highp, tvec1>::call(
   tvec1<genType, highp>(Min),
   tvec1<genType, highp>(Max)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> linearRand(vecType<T, P> const & Min, vecType<T, P> const & Max)
 {
  return detail::compute_linearRand<T, P, vecType>::call(Min, Max);
 }

 template <typename genType> inline
                    genType gaussRand(genType Mean, genType Deviation)
 {
  genType w, x1, x2;

  do
  {
   x1 = linearRand(genType(-1), genType(1));
   x2 = linearRand(genType(-1), genType(1));

   w = x1 * x1 + x2 * x2;
  } while(w > genType(1));

  return x2 * Deviation * Deviation * sqrt((genType(-2) * log(w)) / w) + Mean;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> gaussRand(vecType<T, P> const & Mean, vecType<T, P> const & Deviation)
 {
  return detail::functor2<T, P, vecType>::call(gaussRand, Mean, Deviation);
 }

 template <typename T> inline
                    tvec2<T, defaultp> diskRand(T Radius)
 {
  tvec2<T, defaultp> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(
    tvec2<T, defaultp>(-Radius),
    tvec2<T, defaultp>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template <typename T> inline
                    tvec3<T, defaultp> ballRand(T Radius)
 {
  tvec3<T, defaultp> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(
    tvec3<T, defaultp>(-Radius),
    tvec3<T, defaultp>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template <typename T> inline
                    tvec2<T, defaultp> circularRand(T Radius)
 {
  T a = linearRand(T(0), T(6.283185307179586476925286766559f));
  return tvec2<T, defaultp>(cos(a), sin(a)) * Radius;
 }

 template <typename T> inline
                    tvec3<T, defaultp> sphericalRand(T Radius)
 {
  T z = linearRand(T(-1), T(1));
  T a = linearRand(T(0), T(6.283185307179586476925286766559f));

  T r = sqrt(T(1) - z * z);

  T x = r * cos(a);
  T y = r * sin(a);

  return tvec3<T, defaultp>(x, y, z) * Radius;
 }
}
# 98 "/usr/local/include/glm/./gtc/random.hpp" 2 3
# 50 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/reciprocal.hpp" 1 3
# 22 "/usr/local/include/glm/./gtc/reciprocal.hpp" 3
namespace glm
{
# 33 "/usr/local/include/glm/./gtc/reciprocal.hpp" 3
 template <typename genType>
               genType sec(genType angle);







 template <typename genType>
               genType csc(genType angle);







 template <typename genType>
               genType cot(genType angle);







 template <typename genType>
               genType asec(genType x);







 template <typename genType>
               genType acsc(genType x);







 template <typename genType>
               genType acot(genType x);






 template <typename genType>
               genType sech(genType angle);






 template <typename genType>
               genType csch(genType angle);






 template <typename genType>
               genType coth(genType angle);







 template <typename genType>
               genType asech(genType x);







 template <typename genType>
               genType acsch(genType x);







 template <typename genType>
               genType acoth(genType x);


}


# 1 "/usr/local/include/glm/gtc/reciprocal.inl" 1 3






namespace glm
{

 template <typename genType> inline
                    genType sec(genType angle)
 {
                                                                                                       ;
  return genType(1) / glm::cos(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sec(vecType<T, P> const & x)
 {
                                                                                                 ;
  return detail::functor1<T, T, P, vecType>::call(sec, x);
 }


 template <typename genType> inline
                    genType csc(genType angle)
 {
                                                                                                       ;
  return genType(1) / glm::sin(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> csc(vecType<T, P> const & x)
 {
                                                                                                 ;
  return detail::functor1<T, T, P, vecType>::call(csc, x);
 }


 template <typename genType> inline
                    genType cot(genType angle)
 {
                                                                                                       ;

  genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
  return glm::tan(pi_over_2 - angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cot(vecType<T, P> const & x)
 {
                                                                                                 ;
  return detail::functor1<T, T, P, vecType>::call(cot, x);
 }


 template <typename genType> inline
                    genType asec(genType x)
 {
                                                                                                        ;
  return acos(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asec(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(asec, x);
 }


 template <typename genType> inline
                    genType acsc(genType x)
 {
                                                                                                        ;
  return asin(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acsc(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(acsc, x);
 }


 template <typename genType> inline
                    genType acot(genType x)
 {
                                                                                                        ;

  genType const pi_over_2 = genType(3.1415926535897932384626433832795 / 2.0);
  return pi_over_2 - atan(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acot(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(acot, x);
 }


 template <typename genType> inline
                    genType sech(genType angle)
 {
                                                                                                        ;
  return genType(1) / glm::cosh(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> sech(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(sech, x);
 }


 template <typename genType> inline
                    genType csch(genType angle)
 {
                                                                                                        ;
  return genType(1) / glm::sinh(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> csch(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(csch, x);
 }


 template <typename genType> inline
                    genType coth(genType angle)
 {
                                                                                                        ;
  return glm::cosh(angle) / glm::sinh(angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> coth(vecType<T, P> const & x)
 {
                                                                                                  ;
  return detail::functor1<T, T, P, vecType>::call(coth, x);
 }


 template <typename genType> inline
                    genType asech(genType x)
 {
                                                                                                         ;
  return acosh(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> asech(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::functor1<T, T, P, vecType>::call(asech, x);
 }


 template <typename genType> inline
                    genType acsch(genType x)
 {
                                                                                                         ;
  return acsch(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acsch(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::functor1<T, T, P, vecType>::call(acsch, x);
 }


 template <typename genType> inline
                    genType acoth(genType x)
 {
                                                                                                         ;
  return atanh(genType(1) / x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> acoth(vecType<T, P> const & x)
 {
                                                                                                   ;
  return detail::functor1<T, T, P, vecType>::call(acoth, x);
 }
}
# 135 "/usr/local/include/glm/./gtc/reciprocal.hpp" 2 3
# 51 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtc/round.hpp" 1 3
# 28 "/usr/local/include/glm/./gtc/round.hpp" 3
namespace glm
{






 template <typename genIUType>
               bool isPowerOfTwo(genIUType Value);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isPowerOfTwo(vecType<T, P> const & value);





 template <typename genIUType>
               genIUType ceilPowerOfTwo(genIUType Value);





 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> ceilPowerOfTwo(vecType<T, P> const & value);





 template <typename genIUType>
               genIUType floorPowerOfTwo(genIUType Value);





 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> floorPowerOfTwo(vecType<T, P> const & value);




 template <typename genIUType>
               genIUType roundPowerOfTwo(genIUType Value);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> roundPowerOfTwo(vecType<T, P> const & value);




 template <typename genIUType>
               bool isMultiple(genIUType Value, genIUType Multiple);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isMultiple(vecType<T, P> const & Value, T Multiple);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isMultiple(vecType<T, P> const & Value, vecType<T, P> const & Multiple);
# 110 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename genType>
               genType ceilMultiple(genType Source, genType Multiple);
# 120 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> ceilMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple);
# 130 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename genType>
               genType floorMultiple(
  genType Source,
  genType Multiple);
# 142 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> floorMultiple(
  vecType<T, P> const & Source,
  vecType<T, P> const & Multiple);
# 154 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename genType>
               genType roundMultiple(
  genType Source,
  genType Multiple);
# 166 "/usr/local/include/glm/./gtc/round.hpp" 3
 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> roundMultiple(
  vecType<T, P> const & Source,
  vecType<T, P> const & Multiple);


}


# 1 "/usr/local/include/glm/gtc/round.inl" 1 3





namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType, bool compute = false>
 struct compute_ceilShift
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T)
  {
   return v;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_ceilShift<T, P, vecType, true>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & v, T Shift)
  {
   return v | (v >> Shift);
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType, bool isSigned = true>
 struct compute_ceilPowerOfTwo
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
                                                                                                                        ;

   vecType<T, P> const Sign(sign(x));

   vecType<T, P> v(abs(x));

   v = v - static_cast<T>(1);
   v = v | (v >> static_cast<T>(1));
   v = v | (v >> static_cast<T>(2));
   v = v | (v >> static_cast<T>(4));
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 2>::call(v, 8);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 4>::call(v, 16);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 8>::call(v, 32);
   return (v + static_cast<T>(1)) * Sign;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_ceilPowerOfTwo<T, P, vecType, false>
 { inline
                     static vecType<T, P> call(vecType<T, P> const & x)
  {
                                                                                                                        ;

   vecType<T, P> v(x);

   v = v - static_cast<T>(1);
   v = v | (v >> static_cast<T>(1));
   v = v | (v >> static_cast<T>(2));
   v = v | (v >> static_cast<T>(4));
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 2>::call(v, 8);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 4>::call(v, 16);
   v = compute_ceilShift<T, P, vecType, sizeof(T) >= 8>::call(v, 32);
   return v + static_cast<T>(1);
  }
 };

 template <bool is_float, bool is_signed>
 struct compute_ceilMultiple{};

 template <>
 struct compute_ceilMultiple<true, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source > genType(0))
    return Source + (Multiple - std::fmod(Source, Multiple));
   else
    return Source + std::fmod(-Source, Multiple);
  }
 };

 template <>
 struct compute_ceilMultiple<false, false>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   genType Tmp = Source - genType(1);
   return Tmp + (Multiple - (Tmp % Multiple));
  }
 };

 template <>
 struct compute_ceilMultiple<false, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source > genType(0))
   {
    genType Tmp = Source - genType(1);
    return Tmp + (Multiple - (Tmp % Multiple));
   }
   else
    return Source + (-Source % Multiple);
  }
 };

 template <bool is_float, bool is_signed>
 struct compute_floorMultiple{};

 template <>
 struct compute_floorMultiple<true, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - std::fmod(Source, Multiple);
   else
    return Source - std::fmod(Source, Multiple) - Multiple;
  }
 };

 template <>
 struct compute_floorMultiple<false, false>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template <>
 struct compute_floorMultiple<false, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template <bool is_float, bool is_signed>
 struct compute_roundMultiple{};

 template <>
 struct compute_roundMultiple<true, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - std::fmod(Source, Multiple);
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - std::fmod(Tmp, Multiple) - Multiple;
   }
  }
 };

 template <>
 struct compute_roundMultiple<false, false>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };

 template <>
 struct compute_roundMultiple<false, true>
 {
  template <typename genType> inline
                     static genType call(genType Source, genType Multiple)
  {
   if(Source >= genType(0))
    return Source - Source % Multiple;
   else
   {
    genType Tmp = Source + genType(1);
    return Tmp - Tmp % Multiple - Multiple;
   }
  }
 };
}




 template <typename genType> inline
                    bool isPowerOfTwo(genType Value)
 {
  genType const Result = glm::abs(Value);
  return !(Result & (Result - 1));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isPowerOfTwo(vecType<T, P> const & Value)
 {
  vecType<T, P> const Result(abs(Value));
  return equal(Result & (Result - 1), vecType<T, P>(0));
 }




 template <typename genType> inline
                    genType ceilPowerOfTwo(genType value)
 {
  return detail::compute_ceilPowerOfTwo<genType, defaultp, tvec1, std::numeric_limits<genType>::is_signed>::call(tvec1<genType, defaultp>(value)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> ceilPowerOfTwo(vecType<T, P> const & v)
 {
  return detail::compute_ceilPowerOfTwo<T, P, vecType, std::numeric_limits<T>::is_signed>::call(v);
 }




 template <typename genType> inline
                    genType floorPowerOfTwo(genType value)
 {
  return isPowerOfTwo(value) ? value : static_cast<genType>(1) << findMSB(value);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> floorPowerOfTwo(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(floorPowerOfTwo, v);
 }




 template <typename genIUType> inline
                    genIUType roundPowerOfTwo(genIUType value)
 {
  if(isPowerOfTwo(value))
   return value;

  genIUType const prev = static_cast<genIUType>(1) << findMSB(value);
  genIUType const next = prev << static_cast<genIUType>(1);
  return (next - value) < (value - prev) ? next : prev;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> roundPowerOfTwo(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(roundPowerOfTwo, v);
 }




 template <typename genType> inline
                    bool isMultiple(genType Value, genType Multiple)
 {
  return isMultiple(tvec1<genType>(Value), tvec1<genType>(Multiple)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isMultiple(vecType<T, P> const & Value, T Multiple)
 {
  return (Value % Multiple) == vecType<T, P>(0);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isMultiple(vecType<T, P> const & Value, vecType<T, P> const & Multiple)
 {
  return (Value % Multiple) == vecType<T, P>(0);
 }




 template <typename genType> inline
                    genType ceilMultiple(genType Source, genType Multiple)
 {
  return detail::compute_ceilMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> ceilMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple)
 {
  return detail::functor2<T, P, vecType>::call(ceilMultiple, Source, Multiple);
 }




 template <typename genType> inline
                    genType floorMultiple(genType Source, genType Multiple)
 {
  return detail::compute_floorMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> floorMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple)
 {
  return detail::functor2<T, P, vecType>::call(floorMultiple, Source, Multiple);
 }




 template <typename genType> inline
                    genType roundMultiple(genType Source, genType Multiple)
 {
  return detail::compute_roundMultiple<std::numeric_limits<genType>::is_iec559, std::numeric_limits<genType>::is_signed>::call(Source, Multiple);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> roundMultiple(vecType<T, P> const & Source, vecType<T, P> const & Multiple)
 {
  return detail::functor2<T, P, vecType>::call(roundMultiple, Source, Multiple);
 }
}
# 174 "/usr/local/include/glm/./gtc/round.hpp" 2 3
# 52 "/usr/local/include/glm/ext.hpp" 2 3




# 1 "/usr/local/include/glm/./gtc/ulp.hpp" 1 3
# 25 "/usr/local/include/glm/./gtc/ulp.hpp" 3
namespace glm
{





 template <typename genType>
               genType next_float(genType const & x);



 template <typename genType>
               genType prev_float(genType const & x);



 template <typename genType>
               genType next_float(genType const & x, uint const & Distance);



 template <typename genType>
               genType prev_float(genType const & x, uint const & Distance);



 template <typename T>
               uint float_distance(T const & x, T const & y);



 template<typename T, template<typename> class vecType>
               vecType<uint> float_distance(vecType<T> const & x, vecType<T> const & y);


}


# 1 "/usr/local/include/glm/gtc/ulp.inl" 1 3
# 21 "/usr/local/include/glm/gtc/ulp.inl" 3
typedef union
{
 float value;

 unsigned int word;
} ieee_float_shape_type;

typedef union
{
 double value;
 struct
 {
  glm::detail::int32 lsw;
  glm::detail::int32 msw;
 } parts;
} ieee_double_shape_type;
# 68 "/usr/local/include/glm/gtc/ulp.inl" 3
namespace glm{
namespace detail
{ inline
                    float nextafterf(float x, float y)
 {
  volatile float t;
  glm::detail::int32 hx, hy, ix, iy;

  do { ieee_float_shape_type gf_u; gf_u.value = (x); (hx) = gf_u.word; } while (0);
  do { ieee_float_shape_type gf_u; gf_u.value = (y); (hy) = gf_u.word; } while (0);
  ix = hx&0x7fffffff;
  iy = hy&0x7fffffff;

  if((ix>0x7f800000) ||
   (iy>0x7f800000))
   return x+y;
  if(x==y) return y;
  if(ix==0) {
   do { ieee_float_shape_type sf_u; sf_u.word = ((hy&0x80000000)|1); (x) = sf_u.value; } while (0);
   t = x*x;
   if(t==x) return t; else return x;
  }
  if(hx>=0) {
   if(hx>hy) {
    hx -= 1;
   } else {
    hx += 1;
   }
  } else {
   if(hy>=0||hx>hy){
    hx -= 1;
   } else {
    hx += 1;
   }
  }
  hy = hx&0x7f800000;
  if(hy>=0x7f800000) return x+x;
  if(hy<0x00800000) {
   t = x*x;
   if(t!=x) {
    do { ieee_float_shape_type sf_u; sf_u.word = (hx); (y) = sf_u.value; } while (0);
    return y;
   }
  }
  do { ieee_float_shape_type sf_u; sf_u.word = (hx); (x) = sf_u.value; } while (0);
  return x;
 } inline

                    double nextafter(double x, double y)
 {
  volatile double t;
  glm::detail::int32 hx, hy, ix, iy;
  glm::detail::uint32 lx, ly;

  do { ieee_double_shape_type ew_u; ew_u.value = (x); (hx) = ew_u.parts.msw; (lx) = ew_u.parts.lsw; } while (0);
  do { ieee_double_shape_type ew_u; ew_u.value = (y); (hy) = ew_u.parts.msw; (ly) = ew_u.parts.lsw; } while (0);
  ix = hx & 0x7fffffff;
  iy = hy & 0x7fffffff;

  if(((ix>=0x7ff00000)&&((ix-0x7ff00000)|lx)!=0) ||
   ((iy>=0x7ff00000)&&((iy-0x7ff00000)|ly)!=0))
   return x+y;
  if(x==y) return y;
  if((ix|lx)==0) {
   do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hy & 0x80000000); iw_u.parts.lsw = (1); (x) = iw_u.value; } while (0);
   t = x*x;
   if(t==x) return t; else return x;
  }
  if(hx>=0) {
   if(hx>hy||((hx==hy)&&(lx>ly))) {
    if(lx==0) hx -= 1;
    lx -= 1;
   } else {
    lx += 1;
    if(lx==0) hx += 1;
   }
  } else {
   if(hy>=0||hx>hy||((hx==hy)&&(lx>ly))){
    if(lx==0) hx -= 1;
    lx -= 1;
   } else {
    lx += 1;
    if(lx==0) hx += 1;
   }
  }
  hy = hx&0x7ff00000;
  if(hy>=0x7ff00000) return x+x;
  if(hy<0x00100000) {
   t = x*x;
   if(t!=x) {
    do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (y) = iw_u.value; } while (0);
    return y;
   }
  }
  do { ieee_double_shape_type iw_u; iw_u.parts.msw = (hx); iw_u.parts.lsw = (lx); (x) = iw_u.value; } while (0);
  return x;
 }
}
}





namespace glm
{
 template <> inline
                    float next_float(float const & x)
 {







   return nextafterf(x, 3.40282347e+38F);

 }

 template <> inline
                    double next_float(double const & x)
 {







   return nextafter(x, 1.7976931348623157e+308);

 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> next_float(vecType<T, P> const & x)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = next_float(x[i]);
  return Result;
 } inline

                    float prev_float(float const & x)
 {







   return nextafterf(x, 1.17549435e-38F);

 } inline

                    double prev_float(double const & x)
 {







   return nextafter(x, 2.2250738585072014e-308);

 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> prev_float(vecType<T, P> const & x)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prev_float(x[i]);
  return Result;
 }

 template <typename T> inline
                    T next_float(T const & x, uint const & ulps)
 {
  T temp = x;
  for(uint i = 0; i < ulps; ++i)
   temp = next_float(temp);
  return temp;
 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> next_float(vecType<T, P> const & x, vecType<uint, P> const & ulps)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = next_float(x[i], ulps[i]);
  return Result;
 }

 template <typename T> inline
                    T prev_float(T const & x, uint const & ulps)
 {
  T temp = x;
  for(uint i = 0; i < ulps; ++i)
   temp = prev_float(temp);
  return temp;
 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<T, P> prev_float(vecType<T, P> const & x, vecType<uint, P> const & ulps)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = prev_float(x[i], ulps[i]);
  return Result;
 }

 template <typename T> inline
                    uint float_distance(T const & x, T const & y)
 {
  uint ulp = 0;

  if(x < y)
  {
   T temp = x;
   while(temp != y)
   {
    ++ulp;
    temp = next_float(temp);
   }
  }
  else if(y < x)
  {
   T temp = y;
   while(temp != x)
   {
    ++ulp;
    temp = next_float(temp);
   }
  }
  else
  {

  }

  return ulp;
 }

 template<typename T, precision P, template<typename, precision> class vecType> inline
                    vecType<uint, P> float_distance(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  vecType<uint, P> Result(uninitialize);
  for(length_t i = 0, n = Result.length(); i < n; ++i)
   Result[i] = float_distance(x[i], y[i]);
  return Result;
 }
}
# 63 "/usr/local/include/glm/./gtc/ulp.hpp" 2 3
# 56 "/usr/local/include/glm/ext.hpp" 2 3






# 1 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 3
namespace glm
{





 template<typename T, typename U, precision P>
               U associatedMin(T x, U a, T y, U b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               tvec2<U, P> associatedMin(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  T x, const vecType<U, P>& a,
  T y, const vecType<U, P>& b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b);



 template<typename T, typename U>
               U associatedMin(
  T x, U a,
  T y, U b,
  T z, U c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c);



 template<typename T, typename U>
               U associatedMin(
  T x, U a,
  T y, U b,
  T z, U c,
  T w, U d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c,
  vecType<T, P> const & w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b,
  T z, vecType<U, P> const & c,
  T w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMin(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b,
  vecType<T, P> const & z, U c,
  vecType<T, P> const & w, U d);



 template<typename T, typename U>
               U associatedMax(T x, U a, T y, U b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               tvec2<U, P> associatedMax(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> associatedMax(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b);



 template<typename T, typename U>
               U associatedMax(
  T x, U a,
  T y, U b,
  T z, U c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<T, P> associatedMax(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b,
  T z, vecType<U, P> const & c);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b,
  vecType<T, P> const & z, U c);



 template<typename T, typename U>
               U associatedMax(
  T x, U a,
  T y, U b,
  T z, U c,
  T w, U d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, vecType<U, P> const & a,
  vecType<T, P> const & y, vecType<U, P> const & b,
  vecType<T, P> const & z, vecType<U, P> const & c,
  vecType<T, P> const & w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  T x, vecType<U, P> const & a,
  T y, vecType<U, P> const & b,
  T z, vecType<U, P> const & c,
  T w, vecType<U, P> const & d);



 template<typename T, typename U, precision P, template <typename, precision> class vecType>
               vecType<U, P> associatedMax(
  vecType<T, P> const & x, U a,
  vecType<T, P> const & y, U b,
  vecType<T, P> const & z, U c,
  vecType<T, P> const & w, U d);


}


# 1 "/usr/local/include/glm/./gtx/associated_min_max.inl" 1 3



namespace glm{


template<typename T, typename U, precision P> inline
                   U associatedMin(T x, U a, T y, U b)
{
 return x < y ? a : b;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   tvec2<U, P> associatedMin
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] < y[i] ? a[i] : b[i];
 return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 T x, const vecType<U, P>& a,
 T y, const vecType<U, P>& b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x < y ? a[i] : b[i];
 return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] < y[i] ? a : b;
 return Result;
}


template<typename T, typename U> inline
                   U associatedMin
(
 T x, U a,
 T y, U b,
 T z, U c
)
{
 U Result = x < y ? (x < z ? a : c) : (y < z ? b : c);
 return Result;
}

template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] < y[i] ? (x[i] < z[i] ? a[i] : c[i]) : (y[i] < z[i] ? b[i] : c[i]);
 return Result;
}


template<typename T, typename U> inline
                   U associatedMin
(
 T x, U a,
 T y, U b,
 T z, U c,
 T w, U d
)
{
 T Test1 = min(x, y);
 T Test2 = min(z, w);;
 U Result1 = x < y ? a : b;
 U Result2 = z < w ? c : d;
 U Result = Test1 < Test2 ? Result1 : Result2;
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c,
 vecType<T, P> const & w, vecType<U, P> const & d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = min(x[i], y[i]);
  T Test2 = min(z[i], w[i]);
  U Result1 = x[i] < y[i] ? a[i] : b[i];
  U Result2 = z[i] < w[i] ? c[i] : d[i];
  Result[i] = Test1 < Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b,
 T z, vecType<U, P> const & c,
 T w, vecType<U, P> const & d
)
{
 T Test1 = min(x, y);
 T Test2 = min(z, w);

 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  U Result1 = x < y ? a[i] : b[i];
  U Result2 = z < w ? c[i] : d[i];
  Result[i] = Test1 < Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMin
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b,
 vecType<T, P> const & z, U c,
 vecType<T, P> const & w, U d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = min(x[i], y[i]);
  T Test2 = min(z[i], w[i]);;
  U Result1 = x[i] < y[i] ? a : b;
  U Result2 = z[i] < w[i] ? c : d;
  Result[i] = Test1 < Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U> inline
                   U associatedMax(T x, U a, T y, U b)
{
 return x > y ? a : b;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   tvec2<U, P> associatedMax
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? a[i] : b[i];
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<T, P> associatedMax
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x > y ? a[i] : b[i];
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b
)
{
 vecType<T, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? a : b;
 return Result;
}


template<typename T, typename U> inline
                   U associatedMax
(
 T x, U a,
 T y, U b,
 T z, U c
)
{
 U Result = x > y ? (x > z ? a : c) : (y > z ? b : c);
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? (x[i] > z[i] ? a[i] : c[i]) : (y[i] > z[i] ? b[i] : c[i]);
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<T, P> associatedMax
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b,
 T z, vecType<U, P> const & c
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x > y ? (x > z ? a[i] : c[i]) : (y > z ? b[i] : c[i]);
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b,
 vecType<T, P> const & z, U c
)
{
 vecType<T, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
  Result[i] = x[i] > y[i] ? (x[i] > z[i] ? a : c) : (y[i] > z[i] ? b : c);
 return Result;
}


template<typename T, typename U> inline
                   U associatedMax
(
 T x, U a,
 T y, U b,
 T z, U c,
 T w, U d
)
{
 T Test1 = max(x, y);
 T Test2 = max(z, w);;
 U Result1 = x > y ? a : b;
 U Result2 = z > w ? c : d;
 U Result = Test1 > Test2 ? Result1 : Result2;
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, vecType<U, P> const & a,
 vecType<T, P> const & y, vecType<U, P> const & b,
 vecType<T, P> const & z, vecType<U, P> const & c,
 vecType<T, P> const & w, vecType<U, P> const & d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = max(x[i], y[i]);
  T Test2 = max(z[i], w[i]);
  U Result1 = x[i] > y[i] ? a[i] : b[i];
  U Result2 = z[i] > w[i] ? c[i] : d[i];
  Result[i] = Test1 > Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 T x, vecType<U, P> const & a,
 T y, vecType<U, P> const & b,
 T z, vecType<U, P> const & c,
 T w, vecType<U, P> const & d
)
{
 T Test1 = max(x, y);
 T Test2 = max(z, w);

 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  U Result1 = x > y ? a[i] : b[i];
  U Result2 = z > w ? c[i] : d[i];
  Result[i] = Test1 > Test2 ? Result1 : Result2;
 }
 return Result;
}


template<typename T, typename U, precision P, template <typename, precision> class vecType> inline
                   vecType<U, P> associatedMax
(
 vecType<T, P> const & x, U a,
 vecType<T, P> const & y, U b,
 vecType<T, P> const & z, U c,
 vecType<T, P> const & w, U d
)
{
 vecType<U, P> Result(uninitialize);
 for(length_t i = 0, n = Result.length(); i < n; ++i)
 {
  T Test1 = max(x[i], y[i]);
  T Test2 = max(z[i], w[i]);;
  U Result1 = x[i] > y[i] ? a : b;
  U Result2 = z[i] > w[i] ? c : d;
  Result[i] = Test1 > Test2 ? Result1 : Result2;
 }
 return Result;
}
}
# 202 "/usr/local/include/glm/./gtx/associated_min_max.hpp" 2 3
# 62 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/bit.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/bit.hpp" 3
namespace glm
{




 template <typename genIUType>
               genIUType highestBitValue(genIUType Value);


 template <typename genIUType>
               genIUType lowestBitValue(genIUType Value);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> highestBitValue(vecType<T, P> const & value);






 template <typename genIUType>
 __attribute__((__deprecated__)) genIUType powerOfTwoAbove(genIUType Value);






 template <typename T, precision P, template <typename, precision> class vecType>
 __attribute__((__deprecated__)) vecType<T, P> powerOfTwoAbove(vecType<T, P> const & value);






 template <typename genIUType>
 __attribute__((__deprecated__)) genIUType powerOfTwoBelow(genIUType Value);






 template <typename T, precision P, template <typename, precision> class vecType>
 __attribute__((__deprecated__)) vecType<T, P> powerOfTwoBelow(vecType<T, P> const & value);






 template <typename genIUType>
 __attribute__((__deprecated__)) genIUType powerOfTwoNearest(genIUType Value);






 template <typename T, precision P, template <typename, precision> class vecType>
 __attribute__((__deprecated__)) vecType<T, P> powerOfTwoNearest(vecType<T, P> const & value);


}



# 1 "/usr/local/include/glm/./gtx/bit.inl" 1 3



namespace glm
{



 template <typename genIUType> inline
                    genIUType highestBitValue(genIUType Value)
 {
  genIUType tmp = Value;
  genIUType result = genIUType(0);
  while(tmp)
  {
   result = (tmp & (~tmp + 1));
   tmp &= ~result;
  }
  return result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> highestBitValue(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(highestBitValue, v);
 }




 template <typename genIUType> inline
                    genIUType lowestBitValue(genIUType Value)
 {
  return (Value & (~Value + 1));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> lowestBitValue(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(lowestBitValue, v);
 }




 template <typename genType> inline
                    genType powerOfTwoAbove(genType value)
 {
  return isPowerOfTwo(value) ? value : highestBitValue(value) << 1;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> powerOfTwoAbove(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(powerOfTwoAbove, v);
 }




 template <typename genType> inline
                    genType powerOfTwoBelow(genType value)
 {
  return isPowerOfTwo(value) ? value : highestBitValue(value);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> powerOfTwoBelow(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(powerOfTwoBelow, v);
 }




 template <typename genType> inline
                    genType powerOfTwoNearest(genType value)
 {
  if(isPowerOfTwo(value))
   return value;

  genType const prev = highestBitValue(value);
  genType const next = prev << 1;
  return (next - value) < (value - prev) ? next : prev;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> powerOfTwoNearest(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(powerOfTwoNearest, v);
 }

}
# 94 "/usr/local/include/glm/./gtx/bit.hpp" 2 3
# 63 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/closest_point.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/closest_point.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> closestPointOnLine(
  tvec3<T, P> const & point,
  tvec3<T, P> const & a,
  tvec3<T, P> const & b);


 template <typename T, precision P>
               tvec2<T, P> closestPointOnLine(
  tvec2<T, P> const & point,
  tvec2<T, P> const & a,
  tvec2<T, P> const & b);


}


# 1 "/usr/local/include/glm/./gtx/closest_point.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> closestPointOnLine
 (
  tvec3<T, P> const & point,
  tvec3<T, P> const & a,
  tvec3<T, P> const & b
 )
 {
  T LineLength = distance(a, b);
  tvec3<T, P> Vector = point - a;
  tvec3<T, P> LineDirection = (b - a) / LineLength;


  T Distance = dot(Vector, LineDirection);

  if(Distance <= T(0)) return a;
  if(Distance >= LineLength) return b;
  return a + LineDirection * Distance;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> closestPointOnLine
 (
  tvec2<T, P> const & point,
  tvec2<T, P> const & a,
  tvec2<T, P> const & b
 )
 {
  T LineLength = distance(a, b);
  tvec2<T, P> Vector = point - a;
  tvec2<T, P> LineDirection = (b - a) / LineLength;


  T Distance = dot(Vector, LineDirection);

  if(Distance <= T(0)) return a;
  if(Distance >= LineLength) return b;
  return a + LineDirection * Distance;
 }

}
# 45 "/usr/local/include/glm/./gtx/closest_point.hpp" 2 3
# 64 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/color_space.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/color_space.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> rgbColor(
  tvec3<T, P> const & hsvValue);



 template <typename T, precision P>
               tvec3<T, P> hsvColor(
  tvec3<T, P> const & rgbValue);



 template <typename T>
               tmat4x4<T, defaultp> saturation(
  T const s);



 template <typename T, precision P>
               tvec3<T, P> saturation(
  T const s,
  tvec3<T, P> const & color);



 template <typename T, precision P>
               tvec4<T, P> saturation(
  T const s,
  tvec4<T, P> const & color);



 template <typename T, precision P>
               T luminosity(
  tvec3<T, P> const & color);


}


# 1 "/usr/local/include/glm/./gtx/color_space.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> rgbColor(const tvec3<T, P>& hsvColor)
 {
  tvec3<T, P> hsv = hsvColor;
  tvec3<T, P> rgbColor;

  if(hsv.y == static_cast<T>(0))

   rgbColor = tvec3<T, P>(hsv.z);
  else
  {
   T sector = floor(hsv.x / T(60));
   T frac = (hsv.x / T(60)) - sector;

   T o = hsv.z * (T(1) - hsv.y);
   T p = hsv.z * (T(1) - hsv.y * frac);
   T q = hsv.z * (T(1) - hsv.y * (T(1) - frac));

   switch(int(sector))
   {
   default:
   case 0:
    rgbColor.r = hsv.z;
    rgbColor.g = q;
    rgbColor.b = o;
    break;
   case 1:
    rgbColor.r = p;
    rgbColor.g = hsv.z;
    rgbColor.b = o;
    break;
   case 2:
    rgbColor.r = o;
    rgbColor.g = hsv.z;
    rgbColor.b = q;
    break;
   case 3:
    rgbColor.r = o;
    rgbColor.g = p;
    rgbColor.b = hsv.z;
    break;
   case 4:
    rgbColor.r = q;
    rgbColor.g = o;
    rgbColor.b = hsv.z;
    break;
   case 5:
    rgbColor.r = hsv.z;
    rgbColor.g = o;
    rgbColor.b = p;
    break;
   }
  }

  return rgbColor;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> hsvColor(const tvec3<T, P>& rgbColor)
 {
  tvec3<T, P> hsv = rgbColor;
  float Min = min(min(rgbColor.r, rgbColor.g), rgbColor.b);
  float Max = max(max(rgbColor.r, rgbColor.g), rgbColor.b);
  float Delta = Max - Min;

  hsv.z = Max;

  if(Max != static_cast<T>(0))
  {
   hsv.y = Delta / hsv.z;
   T h = static_cast<T>(0);

   if(rgbColor.r == Max)

    h = static_cast<T>(0) + T(60) * (rgbColor.g - rgbColor.b) / Delta;
   else if(rgbColor.g == Max)

    h = static_cast<T>(120) + T(60) * (rgbColor.b - rgbColor.r) / Delta;
   else

    h = static_cast<T>(240) + T(60) * (rgbColor.r - rgbColor.g) / Delta;

   if(h < T(0))
    hsv.x = h + T(360);
   else
    hsv.x = h;
  }
  else
  {

   hsv.y = static_cast<T>(0);
   hsv.x = static_cast<T>(0);
  }

  return hsv;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> saturation(T const s)
 {
  tvec3<T, defaultp> rgbw = tvec3<T, defaultp>(T(0.2126), T(0.7152), T(0.0722));

  tvec3<T, defaultp> const col((T(1) - s) * rgbw);

  tmat4x4<T, defaultp> result(T(1));
  result[0][0] = col.x + s;
  result[0][1] = col.x;
  result[0][2] = col.x;
  result[1][0] = col.y;
  result[1][1] = col.y + s;
  result[1][2] = col.y;
  result[2][0] = col.z;
  result[2][1] = col.z;
  result[2][2] = col.z + s;
  return result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> saturation(const T s, const tvec3<T, P>& color)
 {
  return tvec3<T, P>(saturation(s) * tvec4<T, P>(color, T(0)));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> saturation(const T s, const tvec4<T, P>& color)
 {
  return saturation(s) * color;
 }

 template <typename T, precision P> inline
                    T luminosity(const tvec3<T, P>& color)
 {
  const tvec3<T, P> tmp = tvec3<T, P>(0.33, 0.59, 0.11);
  return dot(color, tmp);
 }
}
# 68 "/usr/local/include/glm/./gtx/color_space.hpp" 2 3
# 65 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> rgb2YCoCg(
  tvec3<T, P> const & rgbColor);



 template <typename T, precision P>
               tvec3<T, P> YCoCg2rgb(
  tvec3<T, P> const & YCoCgColor);




 template <typename T, precision P>
               tvec3<T, P> rgb2YCoCgR(
  tvec3<T, P> const & rgbColor);




 template <typename T, precision P>
               tvec3<T, P> YCoCgR2rgb(
  tvec3<T, P> const & YCoCgColor);


}


# 1 "/usr/local/include/glm/./gtx/color_space_YCoCg.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> rgb2YCoCg
 (
  tvec3<T, P> const & rgbColor
 )
 {
  tvec3<T, P> result;
  result.x = rgbColor.r / T(4) + rgbColor.g / T(2) + rgbColor.b / T(4);
  result.y = rgbColor.r / T(2) + rgbColor.g * T(0) - rgbColor.b / T(2);
  result.z = - rgbColor.r / T(4) + rgbColor.g / T(2) - rgbColor.b / T(4);
  return result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> YCoCg2rgb
 (
  tvec3<T, P> const & YCoCgColor
 )
 {
  tvec3<T, P> result;
  result.r = YCoCgColor.x + YCoCgColor.y - YCoCgColor.z;
  result.g = YCoCgColor.x + YCoCgColor.z;
  result.b = YCoCgColor.x - YCoCgColor.y - YCoCgColor.z;
  return result;
 }

 template <typename T, precision P, bool isInteger>
 class compute_YCoCgR {
 public:
  static inline tvec3<T, P> rgb2YCoCgR
  (
   tvec3<T, P> const & rgbColor
  )
  {
   tvec3<T, P> result;
   result.x = rgbColor.g / T(2) + (rgbColor.r + rgbColor.b) / T(4);
   result.y = rgbColor.r - rgbColor.b;
   result.z = rgbColor.g - (rgbColor.r + rgbColor.b) / T(2);
   return result;
  }

  static inline tvec3<T, P> YCoCgR2rgb
  (
   tvec3<T, P> const & YCoCgRColor
  )
  {
   tvec3<T, P> result;
   T tmp = YCoCgRColor.x - (YCoCgRColor.z / T(2));
   result.g = YCoCgRColor.z + tmp;
   result.b = tmp - (YCoCgRColor.y / T(2));
   result.r = result.b + YCoCgRColor.y;
   return result;
  }
 };

 template <typename T, precision P>
 class compute_YCoCgR<T, P, true> {
 public:
  static inline tvec3<T, P> rgb2YCoCgR
  (
   tvec3<T, P> const & rgbColor
  )
  {
   tvec3<T, P> result;
   result.y = rgbColor.r - rgbColor.b;
   T tmp = rgbColor.b + (result.y >> 1);
   result.z = rgbColor.g - tmp;
   result.x = tmp + (result.z >> 1);
   return result;
  }

  static inline tvec3<T, P> YCoCgR2rgb
  (
   tvec3<T, P> const & YCoCgRColor
  )
  {
   tvec3<T, P> result;
   T tmp = YCoCgRColor.x - (YCoCgRColor.z >> 1);
   result.g = YCoCgRColor.z + tmp;
   result.b = tmp - (YCoCgRColor.y >> 1);
   result.r = result.b + YCoCgRColor.y;
   return result;
  }
 };

 template <typename T, precision P> inline
                    tvec3<T, P> rgb2YCoCgR
 (
  tvec3<T, P> const & rgbColor
 )
 {
  return compute_YCoCgR<T, P, std::numeric_limits<T>::is_integer>::rgb2YCoCgR(rgbColor);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> YCoCgR2rgb
 (
  tvec3<T, P> const & YCoCgRColor
 )
 {
  return compute_YCoCgR<T, P, std::numeric_limits<T>::is_integer>::YCoCgR2rgb(YCoCgRColor);
 }
}
# 56 "/usr/local/include/glm/./gtx/color_space_YCoCg.hpp" 2 3
# 66 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/compatibility.hpp" 1 3
# 33 "/usr/local/include/glm/./gtx/compatibility.hpp" 3
namespace glm
{



 template <typename T> inline T lerp(T x, T y, T a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec2<T, P> lerp(const tvec2<T, P>& x, const tvec2<T, P>& y, T a){return mix(x, y, a);}

 template <typename T, precision P> inline tvec3<T, P> lerp(const tvec3<T, P>& x, const tvec3<T, P>& y, T a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec4<T, P> lerp(const tvec4<T, P>& x, const tvec4<T, P>& y, T a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec2<T, P> lerp(const tvec2<T, P>& x, const tvec2<T, P>& y, const tvec2<T, P>& a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec3<T, P> lerp(const tvec3<T, P>& x, const tvec3<T, P>& y, const tvec3<T, P>& a){return mix(x, y, a);}
 template <typename T, precision P> inline tvec4<T, P> lerp(const tvec4<T, P>& x, const tvec4<T, P>& y, const tvec4<T, P>& a){return mix(x, y, a);}

 template <typename T, precision P> inline T saturate(T x){return clamp(x, T(0), T(1));}
 template <typename T, precision P> inline tvec2<T, P> saturate(const tvec2<T, P>& x){return clamp(x, T(0), T(1));}
 template <typename T, precision P> inline tvec3<T, P> saturate(const tvec3<T, P>& x){return clamp(x, T(0), T(1));}
 template <typename T, precision P> inline tvec4<T, P> saturate(const tvec4<T, P>& x){return clamp(x, T(0), T(1));}

 template <typename T, precision P> inline T atan2(T x, T y){return atan(x, y);}
 template <typename T, precision P> inline tvec2<T, P> atan2(const tvec2<T, P>& x, const tvec2<T, P>& y){return atan(x, y);}
 template <typename T, precision P> inline tvec3<T, P> atan2(const tvec3<T, P>& x, const tvec3<T, P>& y){return atan(x, y);}
 template <typename T, precision P> inline tvec4<T, P> atan2(const tvec4<T, P>& x, const tvec4<T, P>& y){return atan(x, y);}

 template <typename genType> bool isfinite(genType const & x);
 template <typename T, precision P> tvec1<bool, P> isfinite(const tvec1<T, P>& x);
 template <typename T, precision P> tvec2<bool, P> isfinite(const tvec2<T, P>& x);
 template <typename T, precision P> tvec3<bool, P> isfinite(const tvec3<T, P>& x);
 template <typename T, precision P> tvec4<bool, P> isfinite(const tvec4<T, P>& x);

 typedef bool bool1;
 typedef tvec2<bool, highp> bool2;
 typedef tvec3<bool, highp> bool3;
 typedef tvec4<bool, highp> bool4;

 typedef bool bool1x1;
 typedef tmat2x2<bool, highp> bool2x2;
 typedef tmat2x3<bool, highp> bool2x3;
 typedef tmat2x4<bool, highp> bool2x4;
 typedef tmat3x2<bool, highp> bool3x2;
 typedef tmat3x3<bool, highp> bool3x3;
 typedef tmat3x4<bool, highp> bool3x4;
 typedef tmat4x2<bool, highp> bool4x2;
 typedef tmat4x3<bool, highp> bool4x3;
 typedef tmat4x4<bool, highp> bool4x4;

 typedef int int1;
 typedef tvec2<int, highp> int2;
 typedef tvec3<int, highp> int3;
 typedef tvec4<int, highp> int4;

 typedef int int1x1;
 typedef tmat2x2<int, highp> int2x2;
 typedef tmat2x3<int, highp> int2x3;
 typedef tmat2x4<int, highp> int2x4;
 typedef tmat3x2<int, highp> int3x2;
 typedef tmat3x3<int, highp> int3x3;
 typedef tmat3x4<int, highp> int3x4;
 typedef tmat4x2<int, highp> int4x2;
 typedef tmat4x3<int, highp> int4x3;
 typedef tmat4x4<int, highp> int4x4;

 typedef float float1;
 typedef tvec2<float, highp> float2;
 typedef tvec3<float, highp> float3;
 typedef tvec4<float, highp> float4;

 typedef float float1x1;
 typedef tmat2x2<float, highp> float2x2;
 typedef tmat2x3<float, highp> float2x3;
 typedef tmat2x4<float, highp> float2x4;
 typedef tmat3x2<float, highp> float3x2;
 typedef tmat3x3<float, highp> float3x3;
 typedef tmat3x4<float, highp> float3x4;
 typedef tmat4x2<float, highp> float4x2;
 typedef tmat4x3<float, highp> float4x3;
 typedef tmat4x4<float, highp> float4x4;

 typedef double double1;
 typedef tvec2<double, highp> double2;
 typedef tvec3<double, highp> double3;
 typedef tvec4<double, highp> double4;

 typedef double double1x1;
 typedef tmat2x2<double, highp> double2x2;
 typedef tmat2x3<double, highp> double2x3;
 typedef tmat2x4<double, highp> double2x4;
 typedef tmat3x2<double, highp> double3x2;
 typedef tmat3x3<double, highp> double3x3;
 typedef tmat3x4<double, highp> double3x4;
 typedef tmat4x2<double, highp> double4x2;
 typedef tmat4x3<double, highp> double4x3;
 typedef tmat4x4<double, highp> double4x4;


}


# 1 "/usr/local/include/glm/./gtx/compatibility.inl" 1 3





namespace glm
{

 template <typename genType> inline
                    bool isfinite(
  genType const & x)
 {







   if (std::numeric_limits<genType>::is_integer || std::denorm_absent == std::numeric_limits<genType>::has_denorm)
    return std::numeric_limits<genType>::min() <= x && std::numeric_limits<genType>::max() >= x;
   else
    return -std::numeric_limits<genType>::max() <= x && std::numeric_limits<genType>::max() >= x;

 }

 template <typename T, precision P> inline
                    tvec1<bool, P> isfinite(
  tvec1<T, P> const & x)
 {
  return tvec1<bool, P>(
   isfinite(x.x));
 }

 template <typename T, precision P> inline
                    tvec2<bool, P> isfinite(
  tvec2<T, P> const & x)
 {
  return tvec2<bool, P>(
   isfinite(x.x),
   isfinite(x.y));
 }

 template <typename T, precision P> inline
                    tvec3<bool, P> isfinite(
  tvec3<T, P> const & x)
 {
  return tvec3<bool, P>(
   isfinite(x.x),
   isfinite(x.y),
   isfinite(x.z));
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isfinite(
  tvec4<T, P> const & x)
 {
  return tvec4<bool, P>(
   isfinite(x.x),
   isfinite(x.y),
   isfinite(x.z),
   isfinite(x.w));
 }

}
# 130 "/usr/local/include/glm/./gtx/compatibility.hpp" 2 3
# 67 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/component_wise.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/component_wise.hpp" 3
namespace glm
{






 template <typename floatType, typename T, precision P, template <typename, precision> class vecType>
               vecType<floatType, P> compNormalize(vecType<T, P> const & v);




 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
               vecType<T, P> compScale(vecType<floatType, P> const & v);



 template <typename genType>
               typename genType::value_type compAdd(genType const & v);



 template <typename genType>
               typename genType::value_type compMul(genType const & v);



 template <typename genType>
               typename genType::value_type compMin(genType const & v);



 template <typename genType>
               typename genType::value_type compMax(genType const & v);


}


# 1 "/usr/local/include/glm/./gtx/component_wise.inl" 1 3





namespace glm{
namespace detail
{
 template <typename T, typename floatType, precision P, template <typename, precision> class vecType, bool isInteger, bool signedType>
 struct compute_compNormalize
 {};

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compNormalize<T, floatType, P, vecType, true, true>
 { inline
                     static vecType<floatType, P> call(vecType<T, P> const & v)
  {
   floatType const Min = static_cast<floatType>(std::numeric_limits<T>::min());
   floatType const Max = static_cast<floatType>(std::numeric_limits<T>::max());
   return (vecType<floatType, P>(v) - Min) / (Max - Min) * static_cast<floatType>(2) - static_cast<floatType>(1);
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compNormalize<T, floatType, P, vecType, true, false>
 { inline
                     static vecType<floatType, P> call(vecType<T, P> const & v)
  {
   return vecType<floatType, P>(v) / static_cast<floatType>(std::numeric_limits<T>::max());
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compNormalize<T, floatType, P, vecType, false, true>
 { inline
                     static vecType<floatType, P> call(vecType<T, P> const & v)
  {
   return v;
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType, bool isInteger, bool signedType>
 struct compute_compScale
 {};

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compScale<T, floatType, P, vecType, true, true>
 { inline
                     static vecType<T, P> call(vecType<floatType, P> const & v)
  {
   floatType const Max = static_cast<floatType>(std::numeric_limits<T>::max()) + static_cast<floatType>(0.5);
   vecType<floatType, P> const Scaled(v * Max);
   vecType<T, P> const Result(Scaled - static_cast<floatType>(0.5));
   return Result;
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compScale<T, floatType, P, vecType, true, false>
 { inline
                     static vecType<T, P> call(vecType<floatType, P> const & v)
  {
   return vecType<T, P>(vecType<floatType, P>(v) * static_cast<floatType>(std::numeric_limits<T>::max()));
  }
 };

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType>
 struct compute_compScale<T, floatType, P, vecType, false, true>
 { inline
                     static vecType<T, P> call(vecType<floatType, P> const & v)
  {
   return v;
  }
 };
}

 template <typename floatType, typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<floatType, P> compNormalize(vecType<T, P> const & v)
 {
                                                                                                                                                      ;

  return detail::compute_compNormalize<T, floatType, P, vecType, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
 }

 template <typename T, typename floatType, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> compScale(vecType<floatType, P> const & v)
 {
                                                                                                                                                  ;

  return detail::compute_compScale<T, floatType, P, vecType, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compAdd(vecType<T, P> const & v)
 {
  T Result(0);
  for(length_t i = 0, n = v.length(); i < n; ++i)
   Result += v[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compMul(vecType<T, P> const & v)
 {
  T Result(1);
  for(length_t i = 0, n = v.length(); i < n; ++i)
   Result *= v[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compMin(vecType<T, P> const & v)
 {
  T Result(v[0]);
  for(length_t i = 1, n = v.length(); i < n; ++i)
   Result = min(Result, v[i]);
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T compMax(vecType<T, P> const & v)
 {
  T Result(v[0]);
  for(length_t i = 1, n = v.length(); i < n; ++i)
   Result = max(Result, v[i]);
  return Result;
 }
}
# 65 "/usr/local/include/glm/./gtx/component_wise.hpp" 2 3
# 68 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 1 3
# 28 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 3
namespace glm
{



 template <typename T, precision P = defaultp>
 struct tdualquat
 {


  typedef T value_type;
  typedef glm::tquat<T, P> part_type;



  glm::tquat<T, P> real, dual;



  typedef length_t length_type;

                static length_type length(){return 2;}

                part_type & operator[](length_type i);
                part_type const & operator[](length_type i) const;



                              tdualquat() ;
                              tdualquat(tdualquat<T, P> const & d) ;
  template <precision Q>
                              tdualquat(tdualquat<T, Q> const & d);



                                   explicit tdualquat(ctor);
                              tdualquat(tquat<T, P> const & real);
                              tdualquat(tquat<T, P> const & orientation, tvec3<T, P> const & translation);
                              tdualquat(tquat<T, P> const & real, tquat<T, P> const & dual);



  template <typename U, precision Q>
                                           tdualquat(tdualquat<U, Q> const & q);

                             tdualquat(tmat2x4<T, P> const & holder_mat);
                             tdualquat(tmat3x4<T, P> const & aug_mat);



                tdualquat<T, P> & operator=(tdualquat<T, P> const & m) ;

  template <typename U>
                tdualquat<T, P> & operator=(tdualquat<U, P> const & m);
  template <typename U>
                tdualquat<T, P> & operator*=(U s);
  template <typename U>
                tdualquat<T, P> & operator/=(U s);
 };



 template <typename T, precision P>
               tdualquat<T, P> operator+(tdualquat<T, P> const & q);

 template <typename T, precision P>
               tdualquat<T, P> operator-(tdualquat<T, P> const & q);



 template <typename T, precision P>
               tdualquat<T, P> operator+(tdualquat<T, P> const & q, tdualquat<T, P> const & p);

 template <typename T, precision P>
               tdualquat<T, P> operator*(tdualquat<T, P> const & q, tdualquat<T, P> const & p);

 template <typename T, precision P>
               tvec3<T, P> operator*(tdualquat<T, P> const & q, tvec3<T, P> const & v);

 template <typename T, precision P>
               tvec3<T, P> operator*(tvec3<T, P> const & v, tdualquat<T, P> const & q);

 template <typename T, precision P>
               tvec4<T, P> operator*(tdualquat<T, P> const & q, tvec4<T, P> const & v);

 template <typename T, precision P>
               tvec4<T, P> operator*(tvec4<T, P> const & v, tdualquat<T, P> const & q);

 template <typename T, precision P>
               tdualquat<T, P> operator*(tdualquat<T, P> const & q, T const & s);

 template <typename T, precision P>
               tdualquat<T, P> operator*(T const & s, tdualquat<T, P> const & q);

 template <typename T, precision P>
               tdualquat<T, P> operator/(tdualquat<T, P> const & q, T const & s);



 template <typename T, precision P>
               bool operator==(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2);

 template <typename T, precision P>
               bool operator!=(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2);




 template <typename T, precision P>
               tdualquat<T, P> normalize(tdualquat<T, P> const & q);




 template <typename T, precision P>
               tdualquat<T, P> lerp(tdualquat<T, P> const & x, tdualquat<T, P> const & y, T const & a);




 template <typename T, precision P>
               tdualquat<T, P> inverse(tdualquat<T, P> const & q);




 template <typename T, precision P>
               tmat2x4<T, P> mat2x4_cast(tdualquat<T, P> const & x);




 template <typename T, precision P>
               tmat3x4<T, P> mat3x4_cast(tdualquat<T, P> const & x);




 template <typename T, precision P>
               tdualquat<T, P> dualquat_cast(tmat2x4<T, P> const & x);




 template <typename T, precision P>
               tdualquat<T, P> dualquat_cast(tmat3x4<T, P> const & x);





 typedef tdualquat<float, lowp> lowp_dualquat;




 typedef tdualquat<float, mediump> mediump_dualquat;




 typedef tdualquat<float, highp> highp_dualquat;





 typedef tdualquat<float, lowp> lowp_fdualquat;




 typedef tdualquat<float, mediump> mediump_fdualquat;




 typedef tdualquat<float, highp> highp_fdualquat;





 typedef tdualquat<double, lowp> lowp_ddualquat;




 typedef tdualquat<double, mediump> mediump_ddualquat;




 typedef tdualquat<double, highp> highp_ddualquat;






 typedef highp_fdualquat dualquat;




 typedef highp_fdualquat fdualquat;
# 252 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 3
 typedef highp_ddualquat ddualquat;
# 264 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 3
}


# 1 "/usr/local/include/glm/./gtx/dual_quaternion.inl" 1 3






namespace glm
{


 template <typename T, precision P> inline
                    typename tdualquat<T, P>::part_type & tdualquat<T, P>::operator[](typename tdualquat<T, P>::length_type i)
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 14, "i >= 0 && i < this->length()") : (void)0);
  return (&real)[i];
 }

 template <typename T, precision P> inline
                    typename tdualquat<T, P>::part_type const & tdualquat<T, P>::operator[](typename tdualquat<T, P>::length_type i) const
 {
  (__builtin_expect(!(i >= 0 && i < this->length()), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 21, "i >= 0 && i < this->length()") : (void)0);
  return (&real)[i];
 }




  template <typename T, precision P> inline
                                   tdualquat<T, P>::tdualquat()

    : real(tquat<T, P>())
    , dual(tquat<T, P>(0, 0, 0, 0))

  {}



  template <typename T, precision P> inline
                                   tdualquat<T, P>::tdualquat(tdualquat<T, P> const & d)
   : real(d.real)
   , dual(d.dual)
  {}


 template <typename T, precision P>
 template <precision Q> inline
                                  tdualquat<T, P>::tdualquat(tdualquat<T, Q> const & d)
  : real(d.real)
  , dual(d.dual)
 {}



 template <typename T, precision P> inline
                                       tdualquat<T, P>::tdualquat(ctor)
 {}

 template <typename T, precision P> inline
                                  tdualquat<T, P>::tdualquat(tquat<T, P> const & r)
  : real(r), dual(tquat<T, P>(0, 0, 0, 0))
 {}

 template <typename T, precision P> inline
                                  tdualquat<T, P>::tdualquat(tquat<T, P> const & q, tvec3<T, P> const& p)
  : real(q), dual(
   T(-0.5) * ( p.x*q.x + p.y*q.y + p.z*q.z),
   T(+0.5) * ( p.x*q.w + p.y*q.z - p.z*q.y),
   T(+0.5) * (-p.x*q.z + p.y*q.w + p.z*q.x),
   T(+0.5) * ( p.x*q.y - p.y*q.x + p.z*q.w))
 {}

 template <typename T, precision P> inline
                                  tdualquat<T, P>::tdualquat(tquat<T, P> const & r, tquat<T, P> const & d)
  : real(r), dual(d)
 {}



 template <typename T, precision P>
 template <typename U, precision Q> inline
                                  tdualquat<T, P>::tdualquat(tdualquat<U, Q> const & q)
  : real(q.real)
  , dual(q.dual)
 {}

 template <typename T, precision P> inline
                    tdualquat<T, P>::tdualquat(tmat2x4<T, P> const & m)
 {
  *this = dualquat_cast(m);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P>::tdualquat(tmat3x4<T, P> const & m)
 {
  *this = dualquat_cast(m);
 }




  template <typename T, precision P> inline
                     tdualquat<T, P> & tdualquat<T, P>::operator=(tdualquat<T, P> const & q)
  {
   this->real = q.real;
   this->dual = q.dual;
   return *this;
  }


 template <typename T, precision P>
 template <typename U> inline
                    tdualquat<T, P> & tdualquat<T, P>::operator=(tdualquat<U, P> const & q)
 {
  this->real = q.real;
  this->dual = q.dual;
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tdualquat<T, P> & tdualquat<T, P>::operator*=(U s)
 {
  this->real *= static_cast<T>(s);
  this->dual *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U> inline
                    tdualquat<T, P> & tdualquat<T, P>::operator/=(U s)
 {
  this->real /= static_cast<T>(s);
  this->dual /= static_cast<T>(s);
  return *this;
 }



 template <typename T, precision P> inline
                    tdualquat<T, P> operator+(tdualquat<T, P> const & q)
 {
  return q;
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator-(tdualquat<T, P> const & q)
 {
  return tdualquat<T, P>(-q.real, -q.dual);
 }



 template <typename T, precision P> inline
                    tdualquat<T, P> operator+(tdualquat<T, P> const & q, tdualquat<T, P> const & p)
 {
  return tdualquat<T, P>(q.real + p.real,q.dual + p.dual);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator*(tdualquat<T, P> const & p, tdualquat<T, P> const & o)
 {
  return tdualquat<T, P>(p.real * o.real,p.real * o.dual + p.dual * o.real);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tdualquat<T, P> const & q, tvec3<T, P> const & v)
 {
  tvec3<T, P> const real_v3(q.real.x,q.real.y,q.real.z);
  tvec3<T, P> const dual_v3(q.dual.x,q.dual.y,q.dual.z);
  return (cross(real_v3, cross(real_v3,v) + v * q.real.w + dual_v3) + dual_v3 * q.real.w - real_v3 * q.dual.w) * T(2) + v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> operator*(tvec3<T, P> const & v, tdualquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tdualquat<T, P> const & q, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
 }

 template <typename T, precision P> inline
                    tvec4<T, P> operator*(tvec4<T, P> const & v, tdualquat<T, P> const & q)
 {
  return glm::inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator*(tdualquat<T, P> const & q, T const & s)
 {
  return tdualquat<T, P>(q.real * s, q.dual * s);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator*(T const & s, tdualquat<T, P> const & q)
 {
  return q * s;
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> operator/(tdualquat<T, P> const & q, T const & s)
 {
  return tdualquat<T, P>(q.real / s, q.dual / s);
 }



 template <typename T, precision P> inline
                    bool operator==(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2)
 {
  return (q1.real == q2.real) && (q1.dual == q2.dual);
 }

 template <typename T, precision P> inline
                    bool operator!=(tdualquat<T, P> const & q1, tdualquat<T, P> const & q2)
 {
  return (q1.real != q2.dual) || (q1.real != q2.dual);
 }



 template <typename T, precision P> inline
                    tdualquat<T, P> normalize(tdualquat<T, P> const & q)
 {
  return q / length(q.real);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> lerp(tdualquat<T, P> const & x, tdualquat<T, P> const & y, T const & a)
 {


  (__builtin_expect(!(a >= static_cast<T>(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 236, "a >= static_cast<T>(0)") : (void)0);
  (__builtin_expect(!(a <= static_cast<T>(1)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/dual_quaternion.inl", 237, "a <= static_cast<T>(1)") : (void)0);
  T const k = dot(x.real,y.real) < static_cast<T>(0) ? -a : a;
  T const one(1);
  return tdualquat<T, P>(x * (one - a) + y * k);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> inverse(tdualquat<T, P> const & q)
 {
  const glm::tquat<T, P> real = conjugate(q.real);
  const glm::tquat<T, P> dual = conjugate(q.dual);
  return tdualquat<T, P>(real, dual + (real * (-2.0f * dot(real,dual))));
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> mat2x4_cast(tdualquat<T, P> const & x)
 {
  return tmat2x4<T, P>( x[0].x, x[0].y, x[0].z, x[0].w, x[1].x, x[1].y, x[1].z, x[1].w );
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> mat3x4_cast(tdualquat<T, P> const & x)
 {
  tquat<T, P> r = x.real / length2(x.real);

  tquat<T, P> const rr(r.w * x.real.w, r.x * x.real.x, r.y * x.real.y, r.z * x.real.z);
  r *= static_cast<T>(2);

  T const xy = r.x * x.real.y;
  T const xz = r.x * x.real.z;
  T const yz = r.y * x.real.z;
  T const wx = r.w * x.real.x;
  T const wy = r.w * x.real.y;
  T const wz = r.w * x.real.z;

  tvec4<T, P> const a(
   rr.w + rr.x - rr.y - rr.z,
   xy - wz,
   xz + wy,
   -(x.dual.w * r.x - x.dual.x * r.w + x.dual.y * r.z - x.dual.z * r.y));

  tvec4<T, P> const b(
   xy + wz,
   rr.w + rr.y - rr.x - rr.z,
   yz - wx,
   -(x.dual.w * r.y - x.dual.x * r.z - x.dual.y * r.w + x.dual.z * r.x));

  tvec4<T, P> const c(
   xz - wy,
   yz + wx,
   rr.w + rr.z - rr.x - rr.y,
   -(x.dual.w * r.z + x.dual.x * r.y - x.dual.y * r.x - x.dual.z * r.w));

  return tmat3x4<T, P>(a, b, c);
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> dualquat_cast(tmat2x4<T, P> const & x)
 {
  return tdualquat<T, P>(
   tquat<T, P>( x[0].w, x[0].x, x[0].y, x[0].z ),
   tquat<T, P>( x[1].w, x[1].x, x[1].y, x[1].z ));
 }

 template <typename T, precision P> inline
                    tdualquat<T, P> dualquat_cast(tmat3x4<T, P> const & x)
 {
  tquat<T, P> real(uninitialize);

  T const trace = x[0].x + x[1].y + x[2].z;
  if(trace > static_cast<T>(0))
  {
   T const r = sqrt(T(1) + trace);
   T const invr = static_cast<T>(0.5) / r;
   real.w = static_cast<T>(0.5) * r;
   real.x = (x[2].y - x[1].z) * invr;
   real.y = (x[0].z - x[2].x) * invr;
   real.z = (x[1].x - x[0].y) * invr;
  }
  else if(x[0].x > x[1].y && x[0].x > x[2].z)
  {
   T const r = sqrt(T(1) + x[0].x - x[1].y - x[2].z);
   T const invr = static_cast<T>(0.5) / r;
   real.x = static_cast<T>(0.5)*r;
   real.y = (x[1].x + x[0].y) * invr;
   real.z = (x[0].z + x[2].x) * invr;
   real.w = (x[2].y - x[1].z) * invr;
  }
  else if(x[1].y > x[2].z)
  {
   T const r = sqrt(T(1) + x[1].y - x[0].x - x[2].z);
   T const invr = static_cast<T>(0.5) / r;
   real.x = (x[1].x + x[0].y) * invr;
   real.y = static_cast<T>(0.5) * r;
   real.z = (x[2].y + x[1].z) * invr;
   real.w = (x[0].z - x[2].x) * invr;
  }
  else
  {
   T const r = sqrt(T(1) + x[2].z - x[0].x - x[1].y);
   T const invr = static_cast<T>(0.5) / r;
   real.x = (x[0].z + x[2].x) * invr;
   real.y = (x[2].y + x[1].z) * invr;
   real.z = static_cast<T>(0.5) * r;
   real.w = (x[1].x - x[0].y) * invr;
  }

  tquat<T, P> dual(uninitialize);
  dual.x = static_cast<T>(0.5) * ( x[0].w * real.w + x[1].w * real.z - x[2].w * real.y);
  dual.y = static_cast<T>(0.5) * (-x[0].w * real.z + x[1].w * real.w + x[2].w * real.x);
  dual.z = static_cast<T>(0.5) * ( x[0].w * real.y - x[1].w * real.x + x[2].w * real.w);
  dual.w = -static_cast<T>(0.5) * ( x[0].w * real.x + x[1].w * real.y + x[2].w * real.z);
  return tdualquat<T, P>(real, dual);
 }
}
# 266 "/usr/local/include/glm/./gtx/dual_quaternion.hpp" 2 3
# 69 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/euler_angles.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/euler_angles.hpp" 3
namespace glm
{





 template <typename T>
               tmat4x4<T, defaultp> eulerAngleX(
  T const & angleX);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleY(
  T const & angleY);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleZ(
  T const & angleZ);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleXY(
  T const & angleX,
  T const & angleY);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleYX(
  T const & angleY,
  T const & angleX);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleXZ(
  T const & angleX,
  T const & angleZ);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleZX(
  T const & angle,
  T const & angleX);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleYZ(
  T const & angleY,
  T const & angleZ);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleZY(
  T const & angleZ,
  T const & angleY);



    template <typename T>
                  tmat4x4<T, defaultp> eulerAngleXYZ(
        T const & t1,
        T const & t2,
        T const & t3);



 template <typename T>
               tmat4x4<T, defaultp> eulerAngleYXZ(
  T const & yaw,
  T const & pitch,
  T const & roll);



 template <typename T>
               tmat4x4<T, defaultp> yawPitchRoll(
  T const & yaw,
  T const & pitch,
  T const & roll);



 template <typename T>
               tmat2x2<T, defaultp> orientate2(T const & angle);



 template <typename T>
               tmat3x3<T, defaultp> orientate3(T const & angle);



 template <typename T, precision P>
               tmat3x3<T, P> orientate3(tvec3<T, P> const & angles);



 template <typename T, precision P>
               tmat4x4<T, P> orientate4(tvec3<T, P> const & angles);



    template <typename T>
                  void extractEulerAngleXYZ(tmat4x4<T, defaultp> const & M,
                                            T & t1,
                                            T & t2,
                                            T & t3);


}


# 1 "/usr/local/include/glm/./gtx/euler_angles.inl" 1 3





namespace glm
{
 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleX
 (
  T const & angleX
 )
 {
  T cosX = glm::cos(angleX);
  T sinX = glm::sin(angleX);

  return tmat4x4<T, defaultp>(
   T(1), T(0), T(0), T(0),
   T(0), cosX, sinX, T(0),
   T(0),-sinX, cosX, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleY
 (
  T const & angleY
 )
 {
  T cosY = glm::cos(angleY);
  T sinY = glm::sin(angleY);

  return tmat4x4<T, defaultp>(
   cosY, T(0), -sinY, T(0),
   T(0), T(1), T(0), T(0),
   sinY, T(0), cosY, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleZ
 (
  T const & angleZ
 )
 {
  T cosZ = glm::cos(angleZ);
  T sinZ = glm::sin(angleZ);

  return tmat4x4<T, defaultp>(
   cosZ, sinZ, T(0), T(0),
   -sinZ, cosZ, T(0), T(0),
   T(0), T(0), T(1), T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleXY
 (
  T const & angleX,
  T const & angleY
 )
 {
  T cosX = glm::cos(angleX);
  T sinX = glm::sin(angleX);
  T cosY = glm::cos(angleY);
  T sinY = glm::sin(angleY);

  return tmat4x4<T, defaultp>(
   cosY, -sinX * -sinY, cosX * -sinY, T(0),
   T(0), cosX, sinX, T(0),
   sinY, -sinX * cosY, cosX * cosY, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleYX
 (
  T const & angleY,
  T const & angleX
 )
 {
  T cosX = glm::cos(angleX);
  T sinX = glm::sin(angleX);
  T cosY = glm::cos(angleY);
  T sinY = glm::sin(angleY);

  return tmat4x4<T, defaultp>(
   cosY, 0, -sinY, T(0),
   sinY * sinX, cosX, cosY * sinX, T(0),
   sinY * cosX, -sinX, cosY * cosX, T(0),
   T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleXZ
 (
  T const & angleX,
  T const & angleZ
 )
 {
  return eulerAngleX(angleX) * eulerAngleZ(angleZ);
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleZX
 (
  T const & angleZ,
  T const & angleX
 )
 {
  return eulerAngleZ(angleZ) * eulerAngleX(angleX);
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleYZ
 (
  T const & angleY,
  T const & angleZ
 )
 {
  return eulerAngleY(angleY) * eulerAngleZ(angleZ);
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleZY
 (
  T const & angleZ,
  T const & angleY
 )
 {
  return eulerAngleZ(angleZ) * eulerAngleY(angleY);
 }

    template <typename T> inline
                       tmat4x4<T, defaultp> eulerAngleXYZ
    (
     T const & t1,
     T const & t2,
     T const & t3
     )
    {
        T c1 = glm::cos(-t1);
        T c2 = glm::cos(-t2);
        T c3 = glm::cos(-t3);
        T s1 = glm::sin(-t1);
        T s2 = glm::sin(-t2);
        T s3 = glm::sin(-t3);

        tmat4x4<T, defaultp> Result;
        Result[0][0] = c2 * c3;
        Result[0][1] =-c1 * s3 + s1 * s2 * c3;
        Result[0][2] = s1 * s3 + c1 * s2 * c3;
        Result[0][3] = static_cast<T>(0);
        Result[1][0] = c2 * s3;
        Result[1][1] = c1 * c3 + s1 * s2 * s3;
        Result[1][2] =-s1 * c3 + c1 * s2 * s3;
        Result[1][3] = static_cast<T>(0);
        Result[2][0] =-s2;
        Result[2][1] = s1 * c2;
        Result[2][2] = c1 * c2;
        Result[2][3] = static_cast<T>(0);
        Result[3][0] = static_cast<T>(0);
        Result[3][1] = static_cast<T>(0);
        Result[3][2] = static_cast<T>(0);
        Result[3][3] = static_cast<T>(1);
        return Result;
    }

 template <typename T> inline
                    tmat4x4<T, defaultp> eulerAngleYXZ
 (
  T const & yaw,
  T const & pitch,
  T const & roll
 )
 {
  T tmp_ch = glm::cos(yaw);
  T tmp_sh = glm::sin(yaw);
  T tmp_cp = glm::cos(pitch);
  T tmp_sp = glm::sin(pitch);
  T tmp_cb = glm::cos(roll);
  T tmp_sb = glm::sin(roll);

  tmat4x4<T, defaultp> Result;
  Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
  Result[0][1] = tmp_sb * tmp_cp;
  Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
  Result[0][3] = static_cast<T>(0);
  Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
  Result[1][1] = tmp_cb * tmp_cp;
  Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
  Result[1][3] = static_cast<T>(0);
  Result[2][0] = tmp_sh * tmp_cp;
  Result[2][1] = -tmp_sp;
  Result[2][2] = tmp_ch * tmp_cp;
  Result[2][3] = static_cast<T>(0);
  Result[3][0] = static_cast<T>(0);
  Result[3][1] = static_cast<T>(0);
  Result[3][2] = static_cast<T>(0);
  Result[3][3] = static_cast<T>(1);
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T, defaultp> yawPitchRoll
 (
  T const & yaw,
  T const & pitch,
  T const & roll
 )
 {
  T tmp_ch = glm::cos(yaw);
  T tmp_sh = glm::sin(yaw);
  T tmp_cp = glm::cos(pitch);
  T tmp_sp = glm::sin(pitch);
  T tmp_cb = glm::cos(roll);
  T tmp_sb = glm::sin(roll);

  tmat4x4<T, defaultp> Result;
  Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
  Result[0][1] = tmp_sb * tmp_cp;
  Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
  Result[0][3] = static_cast<T>(0);
  Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
  Result[1][1] = tmp_cb * tmp_cp;
  Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
  Result[1][3] = static_cast<T>(0);
  Result[2][0] = tmp_sh * tmp_cp;
  Result[2][1] = -tmp_sp;
  Result[2][2] = tmp_ch * tmp_cp;
  Result[2][3] = static_cast<T>(0);
  Result[3][0] = static_cast<T>(0);
  Result[3][1] = static_cast<T>(0);
  Result[3][2] = static_cast<T>(0);
  Result[3][3] = static_cast<T>(1);
  return Result;
 }

 template <typename T> inline
                    tmat2x2<T, defaultp> orientate2
 (
  T const & angle
 )
 {
  T c = glm::cos(angle);
  T s = glm::sin(angle);

  tmat2x2<T, defaultp> Result;
  Result[0][0] = c;
  Result[0][1] = s;
  Result[1][0] = -s;
  Result[1][1] = c;
  return Result;
 }

 template <typename T> inline
                    tmat3x3<T, defaultp> orientate3
 (
  T const & angle
 )
 {
  T c = glm::cos(angle);
  T s = glm::sin(angle);

  tmat3x3<T, defaultp> Result;
  Result[0][0] = c;
  Result[0][1] = s;
  Result[0][2] = 0.0f;
  Result[1][0] = -s;
  Result[1][1] = c;
  Result[1][2] = 0.0f;
  Result[2][0] = 0.0f;
  Result[2][1] = 0.0f;
  Result[2][2] = 1.0f;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> orientate3
 (
  tvec3<T, P> const & angles
 )
 {
  return tmat3x3<T, P>(yawPitchRoll(angles.z, angles.x, angles.y));
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> orientate4
 (
  tvec3<T, P> const & angles
 )
 {
  return yawPitchRoll(angles.z, angles.x, angles.y);
 }

    template <typename T>
                  void extractEulerAngleXYZ(tmat4x4<T, defaultp> const & M,
                                            T & t1,
                                            T & t2,
                                            T & t3)
    {
        float T1 = glm::atan2<T, defaultp>(M[2][1], M[2][2]);
        float C2 = glm::sqrt(M[0][0]*M[0][0] + M[1][0]*M[1][0]);
        float T2 = glm::atan2<T, defaultp>(-M[2][0], C2);
        float S1 = glm::sin(T1);
        float C1 = glm::cos(T1);
        float T3 = glm::atan2<T, defaultp>(S1*M[0][2] - C1*M[0][1], C1*M[1][1] - S1*M[1][2 ]);
        t1 = -T1;
        t2 = -T2;
        t3 = -T3;
    }
}
# 143 "/usr/local/include/glm/./gtx/euler_angles.hpp" 2 3
# 70 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/extend.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/extend.hpp" 3
namespace glm
{





 template <typename genType>
               genType extend(
  genType const & Origin,
  genType const & Source,
  typename genType::value_type const Length);


}


# 1 "/usr/local/include/glm/./gtx/extend.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType extend
 (
  genType const & Origin,
  genType const & Source,
  genType const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> extend
 (
  tvec2<T, P> const & Origin,
  tvec2<T, P> const & Source,
  T const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> extend
 (
  tvec3<T, P> const & Origin,
  tvec3<T, P> const & Source,
  T const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> extend
 (
  tvec4<T, P> const & Origin,
  tvec4<T, P> const & Source,
  T const & Distance
 )
 {
  return Origin + (Source - Origin) * Distance;
 }
}
# 38 "/usr/local/include/glm/./gtx/extend.hpp" 2 3
# 71 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 3
namespace glm
{





 template <typename T>
               T min(
  T const & x,
  T const & y,
  T const & z);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z);



 template <typename T>
               T min(
  T const & x,
  T const & y,
  T const & z,
  T const & w);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w);



 template <typename T, template <typename> class C>
               C<T> min(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w);



 template <typename T>
               T max(
  T const & x,
  T const & y,
  T const & z);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z);



 template <typename T>
               T max(
  T const & x,
  T const & y,
  T const & z,
  T const & w);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w);



 template <typename T, template <typename> class C>
               C<T> max(
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w);


}


# 1 "/usr/local/include/glm/./gtx/extended_min_max.inl" 1 3



namespace glm
{
 template <typename T> inline
                    T min(
  T const & x,
  T const & y,
  T const & z)
 {
  return glm::min(glm::min(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z
 )
 {
  return glm::min(glm::min(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z
 )
 {
  return glm::min(glm::min(x, y), z);
 }

 template <typename T> inline
                    T min
 (
  T const & x,
  T const & y,
  T const & z,
  T const & w
 )
 {
  return glm::min(glm::min(x, y), glm::min(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w
 )
 {
  return glm::min(glm::min(x, y), glm::min(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> min
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w
 )
 {
  return glm::min(glm::min(x, y), glm::min(z, w));
 }

 template <typename T> inline
                    T max(
  T const & x,
  T const & y,
  T const & z)
 {
  return glm::max(glm::max(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z
 )
 {
  return glm::max(glm::max(x, y), z);
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z
 )
 {
  return glm::max(glm::max(x, y), z);
 }

 template <typename T> inline
                    T max
 (
  T const & x,
  T const & y,
  T const & z,
  T const & w
 )
 {
  return glm::max(glm::max(x, y), glm::max(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  typename C<T>::T const & y,
  typename C<T>::T const & z,
  typename C<T>::T const & w
 )
 {
  return glm::max(glm::max(x, y), glm::max(z, w));
 }

 template <typename T, template <typename> class C> inline
                    C<T> max
 (
  C<T> const & x,
  C<T> const & y,
  C<T> const & z,
  C<T> const & w
 )
 {
  return glm::max(glm::max(x, y), glm::max(z, w));
 }

}
# 133 "/usr/local/include/glm/./gtx/extended_min_max.hpp" 2 3
# 72 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 3
namespace glm
{





 template <typename genType>
               genType fastPow(genType x, genType y);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastPow(vecType<T, P> const & x, vecType<T, P> const & y);



 template <typename genTypeT, typename genTypeU>
               genTypeT fastPow(genTypeT x, genTypeU y);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastPow(vecType<T, P> const & x);



 template <typename T>
               T fastExp(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastExp(vecType<T, P> const & x);



 template <typename T>
               T fastLog(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastLog(vecType<T, P> const & x);



 template <typename T>
               T fastExp2(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastExp2(vecType<T, P> const & x);



 template <typename T>
               T fastLog2(T x);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastLog2(vecType<T, P> const & x);


}


# 1 "/usr/local/include/glm/./gtx/fast_exponential.inl" 1 3



namespace glm
{

 template <typename genType> inline
                    genType fastPow(genType x, genType y)
 {
  return exp(y * log(x));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastPow(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return exp(y * log(x));
 }

 template <typename T> inline
                    T fastPow(T x, int y)
 {
  T f = static_cast<T>(1);
  for(int i = 0; i < y; ++i)
   f *= x;
  return f;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastPow(vecType<T, P> const & x, vecType<int, P> const & y)
 {
  vecType<T, P> Result(uninitialize);
  for(length_t i = 0, n = x.length(); i < n; ++i)
   Result[i] = fastPow(x[i], y[i]);
  return Result;
 }



 template <typename T> inline
                    T fastExp(T x)
 {


  T x2 = x * x;
  T x3 = x2 * x;
  T x4 = x3 * x;
  T x5 = x4 * x;
  return T(1) + x + (x2 * T(0.5)) + (x3 * T(0.1666666667)) + (x4 * T(0.041666667)) + (x5 * T(0.008333333333));
 }
# 84 "/usr/local/include/glm/./gtx/fast_exponential.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastExp(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastExp, x);
 }


 template <typename genType> inline
                    genType fastLog(genType x)
 {
  return std::log(x);
 }
# 106 "/usr/local/include/glm/./gtx/fast_exponential.inl" 3
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastLog(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastLog, x);
 }


 template <typename genType> inline
                    genType fastExp2(genType x)
 {
  return fastExp(0.69314718055994530941723212145818f * x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastExp2(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastExp2, x);
 }


 template <typename genType> inline
                    genType fastLog2(genType x)
 {
  return fastLog(x) / 0.69314718055994530941723212145818f;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastLog2(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastLog2, x);
 }
}
# 91 "/usr/local/include/glm/./gtx/fast_exponential.hpp" 2 3
# 73 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 1 3
# 26 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 3
namespace glm
{






 template <typename genType>
               genType fastSqrt(genType x);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastSqrt(vecType<T, P> const & x);




 template <typename genType>
               genType fastInverseSqrt(genType x);




 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> fastInverseSqrt(vecType<T, P> const & x);




 template <typename genType>
               genType fastLength(genType x);




 template <typename T, precision P, template <typename, precision> class vecType>
               T fastLength(vecType<T, P> const & x);




 template <typename genType>
               genType fastDistance(genType x, genType y);




 template <typename T, precision P, template <typename, precision> class vecType>
               T fastDistance(vecType<T, P> const & x, vecType<T, P> const & y);




 template <typename genType>
               genType fastNormalize(genType const & x);


}


# 1 "/usr/local/include/glm/./gtx/fast_square_root.inl" 1 3



namespace glm
{

 template <typename genType> inline
                    genType fastSqrt(genType x)
 {
                                                                                                           ;

  return genType(1) / fastInverseSqrt(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastSqrt(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastSqrt, x);
 }


 template <typename genType> inline
                    genType fastInverseSqrt(genType x)
 {




   return detail::compute_inversesqrt<tvec1, genType, highp, detail::is_aligned<highp>::value>::call(tvec1<genType, lowp>(x)).x;

 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastInverseSqrt(vecType<T, P> const & x)
 {
  return detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);
 }


 template <typename genType> inline
                    genType fastLength(genType x)
 {
                                                                                                              ;

  return abs(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T fastLength(vecType<T, P> const & x)
 {
                                                                                                        ;

  return fastSqrt(dot(x, x));
 }


 template <typename genType> inline
                    genType fastDistance(genType x, genType y)
 {
  return fastLength(y - x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T fastDistance(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return fastLength(y - x);
 }


 template <typename genType> inline
                    genType fastNormalize(genType x)
 {
  return x > genType(0) ? genType(1) : -genType(1);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastNormalize(vecType<T, P> const & x)
 {
  return x * fastInverseSqrt(dot(x, x));
 }
}
# 88 "/usr/local/include/glm/./gtx/fast_square_root.hpp" 2 3
# 74 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 3
namespace glm
{





 template <typename T>
               T wrapAngle(T angle);



 template <typename T>
               T fastSin(T angle);



 template <typename T>
               T fastCos(T angle);




 template <typename T>
               T fastTan(T angle);




 template <typename T>
               T fastAsin(T angle);




 template <typename T>
               T fastAcos(T angle);




 template <typename T>
               T fastAtan(T y, T x);




 template <typename T>
               T fastAtan(T angle);


}


# 1 "/usr/local/include/glm/./gtx/fast_trigonometry.inl" 1 3



namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> taylorCos(vecType<T, P> const & x)
 {
  return static_cast<T>(1)
   - (x * x) / 2.f
   + (x * x * x * x) / 24.f
   - (x * x * x * x * x * x) / 720.f
   + (x * x * x * x * x * x * x * x) / 40320.f;
 }

 template <typename T> inline
                    T cos_52s(T x)
 {
  T const xx(x * x);
  return (T(0.9999932946) + xx * (T(-0.4999124376) + xx * (T(0.0414877472) + xx * T(-0.0012712095))));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> cos_52s(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(cos_52s, x);
 }
}


 template <typename T> inline
                    T wrapAngle(T angle)
 {
  return abs<T>(mod<T>(angle, two_pi<T>()));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> wrapAngle(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(wrapAngle, x);
 }


 template <typename T> inline
                    T fastCos(T x)
 {
  T const angle(wrapAngle<T>(x));

  if(angle < half_pi<T>())
   return detail::cos_52s(angle);
  if(angle < pi<T>())
   return -detail::cos_52s(pi<T>() - angle);
  if(angle < (T(3) * half_pi<T>()))
   return -detail::cos_52s(angle - pi<T>());

  return detail::cos_52s(two_pi<T>() - angle);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastCos(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastCos, x);
 }


 template <typename T> inline
                    T fastSin(T x)
 {
  return fastCos<T>(half_pi<T>() - x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastSin(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastSin, x);
 }


 template <typename T> inline
                    T fastTan(T x)
 {
  return x + (x * x * x * T(0.3333333333)) + (x * x * x * x * x * T(0.1333333333333)) + (x * x * x * x * x * x * x * T(0.0539682539));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastTan(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastTan, x);
 }


 template <typename T> inline
                    T fastAsin(T x)
 {
  return x + (x * x * x * T(0.166666667)) + (x * x * x * x * x * T(0.075)) + (x * x * x * x * x * x * x * T(0.0446428571)) + (x * x * x * x * x * x * x * x * x * T(0.0303819444));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAsin(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastAsin, x);
 }


 template <typename T> inline
                    T fastAcos(T x)
 {
  return T(1.5707963267948966192313216916398) - fastAsin(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAcos(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastAcos, x);
 }


 template <typename T> inline
                    T fastAtan(T y, T x)
 {
  T sgn = sign(y) * sign(x);
  return abs(fastAtan(y / x)) * sgn;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAtan(vecType<T, P> const & y, vecType<T, P> const & x)
 {
  return detail::functor2<T, P, vecType>::call(fastAtan, y, x);
 }

 template <typename T> inline
                    T fastAtan(T x)
 {
  return x - (x * x * x * T(0.333333333333)) + (x * x * x * x * x * T(0.2)) - (x * x * x * x * x * x * x * T(0.1428571429)) + (x * x * x * x * x * x * x * x * x * T(0.111111111111)) - (x * x * x * x * x * x * x * x * x * x * x * T(0.0909090909));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> fastAtan(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(fastAtan, x);
 }
}
# 75 "/usr/local/include/glm/./gtx/fast_trigonometry.hpp" 2 3
# 75 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 1 3
# 17 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 3
namespace glm{
namespace gtx
{






 template <typename genType>
               genType pow2(genType const & x);




 template <typename genType>
               genType pow3(genType const & x);




 template <typename genType>
               genType pow4(genType const & x);


}
}


# 1 "/usr/local/include/glm/./gtx/optimum_pow.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType pow2(genType const & x)
 {
  return x * x;
 }

 template <typename genType> inline
                    genType pow3(genType const & x)
 {
  return x * x * x;
 }

 template <typename genType> inline
                    genType pow4(genType const & x)
 {
  return (x * x) * (x * x);
 }
}
# 50 "/usr/local/include/glm/./gtx/../gtx/optimum_pow.hpp" 2 3
# 17 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 2 3






namespace glm
{





 template <typename T, precision P>
               T radialGradient(
  tvec2<T, P> const & Center,
  T const & Radius,
  tvec2<T, P> const & Focal,
  tvec2<T, P> const & Position);



 template <typename T, precision P>
               T linearGradient(
  tvec2<T, P> const & Point0,
  tvec2<T, P> const & Point1,
  tvec2<T, P> const & Position);


}


# 1 "/usr/local/include/glm/./gtx/gradient_paint.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    T radialGradient
 (
  tvec2<T, P> const & Center,
  T const & Radius,
  tvec2<T, P> const & Focal,
  tvec2<T, P> const & Position
 )
 {
  tvec2<T, P> F = Focal - Center;
  tvec2<T, P> D = Position - Focal;
  T Radius2 = pow2(Radius);
  T Fx2 = pow2(F.x);
  T Fy2 = pow2(F.y);

  T Numerator = (D.x * F.x + D.y * F.y) + sqrt(Radius2 * (pow2(D.x) + pow2(D.y)) - pow2(D.x * F.y - D.y * F.x));
  T Denominator = Radius2 - (Fx2 + Fy2);
  return Numerator / Denominator;
 }

 template <typename T, precision P> inline
                    T linearGradient
 (
  tvec2<T, P> const & Point0,
  tvec2<T, P> const & Point1,
  tvec2<T, P> const & Position
 )
 {
  tvec2<T, P> Dist = Point1 - Point0;
  return (Dist.x * (Position.x - Point0.x) + Dist.y * (Position.y - Point0.y)) / glm::dot(Dist, Dist);
 }
}
# 48 "/usr/local/include/glm/./gtx/gradient_paint.hpp" 2 3
# 76 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 3
namespace glm
{





 template <typename T, precision P>
               bool rightHanded(
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal);



 template <typename T, precision P>
               bool leftHanded(
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal);


}


# 1 "/usr/local/include/glm/./gtx/handed_coordinate_space.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    bool rightHanded
 (
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal
 )
 {
  return dot(cross(normal, tangent), binormal) > T(0);
 }

 template <typename T, precision P> inline
                    bool leftHanded
 (
  tvec3<T, P> const & tangent,
  tvec3<T, P> const & binormal,
  tvec3<T, P> const & normal
 )
 {
  return dot(cross(normal, tangent), binormal) < T(0);
 }
}
# 46 "/usr/local/include/glm/./gtx/handed_coordinate_space.hpp" 2 3
# 77 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/integer.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/integer.hpp" 3
namespace glm
{





               int pow(int x, int y);



               int sqrt(int x);



               unsigned int floor_log2(unsigned int x);



               int mod(int x, int y);



 template <typename genType>
               genType factorial(genType const & x);



 typedef signed int sint;



               uint pow(uint x, uint y);



               uint sqrt(uint x);



               uint mod(uint x, uint y);



               uint nlz(uint x);


}


# 1 "/usr/local/include/glm/./gtx/integer.inl" 1 3



namespace glm
{ inline

                    int pow(int x, int y)
 {
  if(y == 0)
   return 1;
  int result = x;
  for(int i = 1; i < y; ++i)
   result *= x;
  return result;
 } inline


                    int sqrt(int x)
 {
  if(x <= 1) return x;

  int NextTrial = x >> 1;
  int CurrentAnswer;

  do
  {
   CurrentAnswer = NextTrial;
   NextTrial = (NextTrial + x / NextTrial) >> 1;
  } while(NextTrial < CurrentAnswer);

  return CurrentAnswer;
 }


namespace detail
{ inline
                    unsigned int ones32(unsigned int x)
 {




  x -= ((x >> 1) & 0x55555555);
  x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
  x = (((x >> 4) + x) & 0x0f0f0f0f);
  x += (x >> 8);
  x += (x >> 16);
  return(x & 0x0000003f);
 }
} inline
# 66 "/usr/local/include/glm/./gtx/integer.inl" 3
                    int mod(int x, int y)
 {
  return x - y * (x / y);
 }


 template <typename genType> inline
                    genType factorial(genType const & x)
 {
  genType Temp = x;
  genType Result;
  for(Result = 1; Temp > 1; --Temp)
   Result *= Temp;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> factorial(
  tvec2<T, P> const & x)
 {
  return tvec2<T, P>(
   factorial(x.x),
   factorial(x.y));
 }

 template <typename T, precision P> inline
                    tvec3<T, P> factorial(
  tvec3<T, P> const & x)
 {
  return tvec3<T, P>(
   factorial(x.x),
   factorial(x.y),
   factorial(x.z));
 }

 template <typename T, precision P> inline
                    tvec4<T, P> factorial(
  tvec4<T, P> const & x)
 {
  return tvec4<T, P>(
   factorial(x.x),
   factorial(x.y),
   factorial(x.z),
   factorial(x.w));
 } inline

                    uint pow(uint x, uint y)
 {
  uint result = x;
  for(uint i = 1; i < y; ++i)
   result *= x;
  return result;
 } inline

                    uint sqrt(uint x)
 {
  if(x <= 1) return x;

  uint NextTrial = x >> 1;
  uint CurrentAnswer;

  do
  {
   CurrentAnswer = NextTrial;
   NextTrial = (NextTrial + x / NextTrial) >> 1;
  } while(NextTrial < CurrentAnswer);

  return CurrentAnswer;
 } inline

                    uint mod(uint x, uint y)
 {
  return x - y * (x / y);
 } inline
# 151 "/usr/local/include/glm/./gtx/integer.inl" 3
                    unsigned int nlz(unsigned int x)
 {
  int y, m, n;

  y = -int(x >> 16);
  m = (y >> 16) & 16;
  n = 16 - m;
  x = x >> m;

  y = x - 0x100;
  m = (y >> 16) & 8;
  n = n + m;
  x = x << m;

  y = x - 0x1000;
  m = (y >> 16) & 4;
  n = n + m;
  x = x << m;

  y = x - 0x4000;
  m = (y >> 16) & 2;
  n = n + m;
  x = x << m;

  y = x >> 14;
  m = y & ~(y >> 1);
  return unsigned(n + 2 - m);
 }



}
# 72 "/usr/local/include/glm/./gtx/integer.hpp" 2 3
# 78 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/intersect.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/intersect.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 1 3
# 24 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 3
namespace glm
{





 template <typename T, precision P, template <typename, precision> class vecType>
               bool areCollinear(vecType<T, P> const & v0, vecType<T, P> const & v1, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool areOrthogonal(vecType<T, P> const & v0, vecType<T, P> const & v1, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool isNormalized(vecType<T, P> const & v, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool isNull(vecType<T, P> const & v, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<bool, P> isCompNull(vecType<T, P> const & v, T const & epsilon);



 template <typename T, precision P, template <typename, precision> class vecType>
               bool areOrthonormal(vecType<T, P> const & v0, vecType<T, P> const & v1, T const & epsilon);


}


# 1 "/usr/local/include/glm/./gtx/vector_query.inl" 1 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 4 "/usr/local/include/glm/./gtx/vector_query.inl" 2 3


namespace glm{
namespace detail
{
 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_areCollinear{};

 template <typename T, precision P>
 struct compute_areCollinear<T, P, tvec2>
 { inline
                     static bool call(tvec2<T, P> const & v0, tvec2<T, P> const & v1, T const & epsilon)
  {
   return length(cross(tvec3<T, P>(v0, static_cast<T>(0)), tvec3<T, P>(v1, static_cast<T>(0)))) < epsilon;
  }
 };

 template <typename T, precision P>
 struct compute_areCollinear<T, P, tvec3>
 { inline
                     static bool call(tvec3<T, P> const & v0, tvec3<T, P> const & v1, T const & epsilon)
  {
   return length(cross(v0, v1)) < epsilon;
  }
 };

 template <typename T, precision P>
 struct compute_areCollinear<T, P, tvec4>
 { inline
                     static bool call(tvec4<T, P> const & v0, tvec4<T, P> const & v1, T const & epsilon)
  {
   return length(cross(tvec3<T, P>(v0), tvec3<T, P>(v1))) < epsilon;
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct compute_isCompNull{};

 template <typename T, precision P>
 struct compute_isCompNull<T, P, tvec2>
 { inline
                     static tvec2<bool, P> call(tvec2<T, P> const & v, T const & epsilon)
  {
   return tvec2<bool, P>(
    (abs(v.x) < epsilon),
    (abs(v.y) < epsilon));
  }
 };

 template <typename T, precision P>
 struct compute_isCompNull<T, P, tvec3>
 { inline
                     static tvec3<bool, P> call(tvec3<T, P> const & v, T const & epsilon)
  {
   return tvec3<bool, P>(
    (abs(v.x) < epsilon),
    (abs(v.y) < epsilon),
    (abs(v.z) < epsilon));
  }
 };

 template <typename T, precision P>
 struct compute_isCompNull<T, P, tvec4>
 { inline
                     static tvec4<bool, P> call(tvec4<T, P> const & v, T const & epsilon)
  {
   return tvec4<bool, P>(
    (abs(v.x) < epsilon),
    (abs(v.y) < epsilon),
    (abs(v.z) < epsilon),
    (abs(v.w) < epsilon));
  }
 };

}

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool areCollinear
 (
  vecType<T, P> const & v0,
  vecType<T, P> const & v1,
  T const & epsilon
 )
 {
                                                                                                          ;

  return detail::compute_areCollinear<T, P, vecType>::call(v0, v1, epsilon);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool areOrthogonal
 (
  vecType<T, P> const & v0,
  vecType<T, P> const & v1,
  T const & epsilon
 )
 {
                                                                                                           ;

  return abs(dot(v0, v1)) <= max(
   static_cast<T>(1),
   length(v0)) * max(static_cast<T>(1), length(v1)) * epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool isNormalized
 (
  vecType<T, P> const & v,
  T const & epsilon
 )
 {
                                                                                                          ;

  return abs(length(v) - static_cast<T>(1)) <= static_cast<T>(2) * epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool isNull
 (
  vecType<T, P> const & v,
  T const & epsilon
 )
 {
                                                                                                    ;

  return length(v) <= epsilon;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<bool, P> isCompNull
 (
  vecType<T, P> const & v,
  T const & epsilon
 )
 {
                                                                                                        ;

  return detail::compute_isCompNull<T, P, vecType>::call(v, epsilon);
 }

 template <typename T, precision P> inline
                    tvec2<bool, P> isCompNull
 (
  tvec2<T, P> const & v,
  T const & epsilon)
 {
  return tvec2<bool, P>(
   abs(v.x) < epsilon,
   abs(v.y) < epsilon);
 }

 template <typename T, precision P> inline
                    tvec3<bool, P> isCompNull
 (
  tvec3<T, P> const & v,
  T const & epsilon
 )
 {
  return tvec3<bool, P>(
   abs(v.x) < epsilon,
   abs(v.y) < epsilon,
   abs(v.z) < epsilon);
 }

 template <typename T, precision P> inline
                    tvec4<bool, P> isCompNull
 (
  tvec4<T, P> const & v,
  T const & epsilon
 )
 {
  return tvec4<bool, P>(
   abs(v.x) < epsilon,
   abs(v.y) < epsilon,
   abs(v.z) < epsilon,
   abs(v.w) < epsilon);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    bool areOrthonormal
 (
  vecType<T, P> const & v0,
  vecType<T, P> const & v1,
  T const & epsilon
 )
 {
  return isNormalized(v0, epsilon) && isNormalized(v1, epsilon) && (abs(dot(v0, v1)) <= epsilon);
 }

}
# 62 "/usr/local/include/glm/./gtx/../gtx/vector_query.hpp" 2 3
# 22 "/usr/local/include/glm/./gtx/intersect.hpp" 2 3






namespace glm
{






 template <typename genType>
               bool intersectRayPlane(
  genType const & orig, genType const & dir,
  genType const & planeOrig, genType const & planeNormal,
  typename genType::value_type & intersectionDistance);



 template <typename genType>
               bool intersectRayTriangle(
  genType const & orig, genType const & dir,
  genType const & vert0, genType const & vert1, genType const & vert2,
  genType & baryPosition);



 template <typename genType>
               bool intersectLineTriangle(
  genType const & orig, genType const & dir,
  genType const & vert0, genType const & vert1, genType const & vert2,
  genType & position);




 template <typename genType>
               bool intersectRaySphere(
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, typename genType::value_type const sphereRadiusSquered,
  typename genType::value_type & intersectionDistance);



 template <typename genType>
               bool intersectRaySphere(
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, const typename genType::value_type sphereRadius,
  genType & intersectionPosition, genType & intersectionNormal);



 template <typename genType>
               bool intersectLineSphere(
  genType const & point0, genType const & point1,
  genType const & sphereCenter, typename genType::value_type sphereRadius,
  genType & intersectionPosition1, genType & intersectionNormal1,
  genType & intersectionPosition2 = genType(), genType & intersectionNormal2 = genType());


}


# 1 "/usr/local/include/glm/./gtx/intersect.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    bool intersectRayPlane
 (
  genType const & orig, genType const & dir,
  genType const & planeOrig, genType const & planeNormal,
  typename genType::value_type & intersectionDistance
 )
 {
  typename genType::value_type d = glm::dot(dir, planeNormal);
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();

  if(d < -Epsilon)
  {
   intersectionDistance = glm::dot(planeOrig - orig, planeNormal) / d;
   return true;
  }

  return false;
 }

 template <typename genType> inline
                    bool intersectRayTriangle
 (
  genType const & orig, genType const & dir,
  genType const & v0, genType const & v1, genType const & v2,
  genType & baryPosition
 )
 {
  genType e1 = v1 - v0;
  genType e2 = v2 - v0;

  genType p = glm::cross(dir, e2);

  typename genType::value_type a = glm::dot(e1, p);

  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
  if(a < Epsilon && a > -Epsilon)
   return false;

  typename genType::value_type f = typename genType::value_type(1.0f) / a;

  genType s = orig - v0;
  baryPosition.x = f * glm::dot(s, p);
  if(baryPosition.x < typename genType::value_type(0.0f))
   return false;
  if(baryPosition.x > typename genType::value_type(1.0f))
   return false;

  genType q = glm::cross(s, e1);
  baryPosition.y = f * glm::dot(dir, q);
  if(baryPosition.y < typename genType::value_type(0.0f))
   return false;
  if(baryPosition.y + baryPosition.x > typename genType::value_type(1.0f))
   return false;

  baryPosition.z = f * glm::dot(e2, q);

  return baryPosition.z >= typename genType::value_type(0.0f);
 }

 template <typename genType> inline
                    bool intersectLineTriangle
 (
  genType const & orig, genType const & dir,
  genType const & vert0, genType const & vert1, genType const & vert2,
  genType & position
 )
 {
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();

  genType edge1 = vert1 - vert0;
  genType edge2 = vert2 - vert0;

  genType pvec = cross(dir, edge2);

  float det = dot(edge1, pvec);

  if (det > -Epsilon && det < Epsilon)
   return false;
  float inv_det = typename genType::value_type(1) / det;

  genType tvec = orig - vert0;

  position.y = dot(tvec, pvec) * inv_det;
  if (position.y < typename genType::value_type(0) || position.y > typename genType::value_type(1))
   return false;

  genType qvec = cross(tvec, edge1);

  position.z = dot(dir, qvec) * inv_det;
  if (position.z < typename genType::value_type(0) || position.y + position.z > typename genType::value_type(1))
   return false;

  position.x = dot(edge2, qvec) * inv_det;

  return true;
 }

 template <typename genType> inline
                    bool intersectRaySphere
 (
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, const typename genType::value_type sphereRadiusSquered,
  typename genType::value_type & intersectionDistance
 )
 {
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
  genType diff = sphereCenter - rayStarting;
  typename genType::value_type t0 = dot(diff, rayNormalizedDirection);
  typename genType::value_type dSquared = dot(diff, diff) - t0 * t0;
  if( dSquared > sphereRadiusSquered )
  {
   return false;
  }
  typename genType::value_type t1 = sqrt( sphereRadiusSquered - dSquared );
  intersectionDistance = t0 > t1 + Epsilon ? t0 - t1 : t0 + t1;
  return intersectionDistance > Epsilon;
 }

 template <typename genType> inline
                    bool intersectRaySphere
 (
  genType const & rayStarting, genType const & rayNormalizedDirection,
  genType const & sphereCenter, const typename genType::value_type sphereRadius,
  genType & intersectionPosition, genType & intersectionNormal
 )
 {
  typename genType::value_type distance;
  if( intersectRaySphere( rayStarting, rayNormalizedDirection, sphereCenter, sphereRadius * sphereRadius, distance ) )
  {
   intersectionPosition = rayStarting + rayNormalizedDirection * distance;
   intersectionNormal = (intersectionPosition - sphereCenter) / sphereRadius;
   return true;
  }
  return false;
 }

 template <typename genType> inline
                    bool intersectLineSphere
 (
  genType const & point0, genType const & point1,
  genType const & sphereCenter, typename genType::value_type sphereRadius,
  genType & intersectionPoint1, genType & intersectionNormal1,
  genType & intersectionPoint2, genType & intersectionNormal2
 )
 {
  typename genType::value_type Epsilon = std::numeric_limits<typename genType::value_type>::epsilon();
  genType dir = normalize(point1 - point0);
  genType diff = sphereCenter - point0;
  typename genType::value_type t0 = dot(diff, dir);
  typename genType::value_type dSquared = dot(diff, diff) - t0 * t0;
  if( dSquared > sphereRadius * sphereRadius )
  {
   return false;
  }
  typename genType::value_type t1 = sqrt( sphereRadius * sphereRadius - dSquared );
  if( t0 < t1 + Epsilon )
   t1 = -t1;
  intersectionPoint1 = point0 + dir * (t0 - t1);
  intersectionNormal1 = (intersectionPoint1 - sphereCenter) / sphereRadius;
  intersectionPoint2 = point0 + dir * (t0 + t1);
  intersectionNormal2 = (intersectionPoint2 - sphereCenter) / sphereRadius;
  return true;
 }
}
# 87 "/usr/local/include/glm/./gtx/intersect.hpp" 2 3
# 79 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/log_base.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/log_base.hpp" 3
namespace glm
{





 template <typename genType>
               genType log(
  genType const & x,
  genType const & base);



 template <typename T, precision P, template <typename, precision> class vecType>
               vecType<T, P> sign(
  vecType<T, P> const & x,
  vecType<T, P> const & base);


}


# 1 "/usr/local/include/glm/./gtx/log_base.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType log(genType const & x, genType const & base)
 {
  (__builtin_expect(!(x != genType(0)), 0) ? __assert_rtn(__func__, "/usr/local/include/glm/./gtx/log_base.inl", 9, "x != genType(0)") : (void)0);
  return glm::log(x) / glm::log(base);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> log(vecType<T, P> const & x, vecType<T, P> const & base)
 {
  return glm::log(x) / glm::log(base);
 }
}
# 44 "/usr/local/include/glm/./gtx/log_base.hpp" 2 3
# 80 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat3x3<T, P> matrixCross3(
  tvec3<T, P> const & x);



 template <typename T, precision P>
               tmat4x4<T, P> matrixCross4(
  tvec3<T, P> const & x);


}


# 1 "/usr/local/include/glm/./gtx/matrix_cross_product.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> matrixCross3
 (
  tvec3<T, P> const & x
 )
 {
  tmat3x3<T, P> Result(T(0));
  Result[0][1] = x.z;
  Result[1][0] = -x.z;
  Result[0][2] = -x.y;
  Result[2][0] = x.y;
  Result[1][2] = x.x;
  Result[2][1] = -x.x;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> matrixCross4
 (
  tvec3<T, P> const & x
 )
 {
  tmat4x4<T, P> Result(T(0));
  Result[0][1] = x.z;
  Result[1][0] = -x.z;
  Result[0][2] = -x.y;
  Result[2][0] = x.y;
  Result[1][2] = x.x;
  Result[2][1] = -x.x;
  return Result;
 }

}
# 43 "/usr/local/include/glm/./gtx/matrix_cross_product.hpp" 2 3
# 81 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 3
namespace glm
{





 template <typename T, precision P>
               void axisAngle(
  tmat4x4<T, P> const & mat,
  tvec3<T, P> & axis,
  T & angle);



 template <typename T, precision P>
               tmat4x4<T, P> axisAngleMatrix(
  tvec3<T, P> const & axis,
  T const angle);



 template <typename T, precision P>
               tmat4x4<T, P> extractMatrixRotation(
  tmat4x4<T, P> const & mat);




 template <typename T, precision P>
               tmat4x4<T, P> interpolate(
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2,
  T const delta);


}


# 1 "/usr/local/include/glm/./gtx/matrix_interpolation.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    void axisAngle
 (
  tmat4x4<T, P> const & mat,
  tvec3<T, P> & axis,
  T & angle
 )
 {
  T epsilon = (T)0.01;
  T epsilon2 = (T)0.1;

  if((abs(mat[1][0] - mat[0][1]) < epsilon) && (abs(mat[2][0] - mat[0][2]) < epsilon) && (abs(mat[2][1] - mat[1][2]) < epsilon))
  {
   if ((abs(mat[1][0] + mat[0][1]) < epsilon2) && (abs(mat[2][0] + mat[0][2]) < epsilon2) && (abs(mat[2][1] + mat[1][2]) < epsilon2) && (abs(mat[0][0] + mat[1][1] + mat[2][2] - (T)3.0) < epsilon2))
   {
    angle = (T)0.0;
    axis.x = (T)1.0;
    axis.y = (T)0.0;
    axis.z = (T)0.0;
    return;
   }
   angle = static_cast<T>(3.1415926535897932384626433832795);
   T xx = (mat[0][0] + (T)1.0) / (T)2.0;
   T yy = (mat[1][1] + (T)1.0) / (T)2.0;
   T zz = (mat[2][2] + (T)1.0) / (T)2.0;
   T xy = (mat[1][0] + mat[0][1]) / (T)4.0;
   T xz = (mat[2][0] + mat[0][2]) / (T)4.0;
   T yz = (mat[2][1] + mat[1][2]) / (T)4.0;
   if((xx > yy) && (xx > zz))
   {
    if (xx < epsilon) {
     axis.x = (T)0.0;
     axis.y = (T)0.7071;
     axis.z = (T)0.7071;
    } else {
     axis.x = sqrt(xx);
     axis.y = xy / axis.x;
     axis.z = xz / axis.x;
    }
   }
   else if (yy > zz)
   {
    if (yy < epsilon) {
     axis.x = (T)0.7071;
     axis.y = (T)0.0;
     axis.z = (T)0.7071;
    } else {
     axis.y = sqrt(yy);
     axis.x = xy / axis.y;
     axis.z = yz / axis.y;
    }
   }
   else
   {
    if (zz < epsilon) {
     axis.x = (T)0.7071;
     axis.y = (T)0.7071;
     axis.z = (T)0.0;
    } else {
     axis.z = sqrt(zz);
     axis.x = xz / axis.z;
     axis.y = yz / axis.z;
    }
   }
   return;
  }
  T s = sqrt((mat[2][1] - mat[1][2]) * (mat[2][1] - mat[1][2]) + (mat[2][0] - mat[0][2]) * (mat[2][0] - mat[0][2]) + (mat[1][0] - mat[0][1]) * (mat[1][0] - mat[0][1]));
  if (glm::abs(s) < T(0.001))
   s = (T)1.0;
  angle = acos((mat[0][0] + mat[1][1] + mat[2][2] - (T)1.0) / (T)2.0);
  axis.x = (mat[1][2] - mat[2][1]) / s;
  axis.y = (mat[2][0] - mat[0][2]) / s;
  axis.z = (mat[0][1] - mat[1][0]) / s;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> axisAngleMatrix
 (
  tvec3<T, P> const & axis,
  T const angle
 )
 {
  T c = cos(angle);
  T s = sin(angle);
  T t = static_cast<T>(1) - c;
  tvec3<T, P> n = normalize(axis);

  return tmat4x4<T, P>(
   t * n.x * n.x + c, t * n.x * n.y + n.z * s, t * n.x * n.z - n.y * s, T(0),
   t * n.x * n.y - n.z * s, t * n.y * n.y + c, t * n.y * n.z + n.x * s, T(0),
   t * n.x * n.z + n.y * s, t * n.y * n.z - n.x * s, t * n.z * n.z + c, T(0),
   T(0), T(0), T(0), T(1)
  );
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> extractMatrixRotation
 (
  tmat4x4<T, P> const & mat
 )
 {
  return tmat4x4<T, P>(
   mat[0][0], mat[0][1], mat[0][2], 0.0,
   mat[1][0], mat[1][1], mat[1][2], 0.0,
   mat[2][0], mat[2][1], mat[2][2], 0.0,
   0.0, 0.0, 0.0, 1.0
  );
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> interpolate
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2,
  T const delta
 )
 {
  tmat4x4<T, P> m1rot = extractMatrixRotation(m1);
  tmat4x4<T, P> dltRotation = m2 * transpose(m1rot);
  tvec3<T, P> dltAxis;
  T dltAngle;
  axisAngle(dltRotation, dltAxis, dltAngle);
  tmat4x4<T, P> out = axisAngleMatrix(dltAxis, dltAngle * delta) * m1rot;
  out[3][0] = m1[3][0] + delta * (m2[3][0] - m1[3][0]);
  out[3][1] = m1[3][1] + delta * (m2[3][1] - m1[3][1]);
  out[3][2] = m1[3][2] + delta * (m2[3][2] - m1[3][2]);
  return out;
 }
}
# 61 "/usr/local/include/glm/./gtx/matrix_interpolation.hpp" 2 3
# 82 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat2x2<T, P> rowMajor2(
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2);



 template <typename T, precision P>
               tmat2x2<T, P> rowMajor2(
  tmat2x2<T, P> const & m);



 template <typename T, precision P>
               tmat3x3<T, P> rowMajor3(
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3);



 template <typename T, precision P>
               tmat3x3<T, P> rowMajor3(
  tmat3x3<T, P> const & m);



 template <typename T, precision P>
               tmat4x4<T, P> rowMajor4(
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2,
  tvec4<T, P> const & v3,
  tvec4<T, P> const & v4);



 template <typename T, precision P>
               tmat4x4<T, P> rowMajor4(
  tmat4x4<T, P> const & m);



 template <typename T, precision P>
               tmat2x2<T, P> colMajor2(
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2);



 template <typename T, precision P>
               tmat2x2<T, P> colMajor2(
  tmat2x2<T, P> const & m);



 template <typename T, precision P>
               tmat3x3<T, P> colMajor3(
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3);



 template <typename T, precision P>
               tmat3x3<T, P> colMajor3(
  tmat3x3<T, P> const & m);



 template <typename T, precision P>
               tmat4x4<T, P> colMajor4(
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2,
  tvec4<T, P> const & v3,
  tvec4<T, P> const & v4);



 template <typename T, precision P>
               tmat4x4<T, P> colMajor4(
  tmat4x4<T, P> const & m);


}


# 1 "/usr/local/include/glm/./gtx/matrix_major_storage.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat2x2<T, P> rowMajor2
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  tmat2x2<T, P> Result;
  Result[0][0] = v1.x;
  Result[1][0] = v1.y;
  Result[0][1] = v2.x;
  Result[1][1] = v2.y;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> rowMajor2(
  const tmat2x2<T, P>& m)
 {
  tmat2x2<T, P> Result;
  Result[0][0] = m[0][0];
  Result[0][1] = m[1][0];
  Result[1][0] = m[0][1];
  Result[1][1] = m[1][1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> rowMajor3(
  const tvec3<T, P>& v1,
  const tvec3<T, P>& v2,
  const tvec3<T, P>& v3)
 {
  tmat3x3<T, P> Result;
  Result[0][0] = v1.x;
  Result[1][0] = v1.y;
  Result[2][0] = v1.z;
  Result[0][1] = v2.x;
  Result[1][1] = v2.y;
  Result[2][1] = v2.z;
  Result[0][2] = v3.x;
  Result[1][2] = v3.y;
  Result[2][2] = v3.z;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> rowMajor3(
  const tmat3x3<T, P>& m)
 {
  tmat3x3<T, P> Result;
  Result[0][0] = m[0][0];
  Result[0][1] = m[1][0];
  Result[0][2] = m[2][0];
  Result[1][0] = m[0][1];
  Result[1][1] = m[1][1];
  Result[1][2] = m[2][1];
  Result[2][0] = m[0][2];
  Result[2][1] = m[1][2];
  Result[2][2] = m[2][2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rowMajor4(
  const tvec4<T, P>& v1,
  const tvec4<T, P>& v2,
  const tvec4<T, P>& v3,
  const tvec4<T, P>& v4)
 {
  tmat4x4<T, P> Result;
  Result[0][0] = v1.x;
  Result[1][0] = v1.y;
  Result[2][0] = v1.z;
  Result[3][0] = v1.w;
  Result[0][1] = v2.x;
  Result[1][1] = v2.y;
  Result[2][1] = v2.z;
  Result[3][1] = v2.w;
  Result[0][2] = v3.x;
  Result[1][2] = v3.y;
  Result[2][2] = v3.z;
  Result[3][2] = v3.w;
  Result[0][3] = v4.x;
  Result[1][3] = v4.y;
  Result[2][3] = v4.z;
  Result[3][3] = v4.w;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rowMajor4(
  const tmat4x4<T, P>& m)
 {
  tmat4x4<T, P> Result;
  Result[0][0] = m[0][0];
  Result[0][1] = m[1][0];
  Result[0][2] = m[2][0];
  Result[0][3] = m[3][0];
  Result[1][0] = m[0][1];
  Result[1][1] = m[1][1];
  Result[1][2] = m[2][1];
  Result[1][3] = m[3][1];
  Result[2][0] = m[0][2];
  Result[2][1] = m[1][2];
  Result[2][2] = m[2][2];
  Result[2][3] = m[3][2];
  Result[3][0] = m[0][3];
  Result[3][1] = m[1][3];
  Result[3][2] = m[2][3];
  Result[3][3] = m[3][3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> colMajor2(
  const tvec2<T, P>& v1,
  const tvec2<T, P>& v2)
 {
  return tmat2x2<T, P>(v1, v2);
 }

 template <typename T, precision P> inline
                    tmat2x2<T, P> colMajor2(
  const tmat2x2<T, P>& m)
 {
  return tmat2x2<T, P>(m);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> colMajor3(
  const tvec3<T, P>& v1,
  const tvec3<T, P>& v2,
  const tvec3<T, P>& v3)
 {
  return tmat3x3<T, P>(v1, v2, v3);
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> colMajor3(
  const tmat3x3<T, P>& m)
 {
  return tmat3x3<T, P>(m);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> colMajor4(
  const tvec4<T, P>& v1,
  const tvec4<T, P>& v2,
  const tvec4<T, P>& v3,
  const tvec4<T, P>& v4)
 {
  return tmat4x4<T, P>(v1, v2, v3, v4);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> colMajor4(
  const tmat4x4<T, P>& m)
 {
  return tmat4x4<T, P>(m);
 }
}
# 115 "/usr/local/include/glm/./gtx/matrix_major_storage.hpp" 2 3
# 83 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat2x2<T, P> diagonal2x2(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat2x3<T, P> diagonal2x3(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat2x4<T, P> diagonal2x4(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat3x2<T, P> diagonal3x2(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat3x3<T, P> diagonal3x3(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               tmat3x4<T, P> diagonal3x4(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               tmat4x2<T, P> diagonal4x2(
  tvec2<T, P> const & v);



 template <typename T, precision P>
               tmat4x3<T, P> diagonal4x3(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               tmat4x4<T, P> diagonal4x4(
  tvec4<T, P> const & v);


}


# 1 "/usr/local/include/glm/./gtx/matrix_operation.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat2x2<T, P> diagonal2x2
 (
  tvec2<T, P> const & v
 )
 {
  tmat2x2<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x3<T, P> diagonal2x3
 (
  tvec2<T, P> const & v
 )
 {
  tmat2x3<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat2x4<T, P> diagonal2x4
 (
  tvec2<T, P> const & v
 )
 {
  tmat2x4<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x2<T, P> diagonal3x2
 (
  tvec2<T, P> const & v
 )
 {
  tmat3x2<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> diagonal3x3
 (
  tvec3<T, P> const & v
 )
 {
  tmat3x3<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat3x4<T, P> diagonal3x4
 (
  tvec3<T, P> const & v
 )
 {
  tmat3x4<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> diagonal4x4
 (
  tvec4<T, P> const & v
 )
 {
  tmat4x4<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  Result[3][3] = v[3];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x3<T, P> diagonal4x3
 (
  tvec3<T, P> const & v
 )
 {
  tmat4x3<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  Result[2][2] = v[2];
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x2<T, P> diagonal4x2
 (
  tvec2<T, P> const & v
 )
 {
  tmat4x2<T, P> Result(static_cast<T>(1));
  Result[0][0] = v[0];
  Result[1][1] = v[1];
  return Result;
 }
}
# 84 "/usr/local/include/glm/./gtx/matrix_operation.hpp" 2 3
# 84 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/matrix_query.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/matrix_query.hpp" 3
namespace glm
{





 template<typename T, precision P>
               bool isNull(tmat2x2<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNull(tmat3x3<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNull(tmat4x4<T, P> const & m, T const & epsilon);



 template<typename T, precision P, template <typename, precision> class matType>
               bool isIdentity(matType<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNormalized(tmat2x2<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNormalized(tmat3x3<T, P> const & m, T const & epsilon);



 template<typename T, precision P>
               bool isNormalized(tmat4x4<T, P> const & m, T const & epsilon);



 template<typename T, precision P, template <typename, precision> class matType>
               bool isOrthogonal(matType<T, P> const & m, T const & epsilon);


}


# 1 "/usr/local/include/glm/./gtx/matrix_query.inl" 1 3



namespace glm
{
 template<typename T, precision P> inline
                    bool isNull(tmat2x2<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m.length() ; ++i)
   result = isNull(m[i], epsilon);
  return result;
 }

 template<typename T, precision P> inline
                    bool isNull(tmat3x3<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m.length() ; ++i)
   result = isNull(m[i], epsilon);
  return result;
 }

 template<typename T, precision P> inline
                    bool isNull(tmat4x4<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m.length() ; ++i)
   result = isNull(m[i], epsilon);
  return result;
 }

 template<typename T, precision P, template <typename, precision> class matType> inline
                    bool isIdentity(matType<T, P> const & m, T const & epsilon)
 {
  bool result = true;
  for(length_t i = 0; result && i < m[0].length() ; ++i)
  {
   for(length_t j = 0; result && j < i ; ++j)
    result = abs(m[i][j]) <= epsilon;
   if(result)
    result = abs(m[i][i] - 1) <= epsilon;
   for(length_t j = i + 1; result && j < m.length(); ++j)
    result = abs(m[i][j]) <= epsilon;
  }
  return result;
 }

 template<typename T, precision P> inline
                    bool isNormalized(tmat2x2<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i = 0; result && i < m.length(); ++i)
   result = isNormalized(m[i], epsilon);
  for(length_t i = 0; result && i < m.length(); ++i)
  {
   typename tmat2x2<T, P>::col_type v;
   for(length_t j = 0; j < m.length(); ++j)
    v[j] = m[j][i];
   result = isNormalized(v, epsilon);
  }
  return result;
 }

 template<typename T, precision P> inline
                    bool isNormalized(tmat3x3<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i = 0; result && i < m.length(); ++i)
   result = isNormalized(m[i], epsilon);
  for(length_t i = 0; result && i < m.length(); ++i)
  {
   typename tmat3x3<T, P>::col_type v;
   for(length_t j = 0; j < m.length(); ++j)
    v[j] = m[j][i];
   result = isNormalized(v, epsilon);
  }
  return result;
 }

 template<typename T, precision P> inline
                    bool isNormalized(tmat4x4<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i = 0; result && i < m.length(); ++i)
   result = isNormalized(m[i], epsilon);
  for(length_t i = 0; result && i < m.length(); ++i)
  {
   typename tmat4x4<T, P>::col_type v;
   for(length_t j = 0; j < m.length(); ++j)
    v[j] = m[j][i];
   result = isNormalized(v, epsilon);
  }
  return result;
 }

 template<typename T, precision P, template <typename, precision> class matType> inline
                    bool isOrthogonal(matType<T, P> const & m, T const & epsilon)
 {
  bool result(true);
  for(length_t i(0); result && i < m.length() - 1; ++i)
  for(length_t j(i + 1); result && j < m.length(); ++j)
   result = areOrthogonal(m[i], m[j], epsilon);

  if(result)
  {
   matType<T, P> tmp = transpose(m);
   for(length_t i(0); result && i < m.length() - 1 ; ++i)
   for(length_t j(i + 1); result && j < m.length(); ++j)
    result = areOrthogonal(tmp[i], tmp[j], epsilon);
  }
  return result;
 }
}
# 73 "/usr/local/include/glm/./gtx/matrix_query.hpp" 2 3
# 85 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/mixed_product.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/mixed_product.hpp" 3
namespace glm
{




 template <typename T, precision P>
               T mixedProduct(
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3);


}


# 1 "/usr/local/include/glm/./gtx/mixed_product.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    T mixedProduct
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2,
  tvec3<T, P> const & v3
 )
 {
  return dot(cross(v1, v2), v3);
 }
}
# 37 "/usr/local/include/glm/./gtx/mixed_product.hpp" 2 3
# 86 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/norm.hpp" 1 3
# 18 "/usr/local/include/glm/./gtx/norm.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 1 3
# 26 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 3
namespace glm
{






 template<typename T, precision P>
               tvec3<T, P> cross(
  tquat<T, P> const & q,
  tvec3<T, P> const & v);




 template<typename T, precision P>
               tvec3<T, P> cross(
  tvec3<T, P> const & v,
  tquat<T, P> const & q);





 template<typename T, precision P>
               tquat<T, P> squad(
  tquat<T, P> const & q1,
  tquat<T, P> const & q2,
  tquat<T, P> const & s1,
  tquat<T, P> const & s2,
  T const & h);




 template<typename T, precision P>
               tquat<T, P> intermediate(
  tquat<T, P> const & prev,
  tquat<T, P> const & curr,
  tquat<T, P> const & next);




 template<typename T, precision P>
               tquat<T, P> exp(
  tquat<T, P> const & q);




 template<typename T, precision P>
               tquat<T, P> log(
  tquat<T, P> const & q);




 template<typename T, precision P>
               tquat<T, P> pow(
  tquat<T, P> const & x,
  T const & y);
# 100 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 3
 template<typename T, precision P>
               tvec3<T, P> rotate(
  tquat<T, P> const & q,
  tvec3<T, P> const & v);




 template<typename T, precision P>
               tvec4<T, P> rotate(
  tquat<T, P> const & q,
  tvec4<T, P> const & v);




 template<typename T, precision P>
               T extractRealComponent(
  tquat<T, P> const & q);




 template<typename T, precision P>
               tmat3x3<T, P> toMat3(
  tquat<T, P> const & x){return mat3_cast(x);}




 template<typename T, precision P>
               tmat4x4<T, P> toMat4(
  tquat<T, P> const & x){return mat4_cast(x);}




 template<typename T, precision P>
               tquat<T, P> toQuat(
  tmat3x3<T, P> const & x){return quat_cast(x);}




 template<typename T, precision P>
               tquat<T, P> toQuat(
  tmat4x4<T, P> const & x){return quat_cast(x);}




 template<typename T, precision P>
               tquat<T, P> shortMix(
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & a);




 template<typename T, precision P>
               tquat<T, P> fastMix(
  tquat<T, P> const & x,
  tquat<T, P> const & y,
  T const & a);






 template<typename T, precision P>
               tquat<T, P> rotation(
  tvec3<T, P> const & orig,
  tvec3<T, P> const & dest);




 template<typename T, precision P>
               T length2(tquat<T, P> const & q);


}


# 1 "/usr/local/include/glm/./gtx/quaternion.inl" 1 3






namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> cross(tvec3<T, P> const& v, tquat<T, P> const& q)
 {
  return inverse(q) * v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> cross(tquat<T, P> const& q, tvec3<T, P> const& v)
 {
  return q * v;
 }

 template <typename T, precision P> inline
                    tquat<T, P> squad
 (
  tquat<T, P> const & q1,
  tquat<T, P> const & q2,
  tquat<T, P> const & s1,
  tquat<T, P> const & s2,
  T const & h)
 {
  return mix(mix(q1, q2, h), mix(s1, s2, h), static_cast<T>(2) * (static_cast<T>(1) - h) * h);
 }

 template <typename T, precision P> inline
                    tquat<T, P> intermediate
 (
  tquat<T, P> const & prev,
  tquat<T, P> const & curr,
  tquat<T, P> const & next
 )
 {
  tquat<T, P> invQuat = inverse(curr);
  return exp((log(next + invQuat) + log(prev + invQuat)) / static_cast<T>(-4)) * curr;
 }

 template <typename T, precision P> inline
                    tquat<T, P> exp(tquat<T, P> const& q)
 {
  tvec3<T, P> u(q.x, q.y, q.z);
  T const Angle = glm::length(u);
  if (Angle < epsilon<T>())
   return tquat<T, P>();

  tvec3<T, P> const v(u / Angle);
  return tquat<T, P>(cos(Angle), sin(Angle) * v);
 }

 template <typename T, precision P> inline
                    tquat<T, P> log(tquat<T, P> const& q)
 {
  tvec3<T, P> u(q.x, q.y, q.z);
  T Vec3Len = length(u);

  if (Vec3Len < epsilon<T>())
  {
   if(q.w > static_cast<T>(0))
    return tquat<T, P>(log(q.w), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
   else if(q.w < static_cast<T>(0))
    return tquat<T, P>(log(-q.w), pi<T>(), static_cast<T>(0), static_cast<T>(0));
   else
    return tquat<T, P>(std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity());
  }
  else
  {
   T t = atan(Vec3Len, T(q.w)) / Vec3Len;
   T QuatLen2 = Vec3Len * Vec3Len + q.w * q.w;
   return tquat<T, P>(static_cast<T>(0.5) * log(QuatLen2), t * q.x, t * q.y, t * q.z);
  }
 }

 template <typename T, precision P> inline
                    tquat<T, P> pow(tquat<T, P> const & x, T const & y)
 {


  if(y > -epsilon<T>() && y < epsilon<T>())
   return tquat<T, P>(1,0,0,0);


  T magnitude = sqrt(x.x * x.x + x.y * x.y + x.z * x.z + x.w *x.w);



  if(abs(x.w / magnitude) > static_cast<T>(1) - epsilon<T>() && abs(x.w / magnitude) < static_cast<T>(1) + epsilon<T>())
   return tquat<T, P>(pow(x.w, y),0,0,0);

  T Angle = acos(x.w / magnitude);
  T NewAngle = Angle * y;
  T Div = sin(NewAngle) / sin(Angle);
  T Mag = pow(magnitude, y - static_cast<T>(1));

  return tquat<T, P>(cos(NewAngle) * magnitude * Mag, x.x * Div * Mag, x.y * Div * Mag, x.z * Div * Mag);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotate(tquat<T, P> const& q, tvec3<T, P> const& v)
 {
  return q * v;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotate(tquat<T, P> const& q, tvec4<T, P> const& v)
 {
  return q * v;
 }

 template <typename T, precision P> inline
                    T extractRealComponent(tquat<T, P> const& q)
 {
  T w = static_cast<T>(1) - q.x * q.x - q.y * q.y - q.z * q.z;
  if(w < T(0))
   return T(0);
  else
   return -sqrt(w);
 }

 template <typename T, precision P> inline
                    T length2(tquat<T, P> const& q)
 {
  return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
 }

 template <typename T, precision P> inline
                    tquat<T, P> shortMix(tquat<T, P> const& x, tquat<T, P> const& y, T const& a)
 {
  if(a <= static_cast<T>(0)) return x;
  if(a >= static_cast<T>(1)) return y;

  T fCos = dot(x, y);
  tquat<T, P> y2(y);
  if(fCos < static_cast<T>(0))
  {
   y2 = -y;
   fCos = -fCos;
  }


  T k0, k1;
  if(fCos > (static_cast<T>(1) - epsilon<T>()))
  {
   k0 = static_cast<T>(1) - a;
   k1 = static_cast<T>(0) + a;
  }
  else
  {
   T fSin = sqrt(T(1) - fCos * fCos);
   T fAngle = atan(fSin, fCos);
   T fOneOverSin = static_cast<T>(1) / fSin;
   k0 = sin((static_cast<T>(1) - a) * fAngle) * fOneOverSin;
   k1 = sin((static_cast<T>(0) + a) * fAngle) * fOneOverSin;
  }

  return tquat<T, P>(
   k0 * x.w + k1 * y2.w,
   k0 * x.x + k1 * y2.x,
   k0 * x.y + k1 * y2.y,
   k0 * x.z + k1 * y2.z);
 }

 template <typename T, precision P> inline
                    tquat<T, P> fastMix(tquat<T, P> const& x, tquat<T, P> const& y, T const & a)
 {
  return glm::normalize(x * (static_cast<T>(1) - a) + (y * a));
 }

 template <typename T, precision P> inline
                    tquat<T, P> rotation(tvec3<T, P> const& orig, tvec3<T, P> const& dest)
 {
  T cosTheta = dot(orig, dest);
  tvec3<T, P> rotationAxis;

  if(cosTheta >= static_cast<T>(1) - epsilon<T>())
   return quat();

  if(cosTheta < static_cast<T>(-1) + epsilon<T>())
  {





   rotationAxis = cross(tvec3<T, P>(0, 0, 1), orig);
   if(length2(rotationAxis) < epsilon<T>())
    rotationAxis = cross(tvec3<T, P>(1, 0, 0), orig);

   rotationAxis = normalize(rotationAxis);
   return angleAxis(pi<T>(), rotationAxis);
  }


  rotationAxis = cross(orig, dest);

  T s = sqrt((T(1) + cosTheta) * static_cast<T>(2));
  T invs = static_cast<T>(1) / s;

  return tquat<T, P>(
   s * static_cast<T>(0.5f),
   rotationAxis.x * invs,
   rotationAxis.y * invs,
   rotationAxis.z * invs);
 }

}
# 185 "/usr/local/include/glm/./gtx/../gtx/quaternion.hpp" 2 3
# 18 "/usr/local/include/glm/./gtx/norm.hpp" 2 3






namespace glm
{





 template <typename T, precision P, template <typename, precision> class vecType>
               T length2(
  vecType<T, P> const & x);



 template <typename T, precision P, template <typename, precision> class vecType>
               T distance2(
  vecType<T, P> const & p0,
  vecType<T, P> const & p1);



 template <typename T, precision P>
               T l1Norm(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y);



 template <typename T, precision P>
               T l1Norm(
  tvec3<T, P> const & v);



 template <typename T, precision P>
               T l2Norm(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y);



 template <typename T, precision P>
               T l2Norm(
  tvec3<T, P> const & x);



 template <typename T, precision P>
               T lxNorm(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  unsigned int Depth);



 template <typename T, precision P>
               T lxNorm(
  tvec3<T, P> const & x,
  unsigned int Depth);


}


# 1 "/usr/local/include/glm/./gtx/norm.inl" 1 3





namespace glm{
namespace detail
{
 template <template <typename, precision> class vecType, typename T, precision P, bool Aligned>
 struct compute_length2
 { inline
                     static T call(vecType<T, P> const & v)
  {
   return dot(v, v);
  }
 };
}

 template <typename genType> inline
                    genType length2(genType x)
 {
                                                                                                            ;
  return x * x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T length2(vecType<T, P> const & v)
 {
                                                                                                      ;
  return detail::compute_length2<vecType, T, P, detail::is_aligned<P>::value>::call(v);
 }

 template <typename T> inline
                    T distance2(T p0, T p1)
 {
                                                                                                        ;
  return length2(p1 - p0);
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T distance2(vecType<T, P> const & p0, vecType<T, P> const & p1)
 {
                                                                                                        ;
  return length2(p1 - p0);
 }

 template <typename T, precision P> inline
                    T l1Norm
 (
  tvec3<T, P> const & a,
  tvec3<T, P> const & b
 )
 {
  return abs(b.x - a.x) + abs(b.y - a.y) + abs(b.z - a.z);
 }

 template <typename T, precision P> inline
                    T l1Norm
 (
  tvec3<T, P> const & v
 )
 {
  return abs(v.x) + abs(v.y) + abs(v.z);
 }

 template <typename T, precision P> inline
                    T l2Norm
 (
  tvec3<T, P> const & a,
  tvec3<T, P> const & b
 )
 {
  return length(b - a);
 }

 template <typename T, precision P> inline
                    T l2Norm
 (
  tvec3<T, P> const & v
 )
 {
  return length(v);
 }

 template <typename T, precision P> inline
                    T lxNorm
 (
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  unsigned int Depth
 )
 {
  return pow(pow(y.x - x.x, T(Depth)) + pow(y.y - x.y, T(Depth)) + pow(y.z - x.z, T(Depth)), T(1) / T(Depth));
 }

 template <typename T, precision P> inline
                    T lxNorm
 (
  tvec3<T, P> const & v,
  unsigned int Depth
 )
 {
  return pow(pow(v.x, T(Depth)) + pow(v.y, T(Depth)) + pow(v.z, T(Depth)), T(1) / T(Depth));
 }

}
# 86 "/usr/local/include/glm/./gtx/norm.hpp" 2 3
# 87 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/normal.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/normal.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tvec3<T, P> triangleNormal(
  tvec3<T, P> const & p1,
  tvec3<T, P> const & p2,
  tvec3<T, P> const & p3);


}


# 1 "/usr/local/include/glm/./gtx/normal.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> triangleNormal
 (
  tvec3<T, P> const & p1,
  tvec3<T, P> const & p2,
  tvec3<T, P> const & p3
 )
 {
  return normalize(cross(p1 - p2, p1 - p3));
 }
}
# 39 "/usr/local/include/glm/./gtx/normal.hpp" 2 3
# 88 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 3
namespace glm
{







 template <typename T, precision P, template <typename, precision> class vecType>
               T normalizeDot(vecType<T, P> const & x, vecType<T, P> const & y);





 template <typename T, precision P, template <typename, precision> class vecType>
               T fastNormalizeDot(vecType<T, P> const & x, vecType<T, P> const & y);


}


# 1 "/usr/local/include/glm/./gtx/normalize_dot.inl" 1 3



namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T normalizeDot(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return glm::dot(x, y) * glm::inversesqrt(glm::dot(x, x) * glm::dot(y, y));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T fastNormalizeDot(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return glm::dot(x, y) * glm::fastInverseSqrt(glm::dot(x, x) * glm::dot(y, y));
 }
}
# 45 "/usr/local/include/glm/./gtx/normalize_dot.hpp" 2 3
# 89 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/number_precision.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/number_precision.hpp" 3
namespace glm{
namespace gtx
{






 typedef u8 u8vec1;
 typedef u16 u16vec1;
 typedef u32 u32vec1;
 typedef u64 u64vec1;




 typedef f32 f32vec1;
 typedef f64 f64vec1;




 typedef f32 f32mat1;
 typedef f32 f32mat1x1;
 typedef f64 f64mat1;
 typedef f64 f64mat1x1;


}
}


# 1 "/usr/local/include/glm/./gtx/number_precision.inl" 1 3



namespace glm
{

}
# 57 "/usr/local/include/glm/./gtx/number_precision.hpp" 2 3
# 90 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 1 3
# 25 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 3
namespace glm
{






 template <typename T, precision P>
               tmat3x3<T, P> orthonormalize(tmat3x3<T, P> const & m);




 template <typename T, precision P>
               tvec3<T, P> orthonormalize(tvec3<T, P> const & x, tvec3<T, P> const & y);


}


# 1 "/usr/local/include/glm/./gtx/orthonormalize.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> orthonormalize(tmat3x3<T, P> const & m)
 {
  tmat3x3<T, P> r = m;

  r[0] = normalize(r[0]);

  T d0 = dot(r[0], r[1]);
  r[1] -= r[0] * d0;
  r[1] = normalize(r[1]);

  T d1 = dot(r[1], r[2]);
  d0 = dot(r[0], r[2]);
  r[2] -= r[0] * d0 + r[1] * d1;
  r[2] = normalize(r[2]);

  return r;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> orthonormalize(tvec3<T, P> const & x, tvec3<T, P> const & y)
 {
  return normalize(x - y * dot(y, x));
 }
}
# 45 "/usr/local/include/glm/./gtx/orthonormalize.hpp" 2 3
# 92 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/perpendicular.hpp" 1 3
# 18 "/usr/local/include/glm/./gtx/perpendicular.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 3
namespace glm
{






 template <typename vecType>
               vecType proj(vecType const & x, vecType const & Normal);


}


# 1 "/usr/local/include/glm/./gtx/projection.inl" 1 3



namespace glm
{
 template <typename vecType> inline
                    vecType proj(vecType const & x, vecType const & Normal)
 {
  return glm::dot(x, Normal) / glm::dot(Normal, Normal) * Normal;
 }
}
# 36 "/usr/local/include/glm/./gtx/../gtx/projection.hpp" 2 3
# 18 "/usr/local/include/glm/./gtx/perpendicular.hpp" 2 3






namespace glm
{





 template <typename vecType>
               vecType perp(
  vecType const & x,
  vecType const & Normal);


}


# 1 "/usr/local/include/glm/./gtx/perpendicular.inl" 1 3



namespace glm
{
 template <typename vecType> inline
                    vecType perp
 (
  vecType const & x,
  vecType const & Normal
 )
 {
  return x - proj(x, Normal);
 }
}
# 39 "/usr/local/include/glm/./gtx/perpendicular.hpp" 2 3
# 93 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 1 3
# 22 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 3
namespace glm
{






 template <typename T, precision P>
               tvec3<T, P> polar(
  tvec3<T, P> const & euclidean);




 template <typename T, precision P>
               tvec3<T, P> euclidean(
  tvec2<T, P> const & polar);


}


# 1 "/usr/local/include/glm/./gtx/polar_coordinates.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> polar
 (
  tvec3<T, P> const & euclidean
 )
 {
  T const Length(length(euclidean));
  tvec3<T, P> const tmp(euclidean / Length);
  T const xz_dist(sqrt(tmp.x * tmp.x + tmp.z * tmp.z));

  return tvec3<T, P>(
   asin(tmp.y),
   atan(tmp.x, tmp.z),
   xz_dist);
 }

 template <typename T, precision P> inline
                    tvec3<T, P> euclidean
 (
  tvec2<T, P> const & polar
 )
 {
  T const latitude(polar.x);
  T const longitude(polar.y);

  return tvec3<T, P>(
   cos(latitude) * sin(longitude),
   sin(latitude),
   cos(latitude) * cos(longitude));
 }

}
# 44 "/usr/local/include/glm/./gtx/polar_coordinates.hpp" 2 3
# 94 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtx/raw_data.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/raw_data.hpp" 3
namespace glm
{





 typedef detail::uint8 byte;



 typedef detail::uint16 word;



 typedef detail::uint32 dword;



 typedef detail::uint64 qword;


}


# 1 "/usr/local/include/glm/./gtx/raw_data.inl" 1 3
# 47 "/usr/local/include/glm/./gtx/raw_data.hpp" 2 3
# 97 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 1 3
# 18 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 3
# 1 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 1 3
# 26 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 3
namespace glm
{






 template <typename T, precision P>
               tmat4x4<T, P> translate(
  tvec3<T, P> const & v);




 template <typename T, precision P>
               tmat4x4<T, P> rotate(
  T angle,
  tvec3<T, P> const & v);




 template <typename T, precision P>
               tmat4x4<T, P> scale(
  tvec3<T, P> const & v);


}


# 1 "/usr/local/include/glm/./gtx/transform.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat4x4<T, P> translate(tvec3<T, P> const & v)
 {
  return translate(tmat4x4<T, P>(static_cast<T>(1)), v);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> rotate(T angle, tvec3<T, P> const & v)
 {
  return rotate(tmat4x4<T, P>(static_cast<T>(1)), angle, v);
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scale(tvec3<T, P> const & v)
 {
  return scale(tmat4x4<T, P>(static_cast<T>(1)), v);
 }

}
# 56 "/usr/local/include/glm/./gtx/../gtx/transform.hpp" 2 3
# 18 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 2 3






namespace glm
{
# 36 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 3
 template <typename T, precision P>
               tvec3<T, P> slerp(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  T const & a);



 template <typename T, precision P>
               tvec2<T, P> rotate(
  tvec2<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec3<T, P> rotate(
  tvec3<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal);



 template <typename T, precision P>
               tvec4<T, P> rotate(
  tvec4<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal);



 template <typename T, precision P>
               tvec3<T, P> rotateX(
  tvec3<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec3<T, P> rotateY(
  tvec3<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec3<T, P> rotateZ(
  tvec3<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec4<T, P> rotateX(
  tvec4<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec4<T, P> rotateY(
  tvec4<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tvec4<T, P> rotateZ(
  tvec4<T, P> const & v,
  T const & angle);



 template <typename T, precision P>
               tmat4x4<T, P> orientation(
  tvec3<T, P> const & Normal,
  tvec3<T, P> const & Up);


}


# 1 "/usr/local/include/glm/./gtx/rotate_vector.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tvec3<T, P> slerp
 (
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  T const & a
 )
 {

  T CosAlpha = dot(x, y);

  T Alpha = acos(CosAlpha);

  T SinAlpha = sin(Alpha);

  T t1 = sin((static_cast<T>(1) - a) * Alpha) / SinAlpha;
  T t2 = sin(a * Alpha) / SinAlpha;


  return x * t1 + y * t2;
 }

 template <typename T, precision P> inline
                    tvec2<T, P> rotate
 (
  tvec2<T, P> const & v,
  T const & angle
 )
 {
  tvec2<T, P> Result;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos - v.y * Sin;
  Result.y = v.x * Sin + v.y * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotate
 (
  tvec3<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal
 )
 {
  return tmat3x3<T, P>(glm::rotate(angle, normal)) * v;
 }
# 66 "/usr/local/include/glm/./gtx/rotate_vector.inl" 3
 template <typename T, precision P> inline
                    tvec4<T, P> rotate
 (
  tvec4<T, P> const & v,
  T const & angle,
  tvec3<T, P> const & normal
 )
 {
  return rotate(angle, normal) * v;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotateX
 (
  tvec3<T, P> const & v,
  T const & angle
 )
 {
  tvec3<T, P> Result(v);
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.y = v.y * Cos - v.z * Sin;
  Result.z = v.y * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotateY
 (
  tvec3<T, P> const & v,
  T const & angle
 )
 {
  tvec3<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos + v.z * Sin;
  Result.z = -v.x * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec3<T, P> rotateZ
 (
  tvec3<T, P> const & v,
  T const & angle
 )
 {
  tvec3<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos - v.y * Sin;
  Result.y = v.x * Sin + v.y * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotateX
 (
  tvec4<T, P> const & v,
  T const & angle
 )
 {
  tvec4<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.y = v.y * Cos - v.z * Sin;
  Result.z = v.y * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotateY
 (
  tvec4<T, P> const & v,
  T const & angle
 )
 {
  tvec4<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos + v.z * Sin;
  Result.z = -v.x * Sin + v.z * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tvec4<T, P> rotateZ
 (
  tvec4<T, P> const & v,
  T const & angle
 )
 {
  tvec4<T, P> Result = v;
  T const Cos(cos(angle));
  T const Sin(sin(angle));

  Result.x = v.x * Cos - v.y * Sin;
  Result.y = v.x * Sin + v.y * Cos;
  return Result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> orientation
 (
  tvec3<T, P> const & Normal,
  tvec3<T, P> const & Up
 )
 {
  if(all(equal(Normal, Up)))
   return tmat4x4<T, P>(T(1));

  tvec3<T, P> RotationAxis = cross(Up, Normal);
  T Angle = acos(dot(Normal, Up));

  return rotate(Angle, RotationAxis);
 }
}
# 117 "/usr/local/include/glm/./gtx/rotate_vector.hpp" 2 3
# 98 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/spline.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/spline.hpp" 3
namespace glm
{





 template <typename genType>
               genType catmullRom(
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s);



 template <typename genType>
               genType hermite(
  genType const & v1,
  genType const & t1,
  genType const & v2,
  genType const & t2,
  typename genType::value_type const & s);



 template <typename genType>
               genType cubic(
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s);


}


# 1 "/usr/local/include/glm/./gtx/spline.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType catmullRom
 (
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s
 )
 {
  typename genType::value_type s1 = s;
  typename genType::value_type s2 = pow2(s);
  typename genType::value_type s3 = pow3(s);

  typename genType::value_type f1 = -s3 + typename genType::value_type(2) * s2 - s;
  typename genType::value_type f2 = typename genType::value_type(3) * s3 - typename genType::value_type(5) * s2 + typename genType::value_type(2);
  typename genType::value_type f3 = typename genType::value_type(-3) * s3 + typename genType::value_type(4) * s2 + s;
  typename genType::value_type f4 = s3 - s2;

  return (f1 * v1 + f2 * v2 + f3 * v3 + f4 * v4) / typename genType::value_type(2);

 }

 template <typename genType> inline
                    genType hermite
 (
  genType const & v1,
  genType const & t1,
  genType const & v2,
  genType const & t2,
  typename genType::value_type const & s
 )
 {
  typename genType::value_type s1 = s;
  typename genType::value_type s2 = pow2(s);
  typename genType::value_type s3 = pow3(s);

  typename genType::value_type f1 = typename genType::value_type(2) * s3 - typename genType::value_type(3) * s2 + typename genType::value_type(1);
  typename genType::value_type f2 = typename genType::value_type(-2) * s3 + typename genType::value_type(3) * s2;
  typename genType::value_type f3 = s3 - typename genType::value_type(2) * s2 + s;
  typename genType::value_type f4 = s3 - s2;

  return f1 * v1 + f2 * v2 + f3 * t1 + f4 * t2;
 }

 template <typename genType> inline
                    genType cubic
 (
  genType const & v1,
  genType const & v2,
  genType const & v3,
  genType const & v4,
  typename genType::value_type const & s
 )
 {
  return ((v1 * s + v2) * s + v3) * s + v4;
 }
}
# 61 "/usr/local/include/glm/./gtx/spline.hpp" 2 3
# 99 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/std_based_type.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/std_based_type.hpp" 3
namespace glm
{





 typedef tvec1<std::size_t, defaultp> size1;



 typedef tvec2<std::size_t, defaultp> size2;



 typedef tvec3<std::size_t, defaultp> size3;



 typedef tvec4<std::size_t, defaultp> size4;



 typedef tvec1<std::size_t, defaultp> size1_t;



 typedef tvec2<std::size_t, defaultp> size2_t;



 typedef tvec3<std::size_t, defaultp> size3_t;



 typedef tvec4<std::size_t, defaultp> size4_t;


}


# 1 "/usr/local/include/glm/./gtx/std_based_type.inl" 1 3



namespace glm
{

}
# 63 "/usr/local/include/glm/./gtx/std_based_type.hpp" 2 3
# 100 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/string_cast.hpp" 1 3
# 24 "/usr/local/include/glm/./gtx/string_cast.hpp" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 1 3
# 435 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 1 3
# 90 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 76 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_mbstate_t.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 77 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/usr/include/wchar.h" 2 3 4
# 89 "/usr/include/wchar.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 90 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/_wctype.h" 1 3 4
# 47 "/usr/include/_wctype.h" 3 4
# 1 "/usr/include/_types/_wctype_t.h" 1 3 4
# 31 "/usr/include/_types/_wctype_t.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 48 "/usr/include/_wctype.h" 2 3 4
# 65 "/usr/include/_wctype.h" 3 4
inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 170 "/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 93 "/usr/include/wchar.h" 2 3 4



extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime") ;
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 169 "/usr/include/wchar.h" 3 4
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 194 "/usr/include/wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 91 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 2 3
# 94 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;


typedef long long streamoff;

template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

} }
# 436 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 1 3
# 104 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
# 123 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
namespace std {inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;
using ::fclose;
using ::fflush;
using ::fopen;
using ::freopen;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::printf;
using ::scanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;

using ::vfprintf;
using ::vfscanf;
using ::vscanf;
using ::vsscanf;

using ::vprintf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::getchar;

using ::gets;

using ::putc;
using ::putchar;
using ::puts;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;

} }
# 438 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 1 3
# 107 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 1 3
# 54 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 1 3
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 3


namespace std {inline namespace __1 {






using ::isalnum;







using ::isalpha;







using ::isblank;







using ::iscntrl;







using ::isdigit;







using ::isgraph;







using ::islower;







using ::isprint;







using ::ispunct;







using ::isspace;







using ::isupper;







using ::isxdigit;







using ::tolower;







using ::toupper;


} }
# 55 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 2 3
# 1 "/usr/include/wctype.h" 1 3 4
# 36 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/_types/_wctrans_t.h" 1 3 4
# 31 "/usr/include/_types/_wctrans_t.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 37 "/usr/include/wctype.h" 2 3 4
# 49 "/usr/include/wctype.h" 3 4
inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 117 "/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 56 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 2 3
# 59 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 3


namespace std {inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;






using ::iswalnum;







using ::iswalpha;







using ::iswblank;







using ::iswcntrl;







using ::iswdigit;







using ::iswgraph;







using ::iswlower;







using ::iswprint;







using ::iswpunct;







using ::iswspace;







using ::iswupper;







using ::iswxdigit;







using ::iswctype;







using ::wctype;







using ::towlower;







using ::towupper;







using ::towctrans;







using ::wctrans;


} }
# 108 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 2 3
# 115 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3


namespace std {inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::vwprintf;

using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::vwscanf;

using ::wprintf;
using ::wscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::getwchar;
using ::putwc;
using ::putwchar;
using ::ungetwc;
using ::wcstod;

using ::wcstof;
using ::wcstold;

using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
# 180 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return ::wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return ::wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return ::wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return ::wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return ::wmemchr(__s, __c, __n);}



using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;

} }
# 439 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 1 3
# 623 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 1 3
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 3


namespace std
{
# 116 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 3
}
# 624 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 1 3
# 157 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple_03" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple_03" 3


namespace std {inline namespace __1 {

template <class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_size;
template <size_t _Ip, class _Tp> class __attribute__ ((__type_visibility__("default"))) tuple_element;

} }
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 2 3
# 158 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3
# 162 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3


namespace std {inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}



template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
{
    std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
# 233 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
const _Tp&

move_if_noexcept(_Tp& __x) throw()
{
    return std::__1::move(__x);
}

struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { };

extern const piecewise_construct_t piecewise_construct;




template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;




    __attribute__ ((__visibility__("hidden"), __always_inline__)) pair() : first(), second() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair(const _T1& __x, const _T2& __y)
        : first(__x), second(__y) {}

    template<class _U1, class _U2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair(const pair<_U1, _U2>& __p




                                      )
            : first(__p.first), second(__p.second) {}
# 289 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(const pair& __p)


    {
        first = __p.first;
        second = __p.second;
        return *this;
    }
# 381 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    swap(pair& __p)

    {
        std::__1::iter_swap(&first, &__p.first);
        std::__1::iter_swap(&second, &__p.second);
    }
private:
# 398 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)


{
    __x.swap(__y);
}
# 496 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_T1,_T2>
make_pair(_T1 __x, _T2 __y)
{
    return pair<_T1, _T2>(__x, __y);
}



template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
  class __attribute__ ((__type_visibility__("default"))) tuple_size<const pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<0, const pair<_T1, _T2> >
{
public:
    typedef const _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__type_visibility__("default"))) tuple_element<1, const pair<_T1, _T2> >
{
public:
    typedef const _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T1&
    get(pair<_T1, _T2>& __p) throw() {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T1&
    get(const pair<_T1, _T2>& __p) throw() {return __p.first;}
# 568 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _T2&
    get(pair<_T1, _T2>& __p) throw() {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _T2&
    get(const pair<_T1, _T2>& __p) throw() {return __p.second;}
# 594 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}
# 766 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
} }
# 627 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 1 3
# 594 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 1 3
# 61 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 1 3
# 85 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception() throw() {}
    virtual ~exception() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bad_exception() throw() {}
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
};

typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) throw();
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void unexpected();

typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) throw();
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void terminate() throw();

__attribute__ ((__visibility__("default"))) bool uncaught_exception() throw();

class __attribute__ ((__type_visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
__attribute__ ((noreturn)) __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);

class __attribute__ ((__type_visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr() throw() : __ptr_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr(nullptr_t) throw() : __ptr_() {}
    exception_ptr(const exception_ptr&) throw();
    exception_ptr& operator=(const exception_ptr&) throw();
    ~exception_ptr() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __ptr_ != std::__1::__get_nullptr_t();}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) throw()
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }

}



class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() throw();


    virtual ~nested_exception() throw();


    __attribute__ ((noreturn)) void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr nested_ptr() const throw() {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{

    throw __nested<typename remove_reference<_Tp>::type>(std::__1::forward<_Tp>(__t));

}

template <class _Tp>
__attribute__ ((noreturn))
void






throw_with_nested (_Tp& __t, typename enable_if<
                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value
                                    >::type* = 0)

{

    throw std::__1::forward<_Tp>(__t);

}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep& __e, typename enable_if<
                                   is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep&, typename enable_if<
                                   !is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
}

}
# 62 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 1 3
# 149 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 3


namespace std {inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 2 3
# 67 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);
protected:

    const char* __type_name;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit type_info(const char* __n)

        : __type_name(__n) {}




public:
    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* name() const throw()

        {return __type_name;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool before(const type_info& __arg) const throw()

        {return __type_name < __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t hash_code() const throw()

        {return *reinterpret_cast<const size_t*>(&__type_name);}
# 126 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const type_info& __arg) const throw()

        {return __type_name == __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const type_info& __arg) const throw()
        {return !operator==(__arg);}
# 154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
};

class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
public:
    bad_cast() throw();
    virtual ~bad_cast() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
public:
    bad_typeid() throw();
    virtual ~bad_typeid() throw();
    virtual const char* what() const throw();
};

}
# 595 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 1 3
# 73 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() throw();
    virtual ~bad_array_new_length() throw();
    virtual const char* what() const throw();
};
# 111 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
__attribute__ ((__visibility__("default"))) void __throw_bad_alloc();

struct __attribute__ ((__type_visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;
typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) throw();
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() throw();

}







__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) throw();

__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new (std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new[](std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete (void*, void*) throw() {}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete[](void*, void*) throw() {}
# 598 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 1 3
# 346 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3


namespace std {inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_const<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _ForwardIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIter
next(_ForwardIter __x,
     typename iterator_traits<_ForwardIter>::difference_type __n = 1,
     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)
{
    std::__1::advance(__x, __n);
    return __x;
}

template <class _BidiretionalIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidiretionalIter
prev(_BidiretionalIter __x,
     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,
     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)
{
    std::__1::advance(__x, -__n);
    return __x;
}

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
    mutable _Iter __t;
protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator() : current() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t(__u.base()), current(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {__t = current; return *--__t;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {return &(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator++(int)
        {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator--(int)
        {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator+ (difference_type __n) const
        {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator+=(difference_type __n)
        {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator- (difference_type __n) const
        {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator-=(difference_type __n)
        {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
        {return current[-__n-1];}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename reverse_iterator<_Iter1>::difference_type
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() - __x.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      back_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit back_insert_iterator(_Container& __x) : container(&__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      front_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit front_insert_iterator(_Container& __x) : container(&__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      insert_iterator<_Container>&>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(&__x), iter(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator() : __in_stream_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(&__s)
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp* operator->() const {return &(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
        {return __x.__in_stream_ == __y.__in_stream_;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s)
        : __out_stream_(&__s), __delim_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter)
        : __out_stream_(&__s), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator() throw() : __sbuf_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(istream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(const __proxy& __p) throw()
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* operator->() const {return std::__1::__get_nullptr_t();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(ostream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool failed() const throw() {return __sbuf_ == 0;}





    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);

};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;



    typedef typename iterator_traits<iterator_type>::reference reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator(const move_iterator<_Up>& __u)
        : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {
      return static_cast<reference>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {
      typename iterator_traits<iterator_type>::reference __ref = *__i;
      return &__ref;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator++(int)
        {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator--(int)
        {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator+ (difference_type __n) const
        {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator+=(difference_type __n)
        {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator- (difference_type __n) const
        {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator-=(difference_type __n)
        {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
    {
      return static_cast<reference>(__i[__n]);
    }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename move_iterator<_Iter1>::difference_type
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter>
__attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) throw();

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) move_backward(_B1, _B1, _B2);

template <class _Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter() throw()



    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) throw()
        : __i(__u.base())
    {



    }
# 1149 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw()
    {




        return (pointer)&reinterpret_cast<const volatile char&>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator++() throw()
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator++(int) throw()
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator--() throw()
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator--(int) throw()
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator+ (difference_type __n) const throw()
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator+=(difference_type __n) throw()
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator- (difference_type __n) const throw()
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator-=(difference_type __n) throw()
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const throw()
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator_type base() const throw() {return __i;}

private:






    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(iterator_type __x) throw() : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class vector;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    typename __wrap_iter<_Iter1>::difference_type
    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1>
    friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

    template <class _Tp>
    friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) throw()
{
    __x += __n;
    return __x;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}
# 1529 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
begin(_Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
begin(const _Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
end(_Cp& __c)
{
    return __c.end();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
end(const _Cp& __c)
{
    return __c.end();
}



} }
# 601 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 1 3
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3


namespace std {inline namespace __1 {

template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};
# 80 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
addressof(_Tp& __x) throw()
{
    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
}
# 130 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<__typeof__(__test((_Tp*)0)), __two>::value;
    typedef __typeof__(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<typename remove_reference<_Tp>::type>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};



template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2) volatile>
{
    typedef _Rp result_type;
};
# 416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1& __t1)
{
    return (__t1.*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
{
    return (__t1.*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
{
    return (__t1.*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return (__t1.*__f)(__a0, __a1, __a2);
}



template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(), _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0), _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)() const volatile, _T1 __t1)
{
    return ((*__t1).*__f)();
}

template <class _Rp, class _Tp, class _T1, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
{
    return ((*__t1).*__f)(__a0);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
{
    return ((*__t1).*__f)(__a0, __a1);
}

template <class _Rp, class _Tp, class _T1, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    _Rp
>::type
__invoke(_Rp (_Tp::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return ((*__t1).*__f)(__a0, __a1, __a2);
}



template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_base_of<_Tp, typename remove_reference<_T1>::type>::value,
    typename __apply_cv<_T1, _Rp>::type&
>::type
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return __t1.*__f;
}

template <class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__invoke(_Rp _Tp::*)
{
}
# 837 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _T1, class _Rp, bool>
struct __4th_helper
{
};

template <class _T1, class _Rp>
struct __4th_helper<_T1, _Rp, true>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_T1>()), _Rp>::type type;
};

template <class _Rp, class _Tp, class _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __4th_helper<_T1, _Rp,
                      !is_base_of<_Tp,
                                  typename remove_reference<_T1>::type
                                 >::value
                     >::type&
__invoke(_Rp _Tp::* __f, _T1& __t1)
{
    return (*__t1).*__f;
}
# 874 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()())
__invoke(_Fp __f)
{
    return __f();
}

template <class _Fp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>()))
__invoke(_Fp __f, _A0& __a0)
{
    return __f(__a0);
}

template <class _Fp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1)
{
    return __f(__a0, __a1);
}

template <class _Fp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__typeof__(declval<_Fp>()(declval<_A0&>(), declval<_A1&>(), declval<_A2&>()))
__invoke(_Fp __f, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return __f(__a0, __a1, __a2);
}
# 942 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base_03" 3
template <class _Tp>
struct __has_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Fp, bool = __has_result_type<__weak_result_type<_Fp> >::value>
struct __invoke_return
{
    typedef typename __weak_result_type<_Fp>::result_type type;
};

template <class _Fp>
struct __invoke_return<_Fp, false>
{
    typedef __typeof__(__invoke(std::__1::declval<_Fp>())) type;
};

template <class _Tp, class _A0>
struct __invoke_return0
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>())) type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Rp, class _Tp, class _A0>
struct __invoke_return0<_Rp _Tp::*, _A0*>
{
    typedef typename __apply_cv<_A0, _Rp>::type& type;
};

template <class _Tp, class _A0, class _A1>
struct __invoke_return1
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>())) type;

};

template <class _Tp, class _A0, class _A1, class _A2>
struct __invoke_return2
{
    typedef __typeof__(__invoke(std::__1::declval<_Tp>(), std::__1::declval<_A0>(), std::__1::declval<_A1>(), std::__1::declval<_A2>())) type;


};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference_wrapper(type& __f) : __f_(&__f) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator type& () const {return *__f_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) type& get() const {return *__f_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename __invoke_return<type&>::type
       operator() () const
       {
           return __invoke(get());
       }

    template <class _A0>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return0<type&, _A0>::type
          operator() (_A0& __a0) const
          {
              return __invoke(get(), __a0);
          }

    template <class _A0, class _A1>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return1<type&, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1) const
          {
              return __invoke(get(), __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return2<type&, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2) const
          {
              return __invoke(get(), __a0, __a1, __a2);
          }
};

template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t)
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t)
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t)
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t)
{
    return cref(__t.get());
}
# 131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 2 3
# 523 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { };


extern const allocator_arg_t allocator_arg;






template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
# 613 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
} }
# 602 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 1 3
# 132 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3


namespace std {inline namespace __1 {
# 1100 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3
} }
# 604 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 613 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 614 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 617 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3


namespace std {inline namespace __1 {



template <class _Tp> class allocator;

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};



template <class _Tp>
struct __has_element_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::element_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};
# 685 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, true>
{
    typedef typename _Sp<_Tp>::element_type type;
};

template <template <class> class _Sp, class _Tp>
struct __pointer_traits_element_type<_Sp<_Tp>, false>
{
    typedef _Tp type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>
{
    typedef typename _Sp<_Tp, _A0>::element_type type;
};

template <template <class, class> class _Sp, class _Tp, class _A0>
struct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>
{
    typedef _Tp type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>
{
    typedef _Tp type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>
{
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                           class _A1, class _A2>
struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>
{
    typedef _Tp type;
};



template <class _Tp>
struct __has_difference_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::difference_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{



    typedef typename _Tp::template rebind<_Up>::other type;

};
# 801 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>
{



    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;

};

template <template <class> class _Sp, class _Tp, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>
{
    typedef _Sp<_Up> type;
};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;

};

template <template <class, class> class _Sp, class _Tp, class _A0, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>
{
    typedef _Sp<_Up, _A0> type;
};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;

};

template <template <class, class, class> class _Sp, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>
{



    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;

};

template <template <class, class, class, class> class _Sp, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Sp<_Up, _A0, _A1, _A2> type;
};



template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;




    template <class _Up> struct rebind
        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;




    template <class _Up> struct rebind {typedef _Up* other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) throw()
        {return std::__1::addressof(__r);}
};



namespace __has_pointer_type_imp
{
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::pointer* = 0);
}

template <class _Tp>
struct __has_pointer_type
    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>
{
};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};

}

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp>
struct __has_const_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;

};

template <class _Tp>
struct __has_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;

};

template <class _Tp>
struct __has_const_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;

};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
__to_raw_pointer(_Tp* __p) throw()
{
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) throw()
{
    return std::__1::__to_raw_pointer(__p.operator->());
}

template <class _Tp>
struct __has_size_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::size_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_move_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_swap
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};
# 1181 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>
{
    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;
};

template <template <class> class _Alloc, class _Tp, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>
{
    typedef _Alloc<_Up> type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;
};

template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>
{
    typedef _Alloc<_Up, _A0> type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;
};

template <template <class, class, class> class _Alloc, class _Tp, class _A0,
                                         class _A1, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1> type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>
{
    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;
};

template <template <class, class, class, class> class _Alloc, class _Tp, class _A0,
                                                class _A1, class _A2, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>
{
    typedef _Alloc<_Up, _A0, _A1, _A2> type;
};
# 1260 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : true_type
{
};
# 1361 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _Pointer, class _Args>
struct __has_construct
    : false_type
{
};



template <class _Alloc, class _Pointer>
struct __has_destroy
    : false_type
{
};

template <class _Alloc>
struct __has_max_size
    : true_type
{
};

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : false_type
{
};



template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;






    template <class _Tp> struct rebind_alloc
        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};
    template <class _Tp> struct rebind_traits
        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) throw()
        {__a.deallocate(__p, __n);}
# 1452 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p)
            {
                ::new ((void*)__p) _Tp();
            }
    template <class _Tp, class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)
            {
                ::new ((void*)__p) _Tp(__a0);
            }
    template <class _Tp, class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1)
            {
                ::new ((void*)__p) _Tp(__a0, __a1);
            }
    template <class _Tp, class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,
                              const _A1& __a1, const _A2& __a2)
            {
                ::new ((void*)__p) _Tp(__a0, __a1, __a2);
            }


    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type max_size(const allocator_type& __a) throw()
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, ++__begin2)
                construct(__a, std::__1::__to_raw_pointer(__begin2), std::__1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
            __begin2 += _Np;
        }

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__1::__to_raw_pointer(__end2-1), std::__1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}
# 1577 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(true_type, const allocator_type& __a)
            {return __a.max_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(false_type, const allocator_type&)
            {return numeric_limits<size_type>::max();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer address(reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {::operator delete((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {::operator delete((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}
# 1734 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p)
        {
            ::new((void*)__p) _Tp();
        }


    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }
    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0)
        {
            ::new((void*)__p) _Tp(__a0);
        }

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }
    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(pointer __p, const _A0& __a0, const _A1& __a1)
        {
            ::new((void*)__p) _Tp(__a0, __a1);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) throw() {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) throw() {return false;}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(&*__x_) _Tp(__element); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}
};

template <class _Tp>
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) throw()
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void return_temporary_buffer(_Tp* __p) throw() {::operator delete(__p);}

template <class _Tp>
struct auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr<_Up>& __p) throw()
        : __ptr_(__p.release()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr& __p) throw()
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        {reset(__p.release()); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~auto_ptr() throw() {delete __ptr_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp& operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr_ref<_Up>() throw()
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr<_Up>() throw()
        {return auto_ptr<_Up>(release());}
};

template <>
class __attribute__ ((__type_visibility__("default"))) auto_ptr<void>
{
public:
    typedef void element_type;
};

template <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,
                                                     typename remove_cv<_T2>::type>::value,
                                bool = is_empty<_T1>::value

                                       && !__is_final(_T1)

                                ,
                                bool = is_empty<_T2>::value

                                       && !__is_final(_T2)

         >
struct __libcpp_compressed_pair_switch;

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false> {enum {value = 1};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true> {enum {value = 2};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true> {enum {value = 3};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true> {enum {value = 1};};

template <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>
class __libcpp_compressed_pair_imp;

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 0>
{
private:
    _T1 __first_;
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : __first_(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2010 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 1>
    : private _T1
{
private:
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), __second_(std::__1::forward<_T2_param>(__t2)) {}
# 2101 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 2>
    : private _T2
{
private:
    _T1 __first_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)


        : _T2(std::__1::forward<_T2_param>(__t2)), __first_(std::__1::forward<_T1_param>(__t1)) {}
# 2194 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)


    {
        using std::__1::swap;
        swap(__first_, __x.__first_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 3>
    : private _T1,
      private _T2
{
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__1::forward<_T1_param>(__t1)), _T2(std::__1::forward<_T2_param>(__t2)) {}
# 2283 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp&)


    {
    }
};

template <class _T1, class _T2>
class __compressed_pair
    : private __libcpp_compressed_pair_imp<_T1, _T2>
{
    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;
public:
    typedef typename base::_T1_param _T1_param;
    typedef typename base::_T2_param _T2_param;

    typedef typename base::_T1_reference _T1_reference;
    typedef typename base::_T2_reference _T2_reference;

    typedef typename base::_T1_const_reference _T1_const_reference;
    typedef typename base::_T2_const_reference _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T1_param __t1)
        : base(std::__1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T2_param __t2)
        : base(std::__1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair(_T1_param __t1, _T2_param __t2)
        : base(std::__1::forward<_T1_param>(__t1), std::__1::forward<_T2_param>(__t2)) {}
# 2366 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return base::first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return base::first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return base::second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return base::second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__compressed_pair& __x)


        {base::swap(__x);}
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)


    {__x.swap(__y);}



template <class _Ptr1, class _Ptr2,
          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,
                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type
                        >::value
         >
struct __same_or_less_cv_qualified_imp
    : is_convertible<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>
    : false_type {};

template <class _Ptr1, class _Ptr2, bool = is_scalar<_Ptr1>::value &&
                                         !is_pointer<_Ptr1>::value>
struct __same_or_less_cv_qualified
    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified<_Ptr1, _Ptr2, true>
    : false_type {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete
{



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up>&,
             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator() (_Tp* __ptr) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2424;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2425;
            delete __ptr;
        }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]>
{
public:



    __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete() throw() {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up[]>&,
             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) throw() {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void operator() (_Up* __ptr,
                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const throw()
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(sizeof(_Tp) > 0)>)> __t2447;
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Tp>::value)>)> __t2448;
            delete [] __ptr;
        }
};

template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr(unique_ptr<_Up, _Ep>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up, class _Ep>
        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2481;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2487;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p) throw()
        : __ptr_(std::__1::move(__p))
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2493;

        }
# 2563 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    template <class _Up, class _Ep>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)
    {
        reset(__u.release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(std::__1::move(__p), std::__1::move(__d)) {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
                typename enable_if<
                                      is_convertible<_Up*, _Tp*>::value &&
                                      is_same<_Dp, default_delete<_Tp> >::value,
                                      unique_ptr&
                                  >::type
        operator=(auto_ptr<_Up> __p)
            {reset(__p.release()); return *this;}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator*() const
        {return *__ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer()) throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) throw()
        {__ptr_.swap(__u.__ptr_);}
};

template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp>
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;


    unique_ptr(unique_ptr&);
    template <class _Up>
        unique_ptr(unique_ptr<_Up>&);
    unique_ptr& operator=(unique_ptr&);
    template <class _Up>
        unique_ptr& operator=(unique_ptr<_Up>&);


    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr() throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2660;

        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2666;

        }
# 2758 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p)
        : __ptr_(__p)
        {
            typedef __static_assert_check<sizeof(__static_assert_test<(!is_pointer<deleter_type>::value)>)> __t2762;

        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, deleter_type __d)
        : __ptr_(__p, std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t, deleter_type __d)
        : __ptr_(pointer(), std::__1::forward<deleter_type>(__d)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator __rv<unique_ptr>()
    {
        return __rv<unique_ptr>(*this);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(__rv<unique_ptr> __u)
        : __ptr_(__u->release(), std::__1::forward<deleter_type>(__u->get_deleter())) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(__rv<unique_ptr> __u)
    {
        reset(__u->release());
        __ptr_.second() = std::__1::forward<deleter_type>(__u->get_deleter());
        return *this;
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const
        {return __ptr_.first()[__i];}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                         operator bool() const throw()
        {return __ptr_.first() != std::__1::__get_nullptr_t();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }
# 2839 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer())
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}
private:


    template <class _Up>
        explicit unique_ptr(_Up);
    template <class _Up>
        unique_ptr(_Up __u,
                   typename conditional<
                                       is_reference<deleter_type>::value,
                                       deleter_type,
                                       typename add_lvalue_reference<const deleter_type>::type>::type,
                   typename enable_if
                      <
                         is_convertible<_Up, pointer>::value,
                         __nat
                      >::type = __nat());

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) throw() {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(std::__1::__get_nullptr_t(), __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return std::__1::__get_nullptr_t() < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < std::__1::__get_nullptr_t();
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < std::__1::__get_nullptr_t());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(std::__1::__get_nullptr_t() < __x);
}



template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unique_ptr<_Tp, _Dp>
move(unique_ptr<_Tp, _Dp>& __t)
{
    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));
}
# 3062 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Tp> struct hash;

template <class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    _Size operator()(const void* __key, _Size __len);
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
    case 2:
        __h ^= __data[1] << 8;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    _Size operator()(const void* __key, _Size __len);

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp* __v) const throw()
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) hash<unique_ptr<_Tp, _Dp> >
{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t size;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp* __p, false_type) throw()
        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp*, true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(false_type) throw()
        {++size;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, false_type) throw()
        {size = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t, true_type) throw()
        {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __destruct_n(size_t __s) throw()
        : size(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(_Tp*) throw()
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, _Tp*) throw()
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) throw()
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             throw()
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __f != __l; ++__f, ++__r)
            ::new(&*__r) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __n > 0; ++__f, ++__r, --__n)
            ::new(&*__r) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __f != __l; ++__f)
            ::new(&*__f) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __n > 0; ++__f, --__n)
            ::new(&*__f) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

    return __f;
}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() throw();
    virtual const char* what() const throw();
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__type_visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() throw() = 0;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_count(long __refs = 0) throw()
        : __shared_owners_(__refs) {}

    void __add_shared() throw();
    bool __release_shared() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_owners_ + 1;}
};

class __attribute__ ((__type_visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_weak_count(long __refs = 0) throw()
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:
    void __add_shared() throw();
    void __add_weak() throw();
    void __release_shared() throw();
    void __release_weak() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_count::use_count();}
    __shared_weak_count* lock() throw();






    virtual const void* __get_deleter(const type_info&) const throw();

private:
    virtual void __on_zero_shared_weak() throw() = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}


    virtual const void* __get_deleter(const type_info&) const throw();


private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const throw()
{
    return __t == typeid(_Dp) ? &__data_.first().second() : 0;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw()
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(this, 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:
# 3702 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(__a) {}

    template <class _A0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0)
            : __data_(__a, _Tp(__a0)) {}

    template <class _A0, class _A1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)
            : __data_(__a, _Tp(__a0, __a1)) {}

    template <class _A0, class _A1, class _A2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)
            : __data_(__a, _Tp(__a0, __a1, __a2)) {}



private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* get() throw() {return &__data_.second();}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() throw()
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(this, 1);
}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
                      shared_ptr() throw();
                      shared_ptr(nullptr_t) throw();
    template<class _Yp,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        explicit shared_ptr(_Yp* __p);
    template<class _Yp, class _Dp,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        shared_ptr(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a);
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) throw();
    shared_ptr(const shared_ptr& __r) throw();
    template<class _Yp>
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())
                       throw();






    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());
# 3808 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template<class _Yp,
             class = typename enable_if
                     <
                        is_convertible<_Yp*, element_type*>::value
                     >::type
            >
        shared_ptr(auto_ptr<_Yp> __r);
# 3836 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template <class _Yp, class _Dp,
                 class = typename enable_if
                 <
                    !is_array<_Yp>::value &&
                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
                 >::type
             > shared_ptr(unique_ptr<_Yp, _Dp>,
       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());
    template <class _Yp, class _Dp,
                 class = typename enable_if
                 <
                    !is_array<_Yp>::value &&
                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
                 >::type
             >
       shared_ptr(unique_ptr<_Yp, _Dp>,
       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());


    ~shared_ptr();

    shared_ptr& operator=(const shared_ptr& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(const shared_ptr<_Yp>& __r) throw();
# 3883 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template<class _Yp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(auto_ptr<_Yp> __r);

    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type



        operator=(unique_ptr<_Yp, _Dp> __r);


    void swap(shared_ptr& __r) throw();
    void reset() throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool unique() const throw() {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                     operator bool() const throw() {return get() != 0;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}


    template <class _Dp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        _Dp* __get_deleter() const throw()
            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}
# 3976 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    static shared_ptr<_Tp> make_shared();

    template<class _A0>
        static shared_ptr<_Tp> make_shared(_A0&);

    template<class _A0, class _A1>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&);

    template<class _A0, class _A1, class _A2>
        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);

    template<class _Alloc>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a);

    template<class _Alloc, class _A0>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0);

    template<class _Alloc, class _A0, class _A1>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);

    template<class _Alloc, class _A0, class _A1, class _A2>
        static shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);



private:

    template <class _Yp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) throw()
        {
            if (__e)
                __e->__weak_this_ = *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __enable_weak_this(const void*) throw() {}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

shared_ptr<_Tp>::shared_ptr(nullptr_t) throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp, class>
shared_ptr<_Tp>::shared_ptr(_Yp* __p)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());
    __hold.release();
    __enable_weak_this(__p);
}

template<class _Tp>
template<class _Yp, class _Dp, class>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());
        __enable_weak_this(__p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc, class>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();
        __enable_weak_this(__p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) throw()
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}
# 4210 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp, class>



shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r)

    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp, class>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

           typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp, class>



shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,

           typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*,
                                 reference_wrapper<typename remove_reference<_Dp>::type>,
                                 allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}
# 4299 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared()
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class _A0, class _A1, class _A2>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;
    typedef __allocator_destructor<_Alloc2> _D2;
    _Alloc2 __alloc2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}



template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}
# 4531 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template <class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::swap(shared_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::reset() throw()
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}
# 4647 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared()
{
    return shared_ptr<_Tp>::make_shared();
}

template<class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0)
{
    return shared_ptr<_Tp>::make_shared(__a0);
}

template<class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1);
}

template<class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
make_shared(_A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);
}

template<class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a)
{
    return shared_ptr<_Tp>::allocate_shared(__a);
}

template<class _Tp, class _Alloc, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0);
}

template<class _Tp, class _Alloc, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);
}

template<class _Tp, class _Alloc, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)
{
    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);
}



template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    typedef typename common_type<_Tp*, _Up*>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return less<_Tp*>()(__x.get(), std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return less<_Tp*>()(std::__1::__get_nullptr_t(), __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return std::__1::__get_nullptr_t() < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return __x < std::__1::__get_nullptr_t();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(__x < std::__1::__get_nullptr_t());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(std::__1::__get_nullptr_t() < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}



template<class _Dp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) throw()
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
                      weak_ptr() throw();
    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        throw();
    weak_ptr(weak_ptr const& __r) throw();
    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         throw();







    ~weak_ptr();

    weak_ptr& operator=(weak_ptr const& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(weak_ptr<_Yp> const& __r) throw();
# 4964 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(shared_ptr<_Yp> const& __r) throw();

    void swap(weak_ptr& __r) throw();
    void reset() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw()
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool expired() const throw()
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const throw();
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

weak_ptr<_Tp>::weak_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
# 5067 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}
# 5124 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::swap(weak_ptr& __r) throw()
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::reset() throw()
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)

        throw bad_weak_ptr();



}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const throw()
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}

template <class _Tp> struct owner_less;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) throw()
        {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}

    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
# 5394 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
struct __attribute__ ((__type_visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator int() const {return __v_;}
};

__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) pointer_safety get_pointer_safety() throw();
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);

} }
# 628 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 638 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 639 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 642 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3


namespace std {inline namespace __1 {

template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __negate
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __negate() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __negate(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}
};
# 740 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__ctz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_ctz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__ctz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_ctzl(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__ctz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_ctzll(__x));
}


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__clz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_clz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__clz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_clzl (__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__clz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_clzll(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned __x) {return __builtin_popcount (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long __x) {return __builtin_popcountl (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return std::__1::move(__f);
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}



template<class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{

    _ForwardIterator1 __r = __last1;
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1)
                return __r;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (__first2 == __last2)
        return __last1;
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (__first1 == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }

        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
            if (__m1 == __first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
_RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_first_of(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1158 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1235 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{

    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return true;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);


    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
# 1388 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return __first1;
    while (true)
    {

        while (true)
        {
            if (__first1 == __last1)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
                return __first1;
            if (++__m1 == __last1)
                return __last1;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
_RandomAccessIterator1
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;

    _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __first1;
    _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);
    while (true)
    {

        while (true)
        {
            if (__first1 == __s)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
# 1483 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;

         while (true)
         {
             if (++__m2 == __last2)
                 return __first1;
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
# 1534 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (__first == __last)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
_RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1);
    while (true)
    {

        while (true)
        {
            if (__first >= __s)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());
}



template <class _Iter>
struct __libcpp_is_trivial_iterator
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = *__first;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    return std::__1::copy(__first, __first + __n, __result);
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __value_;
    return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
    !is_same<_Tp, bool>::value &&
    is_integral<_Up>::value && sizeof(_Up) == 1,
    _Tp*
>::type
__fill_n(_Tp* __first, _Size __n,_Up __value_)
{
    if (__n > 0)
        std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
    return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, __n, __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __gen();
    return __first;
}



template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            swap(*__first, *__last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}



template <class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Integral
__gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}
# 2571 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}
# 2635 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _ForwardIterator, class _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}
# 2737 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UI, _UI _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UI) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;


    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min
                                          + _Working_result_type(1);




    static const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WDt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WDt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}



template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:

    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __clz(_Rp) - 1;
    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}

class __attribute__ ((__type_visibility__("default"))) __rs_default;

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

class __attribute__ ((__type_visibility__("default"))) __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&);
    ~__rs_default();

    result_type operator()();

    static result_type min() {return _Min;}
    static result_type max() {return _Max;}

    friend __attribute__ ((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        __rs_default __g = __rs_get();
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



               _RandomNumberGenerator& __rand)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        for (--__last; __first < __last; ++__first, --__d)
        {
            difference_type __i = __rand(__d);
            swap(*__first, *(__first + __i));
        }
    }
}

template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



                 _UniformRandomNumberGenerator& __g)

{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _InputIterator, class _Predicate>
bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template<class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }

        *__first = std::__1::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BirdirectionalIterator>
void
__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    _BirdirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BirdirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BirdirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new(__last2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type*)0);
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new(__j2) value_type(std::__1::move(*__i2));
                __d.__incr((value_type*)0);
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__1::move(*__first1));
                __d.__incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}


template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__1::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}





extern template __attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);






template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}



template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        __merge<_Compare>(move_iterator<value_type*>(__buff),
                          move_iterator<value_type*>(__p),
                          move_iterator<_BidirectionalIterator>(__middle),
                          move_iterator<_BidirectionalIterator>(__last),
                          __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),
                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),
                _RBi(__last), __negate<_Compare>(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;

        for (; true; ++__first, --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
        if (__len1 <= __buff_size || __len2 <= __buff_size)
        {
            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);
            return;
        }
# 4359 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__1::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _Tp>
struct __inplace_merge_switch
{
    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;
};

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
        __h.reset(__buf.first);
    }






    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new (__result) value_type(std::__1::move(*__first2));
            __d.__incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
       __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
         if (__comp(*--__last1, *__first1))
        {
            ::new(__first2) value_type(std::__1::move(*__last1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)0);
        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)0);
        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__push_heap_front(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,
                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        difference_type __p = 0;
        _RandomAccessIterator __pp = __first;
        difference_type __c = 2;
        _RandomAccessIterator __cp = __first + __c;
        if (__c == __len || __comp(*__cp, *(__cp - 1)))
        {
            --__c;
            --__cp;
        }
        if (__comp(*__pp, *__cp))
        {
            value_type __t(std::__1::move(*__pp));
            do
            {
                *__pp = std::__1::move(*__cp);
                __pp = __cp;
                __p = __c;
                __c = (__p + 1) * 2;
                if (__c > __len)
                    break;
                __cp = __first + __c;
                if (__c == __len || __comp(*__cp, *(__cp - 1)))
                {
                    --__c;
                    --__cp;
                }
            } while (__comp(__t, *__cp));
            *__pp = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__push_heap_back(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __push_heap_back<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        __push_heap_front<_Compare>(__first, __last, __comp, __len-1);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {
        __last = __first;
        ++__last;
        for (difference_type __i = 1; __i < __n;)
            __push_heap_back<_Compare>(__first, ++__last, __comp, ++__i);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
        __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    __make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            __push_heap_front<_Compare>(__first, __middle, __comp, __len);
        }
    }
    __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = 0;
        for (; __first != __last && __r != __result_last; ++__first, ++__r, ++__len)
            *__r = *__first;
        __make_heap<_Compare>(__result_first, __r, __comp);
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                __push_heap_front<_Compare>(__result_first, __r, __comp, __len);
            }
        __sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            __selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }


                    if (__nth < __i)
                        return;


                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
            else
            {

                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
        }
not_sorted:

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            if (!__comp(*__first1, *__first2))
                ++__first2;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_left(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_right(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));
}

} }
# 440 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 1 3
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{
private:
    void* __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) throw();
    logic_error& operator=(const logic_error&) throw();

    virtual ~logic_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{
private:
    void* __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) throw();
    runtime_error& operator=(const runtime_error&) throw();

    virtual ~runtime_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}

    virtual ~domain_error() throw();
};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}

    virtual ~invalid_argument() throw();
};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() throw();
};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}

    virtual ~out_of_range() throw();
};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}

    virtual ~range_error() throw();
};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~overflow_error() throw();
};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~underflow_error() throw();
};

}
# 444 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 454 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 455 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 458 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3


namespace std {inline namespace __1 {



template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}



template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type((-1));}
};

template <class _CharT>
int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

template <class _CharT>
_CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
            {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return memcmp(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_t length(const char_type* __s) {return strlen(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)memmove(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)memcpy(__s1, __s2, __n);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)memset(__s, to_int_type(__a), __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type((unsigned char)__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type((-1));}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)
        {return wmemcmp(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_t length(const char_type* __s)
        {return wcslen(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)
        {return (const char_type*)wmemchr(__s, __a, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)
        {return (char_type*)wmemmove(__s1, __s2, __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)
        {
            ((void)0);
            return (char_type*)wmemcpy(__s1, __s2, __n);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a)
        {return (char_type*)wmemset(__s, __a, __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(((__darwin_wint_t)-1));}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(0xDFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char16_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void assign(char_type& __c1, const char_type& __c2) throw()
        {__c1 = __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq(char_type __c1, char_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool lt(char_type __c1, char_type __c2) throw()
        {return __c1 < __c2;}

    static int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    static size_t length(const char_type* __s);
    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    static char_type* assign(char_type* __s, size_t __n, char_type __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type not_eof(int_type __c) throw()
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static char_type to_char_type(int_type __c) throw()
        {return char_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type to_int_type(char_type __c) throw()
        {return int_type(__c);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static bool eq_int_type(int_type __c1, int_type __c2) throw()
        {return __c1 == __c2;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static int_type eof() throw()
        {return int_type(0xFFFFFFFF);}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
char_traits<char32_t>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}





template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_first_of(const _CharT *__p, _SizeT __sz,
    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::find_first_of
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_last_of(const _CharT *__p, _SizeT __sz,
    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_first_not_of(const _CharT *__p, _SizeT __sz,
    const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == 0)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_first_not_of(const _CharT *__p, _SizeT __sz,
    _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_last_not_of(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == 0)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
_SizeT __attribute__ ((__visibility__("hidden"), __always_inline__)) __find_last_not_of(const _CharT *__p, _SizeT __sz,
        _CharT __c, _SizeT __pos) throw()
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
size_t __attribute__ ((__visibility__("hidden"), __always_inline__)) __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{

    throw length_error("basic_string");



}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{

    throw out_of_range("basic_string");



}





extern template class __attribute__ ((__type_visibility__("default"))) __basic_string_common<true>;
# 1170 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef _Traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef __static_assert_check<sizeof(__static_assert_test<(is_pod<value_type>::value)>)> __t1187;
    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<_CharT, value_type>::value))>)> __t1189;

    typedef __static_assert_check<sizeof(__static_assert_test<((is_same<typename allocator_type::value_type, value_type>::value))>)> __t1191;





    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;

    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
# 1236 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    struct __long
    {
        size_type __cap_;
        size_type __size_;
        pointer __data_;
    };





    enum {__short_mask = 0x01};
    enum {__long_mask = 0x1ul};


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        union
        {
            unsigned char __size_;
            value_type __lx;
        };
        value_type __data_[__min_cap];
    };



    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string()
                                                                           ;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit basic_string(const allocator_type& __a);
    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);







    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string(const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string(size_type __n, value_type __c, const allocator_type& __a);
    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,
                 const allocator_type& __a = allocator_type());
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);







    ~basic_string();

    basic_string& operator=(const basic_string& __str);






    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 1358 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw()
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw()
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw()
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw()
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rbegin() throw()
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rbegin() const throw()
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reverse_iterator rend() throw()
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator rend() const throw()
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw()
        {return begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw()
        {return end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crbegin() const throw()
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_reverse_iterator crend() const throw()
        {return rend();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type size() const throw()
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type length() const throw() {return size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type capacity() const throw()
        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type res_arg = 0);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void shrink_to_fit() throw() {reserve();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool empty() const throw() {return size() == 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __pos) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __pos);

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& append(const basic_string& __str);
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        append(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        append(_ForwardIterator __first, _ForwardIterator __last);





    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void pop_back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference front();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference front() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference back();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference back() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& assign(const basic_string& __str);





    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            basic_string&
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& insert(size_type __pos1, const basic_string& __str);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
             __is_input_iterator <_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
        typename enable_if
        <
            __is_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);






    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
        typename enable_if
        <
            __is_input_iterator<_InputIterator>::value,
            basic_string&
        >::type
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);






    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_string& __str)

                                                                 ;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* c_str() const throw() {return data();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const value_type* data() const throw() {return std::__1::__to_raw_pointer(__get_pointer());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw() {return __alloc();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find(const value_type* __s, size_type __pos = 0) const throw();
    size_type find(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const throw();
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const throw();
    size_type rfind(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const throw();
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const throw();
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const basic_string& __str) const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const;
    int compare(const value_type* __s) const throw();
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __is_long() const throw()
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1642 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type& __alloc() throw()
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const throw()
        {return __r_.second();}
# 1670 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_short_size(size_type __s) throw()



        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_short_size() const throw()



        {return __r_.first().__s.__size_ >> 1;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_size(size_type __s) throw()
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_size() const throw()
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_size(size_type __s) throw()
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_cap(size_type __s) throw()
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __get_long_cap() const throw()
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __set_long_pointer(pointer __p) throw()
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_long_pointer() throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_long_pointer() const throw()
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_short_pointer() throw()
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_short_pointer() const throw()
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer __get_pointer() throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_pointer __get_pointer() const throw()
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __zero() throw()
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        size_type __align_it(size_type __s) throw()
            {return __s + (__a-1) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type __recommend(size_type __s) throw()
        {return (__s < __min_cap ? __min_cap :
                 __align_it<sizeof(value_type) < __alignment ?
                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}

    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    void __init(const value_type* __s, size_type __sz);
    void __init(size_type __n, value_type __c);

    template <class _InputIterator>
    typename enable_if
    <
         __is_input_iterator <_InputIterator>::value &&
        !__is_forward_iterator<_InputIterator>::value,
        void
    >::type
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    typename enable_if
    <
        __is_forward_iterator<_ForwardIterator>::value,
        void
    >::type
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __erase_to_end(size_type __pos);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() != __str.__alloc())
            {
                clear();
                shrink_to_fit();
            }
            __alloc() = __str.__alloc();
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const basic_string&, false_type) throw()
        {}
# 1804 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    __move_assign_alloc(basic_string& __str)



    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string& __c, true_type)

        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(basic_string&, false_type)
        throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y)


        {__swap_alloc(__x, __y, integral_constant<bool,
                      __alloc_traits::propagate_on_container_swap::value>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)

        {
            using std::__1::swap;
            swap(__x, __y);
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void __swap_alloc(allocator_type&, allocator_type&, false_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1891 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string()

{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)
    : __r_(__a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)
    : __r_(__a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)
    : __r_(__a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());



}
# 2070 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)
    : __r_(__a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();

    try
    {

    for (; __first != __last; ++__first)
        push_back(*__first);

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    void
>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__a)
{
    __init(__first, __last);



}
# 2237 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p),
                          std::__1::__to_raw_pointer(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                          std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    if (__cap >= __n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        traits_type::move(__p, __s, __n);
        traits_type::assign(__p[__n], value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        size_type __sz = size();
        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
    if (this != &__str)
    {
        __copy_assign_alloc(__str);
        assign(__str);
    }
    return *this;
}
# 2424 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)
{
    return assign(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return assign(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)
{
    for (; __first != __last; ++__first)
        push_back(*__first);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer() + __sz;
        for (; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
        traits_type::assign(*__p, value_type());
        __set_size(__sz + __n);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
     __is_input_iterator <_InputIterator>::value &&
    !__is_forward_iterator<_InputIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    size_type __old_sz = size();
    difference_type __ip = __pos - begin();
    for (; __first != __last; ++__first)
        push_back(*__first);
    pointer __p = __get_pointer();
    std::__1::rotate(__p + __ip, __p + __old_sz, __p + size());



    return iterator(__p + __ip);

}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
typename enable_if
<
    __is_forward_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_raw_pointer(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__1::__to_raw_pointer(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:
        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_raw_pointer(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
typename enable_if
<
    __is_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    for (; true; ++__i1, ++__j1)
    {
        if (__i1 == __i2)
        {
            if (__j1 != __j2)
                insert(__i1, __j1, __j2);
            break;
        }
        if (__j1 == __j2)
        {
            erase(__i1, __i2);
            break;
        }
        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        value_type* __p = std::__1::__to_raw_pointer(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::clear() throw()
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const throw()
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)
{
    if (__res_arg > max_size())
        this->__throw_length_error();
    size_type __cap = capacity();
    size_type __sz = size();
    __res_arg = std::__1::max(__res_arg, __sz);
    __res_arg = __recommend(__res_arg);
    if (__res_arg != __cap)
    {
        pointer __new_data, __p;
        bool __was_long, __now_long;
        if (__res_arg == __min_cap - 1)
        {
            __was_long = true;
            __now_long = false;
            __new_data = __get_short_pointer();
            __p = __get_long_pointer();
        }
        else
        {
            if (__res_arg > __cap)
                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);
            else
            {

                try
                {

                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);

                }
                catch (...)
                {
                    return;
                }




            }
            __now_long = true;
            __was_long = __is_long();
            __p = __get_pointer();
        }
        traits_type::copy(std::__1::__to_raw_pointer(__new_data),
                          std::__1::__to_raw_pointer(__p), size()+1);
        if (__was_long)
            __alloc_traits::deallocate(__alloc(), __p, __cap+1);
        if (__now_long)
        {
            __set_long_cap(__res_arg+1);
            __set_long_size(__sz);
            __set_long_pointer(__new_data);
        }
        else
            __set_short_size(__sz);
        __invalidate_all_iterators();
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front()
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back()
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)


{







    std::__1::swap(__r_.first(), __str.__r_.first());
    __swap_alloc(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const char_type& __x, const char_type& __y) throw()
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const throw()
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz || __sz - __pos < __n)
        return npos;
    if (__n == 0)
        return __pos;
    const value_type* __p = data();
    const value_type* __r = std::__1::search(__p + __pos, __p + __sz, __s, __s + __n,
                                     __traits_eq<traits_type>());
    if (__r == __p + __sz)
        return npos;
    return static_cast<size_type>(__r - __p);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const throw()
{
    return find(__str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const throw()
{
    ((void)0);
    return find(__s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const throw()
{
    size_type __sz = size();
    if (__pos >= __sz)
        return npos;
    const value_type* __p = data();
    const value_type* __r = traits_type::find(__p + __pos, __sz - __pos, __c);
    if (__r == 0)
        return npos;
    return static_cast<size_type>(__r - __p);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const throw()
{
    ((void)0);
    size_type __sz = size();
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const value_type* __p = data();
    const value_type* __r = std::__1::find_end(__p, __p + __pos, __s, __s + __n,
                                       __traits_eq<traits_type>());
    if (__n > 0 && __r == __p + __pos)
        return npos;
    return static_cast<size_type>(__r - __p);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const throw()
{
    return rfind(__str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const throw()
{
    ((void)0);
    return rfind(__s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const throw()
{
    size_type __sz = size();
    if (__sz)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        const value_type* __p = data();
        for (const value_type* __ps = __p + __pos; __ps != __p;)
        {
            if (traits_type::eq(*--__ps, __c))
                return static_cast<size_type>(__ps - __p);
        }
    }
    return npos;
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_first_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const throw()
{
    return std::__1::__find_first_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_first_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const throw()
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_last_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const throw()
{
    return std::__1::__find_last_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_last_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const throw()
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const throw()
{
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const throw()
{
    return std::__1::__find_first_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const throw()
{
    ((void)0);
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const throw()
{
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const throw()
{
    ((void)0);
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const throw()
{
    return std::__1::__find_last_not_of<value_type, size_type, traits_type, npos>
     (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const throw()
{
    size_t __lhs_sz = size();
    size_t __rhs_sz = __str.size();
    int __result = traits_type::compare(data(), __str.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    size_type __sz = __str.size();
    if (__pos2 > __sz)
        this->__throw_out_of_range();
    return compare(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2,
                                                                  __sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const throw()
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == 0)
        return false;
    if (data()[size()] != value_type(0))
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) throw()
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) == 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs == __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs.compare(__lhs) > 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return __rhs < __lhs;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__rhs < __lhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) throw()
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw()
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}
# 4059 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)

{
    __lhs.swap(__rhs);
}



typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;



__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const string& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) string to_string(long double __val);

__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = 0);
__attribute__ ((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = 0);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
                   basic_string<_CharT, _Traits, _Allocator>::npos;

template<class _CharT, class _Traits, class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string<_CharT, _Traits, _Allocator> >
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>
{
    size_t
        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const throw();
};

template<class _CharT, class _Traits, class _Allocator>
size_t
hash<basic_string<_CharT, _Traits, _Allocator> >::operator()(
        const basic_string<_CharT, _Traits, _Allocator>& __val) const throw()
{
    return __do_string_hash(__val.data(), __val.data() + __val.size());
}

template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4242 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
extern template class __attribute__ ((__type_visibility__("default"))) basic_string<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_string<wchar_t>;
extern template string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

} }
# 24 "/usr/local/include/glm/./gtx/string_cast.hpp" 2 3
# 34 "/usr/local/include/glm/./gtx/string_cast.hpp" 3
namespace glm
{





 template <template <typename, precision> class matType, typename T, precision P>
               std::string to_string(matType<T, P> const & x);


}


# 1 "/usr/local/include/glm/./gtx/string_cast.inl" 1 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdarg" 1 3
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdarg" 3


namespace std {inline namespace __1 {

using ::va_list;

} }
# 4 "/usr/local/include/glm/./gtx/string_cast.inl" 2 3



namespace glm{
namespace detail
{ inline
                    std::string format(const char* msg, ...)
 {
  std::size_t const STRING_BUFFER(4096);
  char text[STRING_BUFFER];
  va_list list;

  if(msg == 0)
   return std::string();

  __builtin_va_start(list, msg);



   vsprintf(text, msg, list);

  __builtin_va_end(list);

  return std::string(text);
 }

 static const char* LabelTrue = "true";
 static const char* LabelFalse = "false";

 template <typename T, bool isFloat = false>
 struct literal
 { inline
                     static char const * value() {return "%d";};
 };

 template <typename T>
 struct literal<T, true>
 { inline
                     static char const * value() {return "%f";};
 };
# 59 "/usr/local/include/glm/./gtx/string_cast.inl" 3
 template <typename T>
 struct prefix{};

 template <>
 struct prefix<float>
 { inline
                     static char const * value() {return "";};
 };

 template <>
 struct prefix<double>
 { inline
                     static char const * value() {return "d";};
 };

 template <>
 struct prefix<bool>
 { inline
                     static char const * value() {return "b";};
 };

 template <>
 struct prefix<uint8_t>
 { inline
                     static char const * value() {return "u8";};
 };

 template <>
 struct prefix<int8_t>
 { inline
                     static char const * value() {return "i8";};
 };

 template <>
 struct prefix<uint16_t>
 { inline
                     static char const * value() {return "u16";};
 };

 template <>
 struct prefix<int16_t>
 { inline
                     static char const * value() {return "i16";};
 };

 template <>
 struct prefix<uint32_t>
 { inline
                     static char const * value() {return "u";};
 };

 template <>
 struct prefix<int32_t>
 { inline
                     static char const * value() {return "i";};
 };

 template <>
 struct prefix<uint64_t>
 { inline
                     static char const * value() {return "u64";};
 };

 template <>
 struct prefix<int64_t>
 { inline
                     static char const * value() {return "i64";};
 };

 template <template <typename, precision> class matType, typename T, precision P>
 struct compute_to_string
 {};

 template <precision P>
 struct compute_to_string<tvec1, bool, P>
 { inline
                     static std::string call(tvec1<bool, P> const & x)
  {
   return detail::format("bvec1(%s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <precision P>
 struct compute_to_string<tvec2, bool, P>
 { inline
                     static std::string call(tvec2<bool, P> const & x)
  {
   return detail::format("bvec2(%s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <precision P>
 struct compute_to_string<tvec3, bool, P>
 { inline
                     static std::string call(tvec3<bool, P> const & x)
  {
   return detail::format("bvec3(%s, %s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse,
    x[2] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <precision P>
 struct compute_to_string<tvec4, bool, P>
 { inline
                     static std::string call(tvec4<bool, P> const & x)
  {
   return detail::format("bvec4(%s, %s, %s, %s)",
    x[0] ? detail::LabelTrue : detail::LabelFalse,
    x[1] ? detail::LabelTrue : detail::LabelFalse,
    x[2] ? detail::LabelTrue : detail::LabelFalse,
    x[3] ? detail::LabelTrue : detail::LabelFalse);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec1, T, P>
 { inline
                     static std::string call(tvec1<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec1(%s)",
    PrefixStr,
    LiteralStr));

   return detail::format(FormatStr.c_str(), x[0]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec2, T, P>
 { inline
                     static std::string call(tvec2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec2(%s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec3, T, P>
 { inline
                     static std::string call(tvec3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec3(%s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1], x[2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tvec4, T, P>
 { inline
                     static std::string call(tvec4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%svec4(%s, %s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1], x[2], x[3]);
  }
 };


 template <typename T, precision P>
 struct compute_to_string<tmat2x2, T, P>
 { inline
                     static std::string call(tmat2x2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x2((%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1],
    x[1][0], x[1][1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat2x3, T, P>
 { inline
                     static std::string call(tmat2x3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x3((%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2],
    x[1][0], x[1][1], x[1][2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat2x4, T, P>
 { inline
                     static std::string call(tmat2x4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat2x4((%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2], x[0][3],
    x[1][0], x[1][1], x[1][2], x[1][3]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat3x2, T, P>
 { inline
                     static std::string call(tmat3x2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x2((%s, %s), (%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1],
    x[1][0], x[1][1],
    x[2][0], x[2][1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat3x3, T, P>
 { inline
                     static std::string call(tmat3x3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2],
    x[1][0], x[1][1], x[1][2],
    x[2][0], x[2][1], x[2][2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat3x4, T, P>
 { inline
                     static std::string call(tmat3x4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat3x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2], x[0][3],
    x[1][0], x[1][1], x[1][2], x[1][3],
    x[2][0], x[2][1], x[2][2], x[2][3]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat4x2, T, P>
 { inline
                     static std::string call(tmat4x2<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x2((%s, %s), (%s, %s), (%s, %s), (%s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr,
    LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1],
    x[1][0], x[1][1],
    x[2][0], x[2][1],
    x[3][0], x[3][1]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat4x3, T, P>
 { inline
                     static std::string call(tmat4x3<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x3((%s, %s, %s), (%s, %s, %s), (%s, %s, %s), (%s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2],
    x[1][0], x[1][1], x[1][2],
    x[2][0], x[2][1], x[2][2],
    x[3][0], x[3][1], x[3][2]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tmat4x4, T, P>
 { inline
                     static std::string call(tmat4x4<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%smat4x4((%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(),
    x[0][0], x[0][1], x[0][2], x[0][3],
    x[1][0], x[1][1], x[1][2], x[1][3],
    x[2][0], x[2][1], x[2][2], x[2][3],
    x[3][0], x[3][1], x[3][2], x[3][3]);
  }
 };


 template <typename T, precision P>
 struct compute_to_string<tquat, T, P>
 { inline
                     static std::string call(tquat<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%squat(%s, %s, %s, %s)",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x[0], x[1], x[2], x[3]);
  }
 };

 template <typename T, precision P>
 struct compute_to_string<tdualquat, T, P>
 { inline
                     static std::string call(tdualquat<T, P> const & x)
  {
   char const * PrefixStr = prefix<T>::value();
   char const * LiteralStr = literal<T, std::numeric_limits<T>::is_iec559>::value();
   std::string FormatStr(detail::format("%sdualquat((%s, %s, %s, %s), (%s, %s, %s, %s))",
    PrefixStr,
    LiteralStr, LiteralStr, LiteralStr, LiteralStr));

   return detail::format(FormatStr.c_str(), x.real[0], x.real[1], x.real[2], x.real[3], x.dual[0], x.dual[1], x.dual[2], x.dual[3]);
  }
 };

}

template <template <typename, precision> class matType, typename T, precision P> inline
                   std::string to_string(matType<T, P> const & x)
{
 return detail::compute_to_string<matType, T, P>::call(x);
}

}
# 47 "/usr/local/include/glm/./gtx/string_cast.hpp" 2 3
# 102 "/usr/local/include/glm/ext.hpp" 2 3



# 1 "/usr/local/include/glm/./gtx/transform2.hpp" 1 3
# 24 "/usr/local/include/glm/./gtx/transform2.hpp" 3
namespace glm
{





 template <typename T, precision P>
               tmat3x3<T, P> shearX2D(
  tmat3x3<T, P> const & m,
  T y);



 template <typename T, precision P>
               tmat3x3<T, P> shearY2D(
  tmat3x3<T, P> const & m,
  T x);



 template <typename T, precision P>
               tmat4x4<T, P> shearX3D(
  const tmat4x4<T, P> & m,
  T y,
  T z);



 template <typename T, precision P>
               tmat4x4<T, P> shearY3D(
  const tmat4x4<T, P> & m,
  T x,
  T z);



 template <typename T, precision P>
               tmat4x4<T, P> shearZ3D(
  const tmat4x4<T, P> & m,
  T x,
  T y);
# 77 "/usr/local/include/glm/./gtx/transform2.hpp" 3
 template <typename T, precision P>
               tmat3x3<T, P> proj2D(
  const tmat3x3<T, P> & m,
  const tvec3<T, P>& normal);



 template <typename T, precision P>
               tmat4x4<T, P> proj3D(
  const tmat4x4<T, P> & m,
  const tvec3<T, P>& normal);



 template <typename valType, precision P>
               tmat4x4<valType, P> scaleBias(
  valType scale,
  valType bias);



 template <typename valType, precision P>
               tmat4x4<valType, P> scaleBias(
  tmat4x4<valType, P> const & m,
  valType scale,
  valType bias);


}


# 1 "/usr/local/include/glm/./gtx/transform2.inl" 1 3



namespace glm
{
 template <typename T, precision P> inline
                    tmat3x3<T, P> shearX2D(tmat3x3<T, P> const& m, T s)
 {
  tmat3x3<T, P> r(1);
  r[1][0] = s;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> shearY2D(tmat3x3<T, P> const& m, T s)
 {
  tmat3x3<T, P> r(1);
  r[0][1] = s;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> shearX3D(tmat4x4<T, P> const& m, T s, T t)
 {
  tmat4x4<T, P> r(1);
  r[0][1] = s;
  r[0][2] = t;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> shearY3D(tmat4x4<T, P> const& m, T s, T t)
 {
  tmat4x4<T, P> r(1);
  r[1][0] = s;
  r[1][2] = t;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> shearZ3D(tmat4x4<T, P> const& m, T s, T t)
 {
  tmat4x4<T, P> r(1);
  r[2][0] = s;
  r[2][1] = t;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> reflect2D(tmat3x3<T, P> const& m, tvec3<T, P> const& normal)
 {
  tmat3x3<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - static_cast<T>(2) * normal.x * normal.x;
  r[0][1] = -static_cast<T>(2) * normal.x * normal.y;
  r[1][0] = -static_cast<T>(2) * normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - static_cast<T>(2) * normal.y * normal.y;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> reflect3D(tmat4x4<T, P> const& m, tvec3<T, P> const& normal)
 {
  tmat4x4<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - static_cast<T>(2) * normal.x * normal.x;
  r[0][1] = -static_cast<T>(2) * normal.x * normal.y;
  r[0][2] = -static_cast<T>(2) * normal.x * normal.z;

  r[1][0] = -static_cast<T>(2) * normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - static_cast<T>(2) * normal.y * normal.y;
  r[1][2] = -static_cast<T>(2) * normal.y * normal.z;

  r[2][0] = -static_cast<T>(2) * normal.x * normal.z;
  r[2][1] = -static_cast<T>(2) * normal.y * normal.z;
  r[2][2] = static_cast<T>(1) - static_cast<T>(2) * normal.z * normal.z;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat3x3<T, P> proj2D(
  const tmat3x3<T, P>& m,
  const tvec3<T, P>& normal)
 {
  tmat3x3<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - normal.x * normal.x;
  r[0][1] = - normal.x * normal.y;
  r[1][0] = - normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - normal.y * normal.y;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> proj3D(
  const tmat4x4<T, P>& m,
  const tvec3<T, P>& normal)
 {
  tmat4x4<T, P> r(static_cast<T>(1));
  r[0][0] = static_cast<T>(1) - normal.x * normal.x;
  r[0][1] = - normal.x * normal.y;
  r[0][2] = - normal.x * normal.z;
  r[1][0] = - normal.x * normal.y;
  r[1][1] = static_cast<T>(1) - normal.y * normal.y;
  r[1][2] = - normal.y * normal.z;
  r[2][0] = - normal.x * normal.z;
  r[2][1] = - normal.y * normal.z;
  r[2][2] = static_cast<T>(1) - normal.z * normal.z;
  return m * r;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scaleBias(T scale, T bias)
 {
  tmat4x4<T, P> result;
  result[3] = tvec4<T, P>(tvec3<T, P>(bias), static_cast<T>(1));
  result[0][0] = scale;
  result[1][1] = scale;
  result[2][2] = scale;
  return result;
 }

 template <typename T, precision P> inline
                    tmat4x4<T, P> scaleBias(tmat4x4<T, P> const& m, T scale, T bias)
 {
  return m * scaleBias(scale, bias);
 }
}
# 107 "/usr/local/include/glm/./gtx/transform2.hpp" 2 3
# 105 "/usr/local/include/glm/ext.hpp" 2 3

# 1 "/usr/local/include/glm/./gtx/vector_angle.hpp" 1 3
# 27 "/usr/local/include/glm/./gtx/vector_angle.hpp" 3
namespace glm
{






 template <typename vecType>
               typename vecType::value_type angle(
  vecType const & x,
  vecType const & y);




 template <typename T, precision P>
               T orientedAngle(
  tvec2<T, P> const & x,
  tvec2<T, P> const & y);




 template <typename T, precision P>
               T orientedAngle(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  tvec3<T, P> const & ref);


}


# 1 "/usr/local/include/glm/./gtx/vector_angle.inl" 1 3



namespace glm
{
 template <typename genType> inline
                    genType angle
 (
  genType const & x,
  genType const & y
 )
 {
                                                                                                         ;
  return acos(clamp(dot(x, y), genType(-1), genType(1)));
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    T angle
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
                                                                                                   ;
  return acos(clamp(dot(x, y), T(-1), T(1)));
 }


 template <typename T, precision P> inline
                    T orientedAngle
 (
  tvec2<T, P> const & x,
  tvec2<T, P> const & y
 )
 {
                                                                                                           ;
  T const Angle(acos(clamp(dot(x, y), T(-1), T(1))));

  if(all(epsilonEqual(y, glm::rotate(x, Angle), T(0.0001))))
   return Angle;
  else
   return -Angle;
 }

 template <typename T, precision P> inline
                    T orientedAngle
 (
  tvec3<T, P> const & x,
  tvec3<T, P> const & y,
  tvec3<T, P> const & ref
 )
 {
                                                                                                           ;

  T const Angle(acos(clamp(dot(x, y), T(-1), T(1))));
  return mix(Angle, -Angle, dot(ref, cross(x, y)) < T(0));
 }
}
# 60 "/usr/local/include/glm/./gtx/vector_angle.hpp" 2 3
# 106 "/usr/local/include/glm/ext.hpp" 2 3


# 1 "/usr/local/include/glm/./gtx/wrap.hpp" 1 3
# 23 "/usr/local/include/glm/./gtx/wrap.hpp" 3
namespace glm
{





 template <typename genType>
               genType clamp(genType const& Texcoord);



 template <typename genType>
               genType repeat(genType const& Texcoord);



 template <typename genType>
               genType mirrorClamp(genType const& Texcoord);



 template <typename genType>
               genType mirrorRepeat(genType const& Texcoord);


}


# 1 "/usr/local/include/glm/./gtx/wrap.inl" 1 3



namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> clamp(vecType<T, P> const& Texcoord)
 {
  return glm::clamp(Texcoord, vecType<T, P>(0), vecType<T, P>(1));
 }

 template <typename genType> inline
                    genType clamp(genType const & Texcoord)
 {
  return clamp(tvec1<genType, defaultp>(Texcoord)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> repeat(vecType<T, P> const& Texcoord)
 {
  return glm::fract(Texcoord);
 }

 template <typename genType> inline
                    genType repeat(genType const & Texcoord)
 {
  return repeat(tvec1<genType, defaultp>(Texcoord)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mirrorClamp(vecType<T, P> const& Texcoord)
 {
  return glm::fract(glm::abs(Texcoord));
 }

 template <typename genType> inline
                    genType mirrorClamp(genType const & Texcoord)
 {
  return mirrorClamp(tvec1<genType, defaultp>(Texcoord)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType> inline
                    vecType<T, P> mirrorRepeat(vecType<T, P> const& Texcoord)
 {
  vecType<T, P> const Abs = glm::abs(Texcoord);
  vecType<T, P> const Clamp = glm::mod(glm::floor(Abs), vecType<T, P>(2));
  vecType<T, P> const Floor = glm::floor(Abs);
  vecType<T, P> const Rest = Abs - Floor;
  vecType<T, P> const Mirror = Clamp + Rest;
  return mix(Rest, vecType<T, P>(1) - Rest, glm::greaterThanEqual(Mirror, vecType<T, P>(1)));
 }

 template <typename genType> inline
                    genType mirrorRepeat(genType const& Texcoord)
 {
  return mirrorRepeat(tvec1<genType, defaultp>(Texcoord)).x;
 }
}
# 51 "/usr/local/include/glm/./gtx/wrap.hpp" 2 3
# 108 "/usr/local/include/glm/ext.hpp" 2 3
# 15 "./common_utils_cpp.hpp" 2



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 1 3
# 118 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 1 3
# 17 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 2 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 3


namespace std {inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator ~() const throw()
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(bool __x) throw()
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference& operator=(const __bit_reference& __x) throw()
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false> operator&() const throw()
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__bit_reference<_Cp> __x, bool& __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(bool& __x, __bit_reference<_Cp> __y) throw()
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;


    friend typename _Cp::__self;



    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) throw()
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const throw()
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, true> operator&() const throw()
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))

    __bit_const_reference(__storage_pointer __s, __storage_type __m) throw()
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference& __x);
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return _It(__first.__seg_, __first.__ctz_ + __n);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
        if (__n == __dn)
            return _It(__first.__seg_, __first.__ctz_ + __n);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__pop_count(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__pop_count(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__pop_count(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            __fill_n_true(__first, __n);
        else
            __fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return __copy_aligned(__first, __last, __result);
    return __copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                       std::__1::__to_raw_pointer(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const unsigned __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return __copy_backward_aligned(__first, __last, __result);
    return __copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    static const unsigned __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __swap_ranges_aligned(__first1, __last1, __first2);
    return __swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"), __always_inline__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const unsigned __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return __equal_aligned(__first1, __last1, __first2);
    return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator() throw()



    {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) throw()
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) throw()
        : __seg_(__s), __ctz_(__ctz) {}


    friend typename _Cp::__self;



    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 2 3
# 132 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 133 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 2 3

namespace std {inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const throw();
    bool any() const throw();
    size_t __hash_code() const throw();
private:

    void __init(unsigned long long __v, false_type) throw();
    void __init(unsigned long long __v, true_type) throw();

    unsigned long to_ulong(false_type) const;
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    unsigned long long to_ullong(true_type) const;
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset() throw()



{

    std::__1::fill_n(__first_, _N_words, __storage_type(0));

}



template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) throw()
{
    __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
    for (size_t __i = 0; __i < sizeof(__t)/sizeof(__t[0]); ++__i, __v >>= __bits_per_word)
        __t[__i] = static_cast<__storage_type>(__v);
    std::__1::copy(__t, __t + sizeof(__t)/sizeof(__t[0]), __first_);
    std::__1::fill(__first_ + sizeof(__t)/sizeof(__t[0]), __first_ + sizeof(__first_)/sizeof(__first_[0]),
               __storage_type(0));
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::__init(unsigned long long __v, true_type) throw()
{
    __first_[0] = __v;
    std::__1::fill(__first_ + 1, __first_ + sizeof(__first_)/sizeof(__first_[0]), __storage_type(0));
}



template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<_N_words, _Size>::__bitset(unsigned long long __v) throw()
# 260 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bitset" 3
{

    __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());

}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) throw()
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() throw()
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)

        throw overflow_error("bitset to_ulong overflow error");



    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)

        throw overflow_error("bitset to_ullong overflow error");



    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const throw()
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<_N_words, _Size>::__hash_code() const throw()
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long __v) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) throw()
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t __pos) const throw()
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) throw()
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t __pos) const throw()
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    void operator&=(const __bitset& __v) throw();
    void operator|=(const __bitset& __v) throw();
    void operator^=(const __bitset& __v) throw();

    void flip() throw();

    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;

    bool all() const throw();
    bool any() const throw();

    size_t __hash_code() const throw();
};

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset() throw()
    : __first_(0)
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<1, _Size>::__bitset(unsigned long long __v) throw()
    : __first_(static_cast<__storage_type>(__v))
{
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator&=(const __bitset& __v) throw()
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator|=(const __bitset& __v) throw()
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::operator^=(const __bitset& __v) throw()
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__bitset<1, _Size>::flip() throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::all() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__bitset<1, _Size>::any() const throw()
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__bitset<1, _Size>::__hash_code() const throw()
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

                      __bitset() throw();
    explicit __bitset(unsigned long long) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t) throw()
        {return reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_reference __make_ref(size_t) const throw()
        {return const_reference(0, 1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t) throw()
        {return iterator(0, 0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t) const throw()
        {return const_iterator(0, 0);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator&=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator|=(const __bitset&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator^=(const __bitset&) throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void flip() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool all() const throw() {return true;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool any() const throw() {return false;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t __hash_code() const throw() {return 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset() throw()
{
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))

__bitset<0, 0>::__bitset(unsigned long long) throw()
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) bitset() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        bitset(unsigned long long __v) throw() : base(__v) {}
    template<class _CharT>
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    bitset& operator&=(const bitset& __rhs) throw();
    bitset& operator|=(const bitset& __rhs) throw();
    bitset& operator^=(const bitset& __rhs) throw();
    bitset& operator<<=(size_t __pos) throw();
    bitset& operator>>=(size_t __pos) throw();
    bitset& set() throw();
    bitset& set(size_t __pos, bool __val = true);
    bitset& reset() throw();
    bitset& reset(size_t __pos);
    bitset operator~() const throw();
    bitset& flip() throw();
    bitset& flip(size_t __pos);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    size_t count() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_t size() const throw() {return _Size;}
    bool operator==(const bitset& __rhs) const throw();
    bool operator!=(const bitset& __rhs) const throw();
    bool test(size_t __pos) const;
    bool all() const throw();
    bool any() const throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool none() const throw() {return !any();}
    bitset operator<<(size_t __pos) const throw();
    bitset operator>>(size_t __pos) const throw();

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t __hash_code() const throw() {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)

            throw invalid_argument("bitset string ctor has invalid argument");



    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())

        throw out_of_range("bitset string pos out of range");



    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))

            throw invalid_argument("bitset string ctor has invalid argument");



    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) throw()
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) throw()
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) throw()
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) throw()
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::set() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)

        throw out_of_range("bitset set argument out of range");



    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::reset() throw()
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)

        throw out_of_range("bitset reset argument out of range");



    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator~() const throw()
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>&
bitset<_Size>::flip() throw()
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)

        throw out_of_range("bitset flip argument out of range");



    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
bitset<_Size>::count() const throw()
{
    return static_cast<size_t>(std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator==(const bitset& __rhs) const throw()
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::operator!=(const bitset& __rhs) const throw()
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)

        throw out_of_range("bitset test argument out of range");



    return (*this)[__pos];
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::all() const throw()
{
    return base::all();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
bitset<_Size>::any() const throw()
{
    return base::any();
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const throw()
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const throw()
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) throw()
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const bitset<_Size>& __bs) const throw()
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 19 "./common_utils_cpp.hpp" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 1 3
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 1 3
# 216 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 1 3
# 176 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 1 3
# 15 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 1 3
# 281 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 1 3
# 73 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 74 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 2 3
# 77 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3


namespace std {inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp <= max - _Yp)>)> __t130;
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(min - _Yp <= _Xp)>)> __t148;
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(min + _Yp <= _Xp)>)> __t162;
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp <= max + _Yp)>)> __t180;
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp != nan && _Yp != nan && __a_x <= max / __a_y)>)> __t194;
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    typedef __static_assert_check<sizeof(__static_assert_test<(_Xp != nan && _Yp != nan && _Yp != 0)>)> __t228;
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    typedef __static_assert_check<sizeof(__static_assert_test<(__static_abs<_Num>::value >= 0)>)> __t236;
    typedef __static_assert_check<sizeof(__static_assert_test<(_Den != 0)>)> __t237;
    typedef __static_assert_check<sizeof(__static_assert_test<(__static_abs<_Den>::value > 0)>)> __t238;
    static const intmax_t __na = __static_abs<_Num>::value;
    static const intmax_t __da = __static_abs<_Den>::value;
    static const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static const intmax_t num = __s * __na / __gcd;
    static const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den> const intmax_t ratio<_Num, _Den>::num;
template <intmax_t _Num, intmax_t _Den> const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};
# 294 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_multiply
    : public __ratio_multiply<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};
# 321 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_divide
    : public __ratio_divide<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
# 356 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_add
    : public __ratio_add<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
# 391 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_subtract
    : public __ratio_subtract<_R1, _R2>::type {};





template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public integral_constant<bool, _R1::num == _R2::num && _R1::den == _R2::den> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public integral_constant<bool, !ratio_equal<_R1, _R2>::value> {};



template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public integral_constant<bool, __ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public integral_constant<bool, !ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public integral_constant<bool, ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public integral_constant<bool, !ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};

} }
# 282 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 285 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3
# 288 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3


namespace std {inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep zero() {return _Rep(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep max() {return numeric_limits<_Rep>::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static _Rep min() {return numeric_limits<_Rep>::lowest();}
};



template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    typedef __static_assert_check<sizeof(__static_assert_test<(!__is_duration<_Rep>::value)>)> __t409;
    typedef __static_assert_check<sizeof(__static_assert_test<(__is_ratio<_Period>::value)>)> __t410;
    typedef __static_assert_check<sizeof(__static_assert_test<(_Period::num > 0)>)> __t411;

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef _Period period;
private:
    rep __rep_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))



        duration() {}


    template <class _Rep2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = 0)
                : __rep_(__r) {}


    template <class _Rep2, class _Period2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = 0)
                : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) rep count() const {return __rep_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator+() const {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator-() const {return duration(-__rep_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration zero() {return duration(duration_values<rep>::zero());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration min() {return duration(duration_values<rep>::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static duration max() {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;



template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}



template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
struct __duration_divide_result
{
};

template <class _Duration, class _Rep2,
    bool = is_convertible<_Rep2,
                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>
struct __duration_divide_imp
{
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>
{
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>
{
};

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}





template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    typedef __static_assert_check<sizeof(__static_assert_test<(__is_duration<_Duration>::value)>)> __t753;

public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point() : __d_(duration::zero()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit time_point(const duration& __d) : __d_(__d) {}


    template <class _Duration2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = 0)
            : __d_(t.time_since_epoch()) {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) duration time_since_epoch() const {return __d_;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) static time_point min() {return time_point(duration::min());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static time_point max() {return time_point(duration::max());}
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __lhs + (-__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class __attribute__ ((__type_visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady = false;

    static time_point now() throw();
    static time_t to_time_t (const time_point& __t) throw();
    static time_point from_time_t(time_t __t) throw();
};

class __attribute__ ((__type_visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static const bool is_steady = true;

    static time_point now() throw();
};

typedef steady_clock high_resolution_clock;

}
# 1025 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
} }
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 1 3
# 222 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 1 3
# 27 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 3
# 1 "/usr/include/errno.h" 1 3 4
# 23 "/usr/include/errno.h" 3 4
# 1 "/usr/include/sys/errno.h" 1 3 4
# 79 "/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}
# 24 "/usr/include/errno.h" 2 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 2 3
# 31 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 3
# 223 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 2 3
# 229 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 3


namespace std {inline namespace __1 {



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};





struct __attribute__ ((__type_visibility__("default"))) errc { enum __lx
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) errc(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc::__lx>
    : true_type { };


class __attribute__ ((__type_visibility__("default"))) error_condition;
class __attribute__ ((__type_visibility__("default"))) error_code;



class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__type_visibility__("default"))) error_category
{
public:
    virtual ~error_category() throw();




    __attribute__ ((__visibility__("hidden"), __always_inline__))
                                  error_category() throw() {};

private:
    error_category(const error_category&);
    error_category& operator=(const error_category&);

public:
    virtual const char* name() const throw() = 0;
    virtual error_condition default_error_condition(int __ev) const throw();
    virtual bool equivalent(int __code, const error_condition& __condition) const throw();
    virtual bool equivalent(const error_code& __code, int __condition) const throw();
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const error_category& __rhs) const throw() {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const error_category& __rhs) const throw() {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator< (const error_category& __rhs) const throw() {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() throw();
__attribute__ ((__visibility__("default"))) const error_category& system_category() throw();

class __attribute__ ((__type_visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition() throw() : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition(int __val, const error_category& __cat) throw()
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = 0
                                                                     ) throw()
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) throw()
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) throw()
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const throw() {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const throw() {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(errc __e) throw()
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_condition& __x, const error_condition& __y) throw()
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}



class __attribute__ ((__type_visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code() throw() : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_code(int __val, const error_category& __cat) throw()
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0
                                                                     ) throw()
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void assign(int __val, const error_category& __cat) throw()
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) throw()
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw()
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int value() const throw() {return __val_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_category& category() const throw() {return *__cat_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    error_condition default_error_condition() const throw()
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const throw() {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(errc __e) throw()
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const error_code& __x, const error_code& __y) throw()
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_code& __y) throw()
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_code& __x, const error_condition& __y) throw()
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_code& __y) throw()
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const error_condition& __x, const error_condition& __y) throw()
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_code& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_code& __x, const error_condition& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_code& __y) throw()
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const error_condition& __x, const error_condition& __y) throw()
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const error_code& __ec) const throw()
    {
        return static_cast<size_t>(__ec.value());
    }
};



class __attribute__ ((__type_visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    ~system_error() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const error_code& code() const throw() {return __ec_;}

private:
    static string __init(const error_code&, string);
};

__attribute__ ((__visibility__("default"))) void __throw_system_error(int ev, const char* what_arg);

} }
# 17 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 1 "/usr/include/pthread.h" 1 3 4
# 57 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/pthread_impl.h" 1 3 4
# 58 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/sched.h" 1 3 4
# 30 "/usr/include/sched.h" 3 4
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/sys/_types/_pthread_cond_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 63 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_condattr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 64 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_key_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 65 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_mutex_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 66 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_mutexattr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 67 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_once_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 68 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_rwlock_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 69 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sys/_types/_pthread_rwlockattr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 70 "/usr/include/pthread.h" 2 3 4




# 1 "/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 49 "/usr/include/sys/_types/_mach_port_t.h" 3 4
typedef __darwin_mach_port_t mach_port_t;
# 75 "/usr/include/pthread.h" 2 3 4
# 102 "/usr/include/pthread.h" 3 4
extern "C" {
# 206 "/usr/include/pthread.h" 3 4
__attribute__((availability(macosx,introduced=10.4)))
int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getscope(const pthread_attr_t * , int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstack(const pthread_attr_t * , void ** ,
  size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstackaddr(const pthread_attr_t * , void ** );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_init(pthread_cond_t * ,
  const pthread_condattr_t * ) __asm("_" "pthread_cond_init") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_timedwait(pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * ) __asm("_" "pthread_cond_timedwait") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm("_" "pthread_cond_wait") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_create(pthread_t * , const pthread_attr_t * ,
  void *(*)(void *), void * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_detach(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_equal(pthread_t, pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
void pthread_exit(void *) __attribute__((noreturn));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_getconcurrency(void);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_getschedparam(pthread_t , int * ,
  struct sched_param * );

__attribute__((availability(macosx,introduced=10.4)))
void* pthread_getspecific(pthread_key_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_join(pthread_t , void **) __asm("_" "pthread_join") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_key_create(pthread_key_t *, void (*)(void *));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_key_delete(pthread_key_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_once(pthread_once_t *, void (*)(void));

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macosx,introduced=10.4)))
pthread_t pthread_self(void);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype") ;

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setconcurrency(int);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_setspecific(pthread_key_t , const void *);

__attribute__((availability(macosx,introduced=10.4)))
void pthread_testcancel(void) __asm("_" "pthread_testcancel") ;




__attribute__((availability(macosx,introduced=10.4)))
int pthread_is_threaded_np(void);

__attribute__((availability(macosx,introduced=10.6)))
int pthread_threadid_np(pthread_t,__uint64_t*);


__attribute__((availability(macosx,introduced=10.6)))
int pthread_getname_np(pthread_t,char*,size_t);

__attribute__((availability(macosx,introduced=10.6)))
int pthread_setname_np(const char*);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_main_np(void);


__attribute__((availability(macosx,introduced=10.4)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macosx,introduced=10.4)))
void* pthread_get_stackaddr_np(pthread_t);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec *);


__attribute__((availability(macosx,introduced=10.4)))
int pthread_create_suspended_np(pthread_t *, const pthread_attr_t *,
  void *(*)(void *), void *);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_kill(pthread_t, int);

__attribute__((availability(macosx,introduced=10.5)))
pthread_t pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macosx,introduced=10.4)))
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask") ;

__attribute__((availability(macosx,introduced=10.4)))
void pthread_yield_np(void);


}
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) mutex
{
    pthread_mutex_t __m_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))



     mutex() throw() {__m_ = (pthread_mutex_t){0x32AAABA7, {0}};}

     ~mutex();

private:
    mutex(const mutex&);
    mutex& operator=(const mutex&);

public:
    void lock();
    bool try_lock() throw();
    void unlock() throw();

    typedef pthread_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__m_;}
};

struct __attribute__ ((__type_visibility__("default"))) defer_lock_t {};
struct __attribute__ ((__type_visibility__("default"))) try_to_lock_t {};
struct __attribute__ ((__type_visibility__("default"))) adopt_lock_t {};



extern const defer_lock_t defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t adopt_lock;
# 69 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type& __m_;
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit lock_guard(mutex_type& __m)
        : __m_(__m) {__m_.lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    lock_guard(mutex_type& __m, adopt_lock_t)
        : __m_(__m) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~lock_guard() {__m_.unlock();}

private:
    lock_guard(lock_guard const&);
    lock_guard& operator=(lock_guard const&);
};

template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock() throw() : __m_(std::__1::__get_nullptr_t()), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unique_lock(mutex_type& __m)
        : __m_(&__m), __owns_(true) {__m_->lock();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, defer_lock_t) throw()
        : __m_(&__m), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, try_to_lock_t)
        : __m_(&__m), __owns_(__m.try_lock()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unique_lock(mutex_type& __m, adopt_lock_t)
        : __m_(&__m), __owns_(true) {}
    template <class _Clock, class _Duration>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
            : __m_(&__m), __owns_(__m.try_lock_until(__t)) {}
    template <class _Rep, class _Period>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
            : __m_(&__m), __owns_(__m.try_lock_for(__d)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~unique_lock()
    {
        if (__owns_)
            __m_->unlock();
    }

private:
    unique_lock(unique_lock const&);
    unique_lock& operator=(unique_lock const&);

public:
# 157 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
    void lock();
    bool try_lock();

    template <class _Rep, class _Period>
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);

    void unlock();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(unique_lock& __u) throw()
    {
        std::__1::swap(__m_, __u.__m_);
        std::__1::swap(__owns_, __u.__owns_);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* release() throw()
    {
        mutex_type* __m = __m_;
        __m_ = std::__1::__get_nullptr_t();
        __owns_ = false;
        return __m;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool owns_lock() const throw() {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool () const throw() {return __owns_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    mutex_type* mutex() const throw() {return __m_;}
};

template <class _Mutex>
void
unique_lock<_Mutex>::lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::lock: already locked");
    __m_->lock();
    __owns_ = true;
}

template <class _Mutex>
bool
unique_lock<_Mutex>::try_lock()
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock: already locked");
    __owns_ = __m_->try_lock();
    return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool
unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_for(__d);
    return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool
unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    if (__m_ == std::__1::__get_nullptr_t())
        __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_until(__t);
    return __owns_;
}

template <class _Mutex>
void
unique_lock<_Mutex>::unlock()
{
    if (!__owns_)
        __throw_system_error(1, "unique_lock::unlock: not locked");
    __m_->unlock();
    __owns_ = false;
}

template <class _Mutex>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) throw()
    {__x.swap(__y);}


struct __attribute__ ((__type_visibility__("default"))) cv_status { enum __lx
{
    no_timeout,
    timeout
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) cv_status(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit cv_status(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

class __attribute__ ((__type_visibility__("default"))) condition_variable
{
    pthread_cond_t __cv_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))



    condition_variable() {__cv_ = (pthread_cond_t){0x3CB0B1BB, {0}};}

    ~condition_variable();

private:
    condition_variable(const condition_variable&);
    condition_variable& operator=(const condition_variable&);

public:
    void notify_one() throw();
    void notify_all() throw();

    void wait(unique_lock<mutex>& __lk);
    template <class _Predicate>
        void wait(unique_lock<mutex>& __lk, _Predicate __pred);

    template <class _Clock, class _Duration>
        cv_status
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t);

    template <class _Clock, class _Duration, class _Predicate>
        bool
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred);

    template <class _Rep, class _Period>
        cv_status
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d);

    template <class _Rep, class _Period, class _Predicate>
        bool
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d,
                 _Predicate __pred);

    typedef pthread_cond_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {return &__cv_;}

private:
    void __do_timed_wait(unique_lock<mutex>& __lk,
                 chrono::time_point<chrono::system_clock, chrono::nanoseconds>);
};

template <class _To, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    chrono::__is_duration<_To>::value,
    _To
>::type
__ceil(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    _To __r = duration_cast<_To>(__d);
    if (__r < __d)
        ++__r;
    return __r;
}

template <class _Predicate>
void
condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)
{
    while (!__pred())
        wait(__lk);
}

template <class _Clock, class _Duration>
cv_status
condition_variable::wait_until(unique_lock<mutex>& __lk,
                               const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    wait_for(__lk, __t - _Clock::now());
    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool
condition_variable::wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred)
{
    while (!__pred())
    {
        if (wait_until(__lk, __t) == cv_status::timeout)
            return __pred();
    }
    return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d)
{
    using namespace chrono;
    if (__d <= __d.zero())
        return cv_status::timeout;
    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;
    typedef time_point<system_clock, nanoseconds> __sys_tpi;
    __sys_tpf _Max = __sys_tpi::max();
    system_clock::time_point __s_now = system_clock::now();
    steady_clock::time_point __c_now = steady_clock::now();
    if (_Max - __d > __s_now)
        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
    else
        __do_timed_wait(__lk, __sys_tpi::max());
    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :
                                                 cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d,
                             _Predicate __pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}

} }
# 177 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 1 3
# 484 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3


namespace std {inline namespace __1 {




template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};
# 516 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};
# 541 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};
# 566 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};
# 591 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};
# 616 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};
# 641 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};
# 666 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};
# 691 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};
# 718 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};
# 743 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};
# 768 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};
# 793 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};
# 818 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};
# 843 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};
# 868 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};
# 893 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp>

struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};
# 935 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

                                  __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class __attribute__ ((__type_visibility__("default"))) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__ ((__type_visibility__("default"))) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__type_visibility__("default"))) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_03" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_03" 3


template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __mem_fn(type __f) : __f_(__f) {}



    typename __invoke_return<type>::type
       operator() ()
       {
           return __invoke(__f_);
       }

    template <class _A0>
       typename __invoke_return0<type, _A0>::type
          operator() (_A0& __a0)
          {
              return __invoke(__f_, __a0);
          }

    template <class _A0, class _A1>
       typename __invoke_return1<type, _A0, _A1>::type
          operator() (_A0& __a0, _A1& __a1)
          {
              return __invoke(__f_, __a0, __a1);
          }

    template <class _A0, class _A1, class _A2>
       typename __invoke_return2<type, _A0, _A1, _A2>::type
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          {
              return __invoke(__f_, __a0, __a1, __a2);
          }
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm)
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)()>
mem_fn(_Rp (_Tp::* __pm)())
{
    return __mem_fn<_Rp (_Tp::*)()>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0)>
mem_fn(_Rp (_Tp::* __pm)(_A0))
{
    return __mem_fn<_Rp (_Tp::*)(_A0)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1)>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2))
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2)>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const>
mem_fn(_Rp (_Tp::* __pm)() const)
{
    return __mem_fn<_Rp (_Tp::*)() const>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const>
mem_fn(_Rp (_Tp::* __pm)(_A0) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() volatile>
mem_fn(_Rp (_Tp::* __pm)() volatile)
{
    return __mem_fn<_Rp (_Tp::*)() volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) volatile>(__pm);
}

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)() const volatile>
mem_fn(_Rp (_Tp::* __pm)() const volatile)
{
    return __mem_fn<_Rp (_Tp::*)() const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1) const volatile>(__pm);
}

template<class _Rp, class _Tp, class _A0, class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>
mem_fn(_Rp (_Tp::* __pm)(_A0, _A1, _A2) const volatile)
{
    return __mem_fn<_Rp (_Tp::*)(_A0, _A1, _A2) const volatile>(__pm);
}



class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{
};

template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function;

namespace __function
{

template<class _Fp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Fp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template<class _Fp> class __base;

template<class _Rp>
class __base<_Rp()>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()() = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0>
class __base<_Rp(_A0)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0, class _A1>
class __base<_Rp(_A0, _A1)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _Rp, class _A0, class _A1, class _A2>
class __base<_Rp(_A0, _A1, _A2)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __base() {}
    virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_A0, _A1, _A2) = 0;

    virtual const void* target(const type_info&) const = 0;
    virtual const std::type_info& target_type() const = 0;

};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp>
class __func<_Fp, _Alloc, _Rp()>
    : public __base<_Rp()>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    explicit __func(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp()>* __clone() const;
    virtual void __clone(__base<_Rp()>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()();

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp>
__base<_Rp()>*
__func<_Fp, _Alloc, _Rp()>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::__clone(__base<_Rp()>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp>
void
__func<_Fp, _Alloc, _Rp()>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp>
_Rp
__func<_Fp, _Alloc, _Rp()>::operator()()
{
    return __invoke(__f_.first());
}



template<class _Fp, class _Alloc, class _Rp>
const void*
__func<_Fp, _Alloc, _Rp()>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp>
const std::type_info&
__func<_Fp, _Alloc, _Rp()>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0>
class __func<_Fp, _Alloc, _Rp(_A0)>
    : public __base<_Rp(_A0)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0>
__base<_Rp(_A0)>*
__func<_Fp, _Alloc, _Rp(_A0)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::__clone(__base<_Rp(_A0)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
void
__func<_Fp, _Alloc, _Rp(_A0)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
_Rp
__func<_Fp, _Alloc, _Rp(_A0)>::operator()(_A0 __a0)
{
    return __invoke(__f_.first(), __a0);
}



template<class _Fp, class _Alloc, class _Rp, class _A0>
const void*
__func<_Fp, _Alloc, _Rp(_A0)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0)>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
class __func<_Fp, _Alloc, _Rp(_A0, _A1)>
    : public __base<_Rp(_A0, _A1)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
__base<_Rp(_A0, _A1)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::__clone(__base<_Rp(_A0, _A1)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1)
{
    return __invoke(__f_.first(), __a0, __a1);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
const void*
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0, _A1)>::target_type() const
{
    return typeid(_Fp);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
class __func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>
    : public __base<_Rp(_A0, _A1, _A2)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f) : __f_(std::__1::move(__f)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __func(_Fp __f, _Alloc __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}
    virtual __base<_Rp(_A0, _A1, _A2)>* __clone() const;
    virtual void __clone(__base<_Rp(_A0, _A1, _A2)>*) const;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_A0, _A1, _A2);

    virtual const void* target(const type_info&) const;
    virtual const std::type_info& target_type() const;

};

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
__base<_Rp(_A0, _A1, _A2)>*
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::__clone(__base<_Rp(_A0, _A1, _A2)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
void
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::destroy_deallocate()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
_Rp
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2)
{
    return __invoke(__f_.first(), __a0, __a1, __a2);
}



template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
const void*
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::target(const type_info& __ti) const
{
    if (__ti == typeid(_Fp))
        return &__f_.first();
    return (const void*)0;
}

template<class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)>::target_type() const
{
    return typeid(_Fp);
}



}

template<class _Rp>
class __attribute__ ((__type_visibility__("default"))) function<_Rp()>
{
    typedef __function::__base<_Rp()> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2>
        static bool __not_null(const function<_Rp()>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2>
      bool operator==(const function<_R2()>&) const;
    template<class _R2>
      bool operator!=(const function<_R2()>&) const;
public:

    _Rp operator()() const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp>
function<_Rp()>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template<class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp>
template <class _Fp>
function<_Rp()>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
template <class _Fp, class _Alloc>
function<_Rp()>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp()> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>&
function<_Rp()>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp()>&
>::type
function<_Rp()>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp>
function<_Rp()>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp>
void
function<_Rp()>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp>
_Rp
function<_Rp()>::operator()() const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)();
}



template<class _Rp>
const std::type_info&
function<_Rp()>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp>
template <typename _Tp>
_Tp*
function<_Rp()>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp>
template <typename _Tp>
const _Tp*
function<_Rp()>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0)>
    : public unary_function<_A0, _Rp>
{
    typedef __function::__base<_Rp(_A0)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0)) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)()) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() volatile) {return __p;}
    template <class _R2, class _Cp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)() const volatile) {return __p;}
    template <class _R2, class _B0>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_Rp(_B0)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2, class _B0>
      bool operator==(const function<_R2(_B0)>&) const;
    template<class _R2, class _B0>
      bool operator!=(const function<_R2(_B0)>&) const;
public:

    _Rp operator()(_A0) const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0>
function<_Rp(_A0)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template<class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0>
template <class _Fp>
function<_Rp(_A0)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
template <class _Fp, class _Alloc>
function<_Rp(_A0)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>&
function<_Rp(_A0)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0)>&
>::type
function<_Rp(_A0)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0>
function<_Rp(_A0)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0>
void
function<_Rp(_A0)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0>
_Rp
function<_Rp(_A0)>::operator()(_A0 __a0) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0);
}



template<class _Rp, class _A0>
const std::type_info&
function<_Rp(_A0)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0>
template <typename _Tp>
_Tp*
function<_Rp(_A0)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0>
template <typename _Tp>
const _Tp*
function<_Rp(_A0)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1)>
    : public binary_function<_A0, _A1, _Rp>
{
    typedef __function::__base<_Rp(_A0, _A1)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1)) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_Rp(_B0, _B1)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    operator bool() const {return __f_;}

private:

    template<class _R2, class _B0, class _B1>
      bool operator==(const function<_R2(_B0, _B1)>&) const;
    template<class _R2, class _B0, class _B1>
      bool operator!=(const function<_R2(_B0, _B1)>&) const;
public:

    _Rp operator()(_A0, _A1) const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template<class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc&, const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
function<_Rp(_A0, _A1)>::function(_Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                 typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>&
function<_Rp(_A0, _A1)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1)>&
>::type
function<_Rp(_A0, _A1)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1>
function<_Rp(_A0, _A1)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1>
void
function<_Rp(_A0, _A1)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1>
_Rp
function<_Rp(_A0, _A1)>::operator()(_A0 __a0, _A1 __a1) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0, __a1);
}



template<class _Rp, class _A0, class _A1>
const std::type_info&
function<_Rp(_A0, _A1)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0, class _A1>
template <typename _Tp>
_Tp*
function<_Rp(_A0, _A1)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0, class _A1>
template <typename _Tp>
const _Tp*
function<_Rp(_A0, _A1)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template<class _Rp, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_A0, _A1, _A2)>
{
    typedef __function::__base<_Rp(_A0, _A1, _A2)> __base;
    aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_B0, _B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2)) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) volatile) {return __p;}
    template <class _R2, class _Cp, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_B1, _B2) const volatile) {return __p;}
    template <class _R2, class _B0, class _B1, class _B2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_Rp(_B0, _B1, _B2)>& __p) {return __p;}
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit function() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) function(nullptr_t) : __f_(0) {}
    function(const function&);
    template<class _Fp>
      function(_Fp,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<!is_integral<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(nullptr_t);
    template<class _Fp>
      typename enable_if
      <
        !is_integral<_Fp>::value,
        function&
      >::type
      operator=(_Fp);

    ~function();


    void swap(function&);
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp __f, const _Alloc& __a)
        {function(allocator_arg, __a, __f).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator bool() const {return __f_;}

private:

    template<class _R2, class _B0, class _B1, class _B2>
      bool operator==(const function<_R2(_B0, _B1, _B2)>&) const;
    template<class _R2, class _B0, class _B1, class _B2>
      bool operator!=(const function<_R2(_B0, _B1, _B2)>&) const;
public:

    _Rp operator()(_A0, _A1, _A2) const;



    const std::type_info& target_type() const;
    template <typename _Tp> _Tp* target();
    template <typename _Tp> const _Tp* target() const;

};

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template<class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc&,
                                      const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
function<_Rp(_A0, _A1, _A2)>::function(_Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp, class _Alloc>
function<_Rp(_A0, _A1, _A2)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<!is_integral<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_A0, _A1, _A2)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_))
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(__f);
        }
        else
        {
            typedef typename __alloc_traits::template



                rebind_alloc<_FF>::other

                                                         _Ap;
            _Ap __a(__a0);
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(__f, _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>&
function<_Rp(_A0, _A1, _A2)>::operator=(nullptr_t)
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
}

template<class _Rp, class _A0, class _A1, class _A2>
template <class _Fp>
typename enable_if
<
    !is_integral<_Fp>::value,
    function<_Rp(_A0, _A1, _A2)>&
>::type
function<_Rp(_A0, _A1, _A2)>::operator=(_Fp __f)
{
    function(std::__1::move(__f)).swap(*this);
    return *this;
}

template<class _Rp, class _A0, class _A1, class _A2>
function<_Rp(_A0, _A1, _A2)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class _A0, class _A1, class _A2>
void
function<_Rp(_A0, _A1, _A2)>::swap(function& __f)
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class _A0, class _A1, class _A2>
_Rp
function<_Rp(_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2) const
{

    if (__f_ == 0)
        throw bad_function_call();

    return (*__f_)(__a0, __a1, __a2);
}



template<class _Rp, class _A0, class _A1, class _A2>
const std::type_info&
function<_Rp(_A0, _A1, _A2)>::target_type() const
{
    if (__f_ == 0)
        return typeid(void);
    return __f_->target_type();
}

template<class _Rp, class _A0, class _A1, class _A2>
template <typename _Tp>
_Tp*
function<_Rp(_A0, _A1, _A2)>::target()
{
    if (__f_ == 0)
        return (_Tp*)0;
    return (_Tp*)__f_->target(typeid(_Tp));
}

template<class _Rp, class _A0, class _A1, class _A2>
template <typename _Tp>
const _Tp*
function<_Rp(_A0, _A1, _A2)>::target() const
{
    if (__f_ == 0)
        return (const _Tp*)0;
    return (const _Tp*)__f_->target(typeid(_Tp));
}



template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const function<_Fp>& __f, nullptr_t) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const function<_Fp>& __f) {return !__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const function<_Fp>& __f, nullptr_t) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const function<_Fp>& __f) {return (bool)__f;}

template <class _Fp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(function<_Fp>& __x, function<_Fp>& __y)
{return __x.swap(__y);}

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders
{

template <int _Np> struct __ph {};

extern __ph<1> _1;
extern __ph<2> _2;
extern __ph<3> _3;
extern __ph<4> _4;
extern __ph<5> _5;
extern __ph<6> _6;
extern __ph<7> _7;
extern __ph<8> _8;
extern __ph<9> _9;
extern __ph<10> _10;

}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};

template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}
# 1204 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 2 3
# 2200 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(bool __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(signed char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned char __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char16_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char32_t __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(wchar_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(float __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(double __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long double __v) const throw()
    {

        if (__v == 0)
            return 0;
# 2379 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
        union
        {
            long double __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__a = 0;
        __u.__b = 0;
        __u.__t = __v;
        return __u.__a ^ __u.__b;



    }
};
# 2416 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
} }
# 178 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 183 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3
# 186 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) recursive_mutex
{
    pthread_mutex_t __m_;

public:
     recursive_mutex();
     ~recursive_mutex();

private:
    recursive_mutex(const recursive_mutex&);
    recursive_mutex& operator=(const recursive_mutex&);

public:
    void lock();
    bool try_lock() throw();
    void unlock() throw();

    typedef pthread_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    native_handle_type native_handle() {return &__m_;}
};

class __attribute__ ((__type_visibility__("default"))) timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
     timed_mutex();
     ~timed_mutex();

private:
    timed_mutex(const timed_mutex&);
    timed_mutex& operator=(const timed_mutex&);

public:
    void lock();
    bool try_lock() throw();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() throw();
};

template <class _Clock, class _Duration>
bool
timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    unique_lock<mutex> __lk(__m_);
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __locked_)
        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
    if (!__locked_)
    {
        __locked_ = true;
        return true;
    }
    return false;
}

class __attribute__ ((__type_visibility__("default"))) recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    pthread_t __id_;
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

private:
    recursive_timed_mutex(const recursive_timed_mutex&);
    recursive_timed_mutex& operator=(const recursive_timed_mutex&);

public:
    void lock();
    bool try_lock() throw();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() throw();
};

template <class _Clock, class _Duration>
bool
recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    pthread_t __id = pthread_self();
    unique_lock<mutex> lk(__m_);
    if (pthread_equal(__id, __id_))
    {
        if (__count_ == numeric_limits<size_t>::max())
            return false;
        ++__count_;
        return true;
    }
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __count_ != 0)
        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
    if (__count_ == 0)
    {
        __count_ = 1;
        __id_ = __id;
        return true;
    }
    return false;
}

template <class _L0, class _L1>
int
try_lock(_L0& __l0, _L1& __l1)
{
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        if (__l1.try_lock())
        {
            __u0.release();
            return -1;
        }
        else
            return 1;
    }
    return 0;
}
# 345 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template <class _L0, class _L1>
void
lock(_L0& __l0, _L1& __l1)
{
    while (true)
    {
        {
            unique_lock<_L0> __u0(__l0);
            if (__l1.try_lock())
            {
                __u0.release();
                break;
            }
        }
        sched_yield();
        {
            unique_lock<_L1> __u1(__l1);
            if (__l0.try_lock())
            {
                __u1.release();
                break;
            }
        }
        sched_yield();
    }
}
# 428 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag;
# 438 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template<class _Callable>
__attribute__ ((__visibility__("hidden"), __always_inline__))
void call_once(once_flag&, _Callable);



struct __attribute__ ((__type_visibility__("default"))) once_flag
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))

        once_flag() throw() : __state_(0) {}

private:
    once_flag(const once_flag&);
    once_flag& operator=(const once_flag&);

    unsigned long __state_;






    template<class _Callable>
    friend
    void call_once(once_flag&, _Callable);

};
# 500 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template <class _Fp>
class __call_once_param
{
    _Fp __f_;
public:




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __call_once_param(const _Fp& __f) : __f_(__f) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()()
    {
        __f_();
    }
};



template <class _Fp>
void
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

__attribute__ ((__visibility__("default"))) void __call_once(volatile unsigned long&, void*, void(*)(void*));
# 550 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template<class _Callable>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
call_once(once_flag& __flag, _Callable __func)
{
    if (__flag.__state_ != ~0ul)
    {
        __call_once_param<_Callable> __p(__func);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Callable>);
    }
}



} }
# 19 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 2 3


# 1 "/usr/include/locale.h" 1 3 4
# 40 "/usr/include/locale.h" 3 4
# 1 "/usr/include/_locale.h" 1 3 4
# 43 "/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};



extern "C" {
struct lconv *localeconv(void);
}
# 41 "/usr/include/locale.h" 2 3 4
# 52 "/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 2 3





# 1 "/usr/include/xlocale.h" 1 3 4
# 33 "/usr/include/xlocale.h" 3 4
struct _xlocale;
typedef struct _xlocale * locale_t;



# 1 "/usr/include/_xlocale.h" 1 3 4
# 29 "/usr/include/_xlocale.h" 3 4
extern "C" {
int ___mb_cur_max(void);
int ___mb_cur_max_l(locale_t);
}
# 38 "/usr/include/xlocale.h" 2 3 4
# 65 "/usr/include/xlocale.h" 3 4
extern "C" {
extern const locale_t _c_locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}



# 1 "/usr/include/xlocale/_ctype.h" 1 3 4
# 34 "/usr/include/xlocale/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}

extern "C" {
int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}

inline int
__istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l)
{
 return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f)
  : __maskrune_l(_c, _f, _l));
}

inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c]
  : ___toupper_l(_c, _l);
}

inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__maplower[_c]
  : ___tolower_l(_c, _l);
}

inline int
__wcwidth_l(__darwin_ct_rune_t _c, locale_t _l)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune_l(_c, 0xe0000000L|0x00040000L, _l);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}



inline int
digittoint_l(int c, locale_t l)
{
 return (__maskrune_l(c, 0x0F, l));
}

inline int
isalnum_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L|0x00000400L, l));
}

inline int
isalpha_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L, l));
}

inline int
isblank_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00020000L, l));
}

inline int
iscntrl_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000200L, l));
}

inline int
isdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isgraph_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000800L, l));
}

inline int
ishexnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
isideogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00080000L, l));
}

inline int
islower_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00001000L, l));
}

inline int
isnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isphonogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00200000L, l));
}

inline int
isprint_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00040000L, l));
}

inline int
ispunct_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00002000L, l));
}

inline int
isrune_l(int c, locale_t l)
{
 return (__istype_l(c, 0xFFFFFFF0L, l));
}

inline int
isspace_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00004000L, l));
}

inline int
isspecial_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00100000L, l));
}

inline int
isupper_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00008000L, l));
}

inline int
isxdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
tolower_l(int c, locale_t l)
{
        return (__tolower_l(c, l));
}

inline int
toupper_l(int c, locale_t l)
{
        return (__toupper_l(c, l));
}
# 78 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/__wctype.h" 1 3 4
# 30 "/usr/include/xlocale/__wctype.h" 3 4
inline int
iswalnum_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L|0x00000400L, _l));
}

inline int
iswalpha_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L, _l));
}

inline int
iswcntrl_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000200L, _l));
}

inline int
iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l)
{
 return (__istype_l(_wc, _charclass, _l));
}

inline int
iswdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswgraph_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000800L, _l));
}

inline int
iswlower_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00001000L, _l));
}

inline int
iswprint_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00040000L, _l));
}

inline int
iswpunct_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00002000L, _l));
}

inline int
iswspace_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00004000L, _l));
}

inline int
iswupper_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00008000L, _l));
}

inline int
iswxdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline wint_t
towlower_l(wint_t _wc, locale_t _l)
{
        return (__tolower_l(_wc, _l));
}

inline wint_t
towupper_l(wint_t _wc, locale_t _l)
{
        return (__toupper_l(_wc, _l));
}
# 135 "/usr/include/xlocale/__wctype.h" 3 4
extern "C" {
wctype_t
 wctype_l(const char *, locale_t);
}
# 81 "/usr/include/xlocale.h" 2 3 4
# 95 "/usr/include/xlocale.h" 3 4
# 1 "/usr/include/xlocale/_stdio.h" 1 3 4
# 27 "/usr/include/xlocale/_stdio.h" 3 4
extern "C" {

int fprintf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int fscanf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int printf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 2, 3)));
int scanf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 2, 3)));
int sprintf_l(char * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int sscanf_l(const char * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int vfprintf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));
int vprintf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 2, 0)));
int vsprintf_l(char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


int snprintf_l(char * , size_t, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 4, 5)));
int vfscanf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));
int vscanf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 2, 0)));
int vsnprintf_l(char * , size_t, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 4, 0)));
int vsscanf_l(const char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));



int dprintf_l(int, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf_l(int, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((availability(macosx,introduced=10.7)));




int asprintf_l(char ** , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int vasprintf_l(char ** , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


}
# 96 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_stdlib.h" 1 3 4
# 27 "/usr/include/xlocale/_stdlib.h" 3 4
extern "C" {
double atof_l(const char *, locale_t);
int atoi_l(const char *, locale_t);
long atol_l(const char *, locale_t);

long long
  atoll_l(const char *, locale_t);

int mblen_l(const char *, size_t, locale_t);
size_t mbstowcs_l(wchar_t * , const char * , size_t,
     locale_t);
int mbtowc_l(wchar_t * , const char * , size_t,
     locale_t);
double strtod_l(const char *, char **, locale_t) __asm("_" "strtod_l") ;
float strtof_l(const char *, char **, locale_t) __asm("_" "strtof_l") ;
long strtol_l(const char *, char **, int, locale_t);
long double
  strtold_l(const char *, char **, locale_t);
long long
  strtoll_l(const char *, char **, int, locale_t);

long long
  strtoq_l(const char *, char **, int, locale_t);

unsigned long
  strtoul_l(const char *, char **, int, locale_t);
unsigned long long
  strtoull_l(const char *, char **, int, locale_t);

unsigned long long
  strtouq_l(const char *, char **, int, locale_t);

size_t wcstombs_l(char * , const wchar_t * , size_t,
     locale_t);
int wctomb_l(char *, wchar_t, locale_t);





}
# 99 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_string.h" 1 3 4
# 27 "/usr/include/xlocale/_string.h" 3 4
extern "C" {
int strcoll_l(const char *, const char *, locale_t);
size_t strxfrm_l(char *, const char *, size_t, locale_t);
int strcasecmp_l(const char *, const char *, locale_t);
char *strcasestr_l(const char *, const char *, locale_t);
int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
# 102 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_time.h" 1 3 4
# 27 "/usr/include/xlocale/_time.h" 3 4
extern "C" {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm("_" "strftime_l") __attribute__((__format__ (__strftime__, 3, 0)));
char *strptime_l(const char * , const char * ,
  struct tm * , locale_t)
  __asm("_" "strptime_l") __attribute__((__format__ (__strftime__, 2, 0)));
}
# 105 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_wchar.h" 1 3 4
# 28 "/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
wint_t btowc_l(int, locale_t);
wint_t fgetwc_l(FILE *, locale_t);
wchar_t *fgetws_l(wchar_t * , int, FILE * , locale_t);
wint_t fputwc_l(wchar_t, FILE *, locale_t);
int fputws_l(const wchar_t * , FILE * , locale_t);
int fwprintf_l(FILE * , locale_t, const wchar_t * , ...);
int fwscanf_l(FILE * , locale_t, const wchar_t * , ...);
wint_t getwc_l(FILE *, locale_t);
wint_t getwchar_l(locale_t);
size_t mbrlen_l(const char * , size_t, mbstate_t * ,
     locale_t);
size_t mbrtowc_l(wchar_t * , const char * , size_t,
     mbstate_t * , locale_t);
int mbsinit_l(const mbstate_t *, locale_t);
size_t mbsrtowcs_l(wchar_t * , const char ** , size_t,
     mbstate_t * , locale_t);
wint_t putwc_l(wchar_t, FILE *, locale_t);
wint_t putwchar_l(wchar_t, locale_t);
int swprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , ...);
int swscanf_l(const wchar_t * , locale_t,
  const wchar_t * , ...);
wint_t ungetwc_l(wint_t, FILE *, locale_t);
int vfwprintf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , __darwin_va_list);
int vwprintf_l(locale_t, const wchar_t * , __darwin_va_list);
size_t wcrtomb_l(char * , wchar_t, mbstate_t * ,
     locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
size_t wcsftime_l(wchar_t * , size_t, const wchar_t * ,
  const struct tm * , locale_t)
  __asm("_" "wcsftime_l") ;
size_t wcsrtombs_l(char * , const wchar_t ** , size_t,
     mbstate_t * , locale_t);
double wcstod_l(const wchar_t * , wchar_t ** , locale_t);
long wcstol_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long
 wcstoul_l(const wchar_t * , wchar_t ** , int,
     locale_t);
int wcswidth_l(const wchar_t *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t * , const wchar_t * , size_t,
     locale_t);
int wctob_l(wint_t, locale_t);
int wcwidth_l(wchar_t, locale_t);
int wprintf_l(locale_t, const wchar_t * , ...);
int wscanf_l(locale_t, const wchar_t * , ...);
}
# 87 "/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
int vfwscanf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswscanf_l(const wchar_t * , locale_t,
  const wchar_t * , __darwin_va_list);
int vwscanf_l(locale_t, const wchar_t * , __darwin_va_list);
float wcstof_l(const wchar_t * , wchar_t ** , locale_t);
long double
 wcstold_l(const wchar_t * , wchar_t ** , locale_t);

long long
 wcstoll_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long long
 wcstoull_l(const wchar_t * , wchar_t ** , int,
     locale_t);

}
# 114 "/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs_l(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * , locale_t);
int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs_l(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * , locale_t);
}







extern "C" {
wchar_t *fgetwln_l(FILE * , size_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
}
# 108 "/usr/include/xlocale.h" 2 3 4


# 1 "/usr/include/xlocale/_wctype.h" 1 3 4
# 30 "/usr/include/xlocale/_wctype.h" 3 4
inline int
iswblank_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00020000L, _l));
}

inline int
iswhexnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline int
iswideogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00080000L, _l));
}

inline int
iswnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswphonogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00200000L, _l));
}

inline int
iswrune_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}

inline int
iswspecial_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00100000L, _l));
}
# 86 "/usr/include/xlocale/_wctype.h" 3 4
extern "C" {
wint_t nextwctype_l(wint_t, wctype_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t
 wctrans_l(const char *, locale_t);
}
# 111 "/usr/include/xlocale.h" 2 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 2 3
# 32 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3


namespace std {inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) locale;

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale&) throw();

template <class _Facet>
__attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale&);

class __attribute__ ((__type_visibility__("default"))) locale
{
public:

    class __attribute__ ((__type_visibility__("default"))) facet;
    class __attribute__ ((__type_visibility__("default"))) id;

    typedef int category;
    static const category
        none = 0,
        collate = (1 << 0),
        ctype = (1 << 1),
        monetary = (1 << 3),
        numeric = (1 << 4),
        time = (1 << 5),
        messages = (1 << 2),
        all = collate | ctype | monetary | numeric | time | messages;


    locale() throw();
    locale(const locale&) throw();
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) throw();

    template <class _Facet> locale combine(const locale&) const;


    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;


    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) throw();
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__ ((__type_visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();



private:
    virtual void __on_zero_shared() throw();
};

class __attribute__ ((__type_visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&);
    id(const id&);
public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{

    if (!std::__1::has_facet<_Facet>(__other))
        throw runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
has_facet(const locale& __l) throw()
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__ ((__type_visibility__("default"))) collate<char>;
extern template class __attribute__ ((__type_visibility__("default"))) collate<wchar_t>;



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}



class __attribute__ ((__type_visibility__("default"))) ctype_base
{
public:
# 346 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
    typedef __uint32_t mask;





    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask cntrl = 0x00000200L;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask punct = 0x00002000L;
    static const mask xdigit = 0x00010000L;



    static const mask blank = 0x00020000L;
# 391 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ctype_base() {}
};

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;

template <>
class __attribute__ ((__type_visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is(mask __m, char_type __c) const
    {
        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;


    static const size_t table_size = (1 <<8 );



    __attribute__ ((__visibility__("hidden"), __always_inline__)) const mask* table() const throw() {return __tab_;}
    static const mask* classic_table() throw();
# 610 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale" 3
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template <>
class __attribute__ ((__type_visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class __attribute__ ((__type_visibility__("default"))) codecvt_base
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <>
class __attribute__ ((__type_visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int encoding() const throw()
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool always_noconv() const throw()
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int max_length() const throw()
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const throw();
    virtual bool do_always_noconv() const throw();
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const throw();
};



template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}

extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__ ((__type_visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;

__attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

template <>
struct __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <>
struct __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

template <>
struct __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};

template <>
struct __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = (wchar_t)*__p;
            __nb = __nn;
        }
        return __s;
    }
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};



template <class charT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template <>
class __attribute__ ((__type_visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }
# 217 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 2 3
# 225 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios" 3


namespace std {inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__ ((__type_visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__type_visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    typedef iostate io_state;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    typedef openmode open_mode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};
    typedef seekdir seek_dir;

    typedef std::__1::streamoff streamoff;
    typedef std::__1::streampos streampos;

    class __attribute__ ((__type_visibility__("default"))) Init;


    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void unsetf(fmtflags __mask);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) streamsize width(streamsize __wide);


    locale imbue(const locale& __loc);
    locale getloc() const;


    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&);
    ios_base& operator=(const ios_base&);

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ios_base() {
               }

    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static int __xindex_;

    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


struct __attribute__ ((__type_visibility__("default"))) io_errc { enum __lx
{
    stream = 1
};
__lx __v_; __attribute__ ((__visibility__("hidden"), __always_inline__)) io_errc(__lx __v) : __v_(__v) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit io_errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int() const {return __v_;} };

template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc::__lx> : public true_type { };


__attribute__ ((__visibility__("default")))
const error_category& iostream_category() throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_code
make_error_code(io_errc __e) throw()
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
error_condition
make_error_condition(io_errc __e) throw()
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    virtual ~failure() throw();
};

class __attribute__ ((__type_visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return !fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!() const {return fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool good() const {return ios_base::good();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type fill(char_type __ch);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    locale imbue(const locale& __loc);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ios() {
                }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void move(basic_ios& __rhs);




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(basic_ios& __rhs) throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
     mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = 0;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = 0;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) throw()
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, __rhs.__tie_);
    std::__1::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/streambuf" 1 3
# 117 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/streambuf" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();


    locale pubimbue(const locale& __loc);
    locale getloc() const;


    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out);
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out);
    int pubsync();



    streamsize in_avail();
    int_type snextc();
    int_type sbumpc();
    int_type sgetc();
    streamsize sgetn(char_type* __s, streamsize __n);


    int_type sputbackc(char_type __c);
    int_type sungetc();


    int_type sputc(char_type __c);
    streamsize sputn(const char_type* __s, streamsize __n);

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);


    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* eback() const {return __binp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* egptr() const {return __einp_;}
    void gbump(int __n);
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);


    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* epptr() const {return __eout_;}
    void pbump(int __n);
    void setp(char_type* __pbeg, char_type* __pend);



    virtual void imbue(const locale& __loc);


    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)
{
    imbue(__loc);
    locale __r = __loc_;
    __loc_ = __loc;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
locale
basic_streambuf<_CharT, _Traits>::getloc() const
{
    return __loc_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)
{
    return setbuf(__s, __n);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,
                                             ios_base::seekdir __way,
                                             ios_base::openmode __which)
{
    return seekoff(__off, __way, __which);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,
                                             ios_base::openmode __which)
{
    return seekpos(__sp, __which);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int
basic_streambuf<_CharT, _Traits>::pubsync()
{
    return sync();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::in_avail()
{
    if (__ninp_ < __einp_)
        return static_cast<streamsize>(__einp_ - __ninp_);
    return showmanyc();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::snextc()
{
    if (sbumpc() == traits_type::eof())
        return traits_type::eof();
    return sgetc();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sbumpc()
{
    if (__ninp_ == __einp_)
        return uflow();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sgetc()
{
    if (__ninp_ == __einp_)
        return underflow();
    return traits_type::to_int_type(*__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)
{
    return xsgetn(__s, __n);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)
{
    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
        return pbackfail(traits_type::to_int_type(__c));
    return traits_type::to_int_type(*--__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sungetc()
{
    if (__binp_ == __ninp_)
        return pbackfail();
    return traits_type::to_int_type(*--__ninp_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputc(char_type __c)
{
    if (__nout_ == __eout_)
        return overflow(traits_type::to_int_type(__c));
    *__nout_++ = __c;
    return traits_type::to_int_type(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
streamsize
basic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)
{
    return xsputn(__s, __n);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(0),
      __ninp_(0),
      __einp_(0),
      __bout_(0),
      __nout_(0),
      __eout_(0)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__1::swap(__loc_, __sb.__loc_);
    std::__1::swap(__binp_, __sb.__binp_);
    std::__1::swap(__ninp_, __sb.__ninp_);
    std::__1::swap(__einp_, __sb.__einp_);
    std::__1::swap(__bout_, __sb.__bout_);
    std::__1::swap(__nout_, __sb.__nout_);
    std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::gbump(int __n)
{
    __ninp_ += __n;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,
                                                          char_type* __gend)
{
    __binp_ = __gbeg;
    __ninp_ = __gnext;
    __einp_ = __gend;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::pbump(int __n)
{
    __nout_ += __n;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)
{
    __bout_ = __nout_ = __pbeg;
    __eout_ = __pend;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    for (;__i < __n; ++__i, ++__s)
    {
        if (__ninp_ < __einp_)
            *__s = *__ninp_++;
        else if ((__c = uflow()) != __eof)
            *__s = traits_type::to_char_type(__c);
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    for (; __i < __n; ++__s, ++__i)
    {
        if (__nout_ < __eout_)
            *__nout_++ = *__s;
        else if (overflow(traits_type::to_int_type(*__s)) == __eof)
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}

extern template class __attribute__ ((__type_visibility__("default"))) basic_streambuf<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_streambuf<wchar_t>;

extern template class __attribute__ ((__type_visibility__("default"))) basic_ios<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_ios<wchar_t>;

} }
# 40 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 1 3
# 156 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 1 3
# 133 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 1 3
# 197 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
# 1 "/usr/include/nl_types.h" 1 3 4
# 45 "/usr/include/nl_types.h" 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
# 84 "/usr/include/sys/types.h" 3 4
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;

typedef unsigned long u_long;


typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef int32_t daddr_t;



typedef u_int32_t fixpt_t;





# 1 "/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 110 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 111 "/usr/include/sys/types.h" 2 3 4






# 1 "/usr/include/sys/_types/_key_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 118 "/usr/include/sys/types.h" 2 3 4






typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 137 "/usr/include/sys/types.h" 3 4
static inline __int32_t major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 170 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 171 "/usr/include/sys/types.h" 2 3 4
# 185 "/usr/include/sys/types.h" 3 4
typedef __int32_t fd_mask;
# 226 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 227 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 228 "/usr/include/sys/types.h" 2 3 4
# 46 "/usr/include/nl_types.h" 2 3 4
# 89 "/usr/include/nl_types.h" 3 4
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;


# 1 "/usr/include/_types/_nl_item.h" 1 3 4
# 31 "/usr/include/_types/_nl_item.h" 3 4
typedef __darwin_nl_item nl_item;
# 95 "/usr/include/nl_types.h" 2 3 4

extern "C" {
nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *)
 __attribute__((__format_arg__(4)));
int catclose(nl_catd);
}
# 198 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 2 3






# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 205 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 2 3
# 208 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3


namespace std {inline namespace __1 {
# 223 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
typedef std::__1::remove_pointer<locale_t>::type __locale_struct;
typedef std::__1::unique_ptr<__locale_struct, __typeof__(&freelocale)> __locale_unique_ptr;
# 426 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__ ((__visibility__("hidden")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == 0)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {

        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;






        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (__b == __e)
        __err |= ios_base::eofbit;

    for (__st = __status; __kb != __ke; ++__kb, ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__ ((__type_visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__ ((__visibility__("default")))
void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);
};

template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)
{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__ ((__type_visibility__("default"))) __num_get<char>;
extern template struct __attribute__ ((__type_visibility__("default"))) __num_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_get() {}

    template <class _Fp>
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
_Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        if (*__a == '-')
        {
            __err = ios_base::failbit;
            return 0;
        }
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<__typeof__((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long double __ld = strtold_l(__a, &__p2, 0);
        typename remove_reference<__typeof__((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return static_cast<_Tp>(__ld);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,
                                            __ct, __err);
    __v = __i == __names;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __atoms[26];
    char_type __thousands_sep;
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __atoms[26];
    char_type __thousands_sep;
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_float<_Fp>(__a, __a_end, __err);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end - __a == __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }

    __a[sizeof(__a)-1] = 0;

    if (sscanf_l(__a, 0, "%p", &__v) != 1)



        __err = ios_base::failbit;

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) num_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) num_get<wchar_t>;

struct __attribute__ ((__type_visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isxdigit_l(*__ns, 0))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isdigit_l(*__ns, 0))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__ ((__type_visibility__("default"))) __num_put<char>;
extern template struct __attribute__ ((__type_visibility__("default"))) __num_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}





template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == std::__1::__get_nullptr_t())
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = std::__1::__get_nullptr_t();
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}



template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
                          + ((numeric_limits<long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
                          + ((numeric_limits<long long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
                          + 1;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt,
                                   (int)__iob.precision(), __v);




    else

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);



    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)

            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);




        else

            __nc = asprintf_l(&__nb, 0, __fmt, __v);



        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt,
                                   (int)__iob.precision(), __v);




    else

        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);



    unique_ptr<char, void(*)(void*)> __nbh(0, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)

            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);




        else

            __nc = asprintf_l(&__nb, 0, __fmt, __v);



        if (__nb == 0)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{

    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];

    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);



    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__ ((__type_visibility__("default"))) num_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) num_put<wchar_t>;

template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{

    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)
    {

        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__ ((__type_visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{

    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{

    const string_type* __month = this->__months();
    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) time_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_get<wchar_t>;

class __attribute__ ((__type_visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_get_byname() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class __attribute__ ((__type_visibility__("default"))) time_get_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_get_byname<wchar_t>;

class __attribute__ ((__type_visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __time_put() : __loc_(0) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__1::copy(__nb, __ne, __s);
}

extern template class __attribute__ ((__type_visibility__("default"))) time_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~time_put_byname() {}
};

extern template class __attribute__ ((__type_visibility__("default"))) time_put_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) time_put_byname<wchar_t>;



class __attribute__ ((__type_visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) money_base() {}
};



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<char, true>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct<wchar_t, true>;



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> void moneypunct_byname<char, false>::init(const char*);
template<> void moneypunct_byname<char, true>::init(const char*);
template<> void moneypunct_byname<wchar_t, false>::init(const char*);
template<> void moneypunct_byname<wchar_t, true>::init(const char*);

extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<char, true>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__type_visibility__("default"))) moneypunct_byname<wchar_t, true>;



template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__ ((__type_visibility__("default"))) __money_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) __money_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__ ((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }

        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                {
                    if (__psn.size() > 0)
                    {
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(0, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == 0)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__type_visibility__("default"))) money_get<char>;
extern template class __attribute__ ((__type_visibility__("default"))) money_get<wchar_t>;



template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {

            char_type* __t = __me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }

            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }

            reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() > 1)
        __me = std::__1::copy(__sn.begin()+1, __sn.end(), __me);

    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__ ((__type_visibility__("default"))) __money_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) __money_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
    unique_ptr<char, void(*)(void*)> __hn(0, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);

    if (__n > __bs-1)
    {

        __n = static_cast<size_t>(asprintf_l(&__bb, 0, "%.0Lf", __units));



        if (__bb == 0)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
        if (__hd == std::__1::__get_nullptr_t())
            __throw_bad_alloc();
        __db = __hd.get();
    }

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = static_cast<int>(__n) > __fd ?
                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +
                    __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__ ((__type_visibility__("default"))) money_put<char>;
extern template class __attribute__ ((__type_visibility__("default"))) money_put<wchar_t>;



class __attribute__ ((__type_visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) messages_base() {}
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{



    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;

}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{



    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(back_inserter(__w),
                                                        __n, __n + strlen(__n));
    return __w;

}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);

}

extern template class __attribute__ ((__type_visibility__("default"))) messages<char>;
extern template class __attribute__ ((__type_visibility__("default"))) messages<wchar_t>;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~messages_byname() {}
};

extern template class __attribute__ ((__type_visibility__("default"))) messages_byname<char>;
extern template class __attribute__ ((__type_visibility__("default"))) messages_byname<wchar_t>;

template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:
                                 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
    wstring_convert(_Codecvt* __pcvt, state_type __state);
                                 wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());



    ~wstring_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t converted() const throw() {return __cvtcount_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}
# 3847 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/locale" 3
template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);

                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        throw range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != std::__1::__get_nullptr_t())
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);

                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        throw range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:

    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);
public:
                                 wbuffer_convert(streambuf* __bytebuf = 0,
            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
    ~wbuffer_convert();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;
            state_type __svs = __st_;
            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp((char_type*)__e, this->pptr());
                        this->pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    switch (__way)
    {
    case ios_base::beg:
        break;
    case ios_base::cur:
        break;
    case ios_base::end:
        break;
    default:
        return pos_type(off_type(-1));
    }
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = 0;
    if (__cv_ != 0 && __bufptr_ != 0)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = 0;
    }
    return __rt;
}

} }
# 134 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 2 3
# 139 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_ostream();
protected:
# 172 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
    void swap(basic_ostream& __rhs);
public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&));
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));
    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);


    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();


    pos_type tellp();
    basic_ostream& seekp(pos_type __pos);
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    basic_ostream() {}
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {

        try
        {

            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);

        }
        catch (...)
        {
        }

    }
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
{
    this->init(__sb);
}
# 292 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)
{
    basic_ios<char_type, traits_type>::swap(__rhs);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))
{
    return __pf(*this);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&
                                           (*__pf)(basic_ios<char_type,traits_type>&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);

                }
                catch (...)
                {
                    this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
 return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
 return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
 return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
 return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
 return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
 return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
 const char *__s = (const char *) __str;
 return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
 const char *__s = (const char *) __str;
 return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{

    try
    {

        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{

    try
    {

        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (__s)
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (__s)
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}
# 1063 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream" 3
template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
 return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}

extern template class __attribute__ ((__type_visibility__("default"))) basic_ostream<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_ostream<wchar_t>;

} }
# 157 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 159 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 2 3
# 162 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3


namespace std {inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_istream();
protected:
# 193 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
    void swap(basic_istream& __rhs);
public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&));
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&));
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&));
    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    basic_istream& operator>>(float& __f);
    basic_istream& operator>>(double& __f);
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    streamsize gcount() const {return __gc_;}
    int_type get();
    basic_istream& get(char_type& __c);
    basic_istream& get(char_type* __s, streamsize __n);
    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb);
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    basic_istream& getline(char_type* __s, streamsize __n);
    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);


    __attribute__ ((__visibility__("hidden"), __always_inline__))

        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>::basic_istream(basic_streambuf<char_type, traits_type>* __sb)
    : __gc_(0)
{
    this->init(__sb);
}
# 320 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_istream<_CharT, _Traits>::swap(basic_istream& __rhs)
{
    std::__1::swap(__gc_, __rhs.__gc_);
    basic_ios<char_type, traits_type>::swap(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<short>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::min();
            }
            else if (__temp > numeric_limits<short>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<short>::max();
            }
            else
                __n = static_cast<short>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef istreambuf_iterator<char_type, traits_type> _Ip;
            typedef num_get<char_type, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            long __temp;
            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);
            if (__temp < numeric_limits<int>::min())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::min();
            }
            else if (__temp > numeric_limits<int>::max())
            {
                __err |= ios_base::failbit;
                __n = numeric_limits<int>::max();
            }
            else
                __n = static_cast<int>(__temp);
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_istream& (*__pf)(basic_istream&))
{
    return __pf(*this);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_ios<char_type, traits_type>&
                                           (*__pf)(basic_ios<char_type, traits_type>&))
{
    __pf(*this);
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(ios_base& (*__pf)(ios_base&))
{
    __pf(*this);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n-1)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __is.setstate(ios_base::eofbit | ios_base::failbit);
            else
                __c = _Traits::to_char_type(__i);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    __gc_ = 0;

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    ios_base::iostate __err = ios_base::goodbit;
                    while (true)
                    {
                        typename traits_type::int_type __i = this->rdbuf()->sgetc();
                        if (traits_type::eq_int_type(__i, _Traits::eof()))
                        {
                           __err |= ios_base::eofbit;
                           break;
                        }
                        if (traits_type::eq_int_type(
                                __sb->sputc(traits_type::to_char_type(__i)),
                                traits_type::eof()))
                            break;
                        ++__gc_;
                        this->rdbuf()->sbumpc();
                    }
                    if (__gc_ == 0)
                       __err |= ios_base::failbit;
                    this->setstate(__err);

                }
                catch (...)
                {
                    if (__gc_ == 0)
                        this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __s(*this, true);
        if (__s)
        {
            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               this->setstate(ios_base::failbit | ios_base::eofbit);
            else
                __gc_ = 1;
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type& __c)
{
    int_type __ch = get();
    if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (__n > 0)
            {
                ios_base::iostate __err = ios_base::goodbit;
                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                *__s = char_type();
                if (__gc_ == 0)
                   __err |= ios_base::failbit;
                this->setstate(__err);
            }
            else
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n)
{
    return get(__s, __n, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;

            try
            {

                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }

            }
            catch (...)
            {
            }

            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb)
{
    return get(__sb, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __err |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }
            if (__n > 0)
                *__s = char_type();
            if (__gc_ == 0)
               __err |= ios_base::failbit;
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n)
{
    return getline(__s, __n, this->widen('\n'));
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            ios_base::iostate __err = ios_base::goodbit;
            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __err |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            this->setstate(__err);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    __gc_ = 0;
    int_type __r = traits_type::eof();

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                this->setstate(ios_base::eofbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    __gc_ = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                this->setstate(ios_base::failbit | ios_base::eofbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    __gc_ = 0;
    streamsize __c = this->rdbuf()->in_avail();
    switch (__c)
    {
    case -1:
        this->setstate(ios_base::eofbit);
        break;
    case 0:
        break;
    default:
        read(__s, std::__1::min(__c, __n));
        break;
    }
    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    __gc_ = 0;

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
                this->setstate(ios_base::badbit);
        }
        else
            this->setstate(ios_base::failbit);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    int __r = 0;

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf() == 0)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                this->setstate(ios_base::badbit);
                return -1;
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    pos_type __r(-1);

    try
    {

        sentry __sen(*this, true);
        if (__sen)
            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{

    try
    {

        this->clear(this->rdstate() & ~ios_base::eofbit);
        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{

    try
    {

        sentry __sen(*this, true);
        if (__sen)
        {
            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                this->setstate(ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __is.setstate(ios_base::eofbit);
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}
# 1458 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb);
    virtual ~basic_iostream();
protected:
# 1485 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
    void swap(basic_iostream& __rhs);
public:
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_iostream<_CharT, _Traits>::basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
    : basic_istream<_CharT, _Traits>(__sb)
{
}
# 1516 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
basic_iostream<_CharT, _Traits>::swap(basic_iostream& __rhs)
{
    basic_istream<char_type, traits_type>::swap(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            ios_base::iostate __err = ios_base::goodbit;
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
        if (__sen)
        {
            __str.clear();
            ios_base::iostate __err = ios_base::goodbit;
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __err |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}
# 1661 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/istream" 3
template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
        if (__sen)
        {
            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            streamsize __c = 0;
            ios_base::iostate __err = ios_base::goodbit;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __err |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (__c == 0)
               __err |= ios_base::failbit;
            __is.setstate(__err);
        }
        else
            __is.setstate(ios_base::failbit);

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

extern template class __attribute__ ((__type_visibility__("default"))) basic_istream<char>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_istream<wchar_t>;
extern template class __attribute__ ((__type_visibility__("default"))) basic_iostream<char>;

} }
# 41 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 2 3
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iostream" 3


namespace std {inline namespace __1 {

extern __attribute__ ((__visibility__("default"))) istream cin;
extern __attribute__ ((__visibility__("default"))) ostream cout;
extern __attribute__ ((__visibility__("default"))) ostream cerr;
extern __attribute__ ((__visibility__("default"))) ostream clog;
extern __attribute__ ((__visibility__("default"))) wistream wcin;
extern __attribute__ ((__visibility__("default"))) wostream wcout;
extern __attribute__ ((__visibility__("default"))) wostream wcerr;
extern __attribute__ ((__visibility__("default"))) wostream wclog;

} }
# 22 "./common_utils_cpp.hpp" 2

using glm::vec2;
using glm::vec3;
using glm::vec4;
using glm::mat3;
using glm::mat4;
# 48 "./common_utils_cpp.hpp"
enum struct PROPERTY_TYPE {

    PROP_i64 , PROP_u64 , PROP_usize , PROP_f64 , PROP_i32 , PROP_u32 , PROP_f32 , PROP_i16 , PROP_u16 , PROP_i8 , PROP_u8 , PROP_bool , PROP_char , PROP_byteptr , PROP_vec2 , PROP_vec3 , PROP_vec4 ,
    COUNT_PROPERTY_TYPE

};


# 1 "./config/config_state.cpp" 1
# 16 "./config/config_state.cpp"
    struct ConfigVar {
        PROPERTY_TYPE type;
        const char* name;
        const char* name_space;
        union {

            i64 f_i64 ; u64 f_u64 ; usize f_usize ; f64 f_f64 ; i32 f_i32 ; i32 f_u32 ; i32 f_f32 ; i16 f_i16 ; u16 f_u16 ; i8 f_i8 ; u8 f_u8 ; bool f_bool ; char f_char ; char* f_byteptr ; vec2 f_vec2 ; vec3 f_vec3 ; vec4 f_vec4 ;

        };
        void* ptr;
    };

    void ConfigState_load_runtime(void);
# 45 "./config/config_state.cpp"
# 1 "./config/./config_movement.cpp" 1
# 11 "./config/./config_movement.cpp"
namespace wee { extern f64 WEEf64; }
namespace wee { extern i32 WEEi32; }
namespace ha { extern char HAchar; }


namespace physics { extern f64 GRAVITY_DEFAULT; }
namespace physics { extern f64 GRAVITY_TERRESTRIAL; }
namespace physics { extern f64 GRAVITY_OUTER_SPACE; }
namespace physics { extern f64 gravity; }
# 46 "./config/config_state.cpp" 2
# 56 "./common_utils_cpp.hpp" 2

template <typename T>
inline T dref_as(void* ptr);





typedef std::pair<glm::vec3, glm::vec3> vec3_pair;
typedef std::pair<glm::vec4, glm::vec4> vec4_pair;

inline f64 dist2(glm::vec3 v, glm::vec3 w);
inline f64 dist_to_segment_squared(glm::vec3 v, glm::vec3 w, glm::vec3 p);
inline f64 dist_to_segment(glm::vec3 v, glm::vec3 w, glm::vec3 p);


bool line_segment_intersection(const vec3_pair* s0, const vec3_pair* s1, glm::vec3* out);

template<typename T>
static std::string to_binary_string(const T& x);

template <typename T, usize N>
struct Buffer {
    T memory[N];
    usize elements_used;

    operator T*(void)
    {
        return this->memory;
    }

    inline T& operator[](usize i)
    {
        return this->memory[i];
    }

    inline const T& operator[](usize i) const
    {
        return this->memory[i];
    }

    inline usize byte_length(void) const
    {
        return sizeof(T) * N;
    }

    inline usize element_length(void) const
    {
        return N;
    }

    inline void push_back(T val)
    {
        (__builtin_expect(!(this->elements_used < N), 0) ? __assert_rtn(__func__, "./common_utils_cpp.hpp", 109, "this->elements_used < N") : (void)0);
        memory[this->elements_used] = val;
        this->elements_used += 1;
    }

    inline void push_back(T* val)
    {
        (__builtin_expect(!(this->elements_used < N), 0) ? __assert_rtn(__func__, "./common_utils_cpp.hpp", 116, "this->elements_used < N") : (void)0);
        memory[this->elements_used] = *val;
        this->elements_used += 1;
    }

    inline void reset()
    {
        this->elements_used = 0;
    }

    typedef T* iterator;
    typedef const T* const_iterator;
    iterator begin(void) { return &this->memory[0]; }
    iterator end(void) { return &this->memory[N]; }
    iterator first_free(void) { return &this->memory[this->elements_used]; }
};

template <typename T>
struct DynamicBuffer {
    size_t cap;
    size_t count;
    T* array;

    operator T*()
    {
        return this->array;
    }

    T& operator[](size_t i)
    {
        return this->array[i];
    }

    const T& operator[](size_t i) const
    {
        return this->array[i];
    }

    inline size_t element_count() const
    {
        return this->count;
    }

    inline size_t element_size() const
    {
        return sizeof(T);
    }

    inline size_t size() const
    {
        return this->cap;
    }


    typedef T* iterator;
    typedef const T* const_iterator;
    iterator begin() { return &this->array[0]; }
    iterator end() { return &this->array[this->cap]; }
};

void vec2_print(glm::vec2* v);

void vec2_pair_print(glm::vec2* a, glm::vec2* b);

void vec3_print(glm::vec3* v);

void vec3_pair_print(glm::vec3* a, glm::vec3*b);

void vec4_print(glm::vec4* v);

void vec4_pair_print(glm::vec4* a, glm::vec4* b);

template<typename T>
void print_array(T* array, const usize N, const usize M = 1);




static inline f32 atan2pos_32(f64 y, f64 x);
static inline f64 atan2pos_64(f64 y, f64 x);

bool check_file_status(const char* file_path, struct stat* file_stat);

template <typename T>
inline void zero_mem(T* ptr);
# 6 "entity.h" 2
# 32 "entity.h"
    enum struct FIELD_TYPE {

        f_i64 , f_u64 , f_usize , f_f64 , f_i32 , f_u32 , f_f32 , f_i16 , f_u16 , f_i8 , f_u8 , f_bool , f_char , f_byteptr , f_vec2 , f_vec3 , f_vec4 ,


# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

f_Thing,
# 2 "././entities/entity_includes.hpp" 2
# 37 "entity.h" 2
 COUNT_FIELD_TYPE
    };

    FIELD_TYPE x = FIELD_TYPE::f_u16;
# 62 "entity.h"
# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

struct Thing {
    vec2 position;
    f32 speed;
    u32 health;
    u32 damage;
}; Thing Thing_array[ (((64 +0) > 0 && (64 +0) <= 0xFFFFFFFF) ? (64 + 0) : 1) ]; constexpr unsigned int Thing_array_count = (((64 +0) > 0 && (64 +0) <= 0xFFFFFFFF) ? (64 +0) : 1);
# 2 "././entities/entity_includes.hpp" 2
# 63 "entity.h" 2
# 72 "entity.h"
    struct FieldMetaData {
        const char* name;
        const i32 offset;
        FIELD_TYPE type;
        bool is_pointer;
        bool is_array;
    };
# 87 "entity.h"
# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

FieldMetaData Thing_meta_data[] = {
    { "position", __builtin_offsetof(Thing, position), FIELD_TYPE::f_vec2, false, false},
    { "speed", __builtin_offsetof(Thing, speed), FIELD_TYPE::f_f32, false, false},
    { "health", __builtin_offsetof(Thing, health), FIELD_TYPE::f_u32, false, false},
    { "damage", __builtin_offsetof(Thing, damage), FIELD_TYPE::f_u32, false, false},
};
# 2 "././entities/entity_includes.hpp" 2
# 88 "entity.h" 2
# 97 "entity.h"
    struct ArrayMetaData {
        const char* name;
        void* array;
        const i32 element_size;
        void* meta_array;
    };
# 111 "entity.h"
    ArrayMetaData arrays[] = {

# 1 "././entities/entity_includes.hpp" 1
# 1 "././entities/thing.cpp" 1

{ "Thing_array", Thing_array, sizeof(Thing), Thing_meta_data




},
# 2 "././entities/entity_includes.hpp" 2
# 113 "entity.h" 2
 };
